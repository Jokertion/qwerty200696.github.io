<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wangwlj&#39;s Blog</title>
    <link>http://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Thu, 08 Mar 2018 03:28:55 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>剑指offer面试题：斐波那契数列</title>
      <link>http://wangwlj.com/2018/03/06/coding_offer09_Fibonacci/</link>
      <guid>http://wangwlj.com/2018/03/06/coding_offer09_Fibonacci/</guid>
      <pubDate>Tue, 06 Mar 2018 11:57:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp4ae6zmdtj22gg2gkkj7.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp4ae6zmdtj22gg2gkkj7.jpg" alt=""><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39</p><p>题目链接：<a href="https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3" target="_blank" rel="external">https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>给出解法，详细分析见后面：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">            方法一：时间花费950ms，接近一秒了。。。</span></div><div class="line"><span class="comment">        */</span></div><div class="line">        <span class="comment">//if(n &lt;= 0 )</span></div><div class="line">        <span class="comment">//    return 0;</span></div><div class="line">        <span class="comment">//else if (n == 1)</span></div><div class="line">        <span class="comment">//    return 1;</span></div><div class="line">        <span class="comment">//return Fibonacci(n - 1) + Fibonacci(n -2);</span></div><div class="line">        </div><div class="line">        <span class="comment">//方法二：</span></div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span> )</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> ans_i = <span class="number">0</span>, ans_i_1 = <span class="number">1</span>, ans_i_2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(n &gt;= i)&#123;</div><div class="line">            ans_i = ans_i_1 + ans_i_2;</div><div class="line">            ans_i_2 = ans_i_1;</div><div class="line">            ans_i_1 = ans_i;</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans_i;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这个题可以说是迭代（Iteration） VS 递归（Recursion），<br>f(n) = f(n-1) + f(n-2)，第一眼看就是递归啊，简直完美的递归环境，递归肯定很爽，这样想着关键代码两三行就搞定了，注意这题的n是从0开始的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</div><div class="line"><span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</div></pre></td></tr></table></figure></p><p>然而并没有什么用，测试用例里肯定准备着一个超大的n来让Stack Overflow，为什么会溢出？因为重复计算，而且重复的情况还很严重，举个小点的例子，n=4，看看程序怎么跑的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Fibonacci(<span class="number">4</span>) = Fibonacci(<span class="number">3</span>) + Fibonacci(<span class="number">2</span>);</div><div class="line">             = Fibonacci(<span class="number">2</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">0</span>);</div><div class="line">             = Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">0</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">0</span>);</div></pre></td></tr></table></figure></p><p>由于我们的代码并没有记录Fibonacci(1)和Fibonacci(0)的结果，对于程序来说它每次递归都是未知的，因此光是n=4时f(1)就重复计算了3次之多。</p><p>那么如何求解呢，动态规划似乎不错，关于动态规划三个条件：最优子结构、无后效性、子问题重叠这些就不谈了，因为理(wo)论(ye)性(bu)太(tai)强(dong)了。</p><p>下例是一个简单的动态规划，以一定的空间代价避免代价更大的重复计算的栈空间浪费：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">record[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">record[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</div><div class="line">    record[i] = record[i<span class="number">-1</span>] + record[i<span class="number">-2</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> record[n];</div></pre></td></tr></table></figure></p><p>虽然看起来很蠢，空间浪费了<code>sizeof(int)*(n-1)</code>，但是对于那个超大n的测试用例应该是可以通过了，时间复杂度也达到了O(n)。<br>那能不能把“优雅”的递归和动态规划结合起来呢？递归的优点在于便于理解和编码，而重复计算的关键原因在于代码里直接就“递”进去然后等着“归”了，所以避免重复的关键在于对子问题是否已经得出解的判断，即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] record = null;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</div><div class="line">         <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(null == record)&#123;</div><div class="line">        record = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="number">0</span>!=record[n<span class="number">-2</span>] &amp;&amp; <span class="number">0</span>!=record[n<span class="number">-1</span>])&#123;</div><div class="line">        record[n] = record[n<span class="number">-2</span>] + record[n<span class="number">-1</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> Fibonacci(n<span class="number">-2</span>) + Fibonacci(n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/06/coding_offer09_Fibonacci/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：旋转数组的最小数字</title>
      <link>http://wangwlj.com/2018/03/06/coding_offer08_findMinNumberInRotateArray/</link>
      <guid>http://wangwlj.com/2018/03/06/coding_offer08_findMinNumberInRotateArray/</guid>
      <pubDate>Tue, 06 Mar 2018 11:57:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp3d1c9f1wj22bc1jke81.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp3d1c9f1wj22bc1jke81.jpg" alt=""><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>输入一个非递减排序的数组(如{1,2,3,4,5})的一个旋转(如{3,4,5,1,2})，输出旋转数组的最小元素。 </p><p>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p>简而言之，输入的是旋转后的数组，输出数组的最小数字。</p><p>最简单的方法当然是从头到尾查找一遍就知道最小数字了，复杂度为$O(n)$，不过这并不是能让面试官满意的答案。</p><p>需要结合旋转数组的特性来分析。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道二分查找的变形的题目。</p><p>旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的大小都大于后面子数组中的元素</p><p>注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。</p><p>思路：</p><p>（1）我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。</p><p>但是如果不是旋转，第一个元素肯定小于最后一个元素。</p><p>（2）找到数组的中间元素。</p><p>中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。</p><p>移动之后，第一个指针仍然位于前面的递增数组中。</p><p>中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。</p><p>移动之后，第二个指针仍然位于后面的递增数组中。</p><p>这样可以缩小寻找的范围。</p><p>（3）按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。</p><p>最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。</p><p>也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。</p><p>此时的解法答案如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = rotateArray.size();</div><div class="line">        <span class="keyword">if</span>(<span class="number">0</span> == size) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = size - <span class="number">1</span>, mid;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>((high - low) &gt; <span class="number">1</span>) &#123;</div><div class="line">            mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[<span class="number">0</span>]) <span class="comment">//位于左半递增数组上</span></div><div class="line">                low = mid;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[size - <span class="number">1</span>]) &#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> rotateArray[high];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>到目前为止以上思路很好的解决了没有重复数字的情况，这一道题目添加上了这一要求，<strong>有了重复数字</strong>。</p><p>因此这一道题目比上一道题目多了些特殊情况：</p><p>我们看一组例子：<code>｛1，0，1，1，1｝</code> 和 <code>｛1，1， 1，0，1｝</code> 都可以看成是递增排序数组<code>｛0，1，1，1，1｝</code>的旋转。</p><p>这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。</p><p>第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。</p><p>因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（绿色表示）还是属于后面的子数组（紫色表示）。</p><p>也就无法移动指针来缩小查找的范围。</p><p>因此只能按照正常的顺序来遍历查找最小的元素。</p><p>再次放上最终版本的代码。基本上考虑了所有的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = rotateArray.size();</div><div class="line"><span class="keyword">int</span> min = <span class="number">0x7fffffff</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = rotateArray.begin(); i != rotateArray.end(); ++i) &#123;</div><div class="line"><span class="keyword">if</span>(min &gt; *i) &#123;</div><div class="line">min = *i;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> min;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = rotateArray.size();</div><div class="line">        <span class="keyword">if</span>(<span class="number">0</span> == size) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = size - <span class="number">1</span>, mid;</div><div class="line">        <span class="keyword">if</span>(rotateArray[low] &lt; rotateArray[high]) &#123; <span class="comment">//翻转了0个或者翻转全部</span></div><div class="line">            <span class="keyword">return</span> rotateArray[low];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>((high - low) &gt; <span class="number">1</span>) &#123;</div><div class="line">            mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</div><div class="line"><span class="keyword">if</span>(rotateArray[mid] == rotateArray[<span class="number">0</span>] &amp;&amp; rotateArray[mid] == rotateArray[size - <span class="number">1</span>]) <span class="comment">//三个数字都相同，这一种情况比较特殊。</span></div><div class="line">                <span class="keyword">return</span> MinInOrder(rotateArray);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &gt;= rotateArray[<span class="number">0</span>]) <span class="comment">//位于左半递增数组上</span></div><div class="line">                low = mid;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt;= rotateArray[size - <span class="number">1</span>]) &#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> rotateArray[high];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Solution *s = <span class="keyword">new</span> Solution();</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minNumberInRotateArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minNumberInRotateArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minNumberInRotateArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/06/coding_offer08_findMinNumberInRotateArray/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：从1到n整数中1出现的次数</title>
      <link>http://wangwlj.com/2018/03/06/coding_offer32_1toN/</link>
      <guid>http://wangwlj.com/2018/03/06/coding_offer32_1toN/</guid>
      <pubDate>Tue, 06 Mar 2018 11:57:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp5bof1excj23eb1wsnpd.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp5bof1excj23eb1wsnpd.jpg" alt=""><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p><p>额，题目的意思实际上是求出从1到n整数中1出现的次数。</p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6" target="_blank" rel="external">https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6</a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>设N = abcde ,其中abcde分别为十进制中各位上的数字。<br>如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。</p><p>① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~199，1100~1199,2100~2199，，…，11100~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。</p><p>② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~199，1100~1199,2100~2199，，….，11100~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~12113,一共114个，等于低位数字（113）+1。</p><p>③ 如果百位上数字大于1（2~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~199,1100~1199，2100~2199，…，11100~11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。</p><blockquote><p>这题没看题解之前真是一脸懵逼，找规律真是不太容易啊。</p></blockquote><p>至此，就可以写代码了，为了加深理解，我再通过表格的形式叙述一下算法流程。以21345为例，列表如下：</p><table><thead><tr><th>i(当前位)</th><th>n/i/10(前面的数)</th><th>n/i%10(当前位的值)</th><th>n%i(后面的数)</th><th>当前位1的个数</th></tr></thead><tbody><tr><td>1（个位）</td><td>2134</td><td>5</td><td>0</td><td>(2134+1)x1=2135</td></tr><tr><td>10（十位）</td><td>213</td><td>4</td><td>5</td><td>(213+1)x10=2140</td></tr><tr><td>100（百位）</td><td>21</td><td>3</td><td>45</td><td>(21+1)x100=2200</td></tr><tr><td>1000</td><td>2</td><td>1</td><td>345</td><td>2x1000+345+1 = 2346</td></tr><tr><td>10000</td><td>0</td><td>2</td><td>1345</td><td>(0+1)x10000=10000</td></tr></tbody></table><p>综合起来最终结果就是18821.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//1的个数</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//当前位</span></div><div class="line">        <span class="keyword">int</span> current = <span class="number">0</span>,after = <span class="number">0</span>,before = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>((n/i)!= <span class="number">0</span>)&#123;           </div><div class="line">            current = (n/i)%<span class="number">10</span>; <span class="comment">//高位数字</span></div><div class="line">            before = n/(i*<span class="number">10</span>); <span class="comment">//当前位数字</span></div><div class="line">            after = n-(n/i)*i; <span class="comment">//低位数字</span></div><div class="line">            <span class="comment">//如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数</span></div><div class="line">            <span class="keyword">if</span> (current == <span class="number">0</span>)</div><div class="line">                count += before*i;</div><div class="line">            <span class="comment">//如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(current == <span class="number">1</span>)</div><div class="line">                count += before * i + after + <span class="number">1</span>;</div><div class="line">            <span class="comment">//如果大于1,出现1的次数由高位决定,//（高位数字+1）* 当前位数</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                count += (before + <span class="number">1</span>) * i;</div><div class="line">            &#125;    </div><div class="line">            <span class="comment">//前移一位</span></div><div class="line">            i = i*<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面看懂了之后，再来看这个解法，也很容易。<br>其实思路是一样的，只不过代码更加简洁了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="comment">//主要思路：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析</span></div><div class="line">    <span class="comment">//根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i</span></div><div class="line">    <span class="comment">//当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为1</span></div><div class="line">    <span class="comment">//当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1</span></div><div class="line">    <span class="comment">//当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）</span></div><div class="line">    <span class="comment">//综合以上三种情况，当百位对应0或&gt;=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1</span></div><div class="line">    <span class="comment">//之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)</span></div><div class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i*=<span class="number">10</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//i表示当前分析的是哪一个数位</span></div><div class="line">        <span class="keyword">int</span> a = n/i,b = n%i;</div><div class="line">        count=count+(a+<span class="number">8</span>)/<span class="number">10</span>*i+(a%<span class="number">10</span>==<span class="number">1</span>)*(b+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/06/coding_offer32_1toN/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：用两个栈实现队列</title>
      <link>http://wangwlj.com/2018/03/06/coding_offer07_stack2queue/</link>
      <guid>http://wangwlj.com/2018/03/06/coding_offer07_stack2queue/</guid>
      <pubDate>Tue, 06 Mar 2018 02:57:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp3cq46xhdj23v92ky4qs.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp3cq46xhdj23v92ky4qs.jpg" alt=""><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的<code>Push</code>和<code>Pop</code>操作。 队列中的元素为<code>int</code>类型。</p><p>C++版本的初始代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="用两个栈实现一个队列的功能-要求给出算法和思路"><a href="#用两个栈实现一个队列的功能-要求给出算法和思路" class="headerlink" title="用两个栈实现一个队列的功能?要求给出算法和思路!"></a>用两个栈实现一个队列的功能?要求给出算法和思路!</h3><p>&lt;分析&gt;：</p><p>入队：将元素进栈A<br>出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。</p><p>换个说法：<br>栈A用来作入队列；栈B用来出队列，当栈B为空时，栈A全部出栈到栈B,栈B再出栈（即出队列）。</p><p>本地测试的完整C++程序：【添加了一个打印函数】<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.size() &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">while</span> (stack1.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> data = stack1.top();</div><div class="line">                stack1.pop();</div><div class="line">                stack2.push(data);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>)</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            <span class="comment">//throw new exception("queue is empty");</span></div><div class="line">        </div><div class="line">        <span class="keyword">int</span> head = stack2.top();</div><div class="line">        stack2.pop();</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">show_value</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> data;</div><div class="line">        <span class="keyword">while</span> (stack2.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            data = stack2.top();</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="string">" "</span>;</div><div class="line">            stack2.pop();</div><div class="line">            stack1.push(data);</div><div class="line">            ++count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (stack1.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            data = stack1.top();</div><div class="line">            stack1.pop();</div><div class="line">            stack2.push(data);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// stack2中只返回原先就在stack1中的值。</span></div><div class="line">        <span class="keyword">while</span> (stack2.size() &gt; count) &#123;</div><div class="line">            data = stack2.top();</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="string">" "</span>;</div><div class="line">            stack2.pop();</div><div class="line">            stack1.push(data);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>  (stack2.size() != count )</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"error:"</span> &lt;&lt; stack2.size() &lt;&lt; <span class="string">" != "</span> &lt;&lt; count;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Solution *s = <span class="keyword">new</span> Solution();</div><div class="line">    s-&gt;push(<span class="number">5</span>);</div><div class="line">    s-&gt;push(<span class="number">4</span>);</div><div class="line">    s-&gt;push(<span class="number">3</span>);</div><div class="line">    s-&gt;push(<span class="number">2</span>);</div><div class="line">    s-&gt;pop();</div><div class="line">    s-&gt;push(<span class="number">1</span>);</div><div class="line">    s-&gt;push(<span class="number">0</span>);</div><div class="line">    s-&gt;push(<span class="number">-1</span>);</div><div class="line">    s-&gt;pop();</div><div class="line">    s-&gt;push(<span class="number">-2</span>);</div><div class="line">    <span class="comment">// 打印出队列的值。</span></div><div class="line">    s-&gt;show_value();</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此外，还可以思考一下：</p><h3 id="用两个队列实现一个栈的功能-要求给出算法和思路"><a href="#用两个队列实现一个栈的功能-要求给出算法和思路" class="headerlink" title="用两个队列实现一个栈的功能?要求给出算法和思路!"></a>用两个队列实现一个栈的功能?要求给出算法和思路!</h3><p>&lt;分析&gt;：</p><p>入栈：将元素进队列A<br>出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素   以此出队列并放入队列B，直到队列A中的元素留下一个，然后队列A出队列，再把队列B中的元素出队列依次放入队列A中。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/06/coding_offer07_stack2queue/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：重建二叉树</title>
      <link>http://wangwlj.com/2018/03/05/coding_offer06_reconstractBinaryTree/</link>
      <guid>http://wangwlj.com/2018/03/05/coding_offer06_reconstractBinaryTree/</guid>
      <pubDate>Mon, 05 Mar 2018 12:35:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp27xeqledj23sw2iou0x.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp27xeqledj23sw2iou0x.jpg" alt=""><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>根节点肯定是前序遍历的第一个数。找到中序遍历根节点所在位置。<br>对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边。利用上述这点，对二叉树节点进行归并。<br>取出前序和中序遍历根节点左边和右边的子树递归，再对其进行上述所有步骤（递归），即再区分子树的左、右子子数，直到叶节点。</p><p>Python的解法简洁明了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        root = TreeNode(pre.pop(<span class="number">0</span>))</div><div class="line">        index = tin.index(root.val)</div><div class="line">        root.left = self.reConstructBinaryTree(pre, tin[:index])</div><div class="line">        root.right = self.reConstructBinaryTree(pre, tin[index + <span class="number">1</span>:])</div><div class="line">        <span class="keyword">return</span> root</div></pre></td></tr></table></figure></p><p>这是C++的解法，一样的思路。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 先序遍历第一个位置肯定是根节点node，</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">  中序遍历的根节点位置在中间p，在p左边的肯定是node的左子树的中序数组，p右边的肯定是node的右子树的中序数组</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">  另一方面，先序遍历的第二个位置到p，也是node左子树的先序子数组，剩下p右边的就是node的右子树的先序子数组</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">  把四个数组找出来，分左右递归调用即可。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"> </div><div class="line"><span class="keyword">public</span>:</div><div class="line"> </div><div class="line">    <span class="function">struct TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in)</span> </span>&#123;</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> in_size = in.size();</div><div class="line">        <span class="keyword">if</span>(in_size == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre_left, pre_right, in_left, in_right;</div><div class="line">        <span class="comment">//创建根节点，根节点肯定是前序遍历的第一个数</span></div><div class="line">        <span class="keyword">int</span> val = pre[<span class="number">0</span>];</div><div class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(val);<span class="comment">//root node is the first element in pre</span></div><div class="line">        <span class="comment">//找到中序遍历根节点所在位置,存放于变量p中</span></div><div class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(p; p &lt; in_size; ++p)&#123;</div><div class="line">            <span class="keyword">if</span>(in[p] == val) <span class="comment">//Find the root position in in</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"> <span class="comment">//对二叉树节点进行归并</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in_size; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(i &lt; p)&#123;</div><div class="line">                in_left.push_back(in[i]);<span class="comment">//Construct the left pre and in </span></div><div class="line">                pre_left.push_back(pre[i+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; p)&#123;</div><div class="line">                in_right.push_back(in[i]);<span class="comment">//Construct the right pre and in </span></div><div class="line">                pre_right.push_back(pre[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> <span class="comment">//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span></div><div class="line">        node-&gt;left = reConstructBinaryTree(pre_left, in_left);</div><div class="line">        node-&gt;right = reConstructBinaryTree(pre_right, in_right);</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> node;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/05/coding_offer06_reconstractBinaryTree/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：二维数组中的查找</title>
      <link>http://wangwlj.com/2018/03/05/coding_offer03_findInArray/</link>
      <guid>http://wangwlj.com/2018/03/05/coding_offer03_findInArray/</guid>
      <pubDate>Mon, 05 Mar 2018 10:05:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp27ztrx3kj23vc2kw7wi.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp27ztrx3kj23vc2kw7wi.jpg" alt=""><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>从右上角（或者左下角）的元素开始查找。</p><p>矩阵是有序的，有：<br>从右上角来看，向左数字递减，向下数字递增，因此从右上角开始查找，当要查找数字比右上角数字大时，下移；要查找数字比右上角数字小时，左移。<br>从左下角来看，向上数字递减，向右数字递增，因此从左下角开始查找，当要查找数字比左下角数字大时，右移；要查找数字比左下角数字小时，上移。</p><p>代码以右上角为例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>.empty())</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">int</span> rows = <span class="built_in">array</span>.size();</div><div class="line">    <span class="keyword">int</span> cols = <span class="built_in">array</span>[<span class="number">0</span>].size();</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(rows &gt; <span class="number">0</span> &amp;&amp; cols &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> col = cols - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[row][col] == target) &#123;</div><div class="line">                found = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[row][col] &gt; target)</div><div class="line">                --col;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                ++row;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> found;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/05/coding_offer03_findInArray/#disqus_thread</comments>
    </item>
    
    <item>
      <title>编程题：扇形染色问题</title>
      <link>http://wangwlj.com/2018/03/05/coding_dye_problem/</link>
      <guid>http://wangwlj.com/2018/03/05/coding_dye_problem/</guid>
      <pubDate>Mon, 05 Mar 2018 09:05:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp24xc81mjj23vc2kwqv8.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp24xc81mjj23vc2kwqv8.jpg" alt=""><br><a id="more"></a></p><h2 id="染色问题"><a href="#染色问题" class="headerlink" title="染色问题"></a>染色问题</h2><p>将一个圆形等分成N个小扇形,将这些扇形标记为1,2,3,…,N。现在使用M种颜色对每个扇形进行涂色，每个扇形涂一种颜色，且相邻的扇形颜色不同。</p><p>求：有多少种涂色方法。<br>备注：<br>1，不考虑数值越界。<br>2，N&gt;=1，M&gt;=3;</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>【分析】设$a(n) $为符合要求的对n个扇形的涂色方法。<br>对扇形1有m种涂色方法，扇形2有m－1种涂色方法，扇形3也有m－1种涂色方法，扇形n也有m－1种涂色方法。于是，共有$m\times (m-1)^{n-1} $种不同的涂色方法。但是，$a(n)\neq m\times (m-1)^{n-1} $，因为这种涂色方法可能出现1与n着色相同的情形，这是不符合题意的，因此，答案应从$m\times (m-1)^{n-1} $中减去这些不符合题意的涂色方法。</p><p>那么，这些不符合题意的涂色方法，又怎样计算呢？这时，把1与n看作一个扇形，其涂色方法相当于用m种颜色对n－1个扇形涂色（这种转换思维相当巧妙），不同的涂色方法有$a(n-1)$种，于是，有：<br>$$a(n)= m\times (m-1)^{n-1} - a(n-1)\cdots \cdots (n≥3) $$<br>其中，$a(3)=m(m-1)(m-2) $，上式是数列的递推公式，可推导出$a(n)$的通项公式：<br>$$a(n)= (m-1)^{n} - (-1)^n (m-1)\cdots \cdots (n≥3) $$</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们根据递推公式，采用递归法实现计算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">color</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">return</span> m;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</div><div class="line"><span class="keyword">return</span> m*(m - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//else if(n == 3)&#123;</span></div><div class="line"><span class="comment">//return m*(m - 1)*(m - 2);</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="keyword">return</span> m* <span class="built_in">pow</span>(m<span class="number">-1</span>, n<span class="number">-1</span>) - color (m, n<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; color(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; color(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; color(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当然也可以直接根据通项公式来编程。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/05/coding_dye_problem/#disqus_thread</comments>
    </item>
    
    <item>
      <title>西瓜书《机器学习》学习笔记(4)：聚类</title>
      <link>http://wangwlj.com/2018/03/04/ML_chap9_clustering/</link>
      <guid>http://wangwlj.com/2018/03/04/ML_chap9_clustering/</guid>
      <pubDate>Sun, 04 Mar 2018 14:11:19 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp1640ztrgj23t12mgnpd.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp1640ztrgj23t12mgnpd.jpg" alt=""><br><a id="more"></a></p><h2 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h2><ul><li>聚类任务</li><li>性能度量</li><li>距离计算</li><li>原型聚类</li><li>密度聚类</li><li>层次聚类</li></ul><h2 id="（一）聚类任务"><a href="#（一）聚类任务" class="headerlink" title="（一）聚类任务"></a>（一）聚类任务</h2><p>在无监督学习中（<code>unsupervised learning</code>）中，训练样本的标记信息是未知的，目标是通过对无标记的训练样本的学习来揭示数据的内在性质及规律，为进一步的数据分析提供基础。此类学习任务中研究最多、应用最广的是“聚类”（<code>clustering</code>）。</p><p>聚类试图将数据集中的样本划分为若干通常是不相交的子集，每个子集称为一个“簇”（<code>cluster</code>）。</p><p>聚类既能作为一个单独的过程，用于找寻数据内的分布结构，也可作为分类等其他学习任务的前驱过程。</p><h2 id="（二）性能度量"><a href="#（二）性能度量" class="headerlink" title="（二）性能度量"></a>（二）性能度量</h2><p>聚类性能度量亦称聚类“有效性指标”（<code>validity index</code>）。与监督学习中的性能度量作用相似。对聚类结果，我们需通过某种性能度量来评估其好坏；另一方面，若明确了最终将要使用的性能度量，则可直接将其作为聚类过程的优化目标，从而更好地得到符合要求的聚类结果。</p><p>聚类是将样本集D划分为若干不相交的子集，即样本簇。直观上看，我们希望“物以类聚”，即同一簇的样本尽可能彼此相似，不同簇的样本尽可能不同。换言之，聚类结果的“簇内相似度”（<code>intra-cluster similarity</code>）高且“簇间相似度”（<code>inter-cluster similarity</code>）低。<br>聚类性能度量大致有两类：</p><h3 id="“外部指标”（external-index）"><a href="#“外部指标”（external-index）" class="headerlink" title="“外部指标”（external index）"></a>“外部指标”（<code>external index</code>）</h3><p>将聚类结果与某个“参考模型”（reference model）进行比较；</p><p>常用的聚类性能度量外部指标有：</p><ul><li>Jaccard系数（<code>Jaccard Coefficient</code>，简称 JC）</li><li>FM指数（<code>Fowlkes and Mallows Index</code>，简称FMI）</li><li>Rand指数（<code>Rand Index</code>，简称RI）</li></ul><h3 id="“内部指标”（internal-index）"><a href="#“内部指标”（internal-index）" class="headerlink" title="“内部指标”（internal index）"></a>“内部指标”（<code>internal index</code>）</h3><p>直接考察聚类结果而不利用任何参考模型；常用的聚类性能度量内部指标有：</p><ul><li>DB指数（Davies-Bouldin Index，简称DBI）</li><li>Dunn指数（Dunn Index，简称DI）</li></ul><h2 id="（三）距离计算"><a href="#（三）距离计算" class="headerlink" title="（三）距离计算"></a>（三）距离计算</h2><p>给定样本$x_i=(x_{i1}, x_{i2},\cdots ,x_{in})$，与$x_j=(x_{j1}, x_{j2},\cdots,x_{jn})$，最常用的是”闵可夫斯基距离“（<code>Minkowski distance</code>），</p><p><img src="https://pic2.zhimg.com/80/v2-092b54a83787c5132a649ccd90883f47_hd.jpg" alt=""></p><p>p=2时，闵可夫斯基距离即欧氏距离（<code>Euclidean distance</code>），</p><p><img src="https://pic2.zhimg.com/80/v2-d7b50004e720a04337e22e2fdb1bdc1a_hd.jpg" alt=""></p><p>p=1时，闵可夫斯基距离即曼哈顿距离（<code>Manhattan distance</code>），<br><img src="https://pic4.zhimg.com/80/v2-7f1c9f632d8917ce72c768505e5051da_hd.jpg" alt=""></p><p>上面的距离计算式都是事先定义好的，但在不少现实任务中，有必要基于数据样本来确定合适的距离计算式，这可通过”距离度量学习“（<code>distance metric learning</code>）来实现。</p><h2 id="（四）原型聚类"><a href="#（四）原型聚类" class="headerlink" title="（四）原型聚类"></a>（四）原型聚类</h2><p>原型聚类亦称”基于原型的聚类“（<code>prototype-based clustering</code>），此类算法假设聚类结构能通过一组原型刻画，在现实聚类任务中极为常用。通常情形下，算法先对原型进行初始化，然后对原型进行迭代更新求解。采用不同的原型表示、不同的求解方式，将产生不同的算法。</p><h3 id="1-k均值算法"><a href="#1-k均值算法" class="headerlink" title="1. k均值算法"></a>1. k均值算法</h3><p>给定样本集$D={x_1，x_2，…，x_m}$，”k均值“（<code>k-means</code>）算法针对聚类所得簇划分$C={C_1，C_2，…，C_k}$最小化平方误差：<br><img src="https://pic2.zhimg.com/80/v2-a95209fc8754b1e3817e93373ca0d34d_hd.jpg" alt=""></p><p>其中:<br><img src="https://pic3.zhimg.com/80/v2-ca901ec516d4e0c24978c3e39939f3f7_hd.jpg" alt=""></p><p>x是簇$C_i$的均值向量。直观来看，上面式子在一定程度上刻画了簇内样本围绕簇均值向量的紧密程度，E值越小则簇内样本相似度越高。</p><h3 id="2-学习向量量化"><a href="#2-学习向量量化" class="headerlink" title="2. 学习向量量化"></a>2. 学习向量量化</h3><p>与k均值算法类似，“学习向量量化”（<code>Learning Vector Quantization</code>，简称<code>LVQ</code>）也是试图找到一组原型向量来刻画聚类结构，但与一般的聚类算法不同的是，LVQ假设数据样本带有类别标记，学习过程用样本的这些监督信息来辅助聚类。</p><h3 id="3-高斯混合聚类"><a href="#3-高斯混合聚类" class="headerlink" title="3. 高斯混合聚类"></a>3. 高斯混合聚类</h3><p>与k均值、<code>LVQ</code>用原型向量来刻画聚类结构不同，高斯混合（<code>Mixture-of-Gaussian</code>）聚类采用概率模型来表达聚类原型。</p><h2 id="（五）密度聚类"><a href="#（五）密度聚类" class="headerlink" title="（五）密度聚类"></a>（五）密度聚类</h2><p>密度聚类亦称“基于密度的聚类”（<code>density-based clustering</code>），此类算法假设聚类结构能通过样本分布的紧密程度确定。通常情况下，密度聚类算法从样本密度的角度来考察样本之间的可连接性，并基于可连接样本不断扩展聚类簇以获得最终的聚类结果。<br><code>DBSCAN</code>是一种著名的密度聚类算法。</p><h2 id="（六）层次聚类"><a href="#（六）层次聚类" class="headerlink" title="（六）层次聚类"></a>（六）层次聚类</h2><p>层次聚类（<code>hierarchical clustering</code>）试图在不同层次对数据集进行划分，从而形成树形的聚类结构。数据集的划分可采用“自底向上”的聚合策略，也可采用“自顶向下”的分拆策略。<br><code>AGNES</code>是一种采用自底向上聚合策略的层次聚类算法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>西瓜书《机器学习》</li><li><a href="https://zhuanlan.zhihu.com/p/33682166" target="_blank" rel="external">《机器学习》笔记-聚类（9）</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/04/ML_chap9_clustering/#disqus_thread</comments>
    </item>
    
    <item>
      <title>西瓜书《机器学习》学习笔记(3)：集成学习</title>
      <link>http://wangwlj.com/2018/03/04/ML_chap08_EnsembleLearning/</link>
      <guid>http://wangwlj.com/2018/03/04/ML_chap08_EnsembleLearning/</guid>
      <pubDate>Sun, 04 Mar 2018 13:31:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp16exdbpij23v82kzqv7.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp16exdbpij23v82kzqv7.jpg" alt=""><br><a id="more"></a></p><h2 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h2><ul><li>个体与集成</li><li>Boosting</li><li>Bagging与随机森林</li><li>集合策略</li><li>多样性</li></ul><h2 id="（一）个体与集成"><a href="#（一）个体与集成" class="headerlink" title="（一）个体与集成"></a>（一）个体与集成</h2><p>集成学习（ensemble learning）的一般结构：先产生一组“个体学习器”（individual learner），再用某种策略将他们结合起来，如下图所示，</p><p><img src="https://pic1.zhimg.com/80/v2-8c36ecadbc40e1336760bb6797917afc_hd.jpg" alt=""><br>个体学习器通常由一个现有的学习算法从训练数据产生：</p><ul><li>只包含同种类型的个体学习器，这样的集成是“同质”的（homogeneous）。同质集成中的个体学习器亦称为”基学习器“（base learning），相应的学习算法称为”基学习算法“（base learning algorithm）。</li><li>集成也可包含不同类型的个体学习器，这样集成是”异质“的（heterogeneous）。相应的个体学习器，常称为”组件学习器“（component learning）或直接称为个体学习器。</li></ul><p>在一般的经验中，如果把好坏不等的东西掺到一起，那么通常结果会是比坏的好一些，比好的要坏一些。集成学习把多个学习器结合起来，如何能获得比最好的单一学习器更好的性能呢？</p><p>考虑一个简单的例子：在二分类任务中，假定三个分类器在三个测试样本的表现如下图所示，</p><p><img src="https://pic3.zhimg.com/80/v2-eb1728c291a152af07fb418cc321fd89_hd.jpg" alt=""></p><p>其中，√表示分类正确，x表示分类错误，集成学习的结果通过投票法（voting）产生，即“少数服从多数”。这个简单的例子显示出：要获得好的集成，个体学习器应“好而不同”。个体学习器要有一定的“准确性”，即学习器不能太坏，而且要有“多样性”（diversity），即学习器之间有差异。事实上，如何产生并结合“好而不同”的个体学习器，恰是集成学习研究的核心。<br>根据个体学习器的生成方式，目前集成学习的方法大致可分为两大类：</p><ul><li>个体学习器间存在强依赖关系、必须串行生成的序列化方法，代表是Boosting；</li><li>个体学习器间不存在强依赖关系、可同时生成的并行化方法，代表是Baggig和“随机森林”（Random Forest）；</li></ul><h2 id="（二）Boosting"><a href="#（二）Boosting" class="headerlink" title="（二）Boosting"></a>（二）Boosting</h2><p>Boosting是一族可将弱学习器提升为强学习器的算法。这族算法的工作机制类似：先从初始训练集训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续收到更多的关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直到基学习器数目达到事先指定的值T，最终将这T个学习器进行加权结合。<br>Boosting族算法最著名的代表是AdaBoost。AdaBoost有多种推导方式，比较容易理解的是基于“加性模型”（additive model）即基学习器线性组合，</p><p><img src="https://pic4.zhimg.com/80/v2-30b53f6b30cb7ac63b45804c0ae15667_hd.jpg" alt=""></p><p>来最小化指数损失函数（exponential loss function）：</p><p><img src="https://pic1.zhimg.com/80/v2-3b4dc388b9617801d57419b36fbe5c4b_hd.jpg" alt=""></p><p>boosting中的Adaboost算法的详细推导过程——P172：略复杂，有空再看。</p><h2 id="（三）Bagging与随机森林"><a href="#（三）Bagging与随机森林" class="headerlink" title="（三）Bagging与随机森林"></a>（三）Bagging与随机森林</h2><p><strong>欲得到泛化性能强的集成，集成中的个体学习器应尽可能独立</strong>。虽然“独立”在显示任务中无法做到，但可以设法使基学习器尽可能具有较大差异。给定一个训练数据集，一种可能的做法是对训练样本进行采样，产生若干个不同的子集，再从每个数据子集中训练出一个基学习器。这样，由于训练数据不同，我们获得的基学习器可望具有比较大的差异。然而，为获得更好的集成，我们还同时希望个体学习器不能太差。如果采样出的每个子集都完全不同，则每个基学习器只用到了一小部分训练数据，甚至不足进行有效学习，这显然无法确保产生出比较好的基学习器。为考虑这个问题，我们可<strong>考虑使用相互有交叠的采样子集。</strong></p><h3 id="1-Bagging"><a href="#1-Bagging" class="headerlink" title="1. Bagging"></a>1. Bagging</h3><p>Bagging是并行式集成学习方法最著名的代表，从名字即可看出，它直接基于前面介绍过的<strong>自助采样法（bootstrap sampling）</strong>。</p><p>从偏差-方差分解角度看，Bagging主要关注降低方差。</p><h3 id="2-随机森林"><a href="#2-随机森林" class="headerlink" title="2. 随机森林"></a>2. 随机森林</h3><p>随机森林（<code>Random Forest</code>，简称<code>RF</code>）是<code>Bagging</code>的一个扩展变体。RF在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树的训练过程中引入了随机属性选择。<br>随机森林对<code>Bagging</code>只做了小改动，但是与<code>Bagging</code>中基学习器的“多样性”仅通过样本扰动（通过对初始训练集采样）而来不同，随机森林中<strong>基学习器多样性不仅来自样本扰动，还来自属性扰动</strong>，这就使得最终集成的泛化性能可通过个体学习器之间的差异度的增加而进一步提升。</p><h2 id="（四）组合策略"><a href="#（四）组合策略" class="headerlink" title="（四）组合策略"></a>（四）组合策略</h2><p>学习器结合可能从三个方面带来好处：</p><ul><li>从统计的方面看，由于学习任务的假设空间往往很大，可能有多个假设在训练集上达到同等性能，此时若使用单学习器可能因误选而导致泛化性能不佳，结合多个学习器减小这一风险；</li><li>从计算的方面来看，学习算法往往会陷入局部极小，有的局部极小点所对应的泛化性能可能很糟，而通过多次运行之后进行结合，可降低陷入糟糕局部极小点的风险；</li><li>从表示的方面来看，某些但学习器则肯定无效，而通过结合多个学习器，由于响应的假设空间有所扩大，有可能学得更好的近似。</li></ul><p>直观的示意图如下所示：<br><img src="https://pic3.zhimg.com/80/v2-795590b70f290c2fb18a4f9d806e13e6_hd.jpg" alt=""></p><p>集成学习常见策略有：</p><ul><li>平均法：简单平均法和加权平均法。</li><li>投票法：绝对多数投票法；相对多数投票法；加权投票法</li><li>学习法：初级学习器+次级学习器</li></ul><h2 id="（五）多样性"><a href="#（五）多样性" class="headerlink" title="（五）多样性"></a>（五）多样性</h2><h3 id="误差-分歧分解"><a href="#误差-分歧分解" class="headerlink" title="误差-分歧分解"></a>误差-分歧分解</h3><p>欲构建泛化能力强的集成，个体学习器应“好而不同”，其中，“误差-分歧分解”（<code>error-ambiguity decomposition</code>）是一个简单的理论分析方法。但该推导过程只适用于回归学习，难以直接推广到分类学习任务中。</p><h3 id="多样性度量"><a href="#多样性度量" class="headerlink" title="多样性度量"></a>多样性度量</h3><p>多样性度量（<code>diversity measure</code>）是用于度量集成中个体分类器的多样性，即估算个体学习器的多样化程度。常用的多样性度量包括：</p><ul><li>不合度量（disagreement measure）</li><li>相关系数（correlation coefficient）</li><li>Q-统计量（Q-statistics）</li><li>k-统计量（k-statistics）</li></ul><h3 id="多样性增强"><a href="#多样性增强" class="headerlink" title="多样性增强"></a>多样性增强</h3><p>在集成学习中需有效地生成多样性大的个体学习器。与简单地直接用初始数据训练出个体学习器相比，一般思路是在学习过程中引入随机性，常见的做法主要有，</p><ul><li>数据样本扰动：数据样本扰动基于采样法。</li><li>输入属性扰动：随机子空间算法。</li><li>输出表示扰动：翻转法（随机改变一些训练样本的标记）；输出调制法（将分类输出转化为回归输出后构建学习器）…</li><li>算法参数扰动：负相关法；单一学习器通常需要交叉验证等来确定参数值。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>西瓜书《机器学习》</li><li><a href="https://zhuanlan.zhihu.com/p/33621750" target="_blank" rel="external">《机器学习》笔记-集成学习（8）</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/04/ML_chap08_EnsembleLearning/#disqus_thread</comments>
    </item>
    
    <item>
      <title>计算机网络学习笔记：(三)传输层</title>
      <link>http://wangwlj.com/2018/03/01/network_03_transmission_layer/</link>
      <guid>http://wangwlj.com/2018/03/01/network_03_transmission_layer/</guid>
      <pubDate>Thu, 01 Mar 2018 14:34:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fp14w75zxvj22tc1vk4i9.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fp14w75zxvj22tc1vk4i9.jpg" alt=""><br><a id="more"></a></p><p>本文是<a href="https://www.bilibili.com/video/av9876107/" target="_blank" rel="external">计算机网络课程</a>传输层部分的笔记。</p><h3 id="传输层两个协议简介"><a href="#传输层两个协议简介" class="headerlink" title="传输层两个协议简介"></a>传输层两个协议简介</h3><p>传输层有两个协议：TCP和UDP。</p><p>TCP：传输控制协议(Transmission Control Protocol)。文件分段传输，需要建立会话，可靠传输；流量控制功能</p><p>UDP：用户数据报协议(User Data Protocol) 一个数据包就能够完成数据通信，不分段；不需要建立会话，不需要流量控制；不可靠传输。</p><p>查看会话：<code>netstat -n</code><br>查看是哪个进程创建的会话：<code>netstat -nb</code></p><p>举例场景：<br>DNS域名解析：使用UDP协议；<br>QQ聊天：聊天记录 使用UDP协议；<br>QQ传文件：TCP协议；<br>发送邮件：可能很大需要分段，因此TCP协议；<br>FTP下载文件：TCP<br>屏幕广播 多播：UDP</p><h3 id="传输层协议和应用层协议之间的关系"><a href="#传输层协议和应用层协议之间的关系" class="headerlink" title="传输层协议和应用层协议之间的关系"></a>传输层协议和应用层协议之间的关系</h3><p>http = tcp + 80<br>https = tcp +443<br>rdp = tcp +3389<br>ftp = tcp + 21<br>访问共享文件夹=tcp + 445<br>SMTP【发送】 = TCP + 25<br>POP3【接收】 = TCP + 110<br>Telnet = TCP + 23<br>SQL  = TCP +1433<br>DNS = UDP +53</p><h3 id="服务和应用层协议之间的关系"><a href="#服务和应用层协议之间的关系" class="headerlink" title="服务和应用层协议之间的关系"></a>服务和应用层协议之间的关系</h3><p>服务是由端口决定的。<br>服务是启动状态才侦听端口。<br>网卡是大门，网卡设置安全，只允许80端口【Web服务】。只允许特定服务的端口。</p><p>服务使用TCP或者UDP的端口侦听客户端请求。</p><p>客户端使用IP地址定位服务器，使用目标端口定位服务。<br>可以在服务器网卡上设置只开放必要的端口，实现服务器的网络安全。</p><h4 id="如何在Windows上安装服务"><a href="#如何在Windows上安装服务" class="headerlink" title="如何在Windows上安装服务"></a>如何在Windows上安装服务</h4><p>自带Telnet远程登录。远程桌面服务。<br>DNS服务<br>Web服务<br>SMTP服务<br>POP3服务</p><h4 id="如何查看服务侦听的端口"><a href="#如何查看服务侦听的端口" class="headerlink" title="如何查看服务侦听的端口"></a>如何查看服务侦听的端口</h4><p><code>netstat -an</code>查看服务器上侦听的窗口。<br><code>netstat -n</code>查看建立的会话<br><code>netstat -nb</code>查看建立会话的进程<br><code>telnet 192.168.80.100 3389</code> 测试远程计算机某个端口是否打开。</p><h4 id="如何更改服务使用的默认端口"><a href="#如何更改服务使用的默认端口" class="headerlink" title="如何更改服务使用的默认端口"></a>如何更改服务使用的默认端口</h4><p>  迷惑入侵者，使系统更加安全。</p><h4 id="如何设置Windows网络安全"><a href="#如何设置Windows网络安全" class="headerlink" title="如何设置Windows网络安全"></a>如何设置Windows网络安全</h4><p>只开特定服务端口：本地连接属性——TCP/IP协议属性——高级——选项——属性</p><h3 id="传输层功能和端口范围"><a href="#传输层功能和端口范围" class="headerlink" title="传输层功能和端口范围"></a>传输层功能和端口范围</h3><p>传输层功能：<br>为相互通信的应用程序/应用进程提供了端到端的逻辑通信。（网络层是为主机之间提供了逻辑通信）。<br>传输层要对收到的报文进行差错校验。<br>传输层提供面向连接和无连接的服务。</p><p>传输层端口：16位端口号进行标志，标志本计算机应用层中的各进程。端口号只具有本地意义，本地不冲突即可。</p><p>熟知端口：数值一般为0-1023<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FTP：21</div><div class="line">TELNET：23</div><div class="line">SMTP：25</div><div class="line">DNS：53</div><div class="line">HTTP：80</div><div class="line">Https：443</div><div class="line">RDP：3389</div></pre></td></tr></table></figure></p><p>登记端口号：数值为1024~49151<br>客户端口号：数值为49152-65535</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP的主要特点：<br>UDP是无连接的，即发送数据之前不需要建立连接。<br>UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。<br>UDP面向报文，没有拥塞控制，很适合多媒体通信的要求。<br>UDP支持一对一、一对多、多对一和多对多的交互通信。<br>UDP的首部开销小，只有8个字节。<br><img src="http://wx1.sinaimg.cn/large/c38a0784gy1fow7l7mao9j20mv0bkdk3.jpg" alt="image"></p><h3 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h3><p>TCP是面向连接的传输层协议。TCP把连接作为最基本的抽象。</p><p>TCP提供可靠交付的服务。</p><p>TCP提供全双工通信。</p><p>面向字节流。8bit = 1byte</p><p>每一条TCP连接只能有两个端点(endpoint)，每一条TCP连接只能是点对点的(一对一)。<strong>TCP连接的端点叫做<font color="FC0000">套接字(socket)</font></strong>。端口号拼接到IP地址即构成了套接字。<br>套接字 socket = (IP地址：端口号)</p><p>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：<br>TCP连接::={socket1, socket2}<br>      = {(IP1:port1),(IP2:port2)}</p><h4 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h4><p>可靠传输的工作原理————停止等待协议</p><p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</p><p>这种可靠传输协议常称为自动重传请求(<code>Automatic Repeat reQuest</code>)。</p><p><code>ARQ</code>表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</p><p>停止等待协议优点是简单，缺点是信道利用率太低。</p><p>流水线传输：发送方可以连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。由于信道上一直有数据不间断地传送，这种传输方式可获得很高的利用率。</p><p>连续ARQ协议：发送方维持发送窗口（发送窗口是5），<font color="FC0000">滑动窗口。</font></p><p>累积确认。</p><h4 id="TCP如何实现流量控制"><a href="#TCP如何实现流量控制" class="headerlink" title="TCP如何实现流量控制"></a>TCP如何实现流量控制</h4><p>接收端告诉发送端接收窗口有多大来实现流量控制。</p><h4 id="TCP协议如何避免网络拥塞"><a href="#TCP协议如何避免网络拥塞" class="headerlink" title="TCP协议如何避免网络拥塞"></a>TCP协议如何避免网络拥塞</h4><p>暂无</p><h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><p><img src="http://wx1.sinaimg.cn/large/c38a0784gy1fowfjl3fezj20n10e8jvp.jpg" alt="image"><br>首部字节一般是固定部分的20个字节，还有长度可变的选项。</p><table><thead><tr><th>TCP报文段首部</th><th>含义</th></tr></thead><tbody><tr><td>源端口</td><td></td></tr><tr><td>目标端口</td><td></td></tr><tr><td>序号</td><td>第一个字节是整个文章的第几个字节。</td></tr><tr><td>确认号</td><td>收到数据包后，让继续发的号</td></tr><tr><td>数据偏移</td><td>占4位；记录第多少个字节是数据。十进制最大为15，代表最大15x4=60个字节。</td></tr><tr><td>URG</td><td>设为1时代表紧急，发送端不排队，提前传走。</td></tr><tr><td>ACK</td><td>确认号</td></tr><tr><td>PSH</td><td>push，设为1代表接收端不排队，直接交给应用程序</td></tr><tr><td>RST</td><td>reset，表明TCP会话出现严重错误，需要重新连接。</td></tr><tr><td>SYN</td><td>同步，SYN攻击：伪造不存在的IP地址。land攻击：源地址和目的地址同一个。</td></tr><tr><td>FIN</td><td>数据传完了，最后释放连接。</td></tr><tr><td>窗口</td><td>假设客户端接收缓存为65535字节，服务器就设置发送缓存65535字节(不能超过)，反向同样也需要协商</td></tr><tr><td>检验和</td><td></td></tr><tr><td>紧急指针</td><td>URG=1时才起作用。指明紧急数据结束的位置。</td></tr><tr><td>选项(长度可变)</td><td>可以规定最大数据报的长度MSS，是否支持选择性确认SACK，时间戳</td></tr><tr><td>填充</td><td>凑够四个字节整数倍</td></tr></tbody></table><p>三个建立会话的数据包。MSS=1460数据包最大字节</p><h3 id="TCP如何实现可靠传输-1"><a href="#TCP如何实现可靠传输-1" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h3><p>1.以字节为单位的滑动窗口技术</p><p>发送窗口由接收窗口大小来决定的。</p><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>$$新的RTTs = (1-\alpha)\times (旧的RTTs) + \alpha \times (新的RTT样本)$$</p><p>RFC2988推荐的$\alpha$值为1/8。</p><h3 id="TCP的传输连接管理"><a href="#TCP的传输连接管理" class="headerlink" title="TCP的传输连接管理"></a>TCP的传输连接管理</h3><p>传输连接有三个阶段，即：连接建立、数据传送和连接释放。</p><h4 id="三次握手建立TCP连接"><a href="#三次握手建立TCP连接" class="headerlink" title="三次握手建立TCP连接"></a>三次握手建立TCP连接</h4><p><code>SYN=1，ACK=0，seq=x</code><br><code>SYN=1，ACK=1，seq=y，ack=x+1</code><br><code>ACK=1，seq=x+1，ack=y+1</code></p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fp143et6n4j20n20e343x.jpg" alt=""></p><h4 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h4><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fp1471ygbuj20mo0fmtg2.jpg" alt=""></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/01/network_03_transmission_layer/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
