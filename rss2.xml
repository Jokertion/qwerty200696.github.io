<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wangwlj&#39;s Blog</title>
    <link>http://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Fri, 16 Mar 2018 13:10:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>C++常见面试题整理</title>
      <link>http://wangwlj.com/2018/03/16/CPP_review_reproduce/</link>
      <guid>http://wangwlj.com/2018/03/16/CPP_review_reproduce/</guid>
      <pubDate>Fri, 16 Mar 2018 13:09:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fpeyqoz2cgj23vc2kwkjm.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fpeyqoz2cgj23vc2kwkjm.jpg" alt=""><br><a id="more"></a><br>有那么一些零碎的小知识点，偶尔很迷惑，偶尔被忽略，偶然却发现它们很重要，这段时间正好在温习这些，就整理在这里，一起学习一起提高！后面还会继续补充。</p><p>本文转载自：<a href="http://www.cnblogs.com/webary/p/4754522.html" target="_blank" rel="external">http://www.cnblogs.com/webary/p/4754522.html</a> </p><p>我自己也有整理，不过是思维导图的形式，有机会再一起放出来吧。</p><h3 id="1-面向对象的特性"><a href="#1-面向对象的特性" class="headerlink" title="1.面向对象的特性"></a>1.面向对象的特性</h3><p>　　封装、继承、多态。</p><p>　　封装：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。（优点：可以隐藏实现细节，使得代码模块化）</p><p>　　继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。（优点：可以扩展已存在的代码模块（类））</p><p>　　多态：一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。虽然针对不同对象的具体操作不同，但通过一个公共的类，这些操作可以通过相同的方式被调用。</p><p>　　多态实现的两种方式：父类指针指向子类对象 或 将一个基类的引用类型赋值为它的派生类实例。（重要：虚函数 + 指针或引用）</p><p>构造函数、复制构造函数、析构函数、赋值运算符不能被继承。</p><h3 id="2-堆和栈"><a href="#2-堆和栈" class="headerlink" title="2.堆和栈"></a>2.堆和栈</h3><p>　　从内存角度来说：栈区（<code>stack</code>）由编译器自动分配释放，存放函数的参数值，局部变变量的值等，其操作方式类似于数据结构中的栈，可静态亦可动态分配。</p><p>　　堆区（<code>heap</code>）一般由程序员分配释放，若程序员不释放，可能造成内存泄漏，程序结束时可能由<code>OS</code>回收。只可动态分配，分配方式类似于链表。</p><p>　　从数据结构角度来说：堆可以被看成是一棵树，如：堆排序。</p><p>　　而栈是一种先进后出的数据结构。</p><h3 id="3-malloc和new"><a href="#3-malloc和new" class="headerlink" title="3.malloc和new"></a>3.malloc和new</h3><p>　　1.<code>malloc</code>与<code>free</code>是<code>C++/C</code>语言的标准库函数，<code>new/delete</code>是<code>C++</code>的运算符。但它们都可用于申请动态内存和释放内存。</p><p>　　2.对于非内部数据类型的对象而言，用<code>malloc/free</code>无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由<code>malloc/free</code>是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于<code>malloc/free</code>，因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，和一个能完成清理与释放内存工作的运算符delete。</p><p>　　3.<code>new</code>可以认为是<code>malloc</code>加构造函数的执行。<code>new</code>出来的指针是直接带类型信息的。而<code>malloc</code>返回的都是<code>void*</code>指针。<code>new delete</code>在实现上其实调用了<code>malloc,free</code>函数。</p><p>　　4.new 建立的是一个对象；malloc分配的是一块内存。</p><h3 id="4-虚函数实现机制，虚继承在sizeof中有没有影响，构造函数能否为虚函数，与纯虚函数"><a href="#4-虚函数实现机制，虚继承在sizeof中有没有影响，构造函数能否为虚函数，与纯虚函数" class="headerlink" title="4.虚函数实现机制，虚继承在sizeof中有没有影响，构造函数能否为虚函数，与纯虚函数"></a>4.虚函数实现机制，虚继承在sizeof中有没有影响，构造函数能否为虚函数，与纯虚函数</h3><p>　　虚函数表：类的虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址。</p><p>　　编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。类的每个虚函数占据虚函数表中的一块。如果类中有N个虚函数，那么其虚函数表将有<code>N*4</code>字节的大小。</p><p>　　在有虚函数的类的实例中分配了指向这个表的指针的内存，所以，当用父类的指针来操作一个子类的时候，这张虚函数表就显得尤为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p><p>　　编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中<a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88" target="_blank" rel="external">函数指针</a>，并调用相应的函数。</p><p>　　-&gt;有虚函数或虚继承的类实例化后的对象大小至少为4字节（确切的说是一个指针的字节数；说至少是因为还要加上其他非静态数据成员，还要考虑对齐问题）；没有虚函数和虚继承的类实例化后的对象大小至少为1字节（没有非静态数据成员的情况下也要有1个字节来记录它的地址）。</p><p>　　有纯虚函数的类为抽象类，不能定义抽象类的对象，它的子类要么实现它所有的纯虚函数变为一个普通类，要么还是一个抽象类。</p><p>　　特别的：</p><p>　　（1）当存在类继承并且析构函数中有必须要进行的操作时（如需要释放某些资源，或执行特定的函数）析构函数需要是虚函数，否则若使用父类指针指向子类对象，在delete时只会调用父类的析构函数，而不能调用子类的析构函数，从而造成内存泄露或达不到预期结果；</p><p>　　（2）内联函数不能为虚函数：内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开；</p><p>　　（3）构造函数不能为虚函数：构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类的，因此不存在动态绑定的概念；但是构造函数中可以调用虚函数，不过并没有动态效果，只会调用本类中的对应函数；</p><p>　　（4）静态成员函数不能为虚函数：静态成员函数是以类为单位的函数，与具体对象无关，虚函数是与对象动态绑定的。</p><p>　　更多关于虚函数的细节，请移步博文：<a href="http://www.cnblogs.com/webary/p/4731457.html" target="_blank" rel="external">关于C++虚函数表的那些事儿</a></p><h3 id="5-面向对象的多态、多态的实现机制，多态的例子"><a href="#5-面向对象的多态、多态的实现机制，多态的例子" class="headerlink" title="5.面向对象的多态、多态的实现机制，多态的例子"></a>5.面向对象的多态、多态的实现机制，多态的例子</h3><p> 　　见知识点4</p><h3 id="6-对一个类求sizeof需要考虑的内容"><a href="#6-对一个类求sizeof需要考虑的内容" class="headerlink" title="6.对一个类求sizeof需要考虑的内容"></a>6.对一个类求sizeof需要考虑的内容</h3><p> 　　见知识点4。同时，对于一个结构体和一个类执行<code>sizeof()</code>运算时情况比较复杂，详细分析请移步另一篇博文<a href="http://www.cnblogs.com/webary/p/4721017.html" target="_blank" rel="external">struct/class等内存字节对齐问题详解</a></p><h3 id="7-重载和重写（覆盖）"><a href="#7-重载和重写（覆盖）" class="headerlink" title="7.重载和重写（覆盖）"></a>7.重载和重写（覆盖）</h3><p>　　方法的重写<code>Overriding</code>和重载<code>Overloading</code>是多态性的不同表现。</p><p>　　重写<code>Overriding</code>是父类与子类之间多态性的一种表现，重载<code>Overloading</code>是一个类中多态性的一种表现。</p><p>　　如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (<code>Overriding</code>)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了，而且如果子类的方法名和参数类型和个数都和父类相同，那么子类的返回值类型必须和父类的相同；如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloading的方法是可以改变返回值的类型。也就是说，重载的返回值类型可以相同也可以不同。</p><h3 id="8-“引用”与多态的关系"><a href="#8-“引用”与多态的关系" class="headerlink" title="8.“引用”与多态的关系?"></a>8.“引用”与多态的关系?</h3><p>　　引用是除指针外另一个实现多态的方式。这意味着，一个基类的引用可以指向它的派生类实例。例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　Class A; Class B : Class A&#123;…&#125;;</div><div class="line"></div><div class="line">　　B b; A&amp; ref = b;</div></pre></td></tr></table></figure></p><h3 id="9-计算机加载程序包括哪几个区？"><a href="#9-计算机加载程序包括哪几个区？" class="headerlink" title="9.计算机加载程序包括哪几个区？"></a>9.计算机加载程序包括哪几个区？</h3><p>　　一个由<code>C/C++</code>编译的程序占用的内存分为以下几个部分：</p><p>　　（1）栈区（<code>stack</code>）:—由编译器自动分配释放，存放函数的参数值，局部变量的值等。可静态也可动态分配。其操作方式类似于数据结构中的栈。 </p><p>　　（2）堆区（<code>heap</code>）:一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。动态分配。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 </p><p>　　（3）全局区（静态区）:—程序结束后由系统释放，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域；未初始化的全局变量和静态变量在相邻的另一块区域(BSS，Block Started by Symbol)，在程序执行之前BSS段会自动清0。 </p><p>　　（4）文字常量区:—程序结束后由系统释放，常量字符串就是放在这里的。  </p><p>　　（5）程序代码区:—存放函数体的二进制代码。</p><p>10.派生类中构造函数与析构函数，调用顺序</p><p>　　构造函数的调用顺序总是如下：</p><p>　　1.基类构造函数。如果有多个基类，则构造函数的调用顺序是某类<strong><font color="3FAA00">在类派生表中出现的顺序</font></strong>，而不是它们在成员初始化表中的顺序。</p><p>　　2.成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象<strong><font color="3FAA00">在类中被声明的顺序</font></strong>，而不是它们出现在成员初始化表中的顺序。如果有的成员不是类对象，而是基本类型，则初始化顺序按照声明的顺序来确定，而不是在初始化列表中的顺序。</p><p>　　3.派生类构造函数。</p><p>　　析构函数正好和构造函数相反。</p><h3 id="11-extern-“C”的作用"><a href="#11-extern-“C”的作用" class="headerlink" title="11.extern “C”的作用"></a>11.extern “C”的作用</h3><p>　　<code>extern &quot;C&quot;</code>实现C++与C及其它语言的混合编程，是用在C和C++之间的桥梁。之所以需要这个桥梁是因为C编译器编译函数时不带函数的类型信息，只包含函数符号名字；而C++编译器为了实现函数重载，编译时会带上函数的类型信息，如他把上面的a函数可能编译成<code>_a_float</code>这样的符号为了实现重载。</p><p>　　<code>extern &quot;C&quot;</code>的惯用法：</p><p>　　在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为<code>cExample.h</code>）时，需进行下列处理：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">　　<span class="keyword">extern</span> <span class="string">"C"</span>&#123;</div><div class="line">　　　　<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cExample.h"</span></span></div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p><p>　　而在C语言的头文件中，对其外部函数只能指定为<code>extern</code>类型，C语言中不支持<code>extern &quot;C&quot;</code>声明，在<code>.c</code>文件中包含了<code>extern &quot;C&quot;</code>时会出现编译语法错误。</p><p>　　<code>extern</code>本身作为关键字修饰变量（函数）时声明该变量（函数）是外部变量（函数），通常全局变量在头文件中用这种方式声明，在对应源文件中定义，来防止重定义的错误。</p><h3 id="12-析构函数、构造函数能不能被继承"><a href="#12-析构函数、构造函数能不能被继承" class="headerlink" title="12.析构函数、构造函数能不能被继承"></a>12.析构函数、构造函数能不能被继承</h3><p>　　见知识点1</p><h3 id="13-C-为什么用模板类，为什么用泛型"><a href="#13-C-为什么用模板类，为什么用泛型" class="headerlink" title="13.C++为什么用模板类，为什么用泛型"></a>13.C++为什么用模板类，为什么用泛型</h3><p>　　通过泛型可以定义类型安全的数据结构（类型安全），而无须使用实际的数据类型（可扩展）。这能够显著提高性能并得到更高质量的代码（高性能），因为您可以重用数据处理算法，而无须复制类型特定的代码（可重用）。</p><h3 id="14-结构体内存对齐，与什么有关（CPU）"><a href="#14-结构体内存对齐，与什么有关（CPU）" class="headerlink" title="14.结构体内存对齐，与什么有关（CPU）"></a>14.结构体内存对齐，与什么有关（CPU）</h3><p>　　在系统默认的对齐方式下：每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍，且最终占用字节数为成员类型中最大占用字节数的整数倍。</p><p>　　详细分析见博客：<a href="http://www.cnblogs.com/webary/p/4721017.html" target="_blank" rel="external">struct/class等内存字节对齐问题详解</a></p><p>　　为什么要对齐？当CPU访问正确对齐的数据时，它的运行效率最高，当数据大小的数据模数的内存地址是0时，数据是对齐的。例如：WORD值应该是总是从被2除尽的地址开始，而DWORD值应该总是从被4除尽的地址开始，数据对齐不是内存结构的一部分，而是CPU结构的一部分。当CPU试图读取的数值没有正确的对齐时，CPU可以执行两种操作之一：产生一个异常条件；执行多次对齐的内存访问，以便读取完整的未对齐数据，若多次执行内存访问，应用程序的运行速度就会慢。</p><h3 id="15-指针和引用"><a href="#15-指针和引用" class="headerlink" title="15.指针和引用"></a>15.指针和引用</h3><p>　　1.指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。</p><p>　　2.指针可以有多级，但是引用只能是一级；</p><p>　　3.指针的值可以为空，也可能指向一个不确定的内存空间，但是引用的值不能为空，并且引用在定义的时候必须初始化为特定对象；（因此引用更安全）</p><p>　　4.指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变引用对象了；</p><p>　　5.sizeof引用得到的是所指向的变量(对象)的大小，而sizeof指针得到的是指针本身的大小；</p><p>　　6.指针和引用的自增(++)运算意义不一样；</p><h3 id="16-static关键字作用"><a href="#16-static关键字作用" class="headerlink" title="16.static关键字作用"></a>16.static关键字作用</h3><p>　　在C语言中，关键字static有三个明显的作用：</p><p>　　1)在函数体内，一个被声明为静态的变量在这一函数被调用过程中维持上一次的值不变，即只初始化一次（该变量存放在静态变量区，而不是栈区）。</p><p>　　2)在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外访问。（注：模块可以理解为文件）</p><p>　　3)在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。</p><pre><code>【补充】《C和指针》中说static有两层含义：指明存储属性；改变链接属性。 具体解释：（1）全局变量（包括函数）加上static关键字后，链接属性变为internal，也就是将他们限定在了本作用域内；（2）局部变量加上static关键字后，存储属性变为静态存储，不存储在栈区，下一次将保持上一次的尾值。</code></pre><p>　　除此之外，C++中还有新用法：</p><p>　　4)在类中的static成员变量意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；</p><p>　　5)在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量(当然，可以通过传递一个对象来访问其成员)。</p><h3 id="17-虚表，基类的虚表是什么样的，派生类虚表"><a href="#17-虚表，基类的虚表是什么样的，派生类虚表" class="headerlink" title="17.虚表，基类的虚表是什么样的，派生类虚表"></a>17.虚表，基类的虚表是什么样的，派生类虚表</h3><p>　　（1）单继承情况</p><p>　　（2）多重继承（无虚函数覆盖）</p><p>　　（3）多重继承（有虚函数覆盖）</p><p>　　 详细的内容参考博文：关于C++虚函数表的那些事儿</p><h3 id="18-volatile"><a href="#18-volatile" class="headerlink" title="18.volatile"></a>18.volatile</h3><p>　　volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p><p>　　当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p><p>　　volatile 指出 i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在b中。而不是重新从i里面读。这样一来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问。</p><h3 id="19-define与const的区别"><a href="#19-define与const的区别" class="headerlink" title="19.#define与const的区别"></a>19.#define与const的区别</h3><p>　　• define不会做类型检查（容易出错），const拥有类型，会执行相应的类型检查<br>　　• define仅仅是宏替换，不占用内存，而const会占用内存<br>　　• const内存效率更高，编译器可能将const变量保存在符号表中，而不会分配存储空间，这使得它成 为一个编译期间的常量，没有存储和读取的操作</p><p>　　当使用#define定义一个简单的函数时，强烈建议使用内联函数替换！</p><h3 id="20-C-中的强制类型转换"><a href="#20-C-中的强制类型转换" class="headerlink" title="20.C++中的强制类型转换"></a>20.C++中的强制类型转换</h3><p>　　• reinterpret_cast: 转换一个指针为其它类型的指针。它也允许从一个指针转换为整数类型,反之亦 然. 这个操作符能够在非相关的类型之间转换. 操作结果只是简单的从一个指针到别的指针的值的 二进制拷贝. 在类型之间指向的内容不做任何类型的检查和转换?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class A&#123;&#125;; </div><div class="line">class B&#123;&#125;; </div><div class="line">A* a = new A;</div><div class="line">B* b = reinterpret_cast(a);</div></pre></td></tr></table></figure></p><p>　　• static_cast: 允许执行任意的隐式转换和相反转换动作（即使它是不允许隐式的）,例如：应用到类 的指针上, 意思是说它允许子类类型的指针转换为父类类型的指针(这是一个有效的隐式转换), 同 时, 也能够执行相反动作: 转换父类为它的子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class Base &#123;&#125;; </div><div class="line">class Derive:public Base&#123;&#125;; </div><div class="line">Base* a = new Base; </div><div class="line">Derive *b = static_cast(a);</div></pre></td></tr></table></figure></p><p>　　• dynamic_cast: 只用于对象的指针和引用. 当用于多态类型时，它允许任意的隐式类型转换以及相 反过程. 不过，与static_cast不同，在后一种情况里（注：即隐式转换的相反过程）,dynamic_cast 会检查操作是否有效. 也就是说, 它会检查转换是否会返回一个被请求的有效的完整对象。检测在 运行时进行. 如果被转换的指针不是一个被请求的有效完整的对象指针，返回值为NULL. 对于引用 类型，会抛出bad_cast异常。<br>　　• const_cast: 这个转换类型操纵传递对象的const属性，或者是设置或者是移除,例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span>&#125;; </div><div class="line"><span class="keyword">const</span> C* a = <span class="keyword">new</span> C; </div><div class="line">C *b = <span class="keyword">const_cast</span>(a);</div></pre></td></tr></table></figure></p><p>21.析构函数中抛出异常时概括性总结<br>　　（1） C++中析构函数的执行不应该抛出异常；<br>　　（2） 假如析构函数中抛出了异常，那么系统将变得非常危险，也许很长时间什么错误也不会发生；但也许系统有时就会莫名奇妙地崩溃而退出了，而且什么迹象也没有；<br>　　（3） 当在某一个析构函数中会有一些可能（哪怕是一点点可能）发生异常时，那么就必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外，即在析构函数内部写出完整的throw…catch()块。</p><h3 id="22-C-11新特性"><a href="#22-C-11新特性" class="headerlink" title="22.C++11新特性"></a>22.C++11新特性</h3><p>　　Lambda、变参模板、auto、decltype、constexpr、智能指针、列表初始化、正则表达式、线程库、静态断言、委托构造。</p><p>　　weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。</p><p>　　使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。</p><p>　　weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr.</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/16/CPP_review_reproduce/#disqus_thread</comments>
    </item>
    
    <item>
      <title>操作系统常见面试题整理</title>
      <link>http://wangwlj.com/2018/03/16/operating_system_review_reproduce/</link>
      <guid>http://wangwlj.com/2018/03/16/operating_system_review_reproduce/</guid>
      <pubDate>Fri, 16 Mar 2018 12:59:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fpeyf3zq50j21m012o1e2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fpeyf3zq50j21m012o1e2.jpg" alt=""><br><a id="more"></a></p><p>有那么一些零碎的小知识点，偶尔很迷惑，偶尔被忽略，偶然却发现它们很重要，也是各大笔试和面试高频出现考点。这段时间正好在温习这些，就整理在这里，一起学习一起提高！后面还会继续补充。</p><p>本文转载自一个很不错的博客：<a href="http://www.cnblogs.com/webary/p/4782903.html" target="_blank" rel="external">http://www.cnblogs.com/webary/p/4782903.html</a></p><p>我自己也有整理，不过是思维导图的形式，有机会再一起放出来吧。</p><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h3><p>　　线程是指进程内的一个执行单元,也是进程内的可调度实体.</p><p>　　与进程的区别:</p><p>　　(1)地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间(也有少量自己的地址空间);而进程有自己独立的地址空间(多个进程之间一般不会共享地址空间);</p><p>　　(2)资源拥有:进程是资源拥有的单位,同一个进程内的线程共享进程的资源</p><p>　　(3)线程是处理器调度和分派的基本单位.</p><p>　　(4)二者均可并发执行.多线程程序的并发性高。</p><p>　　(5)进程的切换代价远高于线程，同步和通信的实现也比线程复杂。</p><p>　　进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，需要用多线程。</p><h3 id="2-Unix和windows进程间通信的主要方式"><a href="#2-Unix和windows进程间通信的主要方式" class="headerlink" title="2.Unix和windows进程间通信的主要方式"></a>2.Unix和windows进程间通信的主要方式</h3><h4 id="linux系统IPC："><a href="#linux系统IPC：" class="headerlink" title="　　linux系统IPC："></a>　　linux系统IPC：</h4><p>　　<strong>管道( pipe )</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>　　<strong>命名管道 (named pipe)</strong> ： 命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p><p>　　<strong>信号量( semophore )</strong>： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><p>　　<strong>消息队列( message queue )</strong> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p><p>　　<strong>信号 ( sinal )</strong>：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p><p>　　<strong>共享内存( shared memory )</strong> ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p><p>　　<strong>套接字( socket )</strong> ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p><h4 id="windows系统IPC："><a href="#windows系统IPC：" class="headerlink" title="　　windows系统IPC："></a>　　windows系统IPC：</h4><p>　　<strong>剪贴板(Clipboard)</strong>：当用户在应用程序中执行剪切或复制操作时，应用程序将选定的数据以一个或多个标准或应用程序定义的格式放在剪贴板中。</p><p>　　<strong>WM_COPYDATA消息</strong>：当一个应用向另一个应用传送数据时，发送方只需使用调用SendMessage函数， 接收方只需像处理其它消息那样处理WM_COPYDATA消息，这样收发双方就实现了数据共享，它在底层实际上是通过文件映射来实现的。</p><p>　　<strong>文件映射(File Mapping )</strong>：使进程把文件内容当作进程地址区间一块内存那样来对待。只需简单的指针操作就可读取和修改文件的内容。 允许多个进程访问同一文件映射对象，各个进程在它自己的地址空间里接收内存的指针，通过使用这些指针，不同进程就可以读写文件的内容，实现了对文件中数据的共享。</p><p>　　<strong>共享内存(Shared Memory)</strong>是文件映射的一种特殊情况进程在创建文件映射对象时用0xFFFFFFFF来代替文件句柄(HANDLE)，就表示了对应的文件映射对象是从操作系统页面文件访问内存，其它进程打开该文件映射对象就可以访问该内存块。由于共享内存是用 文件映射实现的， 所以它也有较好的安全性，也只能运行于同一计算机上的进程之间。</p><p>　　<strong>动态数据交换(DDE)</strong>：是使用共享内存在应用程序之间进行数据交换的一种进程间通信形式。应用程序可以使用DDE进行一次性数据传输，也可以当出现新数据时， 通过发送更新值在应用程序间动态交换数据。DDE和剪贴板一样既支持标准数据格式(如文本、位图等)，又可以支持自己定义的数据格式。但它们的数据传输机制却不同，一个明显区别是剪贴板操作几乎总是用作对用户指定操作的一次性应答，如从菜单中选择Paste命令。尽管DDE也可以由用户启动，但它继续发挥作用一般不必用户进一步干预。可以发生在单机或网络中不同计算机的应用程序之间。</p><p>　　<strong>邮件槽(Mailslot)</strong>：提供进程间单向通信能力，任何进程都能建立邮件槽成为邮件槽服务器。其它进程称为邮件槽客户，可以通过邮件槽的名字给邮件槽服务器进程发送消息。进来的消息一直放在邮件槽中，直到服务器进程读取它为止。一个进程既可以是邮件槽服务器也可以是邮件槽客户，因此可建立多个 邮件槽实现进程间的双向通信。</p><p>　　<strong>管道( pipe )</strong>：同上linux系统 &amp; 命名管道</p><p>　　<strong>套接字（Sockets  ）</strong>：同上linux系统</p><h3 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3.死锁"></a>3.死锁</h3><p>　　死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的僵局，若无外力作用，它们都将无法推进下去。</p><p>　　产生死锁的四个<strong>必要条件</strong>：</p><p>　　1.互斥条件：一段时间内某资源只由一个进程占有。<br>　　2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>　　3.不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。<br>　　4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p><p>　　预防死锁：需要打破必要条件的2，3，4中之一，由于施加的限制条件较严格，可能导致系统资源利用率和系统吞吐量降低。</p><p>　　避免死锁：施加的限制条件较弱，使系统一直处于安全状态。比如银行家算法。</p><p>　　检测死锁：资源分配图、死锁定理。</p><p>　　解除死锁：剥夺起源、撤销进程。</p><h3 id="4-windows下什么线程优先级最高"><a href="#4-windows下什么线程优先级最高" class="headerlink" title="4.windows下什么线程优先级最高"></a>4.windows下什么线程优先级最高</h3><p>　　<code>SetThreadPriority</code>  设置指定线程的优先级：</p><p>　　<code>BOOL SetThreadPriority(HANDLE hThread, int nPriority);</code></p><p>　　参数说明：</p><p>　　<code>hThread</code>  要设置的线程句柄<br>　　<code>nPriority</code> 优先级别参数 可设置为一下参数</p><p>　　<code>THREAD_PRIORITY_ABOVE_NORMAL</code>  比一般优先级高一个等级<br>　　<code>THREAD_PRIORITY_BELOW_NORMAL</code> 比一般低一个等级<br>　　<code>THREAD_PRIORITY_HIGHEST</code>               比一般高2个等级（最高）<br>　　<code>THREAD_PRIORITY_IDLE</code>                      空闲<br>　　<code>THREAD_PRIORITY_LOWEST</code>                比一般低2个等级（最低）<br>　　<code>THREAD_PRIORITY_NORMAL</code>                一般等级<br>　　<code>THREAD_PRIORITY_TIME_CRITICAL</code>    实时</p><h3 id="5-linux下fork函数"><a href="#5-linux下fork函数" class="headerlink" title="5.linux下fork函数"></a>5.linux下fork函数</h3><p>　　在<code>fork()</code>的调用处，创建一个子进程，并将整个父进程空间会原模原样地复制到子进程中，包括指令，变量值，程序调用栈，环境变量，缓冲区等。<code>fork</code>调用仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p><p>　　（1）在父进程中，fork返回新创建子进程的进程ID；<br>　　（2）在子进程中，fork返回0；<br>　　（3）如果出现错误，fork返回一个负值；</p><p>　　在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p><p>　　fork出错可能有两种原因：</p><p>　　1）当前的进程数已经达到了系统规定的上限，这时<code>errno</code>的值被设置为<code>EAGAIN</code>。<br>　　2）系统内存不足，这时<code>errno</code>的值被设置为<code>ENOMEM</code>。</p><p>　　创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</div><div class="line">        <span class="keyword">pid_t</span> fpid = fork();</div><div class="line">        <span class="keyword">if</span>(fpid==<span class="number">0</span>)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"son\n"</span>);</div><div class="line">        <span class="keyword">else</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"father\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　对于这种N次循环的情况，执行printf函数的次数为<code>2*（2^N-1）</code>次，创建的子进程数为<code>2^N-1</code>个。输出中没有换行时缓冲区也会被复制，参见：<a href="http://www.oschina.net/question/195301_62902" target="_blank" rel="external">http://www.oschina.net/question/195301_62902</a> </p><h3 id="6-程序什么时候使用多线程好，什么时候单线程效率高"><a href="#6-程序什么时候使用多线程好，什么时候单线程效率高" class="headerlink" title="6.程序什么时候使用多线程好，什么时候单线程效率高"></a>6.程序什么时候使用多线程好，什么时候单线程效率高</h3><p>　　1．耗时的操作使用线程，提高应用程序响应速度<br>　　2．并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求<br>　　3．多CPU系统中，使用线程提高CPU利用率<br>　　4．改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。其他情况都使用单线程。</p><h3 id="7-线程间通信"><a href="#7-线程间通信" class="headerlink" title="7.线程间通信"></a>7.线程间通信</h3><p>　　互锁函数、临界段、内核对象（事件对象、互斥对象、信号量）</p><h3 id="8-进程状态转换"><a href="#8-进程状态转换" class="headerlink" title="8.进程状态转换"></a>8.进程状态转换</h3><p>　　在操作系统中，进程一般有三种基本状态：运行状态，就绪状态和等待状态。</p><p>　　1）就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；</p><p>　　2）执行——等待：正在执行的进程因发生某等待事件而无法执行，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等； </p><p>　　3）等待——就绪：处于等待状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；</p><p>　　4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。</p><h3 id="9-内存地址：虚拟地址-线性地址-物理地址的区别与联系"><a href="#9-内存地址：虚拟地址-线性地址-物理地址的区别与联系" class="headerlink" title="9.内存地址：虚拟地址-线性地址-物理地址的区别与联系"></a>9.内存地址：虚拟地址-线性地址-物理地址的区别与联系</h3><p>　　<code>x86</code>平台下的系统采用分段机制与分页机制对地址进行转换，其中分段机制把一个虚拟地址转换成线性地址；分页机制把一个线性地址转换成物理地址。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>《计算机操作系统（第三版）》，西安电子科技大学出版社，汤小丹等</p><p><a href="http://blog.csdn.net/jason314/article/details/5640969" target="_blank" rel="external">linux中fork（）函数详解（原创！！实例讲解）</a></p><p><a href="http://www.oschina.net/question/195301_62902" target="_blank" rel="external">一个fork的面试题</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/16/operating_system_review_reproduce/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：不用加减乘除做加法</title>
      <link>http://wangwlj.com/2018/03/16/coding_offer46_sum1toN/</link>
      <guid>http://wangwlj.com/2018/03/16/coding_offer46_sum1toN/</guid>
      <pubDate>Fri, 16 Mar 2018 12:59:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fpeyy7l1ldj23nd2qj1l1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;四种解法，只有想不到，没有做不到！！&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fpeyy7l1ldj23nd2qj1l1.jpg" alt=""></p><blockquote><p>四种解法，只有想不到，没有做不到！！</p></blockquote><a id="more"></a><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><blockquote><p>四种解法，只有想不到，没有做不到！！</p></blockquote><h3 id="解法一：短路求值"><a href="#解法一：短路求值" class="headerlink" title="解法一：短路求值"></a>解法一：短路求值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> ans = n;</div><div class="line">        ans &amp;&amp; (ans += Sum_Solution(n - <span class="number">1</span>));</div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="解法二：利用异常"><a href="#解法二：利用异常" class="headerlink" title="解法二：利用异常"></a>解法二：利用异常</h3><p>用异常退出递归。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//用异常退出递归</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sum(n);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">1</span>%n;</div><div class="line">            <span class="keyword">return</span> n+sum(n<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="解法三：乘法-gt-sizeof"><a href="#解法三：乘法-gt-sizeof" class="headerlink" title="解法三：乘法-&gt;sizeof"></a>解法三：乘法-&gt;sizeof</h3><p>用公式是不可以的，公式里有乘法！！实现乘法可以用sizeof多维数组，两行代码就可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">bool</span> a[n][n+<span class="number">1</span>];</div><div class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(a)&gt;&gt;<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="解法四：乘法-gt-快速模乘"><a href="#解法四：乘法-gt-快速模乘" class="headerlink" title="解法四：乘法-&gt;快速模乘"></a>解法四：乘法-&gt;快速模乘</h3><p>马客(Mark)：<br>我就猜到大家都是用 <code>&amp;&amp;</code> 的短路原则的，这样复杂是O(n)的。<br>我来一个复杂度32的，可以说O(logM)吧，M是数值大小，对于int也可以说是O(1)吧虽然常数有点大。</p><p>原理就是，类似快速幂，俗称快速模乘。</p><p><code>a * b</code>可以这样算：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">res = <span class="number">0</span></div><div class="line"><span class="keyword">while</span>(a)&#123;</div><div class="line">    <span class="keyword">if</span>(a &amp; <span class="number">1</span>) res += b;</div><div class="line">    a &gt;&gt;= <span class="number">1</span>;</div><div class="line">    b &lt;&lt;= <span class="number">1</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>原理是把a拆成2的幂的和，<code>a = 2^e0 + 2^e1 + 2^e2....</code><br>那么 <code>a * b = (2^e0 + 2^e1 + 2^e2+...) * b = b * 2^e0 + b * 2^e1 + b * 2^e2 + ...= (b &lt;&lt; e0) + (b &lt;&lt; e1) + ....</code></p><p>也就是看成了二进制的相乘。可以写成如下代码【然而用了while】<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="comment">// res = (n+1)xn/2</span></div><div class="line">        <span class="keyword">int</span> a = n, b = n + <span class="number">1</span>, ans = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(a) &#123;</div><div class="line">            <span class="keyword">if</span>(a &amp; <span class="number">1</span>) &#123;</div><div class="line">                ans += b;</div><div class="line">            &#125;</div><div class="line">            a &gt;&gt;= <span class="number">1</span>;</div><div class="line">            b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>由于不能使用while语句，所以符合题意的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//奇数返回0xffffffff，否则0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) ((((x) &amp; 1) <span class="meta-string">&lt;&lt; 31) &gt;&gt; 31)</span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a = n, b = n + <span class="number">1</span>, s = <span class="number">0</span>;</div><div class="line">        <span class="comment">//复制32次。。</span></div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">         </div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">         </div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">         </div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        s += b &amp; f(a); a &gt;&gt;= <span class="number">1</span>; b &lt;&lt;= <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> s &gt;&gt; <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/16/coding_offer46_sum1toN/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：从1到n整数中1出现的次数</title>
      <link>http://wangwlj.com/2018/03/08/coding_offer32_1toN/</link>
      <guid>http://wangwlj.com/2018/03/08/coding_offer32_1toN/</guid>
      <pubDate>Thu, 08 Mar 2018 06:06:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp5bof1excj23eb1wsnpd.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp5bof1excj23eb1wsnpd.jpg" alt=""><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p><p>额，题目的意思实际上是求出从1到n整数中1出现的次数。</p><p>链接：<a href="https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6" target="_blank" rel="external">https://www.nowcoder.com/questionTerminal/bd7f978302044eee894445e244c7eee6</a></p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>设N = abcde ,其中abcde分别为十进制中各位上的数字。<br>如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。</p><p>① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~199，1100~1199,2100~2199，，…，11100~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。</p><p>② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~199，1100~1199,2100~2199，，….，11100~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~12113,一共114个，等于低位数字（113）+1。</p><p>③ 如果百位上数字大于1（2~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~199,1100~1199，2100~2199，…，11100~11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。</p><blockquote><p>这题没看题解之前真是一脸懵逼，找规律真是不太容易啊。</p></blockquote><p>至此，就可以写代码了，为了加深理解，我再通过表格的形式叙述一下算法流程。以21345为例，列表如下：</p><table><thead><tr><th>i(当前位)</th><th>n/i/10(前面的数)</th><th>n/i%10(当前位的值)</th><th>n%i(后面的数)</th><th>当前位1的个数</th></tr></thead><tbody><tr><td>1（个位）</td><td>2134</td><td>5</td><td>0</td><td>(2134+1)x1=2135</td></tr><tr><td>10（十位）</td><td>213</td><td>4</td><td>5</td><td>(213+1)x10=2140</td></tr><tr><td>100（百位）</td><td>21</td><td>3</td><td>45</td><td>(21+1)x100=2200</td></tr><tr><td>1000</td><td>2</td><td>1</td><td>345</td><td>2x1000+345+1 = 2346</td></tr><tr><td>10000</td><td>0</td><td>2</td><td>1345</td><td>(0+1)x10000=10000</td></tr></tbody></table><p>综合起来最终结果就是18821.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//1的个数</span></div><div class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//当前位</span></div><div class="line">        <span class="keyword">int</span> current = <span class="number">0</span>,after = <span class="number">0</span>,before = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>((n/i)!= <span class="number">0</span>)&#123;           </div><div class="line">            current = (n/i)%<span class="number">10</span>; <span class="comment">//高位数字</span></div><div class="line">            before = n/(i*<span class="number">10</span>); <span class="comment">//当前位数字</span></div><div class="line">            after = n-(n/i)*i; <span class="comment">//低位数字</span></div><div class="line">            <span class="comment">//如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数</span></div><div class="line">            <span class="keyword">if</span> (current == <span class="number">0</span>)</div><div class="line">                count += before*i;</div><div class="line">            <span class="comment">//如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(current == <span class="number">1</span>)</div><div class="line">                count += before * i + after + <span class="number">1</span>;</div><div class="line">            <span class="comment">//如果大于1,出现1的次数由高位决定,//（高位数字+1）* 当前位数</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                count += (before + <span class="number">1</span>) * i;</div><div class="line">            &#125;    </div><div class="line">            <span class="comment">//前移一位</span></div><div class="line">            i = i*<span class="number">10</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面看懂了之后，再来看这个解法，也很容易。<br>其实思路是一样的，只不过代码更加简洁了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">    <span class="comment">//主要思路：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析</span></div><div class="line">    <span class="comment">//根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i</span></div><div class="line">    <span class="comment">//当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为1</span></div><div class="line">    <span class="comment">//当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1</span></div><div class="line">    <span class="comment">//当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）</span></div><div class="line">    <span class="comment">//综合以上三种情况，当百位对应0或&gt;=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1</span></div><div class="line">    <span class="comment">//之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)</span></div><div class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i*=<span class="number">10</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//i表示当前分析的是哪一个数位</span></div><div class="line">        <span class="keyword">int</span> a = n/i,b = n%i;</div><div class="line">        count=count+(a+<span class="number">8</span>)/<span class="number">10</span>*i+(a%<span class="number">10</span>==<span class="number">1</span>)*(b+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/08/coding_offer32_1toN/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：斐波那契数列</title>
      <link>http://wangwlj.com/2018/03/06/coding_offer09_Fibonacci/</link>
      <guid>http://wangwlj.com/2018/03/06/coding_offer09_Fibonacci/</guid>
      <pubDate>Tue, 06 Mar 2018 11:57:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp4ae6zmdtj22gg2gkkj7.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp4ae6zmdtj22gg2gkkj7.jpg" alt=""><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39</p><p>题目链接：<a href="https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3" target="_blank" rel="external">https://www.nowcoder.com/questionTerminal/c6c7742f5ba7442aada113136ddea0c3</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>给出解法，详细分析见后面：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">            方法一：时间花费950ms，接近一秒了。。。</span></div><div class="line"><span class="comment">        */</span></div><div class="line">        <span class="comment">//if(n &lt;= 0 )</span></div><div class="line">        <span class="comment">//    return 0;</span></div><div class="line">        <span class="comment">//else if (n == 1)</span></div><div class="line">        <span class="comment">//    return 1;</span></div><div class="line">        <span class="comment">//return Fibonacci(n - 1) + Fibonacci(n -2);</span></div><div class="line">        </div><div class="line">        <span class="comment">//方法二：</span></div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span> )</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> ans_i = <span class="number">0</span>, ans_i_1 = <span class="number">1</span>, ans_i_2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(n &gt;= i)&#123;</div><div class="line">            ans_i = ans_i_1 + ans_i_2;</div><div class="line">            ans_i_2 = ans_i_1;</div><div class="line">            ans_i_1 = ans_i;</div><div class="line">            ++i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ans_i;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这个题可以说是迭代（Iteration） VS 递归（Recursion），<br>f(n) = f(n-1) + f(n-2)，第一眼看就是递归啊，简直完美的递归环境，递归肯定很爽，这样想着关键代码两三行就搞定了，注意这题的n是从0开始的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</div><div class="line"><span class="keyword">else</span> <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</div></pre></td></tr></table></figure></p><p>然而并没有什么用，测试用例里肯定准备着一个超大的n来让Stack Overflow，为什么会溢出？因为重复计算，而且重复的情况还很严重，举个小点的例子，n=4，看看程序怎么跑的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Fibonacci(<span class="number">4</span>) = Fibonacci(<span class="number">3</span>) + Fibonacci(<span class="number">2</span>);</div><div class="line">             = Fibonacci(<span class="number">2</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">0</span>);</div><div class="line">             = Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">0</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">1</span>) + Fibonacci(<span class="number">0</span>);</div></pre></td></tr></table></figure></p><p>由于我们的代码并没有记录Fibonacci(1)和Fibonacci(0)的结果，对于程序来说它每次递归都是未知的，因此光是n=4时f(1)就重复计算了3次之多。</p><p>那么如何求解呢，动态规划似乎不错，关于动态规划三个条件：最优子结构、无后效性、子问题重叠这些就不谈了，因为理(wo)论(ye)性(bu)太(tai)强(dong)了。</p><p>下例是一个简单的动态规划，以一定的空间代价避免代价更大的重复计算的栈空间浪费：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">record[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">record[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</div><div class="line">    record[i] = record[i<span class="number">-1</span>] + record[i<span class="number">-2</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> record[n];</div></pre></td></tr></table></figure></p><p>虽然看起来很蠢，空间浪费了<code>sizeof(int)*(n-1)</code>，但是对于那个超大n的测试用例应该是可以通过了，时间复杂度也达到了O(n)。<br>那能不能把“优雅”的递归和动态规划结合起来呢？递归的优点在于便于理解和编码，而重复计算的关键原因在于代码里直接就“递”进去然后等着“归”了，所以避免重复的关键在于对子问题是否已经得出解的判断，即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] record = null;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</div><div class="line">         <span class="keyword">return</span> n;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(null == record)&#123;</div><div class="line">        record = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(<span class="number">0</span>!=record[n<span class="number">-2</span>] &amp;&amp; <span class="number">0</span>!=record[n<span class="number">-1</span>])&#123;</div><div class="line">        record[n] = record[n<span class="number">-2</span>] + record[n<span class="number">-1</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> Fibonacci(n<span class="number">-2</span>) + Fibonacci(n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/06/coding_offer09_Fibonacci/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：旋转数组的最小数字</title>
      <link>http://wangwlj.com/2018/03/06/coding_offer08_findMinNumberInRotateArray/</link>
      <guid>http://wangwlj.com/2018/03/06/coding_offer08_findMinNumberInRotateArray/</guid>
      <pubDate>Tue, 06 Mar 2018 11:57:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp3d1c9f1wj22bc1jke81.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp3d1c9f1wj22bc1jke81.jpg" alt=""><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>输入一个非递减排序的数组(如{1,2,3,4,5})的一个旋转(如{3,4,5,1,2})，输出旋转数组的最小元素。 </p><p>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p>简而言之，输入的是旋转后的数组，输出数组的最小数字。</p><p>最简单的方法当然是从头到尾查找一遍就知道最小数字了，复杂度为$O(n)$，不过这并不是能让面试官满意的答案。</p><p>需要结合旋转数组的特性来分析。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道二分查找的变形的题目。</p><p>旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的大小都大于后面子数组中的元素</p><p>注意到实际上最小的元素就是两个子数组的分界线。本题目给出的数组一定程度上是排序的，因此我们试着用二分查找法寻找这个最小的元素。</p><p>思路：</p><p>（1）我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。</p><p>但是如果不是旋转，第一个元素肯定小于最后一个元素。</p><p>（2）找到数组的中间元素。</p><p>中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。</p><p>移动之后，第一个指针仍然位于前面的递增数组中。</p><p>中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。</p><p>移动之后，第二个指针仍然位于后面的递增数组中。</p><p>这样可以缩小寻找的范围。</p><p>（3）按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。</p><p>最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。</p><p>也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。</p><p>此时的解法答案如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = rotateArray.size();</div><div class="line">        <span class="keyword">if</span>(<span class="number">0</span> == size) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = size - <span class="number">1</span>, mid;</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>((high - low) &gt; <span class="number">1</span>) &#123;</div><div class="line">            mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt; rotateArray[<span class="number">0</span>]) <span class="comment">//位于左半递增数组上</span></div><div class="line">                low = mid;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt; rotateArray[size - <span class="number">1</span>]) &#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> rotateArray[high];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>到目前为止以上思路很好的解决了没有重复数字的情况，这一道题目添加上了这一要求，<strong>有了重复数字</strong>。</p><p>因此这一道题目比上一道题目多了些特殊情况：</p><p>我们看一组例子：<code>｛1，0，1，1，1｝</code> 和 <code>｛1，1， 1，0，1｝</code> 都可以看成是递增排序数组<code>｛0，1，1，1，1｝</code>的旋转。</p><p>这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。</p><p>第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。</p><p>因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（绿色表示）还是属于后面的子数组（紫色表示）。</p><p>也就无法移动指针来缩小查找的范围。</p><p>因此只能按照正常的顺序来遍历查找最小的元素。</p><p>再次放上最终版本的代码。基本上考虑了所有的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> size = rotateArray.size();</div><div class="line"><span class="keyword">int</span> min = <span class="number">0x7fffffff</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = rotateArray.begin(); i != rotateArray.end(); ++i) &#123;</div><div class="line"><span class="keyword">if</span>(min &gt; *i) &#123;</div><div class="line">min = *i;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> min;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> size = rotateArray.size();</div><div class="line">        <span class="keyword">if</span>(<span class="number">0</span> == size) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = size - <span class="number">1</span>, mid;</div><div class="line">        <span class="keyword">if</span>(rotateArray[low] &lt; rotateArray[high]) &#123; <span class="comment">//翻转了0个或者翻转全部</span></div><div class="line">            <span class="keyword">return</span> rotateArray[low];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>((high - low) &gt; <span class="number">1</span>) &#123;</div><div class="line">            mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</div><div class="line"><span class="keyword">if</span>(rotateArray[mid] == rotateArray[<span class="number">0</span>] &amp;&amp; rotateArray[mid] == rotateArray[size - <span class="number">1</span>]) <span class="comment">//三个数字都相同，这一种情况比较特殊。</span></div><div class="line">                <span class="keyword">return</span> MinInOrder(rotateArray);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &gt;= rotateArray[<span class="number">0</span>]) <span class="comment">//位于左半递增数组上</span></div><div class="line">                low = mid;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid] &lt;= rotateArray[size - <span class="number">1</span>]) &#123;</div><div class="line">                high = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> rotateArray[high];</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Solution *s = <span class="keyword">new</span> Solution();</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minNumberInRotateArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minNumberInRotateArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s-&gt;minNumberInRotateArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/06/coding_offer08_findMinNumberInRotateArray/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：用两个栈实现队列</title>
      <link>http://wangwlj.com/2018/03/06/coding_offer07_stack2queue/</link>
      <guid>http://wangwlj.com/2018/03/06/coding_offer07_stack2queue/</guid>
      <pubDate>Tue, 06 Mar 2018 02:57:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp3cq46xhdj23v92ky4qs.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp3cq46xhdj23v92ky4qs.jpg" alt=""><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的<code>Push</code>和<code>Pop</code>操作。 队列中的元素为<code>int</code>类型。</p><p>C++版本的初始代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="用两个栈实现一个队列的功能-要求给出算法和思路"><a href="#用两个栈实现一个队列的功能-要求给出算法和思路" class="headerlink" title="用两个栈实现一个队列的功能?要求给出算法和思路!"></a>用两个栈实现一个队列的功能?要求给出算法和思路!</h3><p>&lt;分析&gt;：</p><p>入队：将元素进栈A<br>出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。</p><p>换个说法：<br>栈A用来作入队列；栈B用来出队列，当栈B为空时，栈A全部出栈到栈B,栈B再出栈（即出队列）。</p><p>本地测试的完整C++程序：【添加了一个打印函数】<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(stack2.size() &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">while</span> (stack1.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">int</span> data = stack1.top();</div><div class="line">                stack1.pop();</div><div class="line">                stack2.push(data);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>)</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            <span class="comment">//throw new exception("queue is empty");</span></div><div class="line">        </div><div class="line">        <span class="keyword">int</span> head = stack2.top();</div><div class="line">        stack2.pop();</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">show_value</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> data;</div><div class="line">        <span class="keyword">while</span> (stack2.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            data = stack2.top();</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="string">" "</span>;</div><div class="line">            stack2.pop();</div><div class="line">            stack1.push(data);</div><div class="line">            ++count;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (stack1.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            data = stack1.top();</div><div class="line">            stack1.pop();</div><div class="line">            stack2.push(data);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// stack2中只返回原先就在stack1中的值。</span></div><div class="line">        <span class="keyword">while</span> (stack2.size() &gt; count) &#123;</div><div class="line">            data = stack2.top();</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="string">" "</span>;</div><div class="line">            stack2.pop();</div><div class="line">            stack1.push(data);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>  (stack2.size() != count )</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"error:"</span> &lt;&lt; stack2.size() &lt;&lt; <span class="string">" != "</span> &lt;&lt; count;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Solution *s = <span class="keyword">new</span> Solution();</div><div class="line">    s-&gt;push(<span class="number">5</span>);</div><div class="line">    s-&gt;push(<span class="number">4</span>);</div><div class="line">    s-&gt;push(<span class="number">3</span>);</div><div class="line">    s-&gt;push(<span class="number">2</span>);</div><div class="line">    s-&gt;pop();</div><div class="line">    s-&gt;push(<span class="number">1</span>);</div><div class="line">    s-&gt;push(<span class="number">0</span>);</div><div class="line">    s-&gt;push(<span class="number">-1</span>);</div><div class="line">    s-&gt;pop();</div><div class="line">    s-&gt;push(<span class="number">-2</span>);</div><div class="line">    <span class="comment">// 打印出队列的值。</span></div><div class="line">    s-&gt;show_value();</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>此外，还可以思考一下：</p><h3 id="用两个队列实现一个栈的功能-要求给出算法和思路"><a href="#用两个队列实现一个栈的功能-要求给出算法和思路" class="headerlink" title="用两个队列实现一个栈的功能?要求给出算法和思路!"></a>用两个队列实现一个栈的功能?要求给出算法和思路!</h3><p>&lt;分析&gt;：</p><p>入栈：将元素进队列A<br>出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素   以此出队列并放入队列B，直到队列A中的元素留下一个，然后队列A出队列，再把队列B中的元素出队列依次放入队列A中。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/06/coding_offer07_stack2queue/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：重建二叉树</title>
      <link>http://wangwlj.com/2018/03/05/coding_offer06_reconstractBinaryTree/</link>
      <guid>http://wangwlj.com/2018/03/05/coding_offer06_reconstractBinaryTree/</guid>
      <pubDate>Mon, 05 Mar 2018 12:35:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp27xeqledj23sw2iou0x.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp27xeqledj23sw2iou0x.jpg" alt=""><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>根节点肯定是前序遍历的第一个数。找到中序遍历根节点所在位置。<br>对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边。利用上述这点，对二叉树节点进行归并。<br>取出前序和中序遍历根节点左边和右边的子树递归，再对其进行上述所有步骤（递归），即再区分子树的左、右子子数，直到叶节点。</p><p>Python的解法简洁明了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="comment"># class TreeNode:</span></div><div class="line"><span class="comment">#     def __init__(self, x):</span></div><div class="line"><span class="comment">#         self.val = x</span></div><div class="line"><span class="comment">#         self.left = None</span></div><div class="line"><span class="comment">#         self.right = None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></div><div class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></div><div class="line">        <span class="comment"># write code here</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        root = TreeNode(pre.pop(<span class="number">0</span>))</div><div class="line">        index = tin.index(root.val)</div><div class="line">        root.left = self.reConstructBinaryTree(pre, tin[:index])</div><div class="line">        root.right = self.reConstructBinaryTree(pre, tin[index + <span class="number">1</span>:])</div><div class="line">        <span class="keyword">return</span> root</div></pre></td></tr></table></figure></p><p>这是C++的解法，一样的思路。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 先序遍历第一个位置肯定是根节点node，</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">  中序遍历的根节点位置在中间p，在p左边的肯定是node的左子树的中序数组，p右边的肯定是node的右子树的中序数组</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">  另一方面，先序遍历的第二个位置到p，也是node左子树的先序子数组，剩下p右边的就是node的右子树的先序子数组</span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment">  把四个数组找出来，分左右递归调用即可。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"> </div><div class="line"><span class="keyword">public</span>:</div><div class="line"> </div><div class="line">    <span class="function">struct TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in)</span> </span>&#123;</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> in_size = in.size();</div><div class="line">        <span class="keyword">if</span>(in_size == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre_left, pre_right, in_left, in_right;</div><div class="line">        <span class="comment">//创建根节点，根节点肯定是前序遍历的第一个数</span></div><div class="line">        <span class="keyword">int</span> val = pre[<span class="number">0</span>];</div><div class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(val);<span class="comment">//root node is the first element in pre</span></div><div class="line">        <span class="comment">//找到中序遍历根节点所在位置,存放于变量p中</span></div><div class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(p; p &lt; in_size; ++p)&#123;</div><div class="line">            <span class="keyword">if</span>(in[p] == val) <span class="comment">//Find the root position in in</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"> <span class="comment">//对二叉树节点进行归并</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in_size; ++i)&#123;</div><div class="line">            <span class="keyword">if</span>(i &lt; p)&#123;</div><div class="line">                in_left.push_back(in[i]);<span class="comment">//Construct the left pre and in </span></div><div class="line">                pre_left.push_back(pre[i+<span class="number">1</span>]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; p)&#123;</div><div class="line">                in_right.push_back(in[i]);<span class="comment">//Construct the right pre and in </span></div><div class="line">                pre_right.push_back(pre[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> <span class="comment">//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span></div><div class="line">        node-&gt;left = reConstructBinaryTree(pre_left, in_left);</div><div class="line">        node-&gt;right = reConstructBinaryTree(pre_right, in_right);</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> node;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/05/coding_offer06_reconstractBinaryTree/#disqus_thread</comments>
    </item>
    
    <item>
      <title>剑指offer面试题：二维数组中的查找</title>
      <link>http://wangwlj.com/2018/03/05/coding_offer03_findInArray/</link>
      <guid>http://wangwlj.com/2018/03/05/coding_offer03_findInArray/</guid>
      <pubDate>Mon, 05 Mar 2018 10:05:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp27ztrx3kj23vc2kw7wi.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp27ztrx3kj23vc2kw7wi.jpg" alt=""><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>从右上角（或者左下角）的元素开始查找。</p><p>矩阵是有序的，有：<br>从右上角来看，向左数字递减，向下数字递增，因此从右上角开始查找，当要查找数字比右上角数字大时，下移；要查找数字比右上角数字小时，左移。<br>从左下角来看，向上数字递减，向右数字递增，因此从左下角开始查找，当要查找数字比左下角数字大时，右移；要查找数字比左下角数字小时，上移。</p><p>代码以右上角为例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>.empty())</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">int</span> rows = <span class="built_in">array</span>.size();</div><div class="line">    <span class="keyword">int</span> cols = <span class="built_in">array</span>[<span class="number">0</span>].size();</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(rows &gt; <span class="number">0</span> &amp;&amp; cols &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> row = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> col = cols - <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[row][col] == target) &#123;</div><div class="line">                found = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[row][col] &gt; target)</div><div class="line">                --col;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                ++row;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> found;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/05/coding_offer03_findInArray/#disqus_thread</comments>
    </item>
    
    <item>
      <title>编程题：扇形染色问题</title>
      <link>http://wangwlj.com/2018/03/05/coding_dye_problem/</link>
      <guid>http://wangwlj.com/2018/03/05/coding_dye_problem/</guid>
      <pubDate>Mon, 05 Mar 2018 09:05:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp24xc81mjj23vc2kwqv8.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp24xc81mjj23vc2kwqv8.jpg" alt=""><br><a id="more"></a></p><h2 id="染色问题"><a href="#染色问题" class="headerlink" title="染色问题"></a>染色问题</h2><p>将一个圆形等分成N个小扇形,将这些扇形标记为1,2,3,…,N。现在使用M种颜色对每个扇形进行涂色，每个扇形涂一种颜色，且相邻的扇形颜色不同。</p><p>求：有多少种涂色方法。<br>备注：<br>1，不考虑数值越界。<br>2，N&gt;=1，M&gt;=3;</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>【分析】设$a(n) $为符合要求的对n个扇形的涂色方法。<br>对扇形1有m种涂色方法，扇形2有m－1种涂色方法，扇形3也有m－1种涂色方法，扇形n也有m－1种涂色方法。于是，共有$m\times (m-1)^{n-1} $种不同的涂色方法。但是，$a(n)\neq m\times (m-1)^{n-1} $，因为这种涂色方法可能出现1与n着色相同的情形，这是不符合题意的，因此，答案应从$m\times (m-1)^{n-1} $中减去这些不符合题意的涂色方法。</p><p>那么，这些不符合题意的涂色方法，又怎样计算呢？这时，把1与n看作一个扇形，其涂色方法相当于用m种颜色对n－1个扇形涂色（这种转换思维相当巧妙），不同的涂色方法有$a(n-1)$种，于是，有：<br>$$a(n)= m\times (m-1)^{n-1} - a(n-1)\cdots \cdots (n≥3) $$<br>其中，$a(3)=m(m-1)(m-2) $，上式是数列的递推公式，可推导出$a(n)$的通项公式：<br>$$a(n)= (m-1)^{n} - (-1)^n (m-1)\cdots \cdots (n≥3) $$</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们根据递推公式，采用递归法实现计算。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">color</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</div><div class="line"><span class="keyword">return</span> m;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</div><div class="line"><span class="keyword">return</span> m*(m - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//else if(n == 3)&#123;</span></div><div class="line"><span class="comment">//return m*(m - 1)*(m - 2);</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="keyword">return</span> m* <span class="built_in">pow</span>(m<span class="number">-1</span>, n<span class="number">-1</span>) - color (m, n<span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; color(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; color(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="string">" "</span> &lt;&lt; color(<span class="number">4</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当然也可以直接根据通项公式来编程。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/03/05/coding_dye_problem/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
