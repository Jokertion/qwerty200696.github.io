<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wangwlj&#39;s Blog</title>
    <link>http://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Mon, 26 Feb 2018 15:04:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>C++ Primer学习笔记：(十一)关联容器</title>
      <link>http://wangwlj.com/2018/02/26/CPP_11/</link>
      <guid>http://wangwlj.com/2018/02/26/CPP_11/</guid>
      <pubDate>Mon, 26 Feb 2018 13:41:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ws2.sinaimg.cn/mw690/c38a0784gy1fou6gje7a1j23vc2kw7oj.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ws2.sinaimg.cn/mw690/c38a0784gy1fou6gje7a1j23vc2kw7oj.jpg" alt="image"></p><a id="more"></a><h2 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h2><p>关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p><h3 id="关联容器类型"><a href="#关联容器类型" class="headerlink" title="关联容器类型"></a>关联容器类型</h3><table><thead><tr><th>关联容器类型</th><th>含义</th></tr></thead><tbody><tr><td>按关键字有序保存元素</td></tr><tr><td>map</td><td>关联数组，保存关键字-值对</td></tr><tr><td>set</td><td>关键字即值，即只保存关键字的容器</td></tr><tr><td>multimap</td><td>关键字可重复出现的map</td></tr><tr><td>multiset</td><td>关键字可重复出现的set</td></tr><tr><td>无序集合</td></tr><tr><td>unordered_map</td><td>用哈希函数组织的map</td></tr><tr><td>unordered_set</td><td>用哈希函数组织的set</td></tr><tr><td>unordered_multimap</td><td>哈希组织的map；关键字可以重复出现</td></tr><tr><td>unordered_multiset</td><td>哈希组织的set；关键字可以重复出现</td></tr></tbody></table><p>map是关键字-值对的集合，因此map类型被称为关联数组(<code>associative array</code>)。<br>set就是关键字的简单集合。当想知道一个值是否存在的时候，set是最有用的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//chap11_1_word_count_exclude_some_words.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> *统计每个单词在输入中出现的次数。</span></div><div class="line"><span class="comment"> *Linux g++ 5.4.0 编译通过。</span></div><div class="line"><span class="comment"> *命令：</span></div><div class="line"><span class="comment"> *      g++  -std=c++11 chap11_1_word_count_exclude_some_words.cpp</span></div><div class="line"><span class="comment"> *      ./a.out</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</div><div class="line">    <span class="comment">//对关联容器的元素进行列表初始化</span></div><div class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"The"</span>, <span class="string">"But"</span>, <span class="string">"And"</span>, <span class="string">"Or"</span>, <span class="string">"An"</span>, <span class="string">"A"</span>,</div><div class="line">                           <span class="string">"the"</span>, <span class="string">"but"</span>, <span class="string">"and"</span>, <span class="string">"or"</span>, <span class="string">"an"</span>, <span class="string">"a"</span>&#125;;</div><div class="line">    <span class="built_in">string</span> word;</div><div class="line">    <span class="comment">//在新的一行按CTRL+Z（或者LINUX类系统中按CTRL+D）即可终止循环。</span></div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word) &#123;</div><div class="line">        <span class="comment">//find调用返回一个迭代器，只统计不在exclude中的单词。</span></div><div class="line">        <span class="keyword">if</span>(exclude.find(word) == exclude.end())</div><div class="line">            ++word_count[word];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_count) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">" occur "</span> &lt;&lt; w.second </div><div class="line">             &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">" times"</span> : <span class="string">" time"</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="练习11-4"><a href="#练习11-4" class="headerlink" title="练习11.4"></a>练习11.4</h3><p>统计每个单词在输入中出现的次数。要求：忽略标点符号且大小写无关。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//chap11_exersize_4.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> *统计每个单词在输入中出现的次数。[忽略标点符号且大小写无关]</span></div><div class="line"><span class="comment"> *Linux g++ 5.4.0 编译通过。</span></div><div class="line"><span class="comment"> *命令：</span></div><div class="line"><span class="comment"> *      g++  -std=c++11 chap11_exersize_4.cpp</span></div><div class="line"><span class="comment"> *      ./a.out</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</div><div class="line">    <span class="comment">//对关联容器的元素进行列表初始化</span></div><div class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"The"</span>, <span class="string">"But"</span>, <span class="string">"And"</span>, <span class="string">"Or"</span>, <span class="string">"An"</span>, <span class="string">"A"</span>,</div><div class="line">                           <span class="string">"the"</span>, <span class="string">"but"</span>, <span class="string">"and"</span>, <span class="string">"or"</span>, <span class="string">"an"</span>, <span class="string">"a"</span>&#125;;</div><div class="line">    <span class="built_in">string</span> word;</div><div class="line">    <span class="comment">//在新的一行按CTRL+Z（或者LINUX类系统中按CTRL+D）即可终止循环。</span></div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word) &#123;</div><div class="line">        <span class="comment">//将字母统一转化为小写形式</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : word) &#123;</div><div class="line">            ch = <span class="built_in">tolower</span>(ch); <span class="comment">//针对每一字母</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//删去标点</span></div><div class="line">        word.erase(remove_if(word.begin(), word.end(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>(*)(<span class="keyword">int</span>)&gt;(&amp;<span class="built_in">ispunct</span>)), word.end());</div><div class="line">    </div><div class="line">        <span class="comment">//find调用返回一个迭代器，只统计不在exclude中的单词。</span></div><div class="line">        <span class="keyword">if</span>(exclude.find(word) == exclude.end())</div><div class="line">            ++word_count[word];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_count) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">" occur "</span> &lt;&lt; w.second </div><div class="line">             &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">" times"</span> : <span class="string">" time"</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h2><p>关联容器都支持普通容器操作。关联容器不支持顺序容器的位置相关的操作，原因是关联容器中元素都是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。</p><p>pair标准库类型，位于头文件utility中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">// error: in C++98 ‘p’ must be initialized by constructor, not by ‘&#123;...&#125;’</span></div><div class="line"><span class="comment">// command:</span></div><div class="line"><span class="comment">//      g++ chap11_2_pair.cpp -std=c++11</span></div><div class="line"><span class="comment">//      ./a.out</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> s = <span class="string">"hello"</span>;</div><div class="line">    <span class="comment">//初始化方式有很多，这是列表初始化</span></div><div class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">size_t</span>&gt; p = &#123;s, s.size()&#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of string \""</span>&lt;&lt; p.first &lt;&lt; <span class="string">"\" is "</span> &lt;&lt; p.second &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h2><h3 id="关联容器额外的类型别名"><a href="#关联容器额外的类型别名" class="headerlink" title="关联容器额外的类型别名"></a>关联容器额外的类型别名</h3><table><thead><tr><th>关联容器额外的类型别名</th><th>含义</th></tr></thead><tbody><tr><td>key_type</td><td>此容器类型的关键字类型</td></tr><tr><td>mapped_type</td><td>每个关键字关联的类型：只适用于map</td></tr><tr><td>value_type</td><td>对于set，与key_type相同，对于map，为<code>pair&lt;const key_type,mapped_type&gt;</code></td></tr></tbody></table><h3 id="关联容器insert操作"><a href="#关联容器insert操作" class="headerlink" title="关联容器insert操作"></a>关联容器insert操作</h3><table><thead><tr><th>关联容器额外的类型别名</th><th>含义</th></tr></thead><tbody><tr><td>c.insert(v)</td></tr><tr><td>c.elmpace(args)</td><td>v是value_type类型对象；args用来构造一个元素。对于map和set，只有当元素关键字不在c中才插入(或构造)元素。函数返回一个pair，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否是否成功的bool值。对于multimap和multiset，总会插入(或构造)给定元素，并返回一个指向新元素的迭代器。</td></tr><tr><td>c.insert(b,e)           </td></tr><tr><td>c.insert(il)</td><td>b和e是迭代器，表示一个c::value_type类型值的范围；il是这种值的花括号列表。函数返回void。对于map和set，只插入关键字不在c中的元素。对于multimap和multiset，则会插入范围中的每个元素。</td></tr><tr><td>c.insert(p,v)     </td></tr><tr><td>c.insert(p,args)</td><td>类似insert(v)(或emplace(args))，但迭代器p作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。</td></tr></tbody></table><h3 id="map和unordered-map的下标操作"><a href="#map和unordered-map的下标操作" class="headerlink" title="map和unordered_map的下标操作"></a>map和unordered_map的下标操作</h3><table><thead><tr><th>map和unordered_map的下标操作</th><th>含义</th></tr></thead><tbody><tr><td>c[k]</td><td>返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化</td></tr><tr><td>c.at[k]</td><td>访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常</td></tr></tbody></table><h3 id="在一个关联容器中查找元素"><a href="#在一个关联容器中查找元素" class="headerlink" title="在一个关联容器中查找元素"></a>在一个关联容器中查找元素</h3><table><thead><tr><th>关联容器中查找元素</th><th>含义</th></tr></thead><tbody><tr><td>lower_bound和upper_bound</td><td>不适用于无序容器。</td></tr><tr><td>下标和at操作只适用于</td><td>非const的map和unordered_map</td></tr><tr><td>c.find(k)</td><td>返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器</td></tr><tr><td>c.count(k)</td><td>返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远是0和1</td></tr><tr><td>c.lower_bound(k)</td><td>返回一个迭代器，指向第一个关键字不小于k的元素</td></tr><tr><td>c.upper_bound(k)</td><td>返回一个迭代器，指向第一个关键字大于k的元素</td></tr><tr><td>c.equal_range(k)</td><td>返回一个迭代器pair，表示关键字等于k的元素的范围。若k不存在，pair的两个成员均等于c.end()</td></tr></tbody></table><h2 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h2><h3 id="无序容器管理操作"><a href="#无序容器管理操作" class="headerlink" title="无序容器管理操作"></a>无序容器管理操作</h3><table><thead><tr><th>关联容器中查找元素</th><th>含义</th></tr></thead><tbody><tr><td>桶接口</td></tr><tr><td>c.bucket_count()</td><td>正在使用的桶的数目</td></tr><tr><td>c.max_bucket_count()</td><td>容器能容纳的最多的桶的数量</td></tr><tr><td>c.bucket_size()</td><td>第n个桶中有多少个元素</td></tr><tr><td>c.bucket(k)</td><td>关键字为k的元素在哪个桶中</td></tr><tr><td>桶迭代</td></tr><tr><td>local_iterator</td><td>可以用来访问桶中元素的迭代器类型</td></tr><tr><td>const_local_iterator</td><td>桶迭代器的const版本</td></tr><tr><td>c.begin(n),c.end(n)</td><td>桶n的首元素迭代器和尾后迭代器</td></tr><tr><td>c.cbegin(n),c.cend(n)</td><td>与前两个函数类似，但返回<code>const_local_iterator</code></td></tr><tr><td>哈希策略</td></tr><tr><td>c.load_factor()</td><td>每个桶的平均元素数量，返回float值</td></tr><tr><td>c.max_load_factor()</td><td>c试图维护的平均桶大小，返回float值。c会在需要时添加新的桶，以使得<code>load_factor&lt;=max_load_factor</code></td></tr><tr><td>c.rehash(n)</td><td>重组存储，使得bucket_count&gt;=n且bucket_count&gt;size/max_load_factor</td></tr><tr><td>c.reserve(n)</td><td>重组存储，使得c可以保存n个元素且不必rehash</td></tr></tbody></table><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>关联容器：associative container<br>无序容器：unordered container<br>哈希函数：hash function</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/vernice/article/details/50816730" target="_blank" rel="external">c++ 去除字符串中的空格和标点符号 （remove_if 函数的用法）</a><br><a href="http://blog.csdn.net/libin1105/article/details/48749231" target="_blank" rel="external">《C++primer(第五版)》学习之路-第十一章：关联容器</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/02/26/CPP_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(10) 第十二章 二叉搜索树</title>
      <link>http://wangwlj.com/2018/02/02/algorithm_tutorial_chapter_12/</link>
      <guid>http://wangwlj.com/2018/02/02/algorithm_tutorial_chapter_12/</guid>
      <pubDate>Fri, 02 Feb 2018 14:39:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ws2.sinaimg.cn/mw690/c38a0784gy1fou65t0kztj22o01s0b29.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ws2.sinaimg.cn/mw690/c38a0784gy1fou65t0kztj22o01s0b29.jpg" alt="image"></p><a id="more"></a><h2 id="二叉搜索树概述"><a href="#二叉搜索树概述" class="headerlink" title="二叉搜索树概述"></a>二叉搜索树概述</h2><p>搜索树数据结构支持许多动态集合操作：<code>SEARCH</code>、<code>MINIMUM</code>、<code>MAXIMUM</code>、<code>PREDECESSOR</code>、<code>SUCCESSOR</code>、<code>INSERT</code>与<code>DELETE</code>。</p><p>上述基本操作花费的时间与这棵树的高度成正比。</p><h3 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h3><p>（1）设<code>x</code>为二叉查找树中的一个结点，若<code>y</code>是<code>x</code>左子树中的一个结点，则<code>key[y] &lt;= key[x</code>]；若<code>y</code>是<code>x</code>右子树中的一个结点，则<code>key[x]&lt;=key[y]</code><br>（2）二叉查找树上执行的基本操作的时间与树的高度成正比。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>每个节点就是一个对象，包含：关键字<code>key</code>，卫星数据<code>data</code>，以及三个属性：分别指向父、左右孩子的指针<code>p</code>,<code>left</code>, <code>right</code></p><h3 id="在二叉查找树上的操作"><a href="#在二叉查找树上的操作" class="headerlink" title="在二叉查找树上的操作"></a>在二叉查找树上的操作</h3><p>查找一个关键字：SEARCH(x, k)<br>求最小关键字：MINIMUM(x)<br>求最大关键字：MAXIMUM(x)<br>求前驱：PREDECESSOR(x)<br>求后继：SUCCESSOR(x)<br>插入一个结点：INSERT(T, z)<br>删除一个结点：DELETE(z)</p><h3 id="二叉查找树的应用"><a href="#二叉查找树的应用" class="headerlink" title="二叉查找树的应用"></a>二叉查找树的应用</h3><p>1.遍历：中序遍历、先序遍历、后序遍历【根关键字遍历的先后顺序】</p><p>2.查找：查找包含某个关键字的结点，查找关键字最大或最小的结点、查找某个结点的前驱或后继</p><h3 id="12-1-2"><a href="#12-1-2" class="headerlink" title="12.1-2"></a>12.1-2</h3><p>二叉搜索树的性质与最小堆的性质有什么不同？</p><p>二叉搜索树：左子树关键字&lt;=根结点关键字&lt;=右子树关键字</p><p>最小堆：左子树关键字&gt;=根结点关键字 &amp;&amp; 右子树关键字&gt;=根结点关键字</p><p>不能，因为一个结点的的左子树与右子树的关键字大小没有关系</p><h3 id="12-1-3-遍历的非递归实现"><a href="#12-1-3-遍历的非递归实现" class="headerlink" title="12.1-3 遍历的非递归实现"></a>12.1-3 遍历的非递归实现</h3><p>给出一个非递归的中序树遍历算法。(提示：有两种方法，在较容易的方法中，可以采用栈作为辅助数据结构；较复杂的方法中，不采用栈结构，但假设可以测试两个指针是否相等)。</p><p>中根遍历要求顺序是左根右，借助栈s实现。先将根root入栈，接着从根root开始查找最左的子孩子结点直到为空为止，然后将空节点出栈，再将左子树节点出栈遍历，然后判断该左子树的右子树节点入栈。循环此过程，直到栈为空为止。此时需要注意的是入栈过程中空结点也入栈了，用以判断左孩子是否结束和左孩子是否有右孩子结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//中序遍历非递归过程</span></div><div class="line"><span class="keyword">void</span> BST_Tree::Inorder_Iterative_Traverse(BST_Node *root)</div><div class="line">&#123;  <span class="comment">//用C++STL——栈stack实现</span></div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">//空树</span></div><div class="line">    <span class="built_in">stack</span>&lt;BST_Node *&gt;s;</div><div class="line">    s.push(root);</div><div class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</div><div class="line">        BST_Node *p = s.top();</div><div class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)        <span class="comment">//直到左节点为空，即最小元素</span></div><div class="line">        &#123;</div><div class="line">            s.push(p-&gt;left);</div><div class="line">            p = s.top();</div><div class="line">        &#125;                           </div><div class="line">        s.pop();                <span class="comment">//空结点出栈</span></div><div class="line">        <span class="keyword">if</span>(!s.empty())</div><div class="line">        &#123;</div><div class="line">            p = s.top();</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;key &lt;&lt; <span class="string">" "</span>;</div><div class="line">            s.pop();</div><div class="line">            s.push(p-&gt;right);   <span class="comment">//右子树结点入栈（不一定有右节点，可以压入NULL</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>一个更加简洁的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//中序遍历非递归过程——简洁版</span></div><div class="line"><span class="keyword">void</span> BST_Tree::Inorder_Iterative_Traverse_2(BST_Node *root)</div><div class="line">&#123;  <span class="comment">//用C++STL——栈stack实现</span></div><div class="line">    <span class="built_in">stack</span>&lt;BST_Node *&gt;s;</div><div class="line">    BST_Node *p = root;</div><div class="line">    <span class="keyword">while</span> (p || !s.empty()) &#123;</div><div class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>)           <span class="comment">//左节点入栈</span></div><div class="line">        &#123;</div><div class="line">            s.push(p);          <span class="comment">//压入值非空</span></div><div class="line">            p = p-&gt;left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;   <span class="comment">//出栈遍历</span></div><div class="line">            p = s.top();</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;key &lt;&lt; <span class="string">" "</span>;</div><div class="line">            s.pop();</div><div class="line">            p = p-&gt;right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="查询二叉搜索树"><a href="#查询二叉搜索树" class="headerlink" title="查询二叉搜索树"></a>查询二叉搜索树</h2><h3 id="查找任一节点"><a href="#查找任一节点" class="headerlink" title="查找任一节点"></a>查找任一节点</h3><p>伪码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">TREE-SEARCH(x, k)</div><div class="line">if x == NIL or k == x.key</div><div class="line">    return x</div><div class="line">    if k &lt; x.key</div><div class="line">    return TREE-SEARCH(x.left, k)</div><div class="line">   else return TREE-SEARCH(x.right, k)</div><div class="line"></div><div class="line">INTERATIVE-TREE-SEARCH(x, k)</div><div class="line">while x != NIL and k != x.key</div><div class="line">        if k &lt; x.key</div><div class="line">            x = x.left</div><div class="line">        else x = x.right</div><div class="line">    return x</div></pre></td></tr></table></figure></p><p>运行时间为$O(h)$，h为树的高度。</p><h3 id="最大关键字元素和最小关键字元素"><a href="#最大关键字元素和最小关键字元素" class="headerlink" title="最大关键字元素和最小关键字元素"></a>最大关键字元素和最小关键字元素</h3><p>根据二叉查找树的特征，很容易查找出最大和最小关键字。<br>查找二叉树中的最小关键字：从根结点开始，沿着各个节点的left指针查找下去，直到遇到NULL时结束。如果一个结点x无左子树，则以x为根的子树中，最小关键字就是key[x]。<br>查找二叉树中的最大关键字：从根结点开始，沿着各个结点的right指针查找下去，直到遇到NULL时结束。</p><p>书中给出了查找最大最小关键字的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">TREE-MINIMUM(x)</div><div class="line">while x.left != NIL</div><div class="line">    x = x.left</div><div class="line">    return x</div><div class="line">    </div><div class="line">TREE-MAXIMUM(x)</div><div class="line">while x.right != NIL</div><div class="line">    x = x.right</div><div class="line">    return x</div></pre></td></tr></table></figure><p>均能在$O(h)$时间内执行完。</p><h3 id="后继与前驱"><a href="#后继与前驱" class="headerlink" title="后继与前驱"></a>后继与前驱</h3><p>伪码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TREE-SUCCESSOR(x)</div><div class="line">if x.right != NIL</div><div class="line">    return TREE-MINIMUM(x.right)</div><div class="line">    y = x.p</div><div class="line">    while y != NIL and x == y.right</div><div class="line">    x = y</div><div class="line">        y = y.p</div><div class="line">    return y</div></pre></td></tr></table></figure></p><p>x.p 指向双亲。 右侧为空，则向上搜索。</p><blockquote><p>在一颗高度为<code>h</code>的二叉搜索树上，动态集合上的操作<code>SEARCH</code>、<code>MINIMUM</code>、<code>MAXIMUM</code>、<code>SUCCESSOR</code> 和<code>PREDECEDOR</code>可以在$O(h)$时间内完成。</p></blockquote><h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>伪码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">TREE-INSERT(T,z)</div><div class="line">y = NIL</div><div class="line">    x = T.root</div><div class="line">    while x != NIL</div><div class="line">    y = x</div><div class="line">        if z.key &lt; x.key</div><div class="line">        x = x.left</div><div class="line">        else x = x.right</div><div class="line">    z.p = y</div><div class="line">    if y == NIL</div><div class="line">    T.root = z   # tree T is empty</div><div class="line">    else if z.key &lt; y.key</div><div class="line">    y.left = z</div><div class="line">    else y.right = z</div></pre></td></tr></table></figure></p><p>从树根开始，指针x记录了一条向下的简单路径，直到查找到要替换为输入项z的NIL。NIL占据的位置就是z放置的位置。<br>上述过程保持遍历指针(<code>trailing pointer</code>)y作为x的双亲，找到NIL时需要直到z属于哪个节点。</p><p>该过程可以在$O(h)$时间内完成。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>从二叉查找树中删除给定的结点z，分以下情况讨论：</p><ul><li>如果z没有左孩子，那么用右孩子来替换z</li><li>如果z有且仅有一个左孩子，那么用其左孩子替换z</li><li>否则，z既有左孩子又有右孩子，此时我们查找z 的后继y，这个后继位于z的右子树中并且没有左孩子。则将y移出原来的位置进行拼接，并替换数中的z。</li><li>如果y是z的右孩子，那么用y替换z，并且仅留下y的右孩子。</li></ul><p>伪码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">TRANSPLANT(T,u,v)</div><div class="line">    if u.p == NIL</div><div class="line">        T.root = v</div><div class="line">    else if u == u.p.left</div><div class="line">        u.p.left = v</div><div class="line">    else u.p.right = v</div><div class="line">    if v != NIl</div><div class="line">        v.p = u.p</div><div class="line">        </div><div class="line">TREE-DELETE(T,z)</div><div class="line">if z.left == NIL</div><div class="line">    TRANSPLANT(T,z,z.right)</div><div class="line">else if z.right == NIL</div><div class="line">    TRANSPLANT(T,z,z.left)</div><div class="line">    else y = TREE-MINIMUM(z.right)</div><div class="line">    if y.p != z</div><div class="line">        TRANSPLANT(T,y,y.right)  # 删除y</div><div class="line">            y.right = z.right</div><div class="line">            y.right.p = y</div><div class="line">        TRANSPLANT(T,z,y)</div><div class="line">        y.left = z.left</div><div class="line">        y.left.p = y</div></pre></td></tr></table></figure></p><blockquote><p>定理12.3 在一颗高度为<code>h</code>的二叉搜索树上，实现动态集合操作<code>INSERT</code>和<code>DELETE</code>的运行时间均为$O(h)$。</p></blockquote><h2 id="随机构建二叉搜索树"><a href="#随机构建二叉搜索树" class="headerlink" title="随机构建二叉搜索树"></a>随机构建二叉搜索树</h2><p>二叉查找树各种操作时间均是$O(h)$，构建二叉查找树时，一般只用插入函数，这样便于分析，如果按严格增长顺序插入，那么构造出来的树就是一个高度为<code>n-1</code>的链。另一方面练习<code>B.5-4</code>说明了<code>h≥lgn</code>.这里我特别证明下。</p><p>证明：一个有n个结点的非空二叉树的高度至少为<code>lgn</code>。</p><p>对于一个高度为<code>h</code>的二叉树总结点数至多为<code>n≤2^h-1</code>(等于的情况就是完全二叉树)，所以给这个不等式适当变型得：<code>h≥lg(n+1)≥lgn</code>,所以对于<code>n</code>个结点的数高度至少为<code>lgn</code>。虽然没有用归纳法，但是这种方法感觉简单易懂。</p><blockquote><p>定理12.4 一棵有<code>n</code>个不同关键字的随机构建二叉搜索树(<code>random built binary search tree</code>)的期望高度为<code>O(lgn)</code>。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>算法导论 第三版 中文版</li><li><a href="http://blog.csdn.net/z84616995z/article/details/28880407" target="_blank" rel="external">算法导论第十二(12)章 二叉查找树</a></li><li><a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7718917" target="_blank" rel="external">算法导论 第12章 二叉查找树</a></li><li><a href="http://blog.csdn.net/luming_xml/article/details/51277023" target="_blank" rel="external">《算法导论》第12章 二叉查找树</a></li><li><a href="http://blog.csdn.net/z84616995z/article/details/20854381" target="_blank" rel="external">二叉树的递归与非递归实现</a></li><li><a href="http://blog.csdn.net/sdulibh/article/details/50573036" target="_blank" rel="external">对于二叉树三种非递归遍历方式的理解</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/02/02/algorithm_tutorial_chapter_12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>摄影 | 152年一遇的月全食</title>
      <link>http://wangwlj.com/2018/02/01/photo_total_lunar_eclipse/</link>
      <guid>http://wangwlj.com/2018/02/01/photo_total_lunar_eclipse/</guid>
      <pubDate>Thu, 01 Feb 2018 15:06:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/c38a0784gy1fo1cdvwz8dj22ch26j1kz.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ws1.sinaimg.cn/large/c38a0784gy1fo1cdvwz8dj22ch26j1kz.jpg" alt="image"></p><a id="more"></a><p>2018年01月31日晚上（也就是昨天）的月全食据说是152年一遇的月全食。</p><p>大概是今天看到了如下这张图片之后，想着自己也可以弄一张类似的照片。<br><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=efca4ecac9177f3e0439f45f11a650a2/0bd162d9f2d3572c2fdd40a08a13632762d0c38b.jpg" alt=""></p><p>于是便有了封面图的诞生。</p><p>这应该是第三次拍摄月亮了。</p><p>第一次是一个偶然的白天，晴空万里，一抬头居然发现了月亮。<br><img src="http://wx1.sinaimg.cn/large/c38a0784gy1fo1d5e3r4nj20ku0z3gmd.jpg" alt="image"></p><p>第二次，是2016年11月14日出现了超级大月亮，当时也拍摄了几张照片，顺便也附带上。<br><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fo1cuub8wgj20vq0lqjru.jpg" alt="image"><br><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fo1cv4h6eej20zk0mewex.jpg" alt="image"></p><p>第三次就是昨天晚上的月全食啦。<br>就以封面图结束吧。以后等照片多了，说不定就弄个照片墙～</p><p><img src="http://ws1.sinaimg.cn/large/c38a0784gy1fo1cdvwz8dj22ch26j1kz.jpg" alt="image"></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/02/01/photo_total_lunar_eclipse/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(9) 第十一章 散列表</title>
      <link>http://wangwlj.com/2018/01/30/algorithm_tutorial_chapter_11/</link>
      <guid>http://wangwlj.com/2018/01/30/algorithm_tutorial_chapter_11/</guid>
      <pubDate>Tue, 30 Jan 2018 14:39:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/mw690/c38a0784ly1fnxit86pfwj211y0lc7of.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ws1.sinaimg.cn/mw690/c38a0784ly1fnxit86pfwj211y0lc7of.jpg" alt=""></p><a id="more"></a><p>直接寻址表(<code>direct-address table</code>)缺点：如果全域U很大，分配直接寻址表T也不太现实；另一方面，实际存储的关键字集合<code>K</code>相对于<code>U</code>来说可能很小，导致浪费空间。</p><h2 id="散列表综述"><a href="#散列表综述" class="headerlink" title="散列表综述"></a>散列表综述</h2><p>散列表（<code>hash table</code>，也叫哈希表），支持<code>INSERT</code>、<code>SEARCH</code>、<code>DELETE</code>操作。</p><p>散列表可以使得在表小的情况下仍能够保存数据，并且能够在常数时间<code>O(1)</code>内完成查询。为什么是常数时间呢？因为我们不需要比较，不需要遍历查找，只要计算出地址，有待查询的值那么就找到了；没有，那么表中就不存在。</p><p>把关键字<code>k</code>映射到槽<code>h(k)</code>上的过程称为散列。<code>h</code>表示散列函数(<code>hash function</code>)，由关键字k计算出槽(<code>slot</code>)的位置。</p><p>多个关键字映射到同一个数组下标位置(槽)称为碰撞（或冲突，<code>collision</code>）。</p><p>好的散列函数应使每个关键字都等可能地散列到m个槽位中。</p><h3 id="链接法解决冲突"><a href="#链接法解决冲突" class="headerlink" title="链接法解决冲突"></a>链接法解决冲突</h3><p>链接法：把散列到同一个槽的所有元素都放在一个链表中。槽中存放指向该槽的所有元素的链表的表头；如果不存在这样的元素，则槽中为<code>NIL</code>。</p><h3 id="链接法散列的分析"><a href="#链接法散列的分析" class="headerlink" title="链接法散列的分析"></a>链接法散列的分析</h3><p>一个存放n个元素的、具有m个槽位的散列表T，其<strong>装载因子</strong>(<code>load factor</code>)为：$\alpha = \frac nm$，表示一个链的平均存储元素数。</p><p>简单均匀散列(<code>simple uniform hashing</code>)：一个给定元素，等可能地散列到m个槽位中的任意一个上，且与其他元素被散列到什么位置无关。</p><blockquote><p>在简单均匀散列的假设下，对于用链接法解决冲突的散列表，一次不成功查找的平均时间为$\Theta(1+\alpha)$，一次成功查找所需的平均时间也为$\Theta(1+\alpha)$</p></blockquote><p>当散列表的槽数与表中元素个数成正比，则有$n= \text{O}(m)$，查找需要常数时间$\text{O}(1)$。当链表为双向链表时，插入和删除的最坏情况也是$\text{O}(1)$。</p><h2 id="Hash函数（11-3，P147）"><a href="#Hash函数（11-3，P147）" class="headerlink" title="Hash函数（11.3，P147）"></a>Hash函数（11.3，P147）</h2><p>我们如何设计一个好的Hash函数（哈希函数，散列函数）？本节介绍了三种设计哈希函数的方法：除法散列、乘法散列和全域散列。</p><h3 id="好的哈希函数的特点"><a href="#好的哈希函数的特点" class="headerlink" title="好的哈希函数的特点"></a>好的哈希函数的特点</h3><p>这里有两个要点：</p><p>一个好的哈希函数应该能够将关键字均匀的分配到哈希表T中；</p><p>而关键字的分布率不应该影响这种均匀性。</p><h3 id="除法散列法"><a href="#除法散列法" class="headerlink" title="除法散列法"></a>除法散列法</h3><p>定义<code>hash</code>函数为 $h(k) = k \;\text{mod}\; m$</p><p><code>m</code>取值的原则就是<code>m</code>选为质数且不能太接近<code>2</code>或者<code>10</code>的幂次。</p><p>原因：键值的低位可能具有某种分布规律，如果选择<code>2</code>或者<code>10</code>的幂次容易出现冲突。比如$2^r$，关键字只会考虑二进制的低<code>r</code>位；十进制类似。</p><h3 id="乘法散列法"><a href="#乘法散列法" class="headerlink" title="乘法散列法"></a>乘法散列法</h3><p>乘法散列法的公式为：$h(k) = m(kA\; \text{mod}\; 1) $</p><p>其中，$0&lt;A&lt;1$。</p><p>一般的实现方法如下：假设计算机字长是<code>w</code>位，限制A是形如$A =\frac {s}{2^w}$的分数，整数<code>s</code>取值范围为$0&lt; s &lt;2^w $。用整数$s=A\cdot 2^w$乘上<code>k</code>，其结果是2w位的值$r_1 2^w + r_0 $</p><p>A的取值理想情况为$ A \approx \sqrt 5-1 = 0.6180339887\cdots $。（这不就是黄金分割率么……）根据A的取值计算s的值。</p><p>乘法散列法的优点是<code>m</code>的取值不是很关键，一般取为<code>m=2^r</code>。</p><h3 id="11-3-4"><a href="#11-3-4" class="headerlink" title="11.3-4"></a>11.3-4</h3><p>考虑一个大小为<code>m=1000</code>的散列表和一个对应的散列函数<code>h(k)=m(kAmod1)</code>,其中<code>A=(√5-1)/2</code>,试计算关键字61,62,63,64和65被映射到位置。</p><p>直接根据公式计算，实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;  </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> A=(<span class="built_in">sqrt</span>(<span class="number">5</span>)<span class="number">-1</span>)/<span class="number">2.0</span>;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> m)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">double</span> x=(A*k-(<span class="keyword">int</span>)(A*k))*m;  </div><div class="line">    <span class="keyword">return</span> x;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">   <span class="keyword">int</span> k;  </div><div class="line">   <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;k)  </div><div class="line">   &#123;  </div><div class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hash["</span>&lt;&lt;k&lt;&lt;<span class="string">"]="</span>&lt;&lt;hash(k,<span class="number">1000</span>)&lt;&lt;<span class="built_in">endl</span>;  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p>开放寻址法是另一种解决冲突的方法。</p><p>开放寻址法的特点：装载因子不会超过1；不用指针就可以计算出槽的序列。</p><p>插入元素的过程叫做探查(<code>probe</code>)：连续地检查散列表，直到找到一个空槽来放置待插入的关键字为止。检查顺序依赖于待插入的关键字</p><p>开放寻址法的散列函数有第二个参数：探查序号。</p><p>插入元素的伪码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">HASH-INSERT(T,k)</div><div class="line">i = 0</div><div class="line">    repeat</div><div class="line">    j = h(k, i)</div><div class="line">        if T[j] = NIL</div><div class="line">        T[j] = k </div><div class="line">            return j</div><div class="line">        else i = i + 1</div><div class="line">    util i == m</div><div class="line">    error &quot;hash table overflow&quot;</div></pre></td></tr></table></figure></p><p>查找元素的伪码：（由于是依次插入，因此可以依次查找；有个前提：关键字不会被删除）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HASH-SEARCH(T,k)</div><div class="line">i = 0</div><div class="line">    repeat</div><div class="line">    j = h(k, i)</div><div class="line">        if T[j] = K </div><div class="line">            return j</div><div class="line">        else i = i + 1</div><div class="line">    util T[j] == NIl or i == m</div><div class="line">    return NIL</div></pre></td></tr></table></figure></p><p>在开放寻址法中，删除操作比较困难，但也有解决办法，在必须删除关键字的应用中，往往采用链接法解决碰撞。</p><h3 id="三种探查技术"><a href="#三种探查技术" class="headerlink" title="三种探查技术"></a>三种探查技术</h3><p>三种探查技术来计算探查序列：</p><p>1)线性探查：<br>$$h(k,i)=(h’(k)+i)\text{mod}\; m,\; i=0,1,\cdots,m-1$$<br>线性探查存在问题：一次群集(primary clustering)。</p><p>2)二次探查：<br>$$h(k,i)=(h’(k)+c_1i+c_2i^2)\text{mod}\; m, \; i=0,1,\cdots,m-1$$<br>二次探查存在问题：二次群集(secondary clustering)。二次探查与线性探查都是初始位置决定了探查序列，且只有m个探查序列被使用到。</p><p>3)双重探查：<br>$$h(k,i)=(h_1(k)+ih_2(k))\text{mod}\; m, \; i=0,1,\cdots,m-1 $$<br>双重探查要求值$h_2(k)$与表的大小<code>m</code>互素。一种简便的方法是：<code>m</code>取<code>2</code>的幂，$h_2(k)$只产生奇数；或者m为素数，h2总是返回比m小的正整数。</p><p>由于每一对可能的$ (h_1(k), h_2(k))$都会产生一个不同的探查序列，因此双重散列法用到了$\Theta(m^2) $种探查序列。</p><p>双重散列的例子：<br>$$h_1(k) = k \;\text{mod}\; m ,\;h_2(k) = 1+(k\; \text{mod} \;m’) $$<br>取m为素数，$m’ $略小于m（比如，m-1）</p><h3 id="开放寻址散列的分析："><a href="#开放寻址散列的分析：" class="headerlink" title="开放寻址散列的分析："></a>开放寻址散列的分析：</h3><blockquote><p>定理11.6 给定一个装载因子<code>a=n/m&lt;1</code>的开放寻址散列表，假设散列是均匀的，在一次不成功的查找中，期望的探查数至多为<code>1/(1-a)</code>.。</p></blockquote><p>不成功的查找即：最后一次查找为<code>NIL</code>，且前面的<code>Hash table</code>查找都是被占用但是不包含所查的关键字。因此，可以推论插入的期望值，即：插入前需要做一次不成功的查找。</p><blockquote><p>推论11.7 均匀散列，平均情况下，向一个装载因子为a的开放寻址散列表中插入一个元素时，至多需要做<code>1/(1-a)</code>次探查。</p></blockquote><p>查找的过程和插入类似，假设待查找的关键字k的插入位置为i，则，根据推论11.7，有探查的期望次数至多为$1/(1-i/m) = m/(m - i)$。对散列表的所有n个关键字求平均，则得到一次成功查找的探查期望次数：<br>$$\begin{align}<br>\frac 1 n \sum_{i = 0}^{n-1} \frac {m}{m-i}<br>&amp; = \frac mn \sum_{i = 0}^{n-1}\frac {1}{m-i} =\frac 1\alpha \sum_{k = m-n+1}^{n} \frac 1k \leqslant\frac 1 \alpha \int_{m-n}^{m}\frac 1x dx\\<br>&amp; =\frac 1\alpha ln \frac m{m-n} = \frac 1a ln\frac1{1-a}<br>\end{align}$$</p><p>因此得到定理11.8：</p><blockquote><p>定理11.8 给定一个装载因子为<code>a&lt;1</code>的开放寻址散列表，假设散列是均匀的，一次成功查找中的期望探查数至多为<code>(1/a)ln(1/(1-a))</code>.</p></blockquote><h3 id="11-4-1"><a href="#11-4-1" class="headerlink" title="11.4-1"></a>11.4-1</h3><p>考虑将关键字10,22,31,4,15,28,17,88,59用<strong>开放寻址法</strong>插入到一个长度为<code>m=11</code>的散列表中，主散列函数为<code>h&#39;(k)=k mod m</code>.说明用线性探查，二次探查<code>(c1=1,c2=3)</code>以及双重散列<code>h2(k)=1+(k mod (m-1))</code>将这些关键字插入散列表的结果。</p><p>C++实现代码：<br><a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_11/hash_table.cpp" target="_blank" rel="external">Introduction_to_Algorithms/Part_3/Chap_11/hash_table.cpp</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt; // for memset</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Null -1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETED -2</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 算法导论习题11.4-1 开放寻址法实现散列表。</span></div><div class="line"><span class="comment"> * 顺便也实现了搜索与删除。</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * Linux下g++5.4.0编译通过。</span></div><div class="line"><span class="comment"> * 命令：</span></div><div class="line"><span class="comment"> *   $ g++ -o hash_table.out hash_table.cpp -std=c++11</span></div><div class="line"><span class="comment"> *   $ ./hash_table.out</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">11</span>;  <span class="comment">//槽位数量</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1 = <span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> c2 = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> *T)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; T[i] &lt;&lt; <span class="string">' '</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> k % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 线性探查</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">linear_probing</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (key + i) % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//二次探查</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">quadratic_probing</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (key + c1 * i + c2 * i * i) % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//双重散列</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">double_hashing</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (key + i * (<span class="number">1</span> + key % (m - <span class="number">1</span>))) % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span> (*) (<span class="keyword">int</span>, <span class="keyword">int</span>);   <span class="comment">//函数指针</span></div><div class="line">PF hash_functions[<span class="number">3</span>] = &#123;linear_probing, quadratic_probing, double_hashing&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 判断探查的状态：当槽为空或者已到末尾时，为True</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">probe_state</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> T[j] == Null || T[j] == DELETED || T[j] == <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_insert</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> key, PF hash_function)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> k = key;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> j = hash_function(k, i);  <span class="comment">//这里通过函数指针，可以在调用时选择线性、二次及双重探查。关于函数指针的简单介绍，可以查看http://wangwlj.com/2018/01/06/CPP_06/</span></div><div class="line">        <span class="keyword">if</span> (probe_state(T, j))</div><div class="line">        &#123;</div><div class="line">            T[j] = k;</div><div class="line">            <span class="keyword">return</span> j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> ++i;</div><div class="line">    &#125; <span class="keyword">while</span> (i != m);</div><div class="line"></div><div class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"hash table overflow"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_search</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> k, PF hash_function)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        j = hash_function(k, i);  <span class="comment">//这里可以替换成二次，双重探查。插入，查找，删除函数同时被替换  </span></div><div class="line">        <span class="keyword">if</span> (T[j] == k)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> ++i;</div><div class="line">    &#125; <span class="keyword">while</span> (!probe_state(T, j));</div><div class="line">    <span class="keyword">return</span> Null;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_delete</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> k, PF hash_function)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">int</span> j = hash_search(T, k, hash_function);  <span class="comment">//首先先找到该关键字k  </span></div><div class="line">    <span class="keyword">if</span> (j != Null)  </div><div class="line">    &#123;  </div><div class="line">       T[j] = DELETED;  <span class="comment">//如果找到了，那么设置其为空。  </span></div><div class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"关键字："</span> &lt;&lt; k &lt;&lt; <span class="string">" 删除成功！"</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"待删除的数据不在表中！"</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> key[<span class="number">9</span>] = &#123;<span class="number">10</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">88</span>, <span class="number">59</span>&#125;;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> T[<span class="number">11</span>];</div><div class="line">   </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123; </div><div class="line">        <span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T));  <span class="comment">// 初始化T为全零</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</div><div class="line">            hash_insert(T, key[j], hash_functions[i]); </div><div class="line">        &#125;</div><div class="line">    Print(T);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"搜索关键字：88，返回结果："</span> &lt;&lt; hash_search(T, <span class="number">88</span>, hash_functions[i]) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    hash_delete(T, <span class="number">88</span>, hash_functions[i]);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除 88 之后元素为："</span>;</div><div class="line">    Print(T);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>算法导论 第三版 中文版</li><li><a href="http://blog.csdn.net/z84616995z/article/details/21329071" target="_blank" rel="external">算法导论第十一(11)章散列(Hash)表</a></li><li><a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7713307" target="_blank" rel="external">算法导论-第11章-散列表</a></li><li><a href="http://wangwlj.com/2018/01/06/CPP_06/">C++ Primer学习笔记：(六)函数</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/30/algorithm_tutorial_chapter_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(8) 第十章 基本数据结构</title>
      <link>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_10/</link>
      <guid>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_10/</guid>
      <pubDate>Sat, 27 Jan 2018 09:11:56 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fnva4kd9a0j20k50j5wjm.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;本章介绍几种基本的结构：栈、队列、链表和有根树。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fnva4kd9a0j20k50j5wjm.jpg" alt=""><br>本章介绍几种基本的结构：栈、队列、链表和有根树。</p><a id="more"></a><h2 id="栈和队列（10-1，P129）"><a href="#栈和队列（10-1，P129）" class="headerlink" title="栈和队列（10.1，P129）"></a>栈和队列（10.1，P129）</h2><p>栈和队列都是动态集合。</p><h3 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h3><p><strong>概念定义</strong>：栈采用<strong><font color="FA1C1C">先进后出</font></strong>策略（LIFO）。基本操作是<strong>压入（PUSH）</strong>和<strong>弹出（POP）</strong>。如果<code>s.top=0</code>，表示栈空，如果试图对空栈进行<code>POP</code>操作会发生下溢（<code>underflow</code>）。如果<code>s.top&gt;n</code>,表示栈满，如果进行<code>PUSH</code>操作会发生上溢（<code>overflow</code>）。</p><p>栈的Python实现代码链接：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_10/stack.py" target="_blank" rel="external">Introduction_to_Algorihtms/stack_my.py</a></p><h3 id="队列queue"><a href="#队列queue" class="headerlink" title="队列queue"></a>队列queue</h3><p><strong>概念定义</strong>：队列采用<strong><font color="FA1C1C">先进先出</font></strong>策略（FIFO）。基本操作是<strong>入队（enqueue）</strong>和<strong>出队（dequeue）</strong>。如果<code>head=tail</code>，表示队列为空，如果试图对空队列进行<code>enqueue</code>操作会发生下溢（<code>underflow</code>）。如果<code>head=tail+1</code>,表示队列满，如果进行<code>dequeue</code>操作会发生上溢（<code>overflow</code>）。</p><p>队列的Python实现：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_10/queue.py" target="_blank" rel="external">Introduction_to_Algorihtms/queue_my.py</a></p><h2 id="链表（10-2，P131）"><a href="#链表（10-2，P131）" class="headerlink" title="链表（10.2，P131）"></a>链表（10.2，P131）</h2><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。</p><p>双向链表(<code>doubly linked list</code>)的每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个(前一个)结点地址的指针域。 </p><p>未排序双向链表的Python实现代码：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_10/list.py" target="_blank" rel="external">Introduction_to_Algorihtms/list_my.py</a></p><h2 id="指针和对象的实现（10-3，P134）"><a href="#指针和对象的实现（10-3，P134）" class="headerlink" title="指针和对象的实现（10.3，P134）"></a>指针和对象的实现（10.3，P134）</h2><p>当有些语言不支持指针和对象数据类型时，我们可以用数组和数组下标构造对象和指针。这种链表称为<a href="http://baike.baidu.com/link?url=GFeesiUYKbcXr0Q4vPTOK518GTn6z4DnzuBNxiplK80cT9bzyAVcqpX8G9Huw8yC" target="_blank" rel="external">静态链表</a>。</p><h3 id="对象的多数组表示"><a href="#对象的多数组表示" class="headerlink" title="对象的多数组表示"></a>对象的多数组表示</h3><p>用三个数组<code>next</code> <code>key</code> <code>prev</code> 分别表示链表的后继/数据/前驱。<br>多数组表示只能表示同构对象（所有对象有相同的属性）。而单数组表示可以表示异构对象（比如对象具有不同的长度）。</p><h3 id="对象的单数组表示"><a href="#对象的单数组表示" class="headerlink" title="对象的单数组表示"></a>对象的单数组表示</h3><p>用一个数组即可表示双链表，这种表示法比较灵活，因为它允许不同长度的对象存储于同一数组中。一般地我们考虑的数据结构多是由同构的元素构成，因此采用对象的多数组表示法足够满足我们的需求。</p><h3 id="对象的分配与释放"><a href="#对象的分配与释放" class="headerlink" title="对象的分配与释放"></a>对象的分配与释放</h3><p>把自由(<code>free</code>)对象保存在一个单链表中，称为自由表(<code>free list</code>)。</p><p>自由表只使用next数组，该数组只存储链表中的next指针。自由表的头存储在全局变量free中。</p><p>自由表的实现类似与栈：下一个被分配的对象就是最后被释放的对象（后进先出）。</p><h2 id="有根树的表示（10-4，P137）"><a href="#有根树的表示（10-4，P137）" class="headerlink" title="有根树的表示（10.4，P137）"></a>有根树的表示（10.4，P137）</h2><p>用链式结构表示有根树。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树<code>T</code>具有三个属性：<code>p</code>，<code>left</code>，<code>right</code>分别存放指向父节点、左孩子节点和右孩子节点的指针。<br>如果<code>x.p=NIL</code>，则<code>x</code>是根节点。属性<code>T.root</code>指向整棵树<code>T</code>的根节点。</p><p>更多关于二叉树的内容将在第12章中介绍。本次就暂不实现二叉树。</p><h3 id="分支无限制的有根树"><a href="#分支无限制的有根树" class="headerlink" title="分支无限制的有根树"></a>分支无限制的有根树</h3><p>两种表示方法。一种是将<code>left</code>，<code>right</code>扩展为$child_1,\cdots,child_k$，这种方法的缺点是若<code>k</code>很大，但是多数节点只有少量的孩子，则会浪费大量存储空间。</p><p>第二种方法是左孩子右兄弟表示法(<code>left-child,right-sibling representation</code>)。每个节点除了父节点指针<code>p</code>，还有两个指针:<br><code>x.left-child</code>表示节点<code>x</code>最左边的孩子节点；<code>x.right-sibling</code>表示右侧相邻的兄弟节点。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.算法导论 中文 第三版<br>2.<a href="http://blog.csdn.net/z84616995z/article/details/19202773" target="_blank" rel="external">算法导论第十章基本数据结构</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(7) 第八章 线性排序算法</title>
      <link>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_8/</link>
      <guid>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_8/</guid>
      <pubDate>Sat, 27 Jan 2018 08:26:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;任何比较排序在最坏情况下都要经过$\Theta(n\text{lg}n)$次比较。&lt;/p&gt;
&lt;p&gt;本文介绍三种线性时间排序的算法：计数排序，基数排序以及桶排序。因此，这些都不属于比较排序。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>任何比较排序在最坏情况下都要经过$\Theta(n\text{lg}n)$次比较。</p><p>本文介绍三种线性时间排序的算法：计数排序，基数排序以及桶排序。因此，这些都不属于比较排序。</p><a id="more"></a><p>本文所有实现代码均已放在<code>GitHub</code>上，欢迎查看：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms" target="_blank" rel="external">GitHub链接</a></p><h2 id="本章概述"><a href="#本章概述" class="headerlink" title="本章概述"></a>本章概述</h2><p>非比较排序指使用一些非比较的操作来确定排序顺序的排序算法，对于非比较排序，下界O(nlgn)不适用。</p><p>计数排序是稳定排序，若n个数据的取值范围是<code>[0..k]</code>，则运行时间为<code>O(n+k)</code>，运行空间是<code>O(n+k)</code></p><p>基数排序也是稳定排序，需要另一个稳定排序作为基础，若n个d位数，每一位有k种取值可能，所用的稳定排序运行时间为<code>O(n+k)</code>，则基数排序的时间是<code>O(d(n+k))</code></p><p>桶排序也是稳定排序，当输入数据符合均匀分布时，桶排序可以以线性时间运行。所设所有元素均匀分布在区间<code>[0,1)</code>上，把区间[0,1)划分成n个相同大小的子区间（桶），对各个桶中的数进行排序，把依次把各桶中的元素列出来。</p><h2 id="计数排序（8-2，P108）"><a href="#计数排序（8-2，P108）" class="headerlink" title="计数排序（8.2，P108）"></a>计数排序（8.2，P108）</h2><p>计数排序(<code>counting sort</code>)是使用输入元素的实际值来确定其在数组中的位置。</p><p>计数排序的一个重要特性就是它是稳定的：即对于相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同。也就是说，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。</p><p>计数排序的伪代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">COUNTING_SORT(A,B,k)</div><div class="line">      <span class="keyword">for</span> i=<span class="number">0</span> to k</div><div class="line">        <span class="keyword">do</span> C[i] = <span class="number">0</span></div><div class="line">      <span class="keyword">for</span> j=<span class="number">1</span> to length(A)</div><div class="line">          <span class="keyword">do</span> C[A[j]] = C[A[j]]+<span class="number">1</span>   <span class="comment">//C[i]中包含等于元素i的个数</span></div><div class="line">      <span class="keyword">for</span> i=<span class="number">1</span> to k</div><div class="line">          <span class="keyword">do</span> C[i] = C[i] + C[i<span class="number">-1</span>]  <span class="comment">//C[i]中包含小于等于元素i的个数</span></div><div class="line">      <span class="keyword">for</span> j=length[A] downto <span class="number">1</span></div><div class="line">          <span class="keyword">do</span> B[C[A[j]]] = A[j]</div><div class="line">             C[A[j]] = C[A[j]] <span class="number">-1</span></div></pre></td></tr></table></figure></p><p>计数排序的<code>Python</code>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Author：wangwlj</span></div><div class="line"><span class="comment"># 计数排序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(A)</span>:</span></div><div class="line">    k = max(A)  <span class="comment"># k is max of A</span></div><div class="line">    C = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, k + <span class="number">1</span>):</div><div class="line">        C.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        C[A[j]] = C[A[j]] + <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k + <span class="number">1</span>):</div><div class="line">        C[i] = C[i] + C[i - <span class="number">1</span>]</div><div class="line"></div><div class="line">    B = []  <span class="comment"># output</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        B.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        <span class="comment"># m = A[j],n  = C[m],k = B[n - 1]  # for test</span></div><div class="line">        B[C[A[j]] - <span class="number">1</span>] = A[j]  <span class="comment"># B[n] start from 0, so need -1</span></div><div class="line">        C[A[j]] = C[A[j]] - <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> B</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    A = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>]</div><div class="line">    B = counting_sort(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(B)):</div><div class="line">        print(B[i], end=<span class="string">" "</span>)</div></pre></td></tr></table></figure></p><h3 id="练习8-2-3"><a href="#练习8-2-3" class="headerlink" title="练习8.2-3"></a>练习8.2-3</h3><p>在<code>COUNTING_SORT</code>过程中，第四个for循环为什么是<code>for j=length[A] downto 1</code>，而不是<code>for j=1 to length[A]</code>？</p><p><strong>为了保证算法是稳定的</strong>。由于是从前往后计数排序，两个数相同的时候，计数值较大的数对应于数组中靠后的元素，所以在输出时需要逆序。</p><h2 id="基数排序（8-3，P110）"><a href="#基数排序（8-3，P110）" class="headerlink" title="基数排序（8.3，P110）"></a>基数排序（8.3，P110）</h2><p>基数排序(<code>radix sort</code>)按有效位从低到高依次排序。</p><p>伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RADIX_SORT(A,d）</div><div class="line">    for i=1 to d</div><div class="line">          use a stable sort to sort array A on digit i</div></pre></td></tr></table></figure></p><p>基数排序一般采用<strong>计数排序</strong>作为中间稳定排序。</p><p>基数排序的<code>python</code>实现请参阅下面的练习题<code>8.3-4</code>。</p><h3 id="练习8-3-1"><a href="#练习8-3-1" class="headerlink" title="练习8.3-1"></a>练习8.3-1</h3><p>说明<code>RADIX-SORT</code>在如下英文单词上的操作过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">    A = &#123;COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB, BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX&#125;  </div><div class="line">==&gt; A = &#123;SEA, TEA, MOB, TAB, DOG, RUG, DIG, BIG, BAR, EAR, TAR, COW, ROW, NOW, BOX, FOX&#125;  </div><div class="line">==&gt; A = &#123;TAB, BAR, EAR, TAR, SEA, TEA, DIG, BIG, MOB, DOG, COW, ROW, NOW, BOX, FOX, RUB&#125;  </div><div class="line">==&gt; A = &#123;BAR, BIG, BOX, COW, DIG, DOG, EAR, FOX, MOB, NOW, ROW, TAB, TAR, TEA, SEA, RUB&#125;</div></pre></td></tr></table></figure></p><h3 id="练习8-3-4"><a href="#练习8-3-4" class="headerlink" title="练习8.3-4"></a>练习8.3-4</h3><p>题目：在<code>O(n)</code>时间内对<code>[0..n^3-1]</code>之间的n个整数排序。</p><p>思路：把整数转换为n进制再排序，每个数有三位，每位的取值范围是[0..n-1]，再进行基数排序</p><p>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">n = <span class="number">5</span></div><div class="line">base_k = <span class="number">5</span>  <span class="comment"># bask could be any number. In test 8.3-4 is 5(equal to n)</span></div><div class="line">d = <span class="number">3</span>  <span class="comment"># 8.3-4</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stable_sort</span><span class="params">(A, index)</span>:</span>  <span class="comment"># similar with counting sort,</span></div><div class="line">    C = []  <span class="comment"># C：统计每位数上可能出现的k个数的次数</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, base_k + <span class="number">1</span>):  <span class="comment"># the number is in range of base_k（k）</span></div><div class="line">        C.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        <span class="comment"># 统计当前位上的数出现的次数</span></div><div class="line">        num = int(A[j] % pow(base_k, index) / pow(base_k, index - <span class="number">1</span>))  <span class="comment"># the base number</span></div><div class="line">        <span class="comment"># print(A[j], ' 当前位编号：', index, '当前值：', num, )  # for test</span></div><div class="line">        C[num] = C[num] + <span class="number">1</span>  <span class="comment"># the count of the base number (C - num)</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, base_k + <span class="number">1</span>):</div><div class="line">        C[i] = C[i] + C[i - <span class="number">1</span>]</div><div class="line"></div><div class="line">    B = []  <span class="comment"># output</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        B.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        num = int(A[j] % pow(base_k, index) / pow(base_k, index - <span class="number">1</span>))</div><div class="line">        B[C[num] - <span class="number">1</span>] = A[j]  <span class="comment"># B[n] start from 0, so need -1</span></div><div class="line">        C[num] = C[num] - <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> B</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, d + <span class="number">1</span>):</div><div class="line">        A = stable_sort(A, i)</div><div class="line">    <span class="comment"># for i in range(0, len(A)):</span></div><div class="line">    <span class="comment">#     print(A[i], end=' ')</span></div><div class="line">    <span class="keyword">return</span> A</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    <span class="comment"># A = [114, 18, 35, 74, 36]</span></div><div class="line">    A = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</div><div class="line">        A.append(random.randint(<span class="number">0</span>, pow(n, <span class="number">3</span>)))</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'\n'</span>)</div><div class="line"></div><div class="line">    A = radix_sort(A)</div><div class="line">    print(<span class="string">'After radix_sort：'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">' '</span>)</div></pre></td></tr></table></figure></p><h2 id="桶排序（8-4，P112）"><a href="#桶排序（8-4，P112）" class="headerlink" title="桶排序（8.4，P112）"></a>桶排序（8.4，P112）</h2><p>桶排序(<code>bucket sort</code>)假设输入数据服从均匀分布，平均情况下它的时间代价为$\text{O}_n$，与计数排序类似，因为对输入数据做了某种假设，桶排序的速度也很快。具体来说，计数排序假设输入数据都属于一个小区间的整数，而桶排序则假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.算法导论 中文 第三版<br>2.<a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7678859" target="_blank" rel="external">算法导论 第8章 线性时间排序</a>这个包含习题答案，很不错<br>3.<a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7685839" target="_blank" rel="external">算法导论8.3-4</a><br>4.<a href="http://blog.csdn.net/qing0706/article/details/50117873" target="_blank" rel="external">MIT算法导论-第五讲-线性时间排序</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python数据结构之链表</title>
      <link>http://wangwlj.com/2018/01/26/python_linkedlist/</link>
      <guid>http://wangwlj.com/2018/01/26/python_linkedlist/</guid>
      <pubDate>Fri, 26 Jan 2018 14:56:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fnvahij9xbj20jm0ejgr2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;主要实现了链表的三个功能：链表的查找、插入与删除。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fnvahij9xbj20jm0ejgr2.jpg" alt=""><br>主要实现了链表的三个功能：链表的查找、插入与删除。<br><a id="more"></a></p><p>最近在看《算法导论》，看到第十章——基本数据结构中，提到了链表，于是用<code>Python</code>进行了实现。算法导论中只给出了三个操作：链表的查找、插入与删除。于是，暂时也只实现了这三个。</p><p>下面进行简要的介绍：</p><p>我们首先定义一个节点的类，用来存储链表中的每个节点。每个节点都有三个属性：节点存储的元素值，指向上一个节点的指针以及指向下一个节点的指针。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span>  <span class="comment"># 链表的每个节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, _prev=None, _next=None)</span>:</span></div><div class="line">        self.value = value</div><div class="line">        self.prev = _prev</div><div class="line">        self.next = _next</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>  <span class="comment"># 在print时默认返回value</span></div><div class="line">        <span class="keyword">return</span> str(self.value)</div></pre></td></tr></table></figure></p><p>其中，<code>__str__</code>函数使得在print一个Node对象的时候打印其value值。</p><p>接着我们定义链表类List。Python中<code>list</code>是一个关键字，表示序列，故避免重复，也可以把链表叫做<code>LinkedList</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.head = <span class="keyword">None</span>  <span class="comment"># init as a empty list</span></div></pre></td></tr></table></figure></p><p>上述初始化函数中的<code>self.head = None</code>将链表初始化为空链表。</p><p>接着分别实现搜索、插入和删除三个功能。可以对照着书中的伪码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, key)</span>:</span></div><div class="line">    x = self.head</div><div class="line">    <span class="keyword">while</span> x.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> x.value != key:</div><div class="line">        x = x.next</div><div class="line">    <span class="keyword">return</span> x</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></div><div class="line">    <span class="comment"># 插入节点x作为新的头节点</span></div><div class="line">    x.next = self.head</div><div class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        self.head.prev = x</div><div class="line">    self.head = x</div><div class="line">    x.prev = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></div><div class="line">    <span class="comment"># x is in list and known (can use search to find)</span></div><div class="line">    <span class="keyword">if</span> x.prev <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        x.prev.next = x.next</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        self.head = x.next</div><div class="line"></div><div class="line">    <span class="keyword">if</span> x.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        x.next.prev = x.prev</div></pre></td></tr></table></figure></p><p>下面的这个<code>show_value</code>函数是为了依次打印链表的元素，不是必须的，可以跳过。<code>__str__</code>与Node中的类似，实现了可以直接打印一个List的对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_value</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment"># 依次打印链表的值</span></div><div class="line">    x = self.head</div><div class="line">    print(<span class="string">"The List Value is:"</span>, end=<span class="string">' '</span>)</div><div class="line">    <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        print(x.value, end=<span class="string">' '</span>)</div><div class="line">        x = x.next</div><div class="line">    print()</div><div class="line">    <span class="keyword">return</span> <span class="string">'show_value'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment"># 支持直接print一个List的对象</span></div><div class="line">    <span class="keyword">return</span> self.show_value() + <span class="string">" in List"</span></div></pre></td></tr></table></figure></p><p>最后是主函数，对上述实现进行简单的测试。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    l = List()</div><div class="line">    l.insert(Node(<span class="number">5</span>))</div><div class="line">    l.insert(Node(<span class="number">4</span>))</div><div class="line">    l.insert(Node(<span class="number">3</span>))</div><div class="line">    n = l.search(<span class="number">5</span>)</div><div class="line">    print(<span class="string">"search value: "</span>, n.value, n.prev, n.next,</div><div class="line">          <span class="string">"\nhead: "</span>, l.head.value, l.head.prev, l.head.next)</div><div class="line">    l.delete(n)</div><div class="line">    print(<span class="string">"head: "</span>, l.head.value, l.head.prev, l.head.next)</div><div class="line">    l.insert(Node(<span class="number">6</span>))  <span class="comment"># always insert as head.</span></div><div class="line">    l.insert(Node(<span class="number">7</span>))</div><div class="line">    l.insert(Node(<span class="number">8</span>))</div><div class="line">    l.show_value()</div><div class="line"></div><div class="line">    n = l.search(<span class="number">7</span>)</div><div class="line">    print(<span class="string">"search value:"</span>, n, n.prev, n.next,</div><div class="line">          <span class="string">"\nhead:"</span>, l.head, l.head.prev, l.head.next)</div><div class="line"></div><div class="line">    l.delete(l.search(<span class="number">6</span>))</div><div class="line">    print(l)</div></pre></td></tr></table></figure></p><p>完整的代码放在Github上了，仅供参考。链接为：<a href="https://github.com/qwerty200696/Introduction_to_Algorihtms/blob/master/list_my.py" target="_blank" rel="external">Introduction_to_Algorihtms/list_my.py</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/26/python_linkedlist/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(十)泛型算法</title>
      <link>http://wangwlj.com/2018/01/20/CPP_10/</link>
      <guid>http://wangwlj.com/2018/01/20/CPP_10/</guid>
      <pubDate>Sat, 20 Jan 2018 15:00:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;标准库并没有给每个容器添加大量功能，而是提供了一组算法，这些算法大多数都独立于任何特定的容器。这些算法是通用的(&lt;code&gt;generic&lt;/code&gt;，或称泛型的)：可以用于不同类型的容器或者元素。算法通过在迭代器上进行操作来实现类型无关。&lt;/p&gt;
&lt;p&gt;算法不直接改变所操作序列的大小。它们会将一个元素从一个位置拷贝到另一个位置，但不会直接添加或删除元素。&lt;br&gt;虽然算法不能向序列添加元素，但是插入迭代器可以做到。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>标准库并没有给每个容器添加大量功能，而是提供了一组算法，这些算法大多数都独立于任何特定的容器。这些算法是通用的(<code>generic</code>，或称泛型的)：可以用于不同类型的容器或者元素。算法通过在迭代器上进行操作来实现类型无关。</p><p>算法不直接改变所操作序列的大小。它们会将一个元素从一个位置拷贝到另一个位置，但不会直接添加或删除元素。<br>虽然算法不能向序列添加元素，但是插入迭代器可以做到。</p><a id="more"></a><h2 id="概述（10-1，P336）"><a href="#概述（10-1，P336）" class="headerlink" title="概述（10.1，P336）"></a>概述（10.1，P336）</h2><p>顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或者尾元素之后位置的迭代器。</p><p>标准库定义了大约100个类型无关的对序列进行操作的算法。序列可以是标准库类型中的元素、一个内置数组或者是（例如）通过读写一个流来生成的。</p><p>大多数算法都定义在头文件<code>algorithm</code>中。标准库还在文件<code>numeric</code>中定义了一组数值泛型算法。</p><h2 id="初识泛型算法（10-2，P338）"><a href="#初识泛型算法（10-2，P338）" class="headerlink" title="初识泛型算法（10.2，P338）"></a>初识泛型算法（10.2，P338）</h2><p><code>accumulate</code>：定义在头文件<code>numeric</code>中。作用是对范围求和。</p><p><code>euqal</code>：定义在头文件<code>algorithm</code>中。作用是判断给定两个区间是否相等。假定第二个序列至少与第一个序列一样长。</p><p><code>fill</code>：定义在头文件algorithm中。作用是对给定区间全部赋予某值。</p><p><code>fill_n</code>：定义在头文件algorithm中。作用是对给定迭代器后的n个元素赋予某值。</p><p><code>back_inserter</code>：定义在头文件<code>iterator</code>中。得到指向容器尾部的迭代器。</p><h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>&#125;;</div><div class="line">sort(words.begin(),words.end());</div><div class="line"><span class="keyword">auto</span> end_unique = unique(words.begin(),words.end());</div><div class="line">words.erase(end_unique,words.end());</div></pre></td></tr></table></figure><p>消除重复单词的程序：使用到了下面这三个算法：</p><ul><li><code>sort</code>：定义在头文件<code>algorithm</code>中。对指定区间排序；</li><li><code>unique</code>：定义在头文件<code>algorithm</code>中。“消除”重复项，返回指向不重复值范围末尾的迭代器；</li><li><code>erase</code>：容器操作，而不是算法。删除指定范围内的元素。</li></ul><h2 id="定制操作（10-3）"><a href="#定制操作（10-3）" class="headerlink" title="定制操作（10.3）"></a>定制操作（10.3）</h2><h3 id="向算法传递函数（10-3-1）"><a href="#向算法传递函数（10-3-1）" class="headerlink" title="向算法传递函数（10.3.1）"></a>向算法传递函数（10.3.1）</h3><p><strong>谓词(predicate)</strong>是一个可调用的表达式，其返回结果是一个能用作条件的值。谓词分为：一元谓词和二元谓词。几元谓词接受几元参数。</p><p>使用谓词的排序版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>&#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Before: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = words.begin();iter != words.end(); ++iter)&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">"  "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">sort(words.begin(),words.end(), isShorter); <span class="comment">//使用谓词进行排序</span></div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After sort: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s: words)&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"  "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before: the  quick  red  fox  red  the  slow  </div><div class="line">After sort: the  red  fox  red  the  slow  quick</div></pre></td></tr></table></figure></p><p>可以看到三个字母的都在最前面，接着是长度为4,然后是长度为5的。</p><p>有时候我们希望长度相同的元素按照字典进行排序，此时可用<code>stable_sort</code>算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> s1.size() &lt; s2.size();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</div><div class="line"><span class="comment">//按字典顺序排序</span></div><div class="line">sort(words.begin(),words.end());</div><div class="line"></div><div class="line"><span class="keyword">auto</span> end_unique = unique(words.begin(),words.end());</div><div class="line">words.erase(end_unique,words.end());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>, <span class="string">"seen"</span>&#125;;</div><div class="line"></div><div class="line">elimDups(words);</div><div class="line"></div><div class="line">stable_sort(words.begin(), words.end(), isShorter);</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After stable_sort: "</span>;</div><div class="line"> <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s: words)&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"  "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出为：</p><blockquote><p><code>After sort: fox  red  the  seen  slow  quick</code></p></blockquote><h3 id="lambda表达式-10-3-2，P345"><a href="#lambda表达式-10-3-2，P345" class="headerlink" title="lambda表达式(10.3.2，P345)"></a>lambda表达式(10.3.2，P345)</h3><p>可调用对象：对于一个对象或一个表达式，如果可以对其使用调用运算符，则称为可调用的；可调用的对象有：函数、函数指针、重载函数调用运算符的类和<code>lambda</code>表达式。</p><p><code>lambda</code>表达式形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[capture list](parameter list)-&gt;return type&#123;function body&#125;;</div></pre></td></tr></table></figure></p><p><code>capture list</code>是一个<code>lambda</code>所在函数中定义的局部变量的列表（通常为空）；<br><code>return type</code>、<code>parameter list</code>和<code>function body</code>分别表示返回类型、参数列表和函数体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> s1.size() &lt; s2.size();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</div><div class="line"><span class="comment">//按字典顺序排序</span></div><div class="line">sort(words.begin(),words.end());</div><div class="line"></div><div class="line"><span class="keyword">auto</span> end_unique = unique(words.begin(),words.end());</div><div class="line">words.erase(end_unique,words.end());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type sz)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="comment">// 将words按字典序排序，删除重复单词</span></div><div class="line">elimDups(words); </div><div class="line"></div><div class="line"><span class="comment">// 按长度排序，长度相同的单词维持字典序</span></div><div class="line">stable_sort(words.begin(), words.end(), isShorter); </div><div class="line"></div><div class="line"><span class="comment">// 获取一个迭代器，指向第一个满足size()&gt;=sz的元素</span></div><div class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), [sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)&#123; <span class="keyword">return</span> a.size() &gt;= sz; &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 计算满足size&gt;=sz元素的数目</span></div><div class="line"><span class="keyword">auto</span> count = words.end() - wc;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">" "</span> &lt;&lt; ( (count&gt;<span class="number">1</span>) ? <span class="string">"word"</span> : <span class="string">"words"</span> ) &lt;&lt; <span class="string">" of length "</span> &lt;&lt; sz &lt;&lt; <span class="string">" or longer"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="comment">//打印长度大于等于给定值的单词，每个单词后面接一个空格</span></div><div class="line">for_each(wc,words.end(),[](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)&#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span>; &#125;);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>, <span class="string">"seen"</span>&#125;;</div><div class="line">biggies(words,<span class="number">4</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="lambda捕获与返回（10-3-3，P349）"><a href="#lambda捕获与返回（10-3-3，P349）" class="headerlink" title="lambda捕获与返回（10.3.3，P349）"></a>lambda捕获与返回（10.3.3，P349）</h3><p>捕获方式分为显式捕获、隐式捕获与混合使用。</p><p>显式捕获分为值捕获与引用捕获。<br>值捕获：与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是在调用时拷贝。</p><p>隐式捕获：在捕获列表写一个<code>&amp;</code>（引用捕获）或者<code>=</code>（值捕获）。</p><p>混合使用隐式捕获和显式捕获：捕获列表第一个元素必须是一个<code>&amp;</code>或<code>=</code>，并且显式捕获的变量必须采用与隐式捕获不同的方式。</p><h3 id="参数绑定（10-3-4，P354）"><a href="#参数绑定（10-3-4，P354）" class="headerlink" title="参数绑定（10.3.4，P354）"></a>参数绑定（10.3.4，P354）</h3><p>标准库<code>bind</code>函数：定义在头文件：<code>functional</code>；它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。</p><p>调用<code>bind</code>的形式：</p><blockquote><p>auto newCallable=bind(callable, arg_list);</p></blockquote><p><code>newCallable</code>本身是一个可调用对象，<code>arg_list</code>是一个逗号分隔的参数列表，对应给定的callable的参数。<code>arg_list</code>中的参数可能包含形如<code>_n</code>的名字，<code>_1</code>是<code>newCallable</code>的第一个参数,<code>_2</code>为第二个参数，依次类推。</p><p><code>_n</code>参数在命名空间<code>placeholders</code>中，需要如下声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</div></pre></td></tr></table></figure></p><p><code>bind</code>拷贝参数而不能拷贝<code>ostream</code>。我们可以使用<code>ref</code>函数。</p><p>函数<code>ref</code>返回一个对象，包含给定引用，此对象是可以拷贝的。标准库中还有一个<code>cref</code>函数，生成一个保存<code>const</code>引用的类。与<code>bind</code>一样，函数<code>ref</code>和<code>cref</code>也定义在头文件<code>functional</code>中。</p><h2 id="再探迭代器（10-4）"><a href="#再探迭代器（10-4）" class="headerlink" title="再探迭代器（10.4）"></a>再探迭代器（10.4）</h2><p>标准库在头文件<code>iterator</code>中定义了几种迭代器：</p><ul><li>插入迭代器：这些迭代器被绑定到一个容器上，可用来向容器插入元素。</li><li>流迭代器：这些迭代器被绑定到输入或输出流上，可用来遍历所有关联的IO流。</li><li>反向迭代器：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。</li><li>移动迭代器：这些专用的迭代器不是拷贝其中的元素，而是移动它们。</li></ul><h3 id="插入迭代器（10-4-1，P358）"><a href="#插入迭代器（10-4-1，P358）" class="headerlink" title="插入迭代器（10.4.1，P358）"></a>插入迭代器（10.4.1，P358）</h3><table><thead><tr><th>插入器的三种类型</th><th></th></tr></thead><tbody><tr><td>back_inserter</td><td>创建一个使用<code>push_back</code>的迭代器</td></tr><tr><td>front_inserter</td><td>创建一个使用<code>push_front</code>的迭代器</td></tr><tr><td>inserter</td><td>创建一个使用<code>insert</code>的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将插入到给定迭代器所表示的元素之前。</td></tr></tbody></table><p>练习10.28：分别使用上述三种插入迭代器将vector的内容拷贝到容器中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">9</span>; ++i)</div><div class="line">&#123;</div><div class="line">v.push_back(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; di, dbi, dfi;</div><div class="line">copy(v.begin(), v.end(), inserter(di, di.begin())); <span class="comment">// 接收两个参数</span></div><div class="line">copy(v.begin(), v.end(), back_inserter(dbi));</div><div class="line">copy(v.begin(), v.end(), front_inserter(dfi));</div></pre></td></tr></table></figure></p><p>三个插入器的最终结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inserter:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </div><div class="line">back_inserter:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </div><div class="line">front_inserter:<span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></div></pre></td></tr></table></figure></p><h3 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h3><h4 id="istream-iterator操作"><a href="#istream-iterator操作" class="headerlink" title="istream_iterator操作"></a>istream_iterator操作</h4><table><thead><tr><th><code>istream_iterator</code>操作</th><th>含义</th></tr></thead><tbody><tr><td><code>istream_iterator&lt;T&gt; in(is)</code></td><td>in从输入流is读取类型为T的值</td></tr><tr><td><code>istream_iterator&lt;T&gt; end;</code></td><td>读取类型为T的值的<code>istream_iterator</code>迭代器，表示尾后位置 （默认初始化）</td></tr><tr><td><code>in1 == in2</code></td><td>in1和in2必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同</td></tr><tr><td><code>in1 != in2</code></td><td>的输入，则两者相等</td></tr><tr><td><code>*in</code></td><td>返回从流中读取的值</td></tr><tr><td><code>in-&gt;mem</code></td><td>与<code>(*in).mem</code>的含义相同</td></tr><tr><td>++in,in++</td><td>使用元素类型所定义的&gt;&gt;运算符从输入流中读取下一值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值</td></tr></tbody></table><p>计算从标准输入的值的和：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in_iter(<span class="built_in">cin</span>), eof;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sum is: "</span> &lt;&lt; accumulate(in_iter, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><h4 id="ostream-iterator操作"><a href="#ostream-iterator操作" class="headerlink" title="ostream_iterator操作"></a>ostream_iterator操作</h4><table><thead><tr><th><code>ostream_iterator</code>操作</th><th>含义</th></tr></thead><tbody><tr><td><code>ostream_iterator&lt;T&gt; out(os);</code></td><td>out将类型为T的值写到输出流os中</td></tr><tr><td><code>ostream_iterator&lt;T&gt; out(os,d);</code></td><td>out将类型为T的值写到输出流os中，每个值后面都输出一个d。d指向一个空字符结尾的字符数组</td></tr><tr><td>out = val;</td><td>用<code>&lt;&lt;</code>运算符将val写入到out所绑定的ostream中。val的类型必须与out可写的类型兼容。</td></tr><tr><td><code>*out,++out,out++;</code></td><td>这些运算符是存在的，但不对out做任何事情。每个运算符都返回out</td></tr></tbody></table><p>使用流迭代器输出vector的内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</div><div class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; out_iter(<span class="built_in">cout</span>, <span class="string">" "</span>);</div><div class="line">copy(v.begin(),v.end(),out_iter);</div></pre></td></tr></table></figure></p><h3 id="反向迭代器（10-4-3，P363）"><a href="#反向迭代器（10-4-3，P363）" class="headerlink" title="反向迭代器（10.4.3，P363）"></a>反向迭代器（10.4.3，P363）</h3><p>sort函数正向与逆序排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</div><div class="line"></div><div class="line">sort(v.begin(),v.end());</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After sort: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = v.begin(); i != v.end(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">sort(v.rbegin(),v.rend());</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After reverse sort: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = v.begin(); i != v.end(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">After sort: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </div><div class="line">After reverse sort: <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></div></pre></td></tr></table></figure></p><p>使用反向迭代器逆序打印一个vector(练习10.34)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"逆序打印："</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = v.crbegin(); i != v.crend(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>输出结果为：</p><blockquote><p>逆序打印：8 9 2 6 4 7 1 5 3 </p></blockquote><p>使用<code>find</code>在一个int的<code>list</code>中查找最后一个值为<code>0</code>的元素（练习10.36）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> it = find(v.cbegin(),v.cend(),<span class="number">0</span>);</div><div class="line"><span class="keyword">auto</span> itr = find(v.crbegin(),v.crend(),<span class="number">0</span>);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代器的指向位置： "</span> &lt;&lt; *it &lt;&lt; *itr &lt;&lt;*(itr.base()) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After find: "</span> ;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = it; i != v.cend(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After reverse find: "</span> ;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = itr.base(); i != v.cend(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>输出为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">迭代器的指向位置： <span class="number">006</span></div><div class="line">After find: <span class="number">0</span> <span class="number">7</span> <span class="number">4</span> <span class="number">0</span> <span class="number">6</span> <span class="number">2</span> <span class="number">9</span> <span class="number">8</span> </div><div class="line">After reverse find: <span class="number">6</span> <span class="number">2</span> <span class="number">9</span> <span class="number">8</span></div></pre></td></tr></table></figure></p><h2 id="泛型算法结构（10-5）"><a href="#泛型算法结构（10-5）" class="headerlink" title="泛型算法结构（10.5）"></a>泛型算法结构（10.5）</h2><h3 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h3><table><thead><tr><th>迭代器类别</th><th></th></tr></thead><tbody><tr><td>输入迭代器</td><td>只读，不写；单遍扫描，只能递增</td></tr><tr><td>输出迭代器</td><td>只写，不读；单遍扫描，只能递增</td></tr><tr><td>前向迭代器</td><td>可读写，多遍扫描，只能递增</td></tr><tr><td>双向迭代器</td><td>可读写，多遍扫描，可递增递减</td></tr><tr><td>随机访问迭代器</td><td>可读写，多遍扫描，支持全部迭代器运算</td></tr></tbody></table><h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>4种算法形参模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alg(beg,end,other args);</div><div class="line">alg(beg,end,dest,other args);</div><div class="line">alg(beg,end,beg2,other args);</div><div class="line">alg(beg,end,beg2,end2,other args);</div></pre></td></tr></table></figure></p><p>其中，<code>alg</code>是算法的名字，<code>beg</code>和<code>end</code>是算法所操作的输入范围。<code>dest</code>、<code>beg2</code>和<code>end2</code>，都是迭代器参数。<br><code>dest</code>参数表示算法可以写入的目的位置的迭代器，算法假定：不管写入多少个元素都是安全的。</p><h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>一些算法使用重载参数形式传递一个谓词。</p><p><code>_if</code>版本的算法：接受一个元素值的算法通常有一个接受谓词版本的算法，加上后缀<code>_if</code></p><p>区分拷贝元素的版本和不拷贝元素的版本：重排元素的算法通常直接写回给定的输入序列，也可以将元素写到一个指定的输出目的的位置，此类算法在名字后面加上<code>_copy</code></p><h2 id="特定容器算法（10-6）"><a href="#特定容器算法（10-6）" class="headerlink" title="特定容器算法（10.6）"></a>特定容器算法（10.6）</h2><h3 id="list和forward-list成员函数版本的算法"><a href="#list和forward-list成员函数版本的算法" class="headerlink" title="list和forward_list成员函数版本的算法"></a>list和forward_list成员函数版本的算法</h3><table><thead><tr><th>list和forward_list成员函数版本的算法</th><th>含义</th></tr></thead><tbody><tr><td>lst.merga(lst2)   </td></tr><tr><td>lst.megra(lst2,comp)</td><td>将来自lst2的元素合并入lst。lst和lst2都必须是有序的。元素将从lst2中删除。在合并之后，lst2变成空。第一个版本使用&lt;运算符；第二个版本使用给定的比较操作。</td></tr><tr><td>lst.remove(val)</td></tr><tr><td>lst.remove_if(pred)</td><td>调用erase删除掉与给定值相等(==)或令一元谓词为真的每个元素</td></tr><tr><td>lst.reverse()</td><td>反转lst中元素的顺序</td></tr><tr><td>lst.sort() </td></tr><tr><td>lst.sort(comp)</td><td>使用&lt;或给定比较操作排序元素</td></tr><tr><td>lst.unique()</td></tr><tr><td>lst.unique(pred)</td><td>调用erase删除同一个值的连续拷贝。第一个版本使用==；第二个版本使用给定的二元谓词</td></tr></tbody></table><h3 id="list和forward-list的splice成员函数的参数"><a href="#list和forward-list的splice成员函数的参数" class="headerlink" title="list和forward_list的splice成员函数的参数"></a>list和forward_list的splice成员函数的参数</h3><table><thead><tr><th>lst.splice(args)或flst.splice_after(args)</th><th>含义</th></tr></thead><tbody><tr><td>(p,lst2)</td><td>p是一个指向lst中元素的迭代器，或一个指向flst首前位置的迭代器。函数将lst2的所有元素移动到lst中p之前的位置或是flst中p之后的位置。将元素从lst2中删除。lst2的类型必须与lst或flst相同，且不能是同一个链表。</td></tr><tr><td>(p,lst2,p2)</td><td>p2是一个指向lst2中位置的有效迭代器。将p2指向的元素移动到lst中，或将p2之后的元素移动到flst中。lst2可以是与lst或flst相同的链表。</td></tr><tr><td>(p,lst2,b,e)</td><td>b和e必须表示lst2中的合法范围。将给定范围中的元素从lst2移动到lst或flst。lst2与lst(或flst)可以是相同的链表，但p不能指向给定范围中元素。</td></tr></tbody></table><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>泛型算法：generic algorithm<br>谓词：predicate<br>一元谓词：unary predicate<br>二元谓词：binary predicate</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49803965" target="_blank" rel="external">C++primer第五版第十章学习笔记</a></li><li><a href="http://blog.csdn.net/libin1105/article/details/48706281" target="_blank" rel="external">《C++primer(第五版)》学习之路-第十章：泛型算法</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/20/CPP_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(九)顺序容器</title>
      <link>http://wangwlj.com/2018/01/18/CPP_09/</link>
      <guid>http://wangwlj.com/2018/01/18/CPP_09/</guid>
      <pubDate>Thu, 18 Jan 2018 13:56:55 GMT</pubDate>
      <description>
      
        &lt;p&gt;本章是第三章内容的扩展，完成本章的学习后，对标准库顺序容器知识的掌握就完整了。&lt;/p&gt;
&lt;p&gt;元素在顺序容器中的位置与其加入容器时的位置相对应。 标准库还定义了几种关联容器（第11章），关联容器中元素的位置由元素相关联的关键字决定。&lt;/p&gt;
&lt;p&gt;顺序容器有：&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;deque&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;forward_list&lt;/code&gt;、&lt;code&gt;array&lt;/code&gt;与&lt;code&gt;string&lt;/code&gt;。&lt;br&gt;容器适配器有：&lt;code&gt;stack&lt;/code&gt;、&lt;code&gt;queue&lt;/code&gt;与&lt;code&gt;priority_queue&lt;/code&gt;。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本章是第三章内容的扩展，完成本章的学习后，对标准库顺序容器知识的掌握就完整了。</p><p>元素在顺序容器中的位置与其加入容器时的位置相对应。 标准库还定义了几种关联容器（第11章），关联容器中元素的位置由元素相关联的关键字决定。</p><p>顺序容器有：<code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>、<code>array</code>与<code>string</code>。<br>容器适配器有：<code>stack</code>、<code>queue</code>与<code>priority_queue</code>。</p><a id="more"></a><h2 id="顺序容器概述（9-1，P292）"><a href="#顺序容器概述（9-1，P292）" class="headerlink" title="顺序容器概述（9.1，P292）"></a>顺序容器概述（9.1，P292）</h2><table><thead><tr><th>顺序容器类型</th><th>含义</th></tr></thead><tbody><tr><td>vector</td><td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢</td></tr><tr><td>deque</td><td>双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td></tr><tr><td>list</td><td>双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快</td></tr><tr><td>forward_list</td><td>单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快</td></tr><tr><td>array</td><td>固定大小数组。支持快速随机访问。不能添加或删除元素。</td></tr><tr><td>string</td><td>与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。</td></tr></tbody></table><p>以下是一些选择容器的基本原则：</p><p>⑴.除非你有很好的理由选择其他容器，否则应使用<code>vector</code></p><p>⑵.如果你的程序有很多小的元素，且额外开销很重要，则不要使用<code>list</code>或<code>forward_list</code></p><p>⑶.如果程序要求随机访问元素，应使用<code>vector</code>或<code>deque</code></p><p>⑷.如果程序需要<strong>在中间位置插入或删除元素</strong>，应使用<code>list</code>或<code>forward_list</code></p><p>⑸.如果程序需要<strong>在头尾位置插入或删除元素</strong>，但不会在中间位置进行插入或删除操作，则使用<code>deque</code></p><p>⑹.如果程序只有在读取输入时才需要再容器中间位置插入元素，随后需要随机访问元素，则</p><p>–首先，确定是否真的需要再容器中间位置添加元素。当处理输入数据时，通常可以很容易地向<code>vector</code>追加数据，然后再调用标准库的<code>sort</code>函数来重排容器中的元素，从而避免在中间位置添加元素。</p><p>–如果必须在中间位置插入元素，考虑在输入阶段使用<code>list</code>，一旦输入完成，将<code>list</code>中的内容拷贝到一个<code>vector</code>中。</p><h2 id="容器库概览（9-2，P294）"><a href="#容器库概览（9-2，P294）" class="headerlink" title="容器库概览（9.2，P294）"></a>容器库概览（9.2，P294）</h2><p>本节介绍对所有容器都适用的操作。</p><h3 id="容器操作表"><a href="#容器操作表" class="headerlink" title="容器操作表"></a>容器操作表</h3><table><thead><tr><th>类型别名</th><th></th></tr></thead><tbody><tr><td>iterator</td><td>此容器类型的迭代器类型</td></tr><tr><td>const_iterator</td><td>可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td>size_type</td><td>无符号整数类型，足够保存此种容器类型最大可能容器的大小</td></tr><tr><td>different_type</td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>reference</td><td>元素的左值类型；与value_type含义相同</td></tr><tr><td>const_reference</td><td>元素的const左值类型</td></tr></tbody></table><table><thead><tr><th>构造函数</th><th></th></tr></thead><tbody><tr><td>C c;</td><td>默认构造函数，构造空容器</td></tr><tr><td>C c1(c2);</td><td>构造c2的拷贝c1</td></tr><tr><td>C c(b,e);</td><td>构造c，将迭代器b和e指定范围内的元素拷贝到c(array不支持)</td></tr><tr><td>C c{a,b,c…};</td><td>列表初始化c</td></tr></tbody></table><table><thead><tr><th>赋值与swap</th><th></th></tr></thead><tbody><tr><td>c1 = c2</td><td>将c1中的元素替换为c2中元素</td></tr><tr><td>c1 = {a,b,c..}</td><td>将c1中的元素替换为列表中的元素</td></tr><tr><td>a.swap(b)</td><td>交换a和b的元素</td></tr><tr><td>swap(a,b)</td><td>与a.swap(b)等价</td></tr></tbody></table><table><thead><tr><th>大小</th><th></th></tr></thead><tbody><tr><td>c.size()</td><td>c中元素的数目（不支持forward_list）</td></tr><tr><td>c.max_size()</td><td>c可保存的的最大元素数目</td></tr><tr><td>c.empty()</td><td>若c中存储了元素，返回false，否则返回true</td></tr></tbody></table><table><thead><tr><th>添加/删除元素（不适用于array）</th><th></th></tr></thead><tbody><tr><td>注：在不同容器中，这些操作的接口都不同</td></tr><tr><td>c.insert(args)</td><td>将args中的元素拷贝进c</td></tr><tr><td>c.emplace(inits)</td><td>使用inits构造c中的一个元素</td></tr><tr><td>c.erase(args)</td><td>删除args指定的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素，返回void</td></tr></tbody></table><table><thead><tr><th>关系运算符</th><th></th></tr></thead><tbody><tr><td>==,!=</td><td>所有容器都支持相等（不等）操作</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>关系运算符(无序关联容器不支持)</td></tr></tbody></table><table><thead><tr><th>获取迭代器</th><th></th></tr></thead><tbody><tr><td>c.begin(),c.end()</td><td>返回指向c的首元素和尾元素之后位置的迭代器</td></tr><tr><td>c.cbegin(),c.cend()</td><td>返回const_iterator</td></tr></tbody></table><table><thead><tr><th>反向容器的额外成员</th><th></th></tr></thead><tbody><tr><td>reverse_iterator</td><td>按逆序寻址元素的迭代器</td></tr><tr><td>const_reverse_iterator</td><td>不能修改元素的逆序迭代器</td></tr><tr><td>c.rbegin(),c.rend()</td><td>返回指向c的尾元素和首元素之前位置的迭代器</td></tr><tr><td>c.crbegin(),c.crend()</td><td>返回const_reverse_iterator</td></tr></tbody></table><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器范围(<code>iterator range</code>)：<code>[begin,end)</code>，左闭合区间(<code>left-inclusive interval</code>)</p><p>迭代器的运算符（表3.6，P96）</p><table><thead><tr><th>迭代器的运算符</th><th>含义</th></tr></thead><tbody><tr><td><code>*iter</code></td><td>返回迭代器所指元素的引用</td></tr><tr><td>iter-&gt;mem</td><td>解引用iter并获取该元素的名为mem的成员，等价于<code>(*iter).mem</code></td></tr><tr><td>++iter</td><td>令iter指示容器中的下一个元素</td></tr><tr><td>++iter</td><td>令iter指示容器中的上一个元素</td></tr><tr><td>iter1 == iter2</td><td>判断两个迭代器是否相等（指向同一个位置则相等，包括尾后）</td></tr><tr><td>iter1 != iter2</td><td>判断两个迭代器是否不相等（指向同一个位置则相等，包括尾后）</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(begin != end)&#123;</div><div class="line">*begin = val;</div><div class="line">    ++begin;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果<code>begin</code>与<code>end</code>相等，则范围为空；如果<code>begin</code>与<code>end</code>不等，则范围至少包含一个元素，且<code>begin</code>指向该范围中的第一个元素；我们可以对<code>begin</code>递增若干次，使得<code>begin==end</code>。</p><h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3><h3 id="容器定义和初始化-9-2-4，P299"><a href="#容器定义和初始化-9-2-4，P299" class="headerlink" title="容器定义和初始化(9.2.4，P299)"></a>容器定义和初始化(9.2.4，P299)</h3><table><thead><tr><th>容器定义和初始化</th><th></th></tr></thead><tbody><tr><td>C c</td><td>默认构造函数。如果C是一个array，则c中元素按默认方式初始化，否则c为空</td></tr><tr><td><code>C c1(c2)</code> 与 <code>C c1 = c2</code></td><td>c1初始化为c2的拷贝。c1和c2必须是相同类型。</td></tr><tr><td><code>C c{a,b,c...}</code>与<code>C c = {a,b,c..}</code></td><td>c初始化为初始化列表中元素的拷贝。列表中元素的类型必须与C的元素类型相容。对于array类型，列表中元素数目必须等于或少于array的大小，任何遗漏的元素都进行值初始化。</td></tr><tr><td>C c(b,e)</td><td>c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与C的元素类型相容（对array不适用）</td></tr><tr><td>C seq(n)</td><td>seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的</td></tr><tr><td>C seq(n,t)</td><td>seq包含n个初始化为值t的元素</td></tr></tbody></table><p>$\color{red}{\heartsuit}$ <font color="0D54BD">只有顺序容器（不包括array）的构造函数才能接受大小参数。</font>关联容器并不支持。【上表中的倒数两个】</p><p>$\color{red}{\heartsuit}$ <font color="0D54BD">当一个容器初始化为另一个容器的拷贝时，两个容器的容器类型必须相同。</font></p><p>标准库array的大小也是类型的一部分。定义一个array时，除了指定元素类型，还需要指定容器大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,42&gt;</div><div class="line"><span class="built_in">array</span>&lt;<span class="built_in">string</span>,10&gt;::size_type i;</div></pre></td></tr></table></figure></p><h3 id="赋值与swap-9-2-5，P302"><a href="#赋值与swap-9-2-5，P302" class="headerlink" title="赋值与swap(9.2.5，P302)"></a>赋值与swap(9.2.5，P302)</h3><p>赋值、交换以及assign：</p><table><thead><tr><th>容器赋值运算</th><th></th></tr></thead><tbody><tr><td><code>c1 = c2</code></td><td>将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的类型</td></tr><tr><td><code>c = {a,b,c..}</code></td><td>将c1中元素替换为初始化列表中元素的拷贝</td></tr><tr><td><code>swap(c1,c2)</code>与<code>c1.swap(c2)</code>等价</td><td>交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多。</td></tr><tr><td><strong>assign操作不适用于关联容器和array</strong></td></tr><tr><td>seq.assign(b,e)</td><td>将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素</td></tr><tr><td>seq.assign(il)</td><td>将seq中的元素替换为初始化列表il中的元素</td></tr><tr><td>seq.assign(n,t)</td><td>将seq中的元素替换为n个值为t的元素 </td></tr></tbody></table><p>$\color{red}{\heartsuit}$ <font color="0D54BD">使用assign：允许我们使用不同但相容的类型赋值。</font></p><p>除了array外，swap不对任何元素进行拷贝、删除或者插入操作，因此可以保证常数时间内完成。<br>与其它容器不同，swap两个array会真正交换它们的元素。指针和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应的元素的值进行了交换。</p><p>除了string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。<br>特殊的，对一个string 调用swap会导致迭代器和指针失效。</p><p>forward_list支持max_size和empty，但不支持size。其它每个容器都有三个有关大小的操作。</p><h2 id="顺序容器操作-9-3，P305"><a href="#顺序容器操作-9-3，P305" class="headerlink" title="顺序容器操作(9.3，P305)"></a>顺序容器操作(9.3，P305)</h2><h3 id="向顺序容器中添加元素"><a href="#向顺序容器中添加元素" class="headerlink" title="向顺序容器中添加元素"></a>向顺序容器中添加元素</h3><table><thead><tr><th>向顺序容器添加元素的操作</th><th>含义</th></tr></thead><tbody><tr><td>c.push_back(t)</td><td>在c的尾部创建一个值为t或由args创建的元素，返回void</td></tr><tr><td>c.emplace_back(args)</td></tr><tr><td>c.push_front(t)</td><td>在c的头部创建一个值为t或由args创建的元素。返回void</td></tr><tr><td>c.emplace_front(args)</td></tr><tr><td>c.insert(p,t)</td><td>在迭代器p指向的元素<strong>之前</strong>创建一个值为t或由args创建的元素。返回指向新添加元素的迭 </td></tr><tr><td>c.emplace(p,args)</td><td>代器。 </td></tr><tr><td>c.insert(p,n,t)</td><td>在迭代器p指向的元素<strong>之前</strong>插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回p</td></tr><tr><td>c.insert(p,b,e)</td><td>将迭代器b和e指定的范围内的元素插入迭代器p指向的元素<strong>之前</strong>。b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回p</td></tr><tr><td>c.insert(p,il)</td><td>il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素<strong>之前</strong>。返回指向新添加的第一个元素的迭代器；若列表为空，则返回p</td></tr></tbody></table><table><thead><tr><th>添加元素操作</th><th>描述</th><th>vector</th><th>list</th><th>forward_list</th><th>array</th><th>deque</th></tr></thead><tbody><tr><td>push_back/emplace_back</td><td>尾部添加元素</td><td>ok</td><td>ok</td><td>不支持</td><td>不支持</td><td>ok</td></tr><tr><td>push_front/emplace_front</td><td>首部添加元素</td><td>不支持</td><td>ok</td><td>OK</td><td>不支持</td><td>ok</td></tr><tr><td>insert(p, t)/insert(p, n, t)/insert(p, b, e)/insert(p, {…})</td><td><strong>在指定p位置<font color="0D54BD">之前</font>插入元素</strong></td><td>ok</td><td>ok</td><td>有自己专用版本</td><td>不支持</td><td>ok</td></tr><tr><td>emplace</td><td>插入元素</td><td>ok</td><td>ok</td><td>有自己专用版本</td><td>不支持</td><td>ok</td></tr></tbody></table><p>添加元素会改变容器的大小，array不支持这些操作。forward_list有自己专有版本的insert和emplace。forward_list不支持push_back和emplace_back。</p><p>vector和string不支持push_front和emplace_front。将元素insert插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时。</p><p>emplace函数直接在容器中构造函数，传递给emplace函数的参数必须与元素类型相匹配。</p><h3 id="访问元素-9-3-2，P309"><a href="#访问元素-9-3-2，P309" class="headerlink" title="访问元素(9.3.2，P309)"></a>访问元素(9.3.2，P309)</h3><table><thead><tr><th>访问元素的操作</th><th>含义</th></tr></thead><tbody><tr><td>c.back()</td><td>返回c中尾元素的引用。若c为空，函数行为未定义</td></tr><tr><td>c.front()</td><td>返回c中首元素的引用。若c为空，函数行为未定义</td></tr><tr><td>c[n]</td><td>返回c中下标为n的元素的引用，n是一个无符号的整数。若n&gt;=c.size()，则函数行为未定义。</td></tr><tr><td>c.at(n)</td><td>返回下标为n的元素的引用。如果下标越界，则抛出一out_of_range异常。</td></tr></tbody></table><p>at和下标操作只适用于string,vector,deque和array。<br>back不适用于forward_list。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!c.empty())</div><div class="line">&#123;</div><div class="line">    c.front() = <span class="number">42</span>;</div><div class="line">    <span class="keyword">auto</span> &amp;v = c.back(); <span class="comment">// 获得指向最后一个元素的引用</span></div><div class="line">    v = <span class="number">1024</span>;</div><div class="line">    <span class="keyword">auto</span> v2 = c.back(); <span class="comment">// v2不是引用，只是c.back()的一个拷贝</span></div><div class="line">    v2 = <span class="number">0</span>; <span class="comment">// 没有改变c中的元素</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"v: "</span>&lt;&lt; v &lt;&lt;<span class="string">"  v2: "</span> &lt;&lt; v2 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果希望下标是合法的，可以使用at函数；如果下标越界，则抛出一个out_of_range异常。</p><h3 id="删除元素（9-3-3，P311）"><a href="#删除元素（9-3-3，P311）" class="headerlink" title="删除元素（9.3.3，P311）"></a>删除元素（9.3.3，P311）</h3><p>这些操作会改变容器大小，所以不适用于array；forward_list有特殊版本的erase；forward_list不支持pop_back；vector和string不支持pop_front。</p><table><thead><tr><th>删除元素操作</th><th>含义</th></tr></thead><tbody><tr><td>c.pop_back()</td><td>删除c中尾元素。若c为空，则函数行为未定义。函数返回void</td></tr><tr><td>c.pop_front()</td><td>删除c中首元素。若c为空，则函数行为未定义。函数返回void</td></tr><tr><td>c.erase(p)</td><td>删除迭代器p所指定的元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后(off_the_end)迭代器。若p是尾后迭代器，则函数行为未定义。</td></tr><tr><td>c.erase(b,e)</td><td>删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器</td></tr><tr><td>c.clear()</td><td>删除c中所有元素。返回void</td></tr></tbody></table><p>删除一个<code>list</code>中的所有奇数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</div><div class="line"><span class="keyword">auto</span> it = lst.begin();</div><div class="line"><span class="keyword">while</span>(it != lst.end())</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(*it % <span class="number">2</span>)  <span class="comment">// 如果是奇数</span></div><div class="line">        it = lst.erase(it); <span class="comment">//删除此元素，返回下一个元素</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        ++it; <span class="comment">// 递增</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="特殊的forward-list操作"><a href="#特殊的forward-list操作" class="headerlink" title="特殊的forward_list操作"></a>特殊的forward_list操作</h3><table><thead><tr><th>在forward_list中插入或删除元素的操作</th><th>含义</th></tr></thead><tbody><tr><td>lst.before_begin()</td><td>返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。</td></tr><tr><td>lst.cbefore_begin()</td><td>cbefore_begin()返回一个const_iterator</td></tr><tr><td>lst.insert_after(p,t)</td><td>在迭代器p之后的位置插入元素，t是一个对象</td></tr><tr><td>lst.insert_after(p,n,t)</td><td>t是一个对象，n是数量</td></tr><tr><td>lst.insert_after(p,b,e)</td><td>b和e是表示范围的一对迭代器(b和e不能指向lst内)</td></tr><tr><td>lst.insert_after(p,il)</td><td>il是一个花括号列表。</td></tr><tr><td>insert_after小结</td><td>返回一个指向最后一个插入的元素的迭代器。如果范围为空，则返回p。若p为尾后迭代器，则函数行为未定义</td></tr><tr><td>emplace_after(p,args)</td><td>使用args在p指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若p为尾后迭代器，则函数行为未定义。</td></tr><tr><td>lst.earse_after(p)</td><td>删除p指向的位置之后的元素，或删除从b之后直到(但不包含)e之间的元素。返回一个</td></tr><tr><td>lst.earse_after(b,e)</td><td>指向被删元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。如果p指向lst的尾元素或者是一个尾后迭代器，则函数行为未定义。</td></tr></tbody></table><p>删除一个<code>forward_list</code>中的所有奇数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">forward_list&lt;<span class="keyword">int</span>&gt; flst = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</div><div class="line"><span class="keyword">auto</span> curr = flst.begin();</div><div class="line"><span class="keyword">auto</span> prev = flst.before_begin();</div><div class="line"><span class="keyword">while</span>(curr != flst.end())</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(*curr % <span class="number">2</span>)</div><div class="line">        curr = flst.erase_after(prev);</div><div class="line">    <span class="keyword">else</span> </div><div class="line">        prev = curr++; <span class="comment">//或者 prev=curr; curr++; //或者 prev++;curr++; </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="改变容器大小（9-3-5，P314）"><a href="#改变容器大小（9-3-5，P314）" class="headerlink" title="改变容器大小（9.3.5，P314）"></a>改变容器大小（9.3.5，P314）</h3><table><thead><tr><th>顺序容器大小操作</th><th>含义</th></tr></thead><tbody><tr><td>c.resize(n)</td><td>调整c的大小为n个元素。若<code>n&lt;c.size()</code>，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化</td></tr><tr><td>c.resize(n,t)</td><td>调整c的大小为n个元素。任何新添加的元素都初始化为值t。</td></tr></tbody></table><p><code>resize</code>不适用于<code>array</code>。<code>resize</code>用来增大或者缩小容器。</p><h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>向容器添加元素之后：</p><p>⑴.如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未被重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。</p><p>⑵.对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</p><p>⑶.对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍然有效。</p><p>当我们删除一个元素后：</p><p>⑴.对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍然有效。</p><p>⑵.对于<code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被删除元素之外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。</p><p>⑶.对于<code>vector</code>和<code>string</code>，指向被删元素之前元素的迭代器、引用和指针仍然有效。</p><p>注：当我们删除元素时，尾后迭代器总是会失效。</p><p>$\color{red}{\heartsuit}$ <font color="0D54BD">由于向迭代器添加元素和从迭代器删除元素的代码可能会使得迭代器失效，因此必须保证每次改变容器的操作之后都能正确地重新定位迭代器。</font></p><p>$\color{red}{\heartsuit}$ <font color="0D54BD">添加或删除元素的循环过程必须反复调用end，而不能在循环之前保存end返回的迭代器。</font></p><h2 id="vector是如何增长的（9-4，P317）"><a href="#vector是如何增长的（9-4，P317）" class="headerlink" title="vector是如何增长的（9.4，P317）"></a>vector是如何增长的（9.4，P317）</h2><p>1.容器大小管理操作</p><p><code>shrink_to_fit</code>只使用于<code>vector</code>、<code>string</code>和<code>deque</code>；<code>capacity</code>和<code>reserve</code>只适用于<code>vector</code>和<code>string</code></p><table><thead><tr><th>容器大小管理操作</th><th>含义</th></tr></thead><tbody><tr><td>c.shrink_to_fit()</td><td>请将capacity()减少为与size()相同大小</td></tr><tr><td>c.capacity()</td><td>不重新分配内存空间的话，c可以保存多少元素</td></tr><tr><td>c.reserve(n)</td><td>分配至少能容纳n个元素的内存空间</td></tr></tbody></table><p>2.当添加的数超出了<code>vector</code>原本分配的最大容量，<code>vector</code>的实现采用的策略是在每次需要分配新内存空间时将当前容量翻倍。</p><p>程序测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= <span class="number">33</span>; ++i)&#123;</div><div class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span>&lt;&lt; vec.size() &lt;&lt;<span class="string">"capacity: "</span>&lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">       vec.push_back(i);</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h2 id="额外的string操作（9-5，P320）"><a href="#额外的string操作（9-5，P320）" class="headerlink" title="额外的string操作（9.5，P320）"></a>额外的string操作（9.5，P320）</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><table><thead><tr><th>构造string的其他方法</th><th>含义</th></tr></thead><tbody><tr><td>string s(cp,n)</td><td>s是cp指向的数组中前n个字符的拷贝。此数组至少应该包含n个字符。</td></tr><tr><td>string s(s2,pos2)</td><td>s是string s2从下标pos2开始的字符的拷贝。若pos2&gt;s2.size()，构造函数的行为未定义</td></tr><tr><td>string s(s2,pos2,len2)</td><td>s是string s2从下标pos2开始len2个字符的拷贝。若pos2&gt;s2.size()，构造函数的行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符。</td></tr></tbody></table><h3 id="子字符串操作"><a href="#子字符串操作" class="headerlink" title="子字符串操作"></a>子字符串操作</h3><p><code>s.substr(pos,n)</code>：返回一个<code>string</code>，包含s中从pos开始的n个字符的拷贝。<code>pos</code>的默认值为<code>0</code>。<code>n</code>的默认值为<code>s.size()-pos</code>，即拷贝从pos开始的所有字符。</p><h3 id="改变string的其他方法"><a href="#改变string的其他方法" class="headerlink" title="改变string的其他方法"></a>改变string的其他方法</h3><table><thead><tr><th>修改string的操作</th><th>含义</th></tr></thead><tbody><tr><td>s.insert(pos,args)</td><td>在pos之前插入args指定的字符。pos可以是一个下标或一个迭代器。接受下标的版本返回一个指向s的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td></tr><tr><td>s.earse(pos,len)</td><td>删除从位置pos开始的len个字符。如果len被省略，则删除从pos开始直至s末尾的所有字符。返回一个指向s的引用。</td></tr><tr><td>s.assign(args)</td><td>将s中的字符替换为args指定的字符。返回一个指向s的引用</td></tr><tr><td>s.append(args)</td><td>将args追加到s。返回一个指向s的引用</td></tr><tr><td>s.replace(range,args)</td><td>删除s中范围range内的字符，替换为args指定的字符。range或者是一个下标和一个长度，或者是一对指向s的迭代器。返回一个指向s的引用</td></tr></tbody></table><h3 id="string搜索操作（9-5-3，P325）"><a href="#string搜索操作（9-5-3，P325）" class="headerlink" title="string搜索操作（9.5.3，P325）"></a>string搜索操作（9.5.3，P325）</h3><p><code>string</code>类提供了6个不同的搜索函数，每个函数都有4个重载版本。</p><p>每个搜索操作都会返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。</p><p>如果搜索失败，则返回一个名为<code>string::npos</code>的static成员。标准库将<code>npos</code>定义成一个<code>const string::size_type</code>类型，并初始化为<code>-1</code>。</p><p><code>string</code>搜索函数返回<code>string::size_type</code>值，该类型时一个<code>unsigned</code>类型，因此我们应该尽量不要使用带符号类型来保存这些返回值。</p><table><thead><tr><th>string搜索操作</th><th>含义</th></tr></thead><tbody><tr><td>s.find(args)</td><td>查找s中args第一次出现的位置</td></tr><tr><td>s.rfind(args)</td><td>查找s中args最后一次出现的位置</td></tr><tr><td>s.find_first_of(args)</td><td>在s中查找args中任何一个字符第一次出现的位置</td></tr><tr><td>s.find_last_of(args)</td><td>　在s中查找args中任何一个字符最后第一次出现的位置</td></tr><tr><td>s.find_first_not_of(args)</td><td>在s中查找第一个不在args中的字符</td></tr><tr><td>s.find_last_not_of(args)</td><td>在s中查找最后一个不在args中的字符  </td></tr></tbody></table><table><thead><tr><th>args的形式</th><th>含义</th></tr></thead><tbody><tr><td>c,pos</td><td>从s中位置pos开始查找字符c。pos默认为0</td></tr><tr><td>s2,pos</td><td>从s中位置pos开始查找字符串s2。pos默认为0</td></tr><tr><td>cp,pos</td><td>从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串。pos默认为0</td></tr><tr><td>cp,pos,n</td><td>从s中位置pos开始查找指针cp指向的数组的前n个字符。pos和n无默认值</td></tr></tbody></table><h3 id="字符串比较函数-9-5-4，P327"><a href="#字符串比较函数-9-5-4，P327" class="headerlink" title="字符串比较函数(9.5.4，P327)"></a>字符串比较函数(9.5.4，P327)</h3><table><thead><tr><th>s.compare(args)中args形式</th><th>含义</th></tr></thead><tbody><tr><td>s2</td><td>比较s和s2</td></tr><tr><td>pos1,n1,s2</td><td>将s中从pos1开始的n1个字符与s2比较</td></tr><tr><td>pos1,n1,s2,pos2,n2</td><td>将s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符进行比较</td></tr><tr><td>cp</td><td>比较s与cp指向的以空字符结尾的字符数组</td></tr><tr><td>pos1,n1,cp</td><td>将s中从pos1开始的n1个字符与cp指向的以空字符结尾的字符数组进行比较</td></tr><tr><td>pos1,n1,cp,n2</td><td>将s中从pos1开始的n1个字符与cp指向的地址开始的n2个字符进行比较</td></tr></tbody></table><h3 id="string和数值之间的转换-9-5-5，P327"><a href="#string和数值之间的转换-9-5-5，P327" class="headerlink" title="string和数值之间的转换(9.5.5，P327)"></a>string和数值之间的转换(9.5.5，P327)</h3><p>string参数中第一个非空白符必须是符号(+或-)或数字。它可以以0x或0X开头来表示十六进制数。对那些将字符串转换为浮点值的函数，string参数也可以以小数点开头，并可有包含e或E来表示指数部分。对于那些将字符串转换为整型值的函数，根据基数不同，string参数可以包含字母字符，对应大于数字9的数</p><p>如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常。如果转换得到的数值无法用任何类型表示，则抛出一个out_of_range异常</p><table><thead><tr><th>string和数值之间的转换</th><th>含义</th></tr></thead><tbody><tr><td>to_string(val)</td><td>一组重载函数，返回数值val的string表示。val可以是任何算术类型。对每个浮点类型和int或更大的整型，都有相应版本的to_string。与往常一样，小整型会被提升。</td></tr><tr><td>stoi(s,p,b)</td><td>返回s的起始子串(表示整数内容)的数值，返回值类型分别是int,long,unsigned long,long long,</td></tr><tr><td>stol(s,p,b)</td><td>unsigned long long。b表示转换所用的基数，默认值是10。p是size_t指针，用来保存s中第一个</td></tr><tr><td>stoul(s,p,b)</td><td>非数值字符下标，p默认为0，即函数不保存下标。</td></tr><tr><td>stoll(s,p,b) </td></tr><tr><td>stoull(s,p,b) </td></tr><tr><td>stof(s,p)</td><td>返回s的起始子串(表示浮点数内容)的数值，返回值类型分别是float,double或long double。参数</td></tr><tr><td>stod(s,p)</td><td>p的作用于整数转换函数中一样</td></tr><tr><td>stold(s,p)</td></tr></tbody></table><h2 id="容器适配器（9-6，P329）"><a href="#容器适配器（9-6，P329）" class="headerlink" title="容器适配器（9.6，P329）"></a>容器适配器（9.6，P329）</h2><p>标准库定义了三个顺序容器适配器：<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，stack适配器接受一个顺序容器（除array或forward_list）。</p><p>所有容器适配器都支持的操作和类型：</p><table><thead><tr><th>容器适配器都支持的操作和类型</th><th>含义</th></tr></thead><tbody><tr><td>size_type</td><td>一种类型，足以保存当前类型的最大对象的大小</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>container_type</td><td>实现适配器的底层容器类型</td></tr><tr><td>A a;</td><td>创建一个名为a的空适配器</td></tr><tr><td>A a(c);</td><td>创建一个名为a的适配器，带有容器c的一个拷贝</td></tr><tr><td>关系运算符</td><td>每个适配器都支持所有关系运算符:==,!=,&lt;,&lt;=,&gt;,&gt;=，这些运算符返回底层容器的比较结果</td></tr><tr><td>a.empty()</td><td>若a包含任何元素，返回false，否则返回true</td></tr><tr><td>a.size()</td><td>返回a中元素数目</td></tr><tr><td>swap(a,b)</td><td>交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必须相同</td></tr><tr><td>a.swap(b)</td></tr></tbody></table><h3 id="栈适配器的其他操作"><a href="#栈适配器的其他操作" class="headerlink" title="栈适配器的其他操作"></a>栈适配器的其他操作</h3><table><thead><tr><th>栈适配器的其他操作</th><th>含义</th></tr></thead><tbody><tr><td>s.pop()</td><td>删除栈顶元素，但不返回该元素值</td></tr><tr><td>s.push(item)</td><td>创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，或者由args构造</td></tr><tr><td>s.emplace(args)</td></tr><tr><td>s.top()</td><td>返回栈顶元素，但不将元素弹出栈</td></tr></tbody></table><h3 id="queue和priority-queue的其他操作"><a href="#queue和priority-queue的其他操作" class="headerlink" title="queue和priority_queue的其他操作"></a><code>queue</code>和<code>priority_queue</code>的其他操作</h3><table><thead><tr><th><code>queue</code>和<code>priority_queue</code>的其他操作</th><th>含义</th></tr></thead><tbody><tr><td>q.pop()</td><td>返回queue的首元素或priority_queue的最高优先级元素，但不删除此元素</td></tr><tr><td>q.front()</td><td>返回首元素，但不删除此元素</td></tr><tr><td>q.back()</td><td>返回尾元素，但不删除此元素，只适用于queue</td></tr><tr><td>q.top()</td><td>返回优先级最高的元素，但不删除此元素，只适用于priority_queue</td></tr><tr><td>q.push(item)</td><td>在queue末尾或priority_queue中恰当的位置创建一个元素，其值为item，或者有args构造</td></tr><tr><td>q.emplace(args)</td></tr></tbody></table><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>适配器：adaptor<br>容器：container<br>迭代器范围：iterator range<br>首前迭代器： off-the-beginning iterator<br>尾后迭代器： off-the-end iterator<br>顺序容器： sequential container<br>左闭合区间： left-inclusive interval</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49800101" target="_blank" rel="external">C++primer第五版第九章学习笔记</a></li><li><a href="http://blog.csdn.net/libin1105/article/details/48676235" target="_blank" rel="external">《C++primer(第五版)》学习之路-第九章：顺序容器</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/18/CPP_09/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(八)IO类</title>
      <link>http://wangwlj.com/2018/01/17/CPP_08/</link>
      <guid>http://wangwlj.com/2018/01/17/CPP_08/</guid>
      <pubDate>Wed, 17 Jan 2018 05:18:49 GMT</pubDate>
      <description>
      
        &lt;p&gt;C++使用标准库类来处理面向流的输入和输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iostream处理控制台IO&lt;/li&gt;
&lt;li&gt;fstream处理命名文件IO&lt;/li&gt;
&lt;li&gt;stringstream完成内存string的IO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类fstream和stringstream都继承自iostream。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>C++使用标准库类来处理面向流的输入和输出：</p><ul><li>iostream处理控制台IO</li><li>fstream处理命名文件IO</li><li>stringstream完成内存string的IO</li></ul><p>类fstream和stringstream都继承自iostream。<br><a id="more"></a></p><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>头文件<code>iostream</code>包含所有<code>i/o</code>流所需的基本信息，并定义有四个标准<code>i/o</code>流对象：</p><ul><li>cin：标准输入流对象（与标准输入设备连接）</li><li>cout ：标准输出流（与标准输出设备连接）</li><li>cerr ：非缓冲的标准错误流（默认设备为显示器）</li><li>clog ：经缓冲的标准错误流（默认设备为打印机）</li></ul><p>IO对象没有拷贝或者赋值。</p><h3 id="条件状态-P8-1-1，P279"><a href="#条件状态-P8-1-1，P279" class="headerlink" title="条件状态(P8.1.1，P279)"></a>条件状态(P8.1.1，P279)</h3><p>IO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态(<code>condition state</code>)。</p><table><thead><tr><th style="text-align:center">条件状态</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">strm::iostate</td><td>由各个iostream类定义，用于定义条件状态</td></tr><tr><td style="text-align:center">strm::badbit</td><td>strm::iostate类型的值，用于指出被破坏的流</td></tr><tr><td style="text-align:center">strm::failbit</td><td>strm::iostate类型的值，用于指出失败的IO操作</td></tr><tr><td style="text-align:center">strm::eofbit</td><td>strm::iostate类型的值，用于指出流已经到达文件的结束符</td></tr><tr><td style="text-align:center">s.eof()</td><td>如果设置了流s的eofbit值，该函数返回true</td></tr><tr><td style="text-align:center">s.bad()</td><td>如果设置了流s的badbit值，该函数返回true</td></tr><tr><td style="text-align:center">s.fail()</td><td>如果设置了流s的failbit值，该函数返回true</td></tr><tr><td style="text-align:center">s.good()</td><td>如果流s处于有效状态，该函数返回true</td></tr><tr><td style="text-align:center">s.clear()</td><td>清空流s的所有状态，并设为true</td></tr><tr><td style="text-align:center">s.clear(flag)</td><td>给流s的某个条件状态位设置为true。flag，类型是strm::iostate</td></tr><tr><td style="text-align:center">s.setstate(flag)</td><td>给流s的添加指定条件。flag，类型是strm::iostate</td></tr><tr><td style="text-align:center">s.rdstate()</td><td>返回流s的当前条件，返回值类型是strm::iostate</td></tr></tbody></table><h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3><p><code>endl</code> 操纵符，用于输出一个换行符并刷新缓冲区。<br><code>flush</code>操纵符，用于刷新流，但不在输出中添加任何字符。<br><code>ends</code>操作符，这个操纵符在缓冲区中插入空字符<code>null</code>，然后刷新它。</p><blockquote><p>如果程序崩溃（异常终止），输出缓冲区不会刷新。</p></blockquote><h2 id="文件输入输出-8-2，P283"><a href="#文件输入输出-8-2，P283" class="headerlink" title="文件输入输出(8.2，P283)"></a>文件输入输出(8.2，P283)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>; <span class="comment">//构建一个ifstream并打开给定文件</span></div><div class="line">ofstream out; <span class="comment">//输出文件流，没有与任何文件关联</span></div><div class="line">out.open(iflie +<span class="string">".copy"</span>); <span class="comment">//打开指定的文件</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>(out)  <span class="comment">//检查open是否成功</span></div></pre></td></tr></table></figure><h3 id="文件模式-8-2-2，P286"><a href="#文件模式-8-2-2，P286" class="headerlink" title="文件模式(8.2.2，P286)"></a>文件模式(8.2.2，P286)</h3><p>文件模式有：<code>in</code>,  <code>out</code>,  <code>app</code>（append的缩写，追加模式，写操作前定位到文件末尾）,  <code>ate</code>,  <code>trunk</code>（截断文件）,  <code>binary</code>。</p><blockquote><p>保留<code>ofstream</code>打开的文件中已有数据的唯一方法：显式地指定<code>app</code>或<code>in</code>模式。</p></blockquote><h2 id="string流-8-3，P287"><a href="#string流-8-3，P287" class="headerlink" title="string流(8.3，P287)"></a>string流(8.3，P287)</h2><p>标准库定义了三种类型的字符串流：<br><code>istringstream</code>，由<code>istream</code>派生而来，提供读<code>string</code>的功能。<br><code>ostringstream</code>，由<code>ostream</code>派生而来，提供写<code>string</code>的功能。<br><code>stringstream</code>，由<code>iostream</code>派生而来，提供读写<code>string</code>的功能。</p><p>stringstream 特定的操作：</p><table><thead><tr><th>stringstream 特有的操作</th><th>含义</th></tr></thead><tbody><tr><td>sstream strm;</td><td>strm是一个未绑定的stringstream对象。sstream是头文件sstream中定义的一个类型</td></tr><tr><td>sstream strm(s);</td><td>strm是一个sstream对象，保存string s的一个拷贝。此构造函数是explict的。</td></tr><tr><td>strm.str()</td><td>返回strm所保存的string的拷贝</td></tr><tr><td>strm.str(s)</td><td>将string s拷贝到strm中。返回void</td></tr></tbody></table><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>继承： inheritance<br>条件状态： condition state<br>文件模式： file mode<br>文件流： file stream<br>字符串流： string stream</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49799679" target="_blank" rel="external">C++primer第五版第八章学习笔记</a></li><li><a href="http://blog.csdn.net/libin1105/article/details/48675765" target="_blank" rel="external">《C++primer(第五版)》学习之路-第八章：IO库</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/17/CPP_08/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
