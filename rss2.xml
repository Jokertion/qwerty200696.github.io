<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>王立杰的博客</title>
    <link>http://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Sat, 06 Jan 2018 08:58:29 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>C++ Primer学习笔记：(六)函数</title>
      <link>http://wangwlj.com/2018/01/06/CPP_06/</link>
      <guid>http://wangwlj.com/2018/01/06/CPP_06/</guid>
      <pubDate>Sat, 06 Jan 2018 08:55:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;第六章是和函数有关的知识，函数就是命名了的计算单元，对程序的结构化非常重要。&lt;br&gt;本章内容包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数的概念基础，包括函数的定义声明以及函数如何生成值和返回结果。&lt;/li&gt;
&lt;li&gt;函数重载,重载可以使函数接受不同种类或者数量不同的参数。&lt;/li&gt;
&lt;li&gt;函数指针，指向函数的一类特殊指针。&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>第六章是和函数有关的知识，函数就是命名了的计算单元，对程序的结构化非常重要。<br>本章内容包括：</p><ol><li>函数的概念基础，包括函数的定义声明以及函数如何生成值和返回结果。</li><li>函数重载,重载可以使函数接受不同种类或者数量不同的参数。</li><li>函数指针，指向函数的一类特殊指针。</li></ol><a id="more"></a><h2 id="函数基础（P182，6-1）"><a href="#函数基础（P182，6-1）" class="headerlink" title="函数基础（P182，6.1）"></a>函数基础（P182，6.1）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c)</span> <span class="comment">// 形参  </span></span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    func(<span class="number">1</span>, <span class="string">'a'</span>); <span class="comment">// 实参，与形参的类型、数量相匹配  </span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在调用函数时，第一步编译器会隐式的定义并初始化它的形参。比如一个函数<code>void f(int a);</code>，形参<code>int a</code>会被用户传入的实参初始化，此时形参是实参的一个副本。当有多个形参时，形参对应的实参的求值顺序是不一定的。实参的类型必须和形参的类型一致或能转化为形参声明的类型。</p><p>函数可以返回空值。返回函数指针和数组的特殊函数类型将在之后提到。</p><h3 id="局部静态对象（P185，6-1-1）"><a href="#局部静态对象（P185，6-1-1）" class="headerlink" title="局部静态对象（P185，6.1.1）"></a>局部静态对象（P185，6.1.1）</h3><p>一个对象的名字有作用域，对象本身也有生命周期。名字的作用域是我们可以通过名字访问对象的的区间。相对的，生命周期是指对象的产生和销毁的过程。</p><p>定义在所有函数外部的变量叫做<strong>全局变量</strong>，在整个程序的执行过程中一直存在。这种对象在程序启动时被创建，直到程序结束才会被销毁。</p><p>定义在函数体内的对象或者函数的形参都是<strong>局部变量</strong>。当函数执行路径经过该对象的定义语句时才会自动开始创建该对象，在对应的块结束时，这个对象会被销毁。</p><p>有时候我们有必要使局部变量的生命周期贯穿函数调用及之后的时间，所以我们可以将局部对象定义成static对象，定义语句形如<code>static int a=1;</code>，这样我们就可以在程序的别的地方（只要是在这个static对象的作用域内访问它）操作这个局部静态对象。</p><p>在一个程序中多次定义局部静态对象仍然是不被允许的。但是当一个函数里的对象被定义为局部静态对象，<font color="00A00A">多次调用这个函数并不会重置这个局部静态对象的值</font>。它自己会记得上一次被函数调用之后的值并继承这个值，不被第二次函数调用的变量定义初始化，这就是它静态的特性。</p><blockquote><p>局部静态变量若没有显式的初始化，则执行值初始化，内置类型的局部静态变量初始化为0。</p></blockquote><h3 id="函数声明（P186，6-1-2）"><a href="#函数声明（P186，6-1-2）" class="headerlink" title="函数声明（P186，6.1.2）"></a>函数声明（P186，6.1.2）</h3><p>函数声明要在使用这个函数之前。规范的形式是通常放在头文件里。函数声明可以不写形参的名字，只写形参的类型。</p><p>函数声明也称作函数原型(function prototype)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数的声明，必须要写在函数第一次被调用之前。  </span></div><div class="line"> <span class="comment">// 这部分的代码可放到头文件中，用的时候include进来就可以了(分离式编译)  </span></div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">int</span>)</span></span>;  </div><div class="line">  </div><div class="line"> <span class="comment">// 只要函数在被调用前声明了，那函数的定义可以写在声明之后的任意的位置，  </span></div><div class="line"> <span class="comment">// 如这里的func就可以在声明之后、main函数之前定义；  </span></div><div class="line"> <span class="comment">// 如果func没有在调用前声明，则必须要在被调用前定义(相当于把main函数后面的func那段代码放在这里实现)  </span></div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </div><div class="line">     <span class="keyword">return</span> func(<span class="string">'a'</span>, <span class="string">'1'</span>); <span class="comment">// 函数的调用，虽然func在main后定义，但是因为之前对func进行了声明，所以编译器知道这个函数的三要素是啥  </span></div><div class="line"> &#125;  </div><div class="line">  </div><div class="line"> <span class="comment">/* </span></div><div class="line"><span class="comment">  * 函数的定义的参数列表中各参数的类型、数量以及位置等需要和声明时的相匹配 </span></div><div class="line"><span class="comment">  */</span>  </div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> i)</span>  </span></div><div class="line"><span class="function"> </span>&#123;  </div><div class="line">     <span class="comment">// do something  </span></div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h3 id="传引用调用（P189，6-2-2）"><a href="#传引用调用（P189，6-2-2）" class="headerlink" title="传引用调用（P189，6.2.2）"></a>传引用调用（P189，6.2.2）</h3><p>当函数的形参是一个引用类型的时候，在使用函数时，这个函数的引用形参就绑定在了传入的实参上，这种函数调用就叫做<strong>传引用调用</strong>。在函数涉及到一些比较大的类型对象作为参数的时候，通常地我们使用传引用调用，这样就可以避免实参初始化形参带来的拷贝。在C语言里经常传入指针避免拷贝，在C++里，一般使用引用。</p><p>大多数情况下函数只能有一个返回值，因此在我们需要的时候，我们可以<strong>传一个额外的引用的参数在函数里面。这样函数体内就可以改变引用的值进而改变函数外部被引用连接的对象的值，从而返回多个数值</strong>。</p><h3 id="const形参和实参（-P190，6-2-2）"><a href="#const形参和实参（-P190，6-2-2）" class="headerlink" title="const形参和实参（ P190，6.2.2）"></a>const形参和实参（ P190，6.2.2）</h3><p>函数形参的类型也可以是带const的类型。</p><blockquote><p>顶层const作用于对象本身（离对象最近的const），实参初始化形参的时候会忽略掉顶层const。即<strong>形参的顶层const被忽略掉了</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>; <span class="comment">//fcn 能读取i，但不能向i写值。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">//错误，重复定义了fcn(int)。</span></div></pre></td></tr></table></figure><p>因为顶层const被忽略掉了，所以第二个fcn是错误的。</p><p>形参的初始化方式与变量的初始化方式一样。先回顾一下变量的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int i  = 42;</div><div class="line">const int *cp = &amp;i; //正确，但是cp不能改变i</div><div class="line">const int &amp;r = i;   //正确，但是r不能改变i</div><div class="line">const int &amp;r2 = 42; //正确，参见P55。</div><div class="line"></div><div class="line">int *p = cp;        //错误，p的类型和cp的类型不匹配</div><div class="line">int &amp;r3 = r;        //r3的类型和r的类型不匹配</div><div class="line">int &amp;4 = 42;        //错误，不能用字面值常量初始化一个非常量引用（参见P45）</div></pre></td></tr></table></figure></p><p>将同样的初始化规则应用到参数传递上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</div><div class="line"><span class="built_in">string</span>::size_type ctr = <span class="number">0</span>;</div><div class="line">reset(&amp;i);  <span class="comment">//调用形参类型是int *的函数</span></div><div class="line">reset(&amp;ci);  <span class="comment">//错误：不能用指向const int对象的指针初始化int *</span></div><div class="line"></div><div class="line">reset(i);  <span class="comment">//调用形参类型是int &amp;的函数</span></div><div class="line">reset(ci);  <span class="comment">//错误：不能把普通引用绑定到const对象ci上</span></div><div class="line">reset(<span class="number">42</span>);  <span class="comment">//错误：不能把普通引用绑定到字面值上</span></div><div class="line">reset(ctr);  <span class="comment">//错误：类型不匹配，ctr是无符号类型</span></div></pre></td></tr></table></figure></p><p><strong><font color="00A00A">我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。</font></strong></p><hr><p><strong>当我们接受函数的参数是为了完成比较或者判断等操作，而不需要改变参数的值，我们应该使用带const的参数来确保参数不会被更改</strong>。另外，const类型的形参能比普通类型的形参接受更多种类的参数。比如<code>void fn(const string&amp;);</code>这个函数，字符串字面值是<code>const char [ ]</code>类型，因此fn这个函数接受字符串字面值。但是如果声明成了<code>void fn(string&amp;);</code>，那么这个函数就没有办法接受字符串字面值（类似：<code>“string”</code>这样的值就是字符串字面值）。另外，带const的形参也接受带底层const的对象。</p><h3 id="传递数组作为参数（P193，6-2-4）"><a href="#传递数组作为参数（P193，6-2-4）" class="headerlink" title="传递数组作为参数（P193，6.2.4）"></a>传递数组作为参数（P193，6.2.4）</h3><p>又是我们想要向函数传递一个数组，但是数组是不可拷贝的，因此我们不能够通过值传递的方式传递一个数组到函数里，另外，如果数组的内容很大，传递数组的每个元素会带来不必要的拷贝。</p><p>以下的方法都基于或类似<strong><font color="00A00A">传递数组的指针</font></strong>。一维数组的指针指向数组的第一个元素。我们可以声明类似如下的形式传递一个数组指针到函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span> [])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span> [<span class="number">10</span>])</span></span>;</div></pre></td></tr></table></figure></p><p>这三者是等价的。传递之后形参的类型都是<code>int *</code>类型。</p><p>但是正因为数组的信息是以指针的形式传递给函数的，所以函数只得到一个地址，并不知道数组的大小，因此也就很容易访问到未定义的内存区域，因此在传递数组指针的基础上，我们可以通过手动标志数组大小等方法保证函数访问的内存是合法的不越界的。因此衍生出以下几种方法。</p><ol><li>第一种方法：<strong>在数组的末尾加标记。</strong>这种方法类似于C风格字符串，末尾会自动加’\0’来告诉大家这个字符串结束了。在数组末尾加特殊的标记来使数组不越界是简单易用的方法。</li><li>第二种方法：<strong>使用标准库规范中的begin和end函数。</strong>头文件<code>iterator</code>里有针对数组的begin和end函数，返回数组的首指针和尾后指针，指针指向数组元素的类型，这种方法也可以检测越界。</li><li>第三种方法：<strong>传递一个表示数组大小的参数。</strong>这样构建函数时就知道数组有多大了。如<code>print(j, end(j)-begin(j));</code></li><li>第四种方法：<strong>传递数组的引用。</strong>除了使用指针，我们还可以使用引用来得到一个完整数组的引用（别名）。声明格式类似下面这种：<code>void fx(int (&amp;arr)[10]);</code>，这里形参的名字是<code>arr</code>，<code>arr</code>前面的<code>&amp;</code>符号代表它是引用类型，引用了一个实参数组，这个数组必须只有10个元素（因为arr后面的[10]也是构成引用声明的必要部分。）</li></ol><blockquote><p>注意<code>void fx(int &amp;arr[10]);</code>这个去掉括号的写法是错误的，不存在引用的数组。</p></blockquote><hr><p><strong>传递多维数组</strong>：有时我们也需要向一个函数传递多维数组。多维数组的实质是数组的数组，一维数组的名是指向数组元素的指针，二维数组是指向数组元素的指针的指针。因此想要一个函数传递多维数组的形参声明如下：<code>void fx(int (*arr)[10]);</code>这时arr指向有10个int型元素的数组。当我们把arr+1，它就又指向了新的10个元素，因此arr相当于二维数组的数组名（两者都是指向包含的一维数组首元素的指针）。</p><p>也可以用<code>int arr[][10]</code>代替<code>int (*arr)[10]</code>，因为它们是等价的，都是二维数组名。用<code>int arr[][10]</code>这种方式定义形参时，要标出除了第一个维度以外的每个维度。（假设有一个数组<code>int b[2][3]</code>，就说明b有两列，每列3个元素，这里的2就是第一个维度。指向一维数组的指针不关心在这个维度上有几个元素，因此忽略）。</p><h3 id="main函数的命令行选项（P196，6-2-5）"><a href="#main函数的命令行选项（P196，6-2-5）" class="headerlink" title="main函数的命令行选项（P196，6.2.5）"></a>main函数的命令行选项（P196，6.2.5）</h3><p>最开始我们使用<code>UNIX</code>或<code>LINUX</code>系统编程时经常使用没有图形界面的编译器来把写好的代码编译成obj文件，这时候我们使用命令行来编译一份源代码文件，我们需要在终端里输入类似“<code>prog -d -o oflie data0</code>”的命令行来进行命令行控制。</p><p>现在我们看到的main函数一般都是<code>int main()</code>，括号里面什么也不写，我们也可以给main传递上述的那个命令行参数。形如：<code>int main(int argc,char *argv[])</code>。 main可以什么参数也不接受，也可以接受一个int和一个指向字符串的指针这两个参数。main没有第三种形式了。</p><p><code>int argc</code>是表示后面的argv一共指向几个字符串用的。<code>char *argv[]</code>里面的每一个字符串都顺序对应着命令行的参数。这些参数的字符串数组的第一个元素应该是可执行文件的名字或者空参数，最后一个字符串的值必须为<code>0</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对于命令”prog -d -o oflie data0“：</span></div><div class="line">argc = <span class="number">5</span>;</div><div class="line">argv[<span class="number">0</span>] = <span class="string">"prog"</span>;</div><div class="line">argv[<span class="number">1</span>] = <span class="string">"-d"</span>;</div><div class="line">argv[<span class="number">2</span>] = <span class="string">"-o"</span>;</div><div class="line">argv[<span class="number">3</span>] = <span class="string">"0file"</span>;</div><div class="line">argv[<span class="number">4</span>] = <span class="string">"data0"</span>;</div><div class="line">argv[<span class="number">5</span>] = <span class="number">0</span>;</div></pre></td></tr></table></figure></p><p>有关命令行的更多选项和argv参数的具体用法，可以参照对应的编译器文档。</p><h3 id="含有可变形参的函数（P197，6-2-6）"><a href="#含有可变形参的函数（P197，6-2-6）" class="headerlink" title="含有可变形参的函数（P197，6.2.6）"></a>含有可变形参的函数（P197，6.2.6）</h3><p>到现在我们定义的函数都是固定参数的，但是有时候我们无法预知向函数传递几个参数，又想使用一个函数接受这种变化，我们就可以使用C++指定的两种方法来定义含有可变形参的函数。</p><ul><li>第一种方法是当参数个数不一定，但是<strong>参数类型都相同</strong>时，我们可以<strong>传递一个initializer_list参数</strong>。这是标准库设施中的一部分。</li><li>第二种方法在当我们想传递不确定个数的<strong>不同类型的实参</strong>时要使用的技术：<strong>可变参数模板。</strong>这个16章才介绍。</li></ul><p>其实还有一种方法使函数接受多种形参，不过这种方法多用于和C语言旧代码对接时使用。<strong>这个方法用省略符来传递可变数量的形参</strong>。</p><h3 id="initializer-list（P197，6-2-6）"><a href="#initializer-list（P197，6-2-6）" class="headerlink" title="initializer_list（P197，6.2.6）"></a>initializer_list（P197，6.2.6）</h3><p>下面是关于定义可变形参函数的第一种方法——<code>initializer_list</code>参数的介绍：</p><p><code>initializer_list</code>类似<code>vector</code>，是一种容器，接纳一种同样类型的元素。initializer_list定义在同名的<code>&lt;initializer_list &gt;</code>中，我们可以把任意数量，同样类型的参数传递给这个容器使函数能够处理多个元素。</p><p>initializer_list支持的操作包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">initializer_list&lt;容器内元素的类型名&gt; 容器名 //默认初始化一个 initializer_list空容器</div><div class="line">initializer_list&lt;容器内元素的类型名&gt; 容器名&#123;元素值1，元素值2，元素值2...&#125; //大括号初始化</div><div class="line">initializer_list 容器名1（已被定义的initializer_list 容器的容器名2 ）//使容器1的内容和容器二一致，两个容器共享容器二里面的元素。不会形成拷贝，（也可以用initializer_list 容器名1=initializer_list 容器名2）</div><div class="line">initializer_list 容器名.size() //元素数量</div><div class="line">initializer_list 容器名.begin() //指向首元素的迭代器</div><div class="line">initializer_list 容器名.end() //尾后迭代器</div></pre></td></tr></table></figure></p><p>initializer_list里面元素的值永远是常量不能被更改，如果里面的元素是指针或引用，这个元素的属性将被自动加上底层const。<br>当我们声明一个接受 <code>initializer_list</code>类型的函数 <code>void fa(initializer_list&lt;int&gt; list1);</code>的时候，我们需要使用大括号来调用这个函数，形如fa({2,3,4});这样我们就向initializer_list传递了一个值的序列。<br>我们也可以声明<code>void fa(string b,initializer_list&lt;int&gt; list1);</code>这种函数。</p><h3 id="省略符形参（P199，6-2-6）"><a href="#省略符形参（P199，6-2-6）" class="headerlink" title="省略符形参（P199，6.2.6）"></a>省略符形参（P199，6.2.6）</h3><p>下面是关于定义可变形参函数的第三种方法——省略符形参的介绍。</p><p>省略符形参有下列两种形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">( parm_list , ...)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">( ... )</span></span>;</div></pre></td></tr></table></figure></p><p>第一种形式为特定数目的形参提供了声明。在这种情况下，当函数被调用时，对于与显示声明的形参相对应的实参进行类型检查，而对于与省略符对应的实参则暂停类型检查。在第一种形式中，形参声明后面的逗号是可选的。如果没有逗号，相应地，就变成了第二种情况。</p><blockquote><p>省略符形参应该仅仅用于C和C++通用的类型。<br>特别注意的是，大多数类型的对象在传递给省略符形参时都无法正确拷贝。<br>（感慨：所以说有什么用？还是用<code>intializer_list</code>吧？）</p></blockquote><p>你可以传递任意数量的参数给省略符形参。要注意省略号的优先级别最低，所以在函数解析时，只有当其它所有的函数都无法调用时，编译器才会考虑调用省略号函数的。<br>(optional)首先，如果要用省略符的方式处理不定参数的函数要包含头文件：<code>#include &lt;stdarg.h&gt;</code> （C语言中）或者<code>#include &lt;cstdarg&gt;</code>（C++中）。 然后利用va_list类型和va_start、va_arg、va_end 3个宏读取传递到函数中的参数值。<br>用省略符处理不定参数的函数基于C语言的方法，在C++中不建议使用。（使用了C语言标准库功能varargs）。</p><h2 id="返回值（P202，6-3）"><a href="#返回值（P202，6-3）" class="headerlink" title="返回值（P202，6.3）"></a>返回值（P202，6.3）</h2><p>在void返回值的语句最后会隐式地有<code>return;</code>语句，这时函数什么也不返回。</p><blockquote><p>不要返回局部对象的引用或指针。</p></blockquote><p>函数可以返回一个<strong>非常量引用</strong>作为左值。也可以返回一个花括号括起来的列表，来初始化vector等类型。</p><p>main函数的return语句可以不写，编译器会带为隐式补充。</p><blockquote><p>main 函数不能调用自己。</p></blockquote><h3 id="返回数组指针（P205，6-3-3）"><a href="#返回数组指针（P205，6-3-3）" class="headerlink" title="返回数组指针（P205，6.3.3）"></a>返回数组指针（P205，6.3.3）</h3><p>虽然我们不能直接让函数返回一个数组，但是我们可以设定函数返回一个指针的类型。函数会返回数组的指针。返回数组指针的函数定义语句如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">数组元素类型 （*函数名 （参数列表））[ 数组大小 ]</div></pre></td></tr></table></figure></p><p>当然，返回一个临时量或者局部对象的引用/指针都是错误的行为，如果你在函数里普通地定义了一个数组，那么这个数组的生命周期在函数返回时就结束了，会被内存中释放，因此可能需要用static使这个数组静态。静态对象只是延长了对象的生命周期，但是无论如何在函数内部定义的对象在外部都无法访问，除非使用返回指针的方法。</p><p>一条<code>double (*func(int a))[10]</code>这种语句来说明函数接受一个<code>int a</code>形参并且返回一个带有10个元素的double数组，这种语句在写法上比较乱，因此<code>C++11</code>提供了<strong><font color="00A00A">尾置返回</font></strong>的方法让程序员不必要非要迁就编译器的理解能力，上一条语句等价于这样：<code>auto func(int a)-&gt;double(*)[10]</code>我们使用<code>-&gt;</code>符号把返回值类型的描述放在了参数列表后面并和函数声明分离开让函数看起来不那么乱。</p><p>我们也可以使用<code>decltype</code>语句返回数组指针。<code>decltype</code>后面的括号可以括起一个现有的数组推导数组类型。我们再手动加<code>*</code>得到数组指针类型的返回值。在已有<code>int a[10];</code>的情况下，我们可以使用<code>decltype(a) *fn(int b)</code>这种形式定义一个返回指向数组的指针的返回值类型。</p><h2 id="函数重载（P207，6-4）"><a href="#函数重载（P207，6-4）" class="headerlink" title="函数重载（P207，6.4）"></a>函数重载（P207，6.4）</h2><p>我们可以定义一组功能类似，函数名一致，但是接受的参数类型或数量不同的函数。定义多个这种函数就叫做<strong>函数重载</strong>。函数重载可以提供给我们用一个函数名处理多种参数形式的情况。</p><p>定义重载函数要能重传入的参数里区别出实质不同的重载函数，如函数A的定义为<code>int fa(const int a);</code>和函数<code>B int fa(int b);</code>这两个函数函数名一样，形参类型不同，但仍然无法作为重载函数。因为我们传入一个int值时，fa不知道应该执行第一种还是第二种。所以<strong>只有参数顶层const属性不同的几个函数不是重载函数。</strong></p><blockquote><p>形参相同，但返回类型不同的函数也不能构成重载。</p></blockquote><p>当然，对于底层const，比如参数列表为<code>const int *a</code>的函数和参数列表为int a的函数能被看出不同，因为对于一个传入的const常量指针，这个实参只能初始化<code>const int *a</code>，不能被初始化<code>int a</code>。当同时有这两种形式的重载函数时，当传入一个非常量，IDE会优先选择为它匹配形参为<code>int a</code>版本的普通变量形参函数。</p><blockquote><p>形参是某种类型的引用或指针，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载。（此时的const是底层的）</p></blockquote><h3 id="const-cast和函数（P209，6-4）"><a href="#const-cast和函数（P209，6-4）" class="headerlink" title="const_cast和函数（P209，6.4）"></a>const_cast和函数（P209，6.4）</h3><p>这里主要介绍<code>const_cast</code>类型强制转换是如何在函数中被使用的。在第四章(4.11.3, P145)第一次接触<code>const_cast</code>的时候我们提到过这个常被用于函数里。这里我们就看看怎么使用。</p><p>之前说过，向函数传递参数时最好传递<code>const</code>型参数使其能够接受多种参数，这里我们可以在函数体内使用<code>const</code>再把参数变回普通的变量，这样就可以返回一个<code>非const</code>值了。</p><h3 id="重载和作用域（P210，6-4）"><a href="#重载和作用域（P210，6-4）" class="headerlink" title="重载和作用域（P210，6.4）"></a>重载和作用域（P210，6.4）</h3><p>声明变量时，变量的作用域就在块里，声明函数也一样，而且里层的作用域会隐藏外部的作用域。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">int a=0; //这里是a的外层作用域</div><div class="line">    &#123;</div><div class="line">    double a=1.2; //外边已经有a了，这里又声明了一个a，因此这个a的作用域覆盖了前面的int a；</div><div class="line">    cout&lt;&lt;a&lt;&lt;endl; //输出的会是1.2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>函数声明也一样，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    int fa(int b); //这里是函数fa的外层作用域</div><div class="line">    double fa(double b); //重载了函数fa使它能够接受double</div><div class="line">    &#123;</div><div class="line">        double fa(string &amp; c); //外边已经有fa了，这里又声明了一个fa，因此这个fa的作用域覆盖了前面的;</div><div class="line">        fa(2.3); //错误，原型为double fa(double b)的函数声明作用域被double fa(string &amp; c);覆盖，匹配不到函数</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>C++中，名字查找发生在类型检查之前。</p></blockquote><h2 id="特殊用途语言特性（6-5）"><a href="#特殊用途语言特性（6-5）" class="headerlink" title="特殊用途语言特性（6.5）"></a>特殊用途语言特性（6.5）</h2><h3 id="默认实参（P211，6-5-1）"><a href="#默认实参（P211，6-5-1）" class="headerlink" title="默认实参（P211，6.5.1）"></a>默认实参（P211，6.5.1）</h3><p>有时候一些函数我们每次调用它总会向它传递一些特殊的值。我们可以声明带有默认实参的函数。默认实参如果没有明确说明，默认实参会被自动当做函数的初始值传递进去。<br>形如<code>int fn(int a,int b=2,double c=3.3)</code>这样定义函数头的方式就给了b和c默认的实参，注意，<strong>当一个形参被给了默认实参，它后面的所有参数都要有默认实参才行。</strong></p><p>当我们想使用默认实参的时候，只要调用函数的时候使用这种对应的实参就行了，默认实参会用来填补缺少的尾部实参，上面的定义的函数如果这么调用：<code>fn(1,2);</code>，<code>double c</code>的值会被自动设为3.3。书写这种函数时要尽量保证要经常用到的默认实参放在参数列表的更后面一点，这样才合理。</p><p>可以只在函数声明里标注默认实参不在函数定义里这样写，结果仍然将是正确的。<code>void fn(int = 1, int = 2, int =3);</code>这种函数声明语句省略了形参的名字，不过也是可以的。</p><blockquote><p>通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p></blockquote><p>局部变量不能做默认实参，默认实参的定义在函数体之外。另外，<strong>默认实参是可以在名字的作用域内通过名字更改的</strong>。</p><h3 id="内联函数（P213，6-5-2）"><a href="#内联函数（P213，6-5-2）" class="headerlink" title="内联函数（P213，6.5.2）"></a>内联函数（P213，6.5.2）</h3><p>有时我们要频繁调用一个优化规模小，流程直接，频繁被调用的函数，定义函数时我们可以在返回值类型前面加上关键字<code>inline</code>使它成为内联函数，减少运行时的开销。</p><blockquote><p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p></blockquote><h3 id="constexpr函数（P214，6-5-2）"><a href="#constexpr函数（P214，6-5-2）" class="headerlink" title="constexpr函数（P214，6.5.2）"></a>constexpr函数（P214，6.5.2）</h3><p>这是一种能够被用在常量表达式的函数，但是函数的返回值类型和形参类型必须都是字面值。函数体中必须有且只有一条<code>return</code>语句，<code>constexpr</code>函数被隐式的指定为内连函数。const函数中也可以有类型别名，使用作用域声明等不执行操作的其他语句。这里没有赋值，没有构建对象。同时<code>constexpr</code>可以返回计算后的结果。如<code>constexpr int fn(int a){return a+22;}</code>，这条定义是正确的，前提是调用函数这个函数fn时，传入的实参是一个常量。比如<code>fn(3);</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> </span>&#123; <span class="keyword">return</span> new_sz() * cnt; &#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)]; <span class="comment">//正确，scale(2)是常量表达式</span></div><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line"><span class="keyword">int</span> a2[scale(i)]; <span class="comment">//错误，scale(i)不是常量表达式</span></div></pre></td></tr></table></figure></p><blockquote><p>内联函数和constexpr函数通常定义在头文件中。</p></blockquote><h3 id="调试帮助（P215，6-5-3）"><a href="#调试帮助（P215，6-5-3）" class="headerlink" title="调试帮助（P215，6.5.3）"></a>调试帮助（P215，6.5.3）</h3><p>程序员在写程序时可能涉及到一些调试中的代码，这些代码只在开发程序时使用，当即将发布程序的时候，要暂时屏蔽掉正在调试中的代码。C++提供了<code>assert</code>和<code>NDEBUG</code>两个预处理功能屏蔽测试代码。</p><h4 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h4><p>assert这个宏定义在<code>cassert</code>头文件中，assert使用一个表达式作为它的条件，形如<code>assert(expr);</code>首先对expr或者表达式求值，如果结果为真（非0），那么assert什么都不做。如果结果为假(表达式值为0)，那么assert输出信息并且终止程序的执行。</p><p>assert经常用于处理不能发生的条件，如果你写了一段代码，代码没测试越界，你就可以用assert，当它越界了我们就结束程序的执行。</p><h4 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h4><p><code>NDEBUG</code>宏定义可以影响assert的行为，这个默认是没被定义的。当我们宏定义了<code>NDEBUG</code>，就屏蔽掉了assert的功能。</p><p>可以使用<code>NDEBUG</code>编写自己的调试代码。</p><p>此外，IDE还提供了<code>__FILE__</code>(这里是两个英文下划线，这个存放文件名) 、<code>__func__</code>（这个存放所在的函数名) 、 <code>__LINE__</code>（这个存放所在的行数) 、<code>__TIME__</code>（这个存放调试的时间) 、 <code>__DATE__</code>（这个存放调试的日期) 这五种静态数组来提供错误信息。</p><h2 id="函数匹配（P217，6-6）"><a href="#函数匹配（P217，6-6）" class="headerlink" title="函数匹配（P217，6.6）"></a>函数匹配（P217，6.6）</h2><p>程序员定义重载函数之后就可以使用它们了，挑选到底使用哪个版本的函数是一个过程，这个过程叫做函数匹配。</p><ol><li>函数匹配的第一步是在调用时先找与与调用函数同名的函数名。且调用点在函数作用域内。这一步筛选出的函数叫做<strong>候选函数</strong>。</li><li>函数匹配的第二步是从候选函数中选择出能够被本次函数调用的实参传入的函数，函数名一致的前提下还要求函数的形参个数和实参一致，实参能够转化成（或者就是）形参规定的类型。这一步筛选出的函数叫做<strong>可行函数</strong>。</li><li><strong>寻找最佳匹配。</strong>当<code>有int fn(int a);</code>和<code>int fn(double a,double b=1.0)</code>时，我们调用函数fn形如<code>fn(3.4);</code>显然这两种函数都是可行函数，这是我们再寻找最佳的匹配，因为<code>fn(3.4);</code>对应<code>fn(double,double=1.0);</code>的话无需转化，因此是最佳匹配。当有多个最佳匹配的时候函数将停止调用。</li></ol><p>为了划分最佳匹配的各种情况，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示：</p><ol><li>精确匹配：<br>精确匹配可以包含以下情况：数组名转化成数组指针的匹配，函数类型转换成函数指针的匹配，实参类型与形参类型相同。另外，像实参添加顶层const或者忽略实参赋值给形参的顶层const也属于精确匹配。</li><li>通过指针的转换把非常量指针转换成常量指针。</li><li>通过类型提升实现的匹配。</li><li>通过算数类型转换或指针转换实现的匹配</li><li>通过类类型转换实现匹配（类类型转换还没有讲）</li></ol><p>要注意小整数字面值会被自动转换成int，而带小数点的字面值会被默认转换成doube。</p><h2 id="函数指针（P221，6-7）"><a href="#函数指针（P221，6-7）" class="headerlink" title="函数指针（P221，6.7）"></a>函数指针（P221，6.7）</h2><p>声明一条函数指针的语句如下: <code>int (*PtrOfFunc)(参数列表)</code>，其中<code>PtrOfFunc</code>就是<strong><font color="00A00A">指向函数的指针</font></strong>。我们可以把函数名赋值给定义的函数指针的名字。</p><blockquote><p><code>*PtrOfFunc</code>两端 的括号不能少。</p></blockquote><p>返回函数指针的形参定义为<code>double(*fn(int a)) (int d,char b);</code>这里声明的函数是fn，函数的形参是<code>int a</code>，返回值是函数指针类型的，返回的函数指针对应的函数的返回类型是double，参数是int d,char b。</p><p>和处理数组一样，我们也可以<strong>使用尾置</strong>返回来返回一个函数指针，尾置返回函数指针的声明是<code>auto fn(int a)-&gt;double (*)(int d,char b);</code>尾置返回适合用来返回复杂的类型比如数组，函数指针等等。</p><p>遇到<code>double(*fn(int a)) (int d,char b);</code>这种复杂的表达式，应该以定义的变量名为中心，从里往外一层层往外扩展。这个函数的定义语句里面，fn就是其中的变量名，看它右侧，有<code>（int a）</code>,这（<code>int a）</code>是一个形参列表。因此得出结论fn的本质是一个函数，再看左侧，<code>*</code>代表这个函数返回一个指针，这个指针的类型在更外层<code>（double (*) (int d,char b)）</code>型。</p><p>当然这种声明/定义容易让人心累，所以这种情况下使用<code>auto fn(int a)-&gt;double (*)(int d,char b)</code>是不错的选择。如果这样还是觉得太长了，可以使用typdef，USING等重命名语句加上decltype推导。比如<code>tpyedef double func (int d,char b);</code>这样的语句之后，func就是一个函数类型。</p><p>也可以使用<code>tpyedef decltype(fn) func2;</code>这条语句等价于上面的语句。<br>对于using语句，<code>using Func2 = double (int d,char b);</code>即可。<br>可见typedef和using的替换原则是不同的，在涉及到复杂类型的时候，类似数组，函数指针，tpyedef的替换名要和被替换的类型一起被声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>); <span class="comment">//F是函数类型，不是指针</span></div><div class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span> (*) (<span class="keyword">int</span> *, <span class="keyword">int</span>); <span class="comment">// PF是指针类型</span></div><div class="line"></div><div class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//正确，PF是指向函数的指针，f1返回指向函数的指针。</span></div><div class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//错误，F是函数类型，f1不能返回一个函数</span></div><div class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//正确，显式地指定返回类型是指向函数的指针。</span></div><div class="line"></div><div class="line"><span class="comment">// 当然也可以使用下面的形式直接声明f1</span></div><div class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span> *, <span class="keyword">int</span>);</div></pre></td></tr></table></figure><h2 id="术语表-P225"><a href="#术语表-P225" class="headerlink" title="术语表(P225)"></a>术语表(P225)</h2><p>1.函数 function<br>2.形参 parameter<br>3.调用运算符（一个动作） call operator<br>4.实参 argument<br>5.主调函数 calling function<br>6.被调函数 called function<br>7.生命周期 lifetime<br>8.局部变量 local variable<br>9.自动对象 automatic object<br>10.局部静态对象 local static object<br>11.函数原型 function prototype<br>12.分离式编译 separate compilation<br>13.可执行文件 executable file<br>14.引用传递 passed by reference<br>15.传引用调用 called by reference<br>16.值传递 passed by value<br>17.传值调用 called by value<br>18.重载 overloaded<br>19.函数匹配 function matching<br>20.重载确定 overloaded resolution<br>21.最佳匹配 best match<br>22.二义性调用 ambiguous call<br>23.默认实参 default argument<br>24.预处理宏 preprocessor marco<br>25.候选函数 candidate function<br>26.可行函数 viable function<br>27.递归循环 recursion loop<br>28.递归函数 recursive function<br>29.尾置返回类型 trailing return type</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>C++ Primer 中文版 第5版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49760521" target="_blank" rel="external">C++primer第五版第六章学习笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/23536587" target="_blank" rel="external">C++Primer第5版学习笔记（六）</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/06/CPP_06/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(四/五)表达式和语句</title>
      <link>http://wangwlj.com/2018/01/05/CPP_04_05/</link>
      <guid>http://wangwlj.com/2018/01/05/CPP_04_05/</guid>
      <pubDate>Fri, 05 Jan 2018 07:51:49 GMT</pubDate>
      <description>
      
        &lt;p&gt;第四章是和表达式有关的知识，表达式是C++的基础设施，本章由三部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表达式概念基础，包括表达式的基本概念，左值和右值的概念，优先级结合律，求值顺序。&lt;/li&gt;
&lt;li&gt;各种运算符,主要包括算数\关系\逻辑\赋值\递增递减\成员访问\条件\位运算\sizeof\逗号运算符 这10种运算符。&lt;/li&gt;
&lt;li&gt;类型转换，包括隐式和显式两种转换的规则。&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>第四章是和表达式有关的知识，表达式是C++的基础设施，本章由三部分组成：</p><ol><li>表达式概念基础，包括表达式的基本概念，左值和右值的概念，优先级结合律，求值顺序。</li><li>各种运算符,主要包括算数\关系\逻辑\赋值\递增递减\成员访问\条件\位运算\sizeof\逗号运算符 这10种运算符。</li><li>类型转换，包括隐式和显式两种转换的规则。</li></ol><a id="more"></a><h2 id="表达式基础"><a href="#表达式基础" class="headerlink" title="表达式基础"></a>表达式基础</h2><h3 id="表达式的基本概念-P120，4-1-1"><a href="#表达式的基本概念-P120，4-1-1" class="headerlink" title="表达式的基本概念(P120，4.1.1)"></a>表达式的基本概念(P120，4.1.1)</h3><p>表达式由一个或者多个运算对象组成，多个对象组成表达式时，对象之间用运算符连接形成复杂表达式。</p><p>运算符中，需要两个对象和运算符连接形成表达式的这种运算符叫做二元（双目，二目）运算符。</p><p>分析一个表达式，必须先了解运算对象的含义、运算符的优先级(precedence)、结合律(associativity)和运算符的求值顺序(order of evaluation)。</p><ol><li>对于含有子表达式的复杂表达式，应该按照求值顺序，看看应该先求哪一个子表达式的值。</li><li>对于不那么复杂的子表达式，应该按照优先级，查看表达式中的每个操作数（对象）应该先跟那一个运算符在一起运算。</li><li>如果有优先级相同的运算符同时在同一个运算对象左右，应该按照结合律选定结合顺序是从右向左还是从左向右计算表达式的值。</li></ol><h3 id="左值和右值-P121，4-1-1"><a href="#左值和右值-P121，4-1-1" class="headerlink" title="左值和右值(P121，4.1.1)"></a>左值和右值(P121，4.1.1)</h3><p><strong>起源</strong>：左值和右值原来是C语言中的概念，特指赋值运算符左右两段的表达式。C语言中，能放在赋值运算符左侧被赋值的对象就是左值，反过来在赋值运算符右侧的对象就是右值。C++中的这两个概念的词义发生了改变。</p><p><strong>概述</strong>：可以暂时概述一下C++中左值和右值的概念。从性质上来看，当一个对象做右值时，我们使用的是这个对象的内容（值）；当一个对象做左值时，我们使用的是它对象的身份（在内存中的位置）。</p><p><strong>应用</strong>：表达式中有的位置需要的是左值，有的位置需要的是右值。表达式的值本身也有左右的分别。<br><strong>赋值运算符</strong>中左侧操作数和表达式结果都是左值。<br><strong>取地址符</strong>的操作对象是左值，得到的是右值。<br><strong>解引用、下标运算符</strong>的求值结果是左值。<br><strong>decltype</strong>作用于表达式时，如果表达式的结果是一个左值，decltype会返回一个引用类型。</p><h3 id="优先级和结合律（P122，4-1-2）"><a href="#优先级和结合律（P122，4-1-2）" class="headerlink" title="优先级和结合律（P122，4.1.2）"></a>优先级和结合律（P122，4.1.2）</h3><p>1.<font color="AA0AA0">优先级</font> 复杂表达式中一个运算对象连接多个不同运算符时，哪个运算符优先级高，就先计算哪个运算符和对象作用后的值。</p><p>2.<font color="AA0AA0">结合律</font> 复杂表达式中一个运算对象连接多个优先级相同的运算符时，根据这一优先级对应的结合律，按从右至左或者从左至右的顺序计算表达式的值。</p><p>如<code>3+2*4-7；</code>这个表达式是一个复杂表达式，因为表达式里<code>*</code>号优先级比较高，所以先计算<code>2*4</code>，得到<code>3+8-7</code>；得到的新表达式更简洁了，只剩下+-两个符号，这两个符号优先级相同，因此查看这个优先级对应的结合律可知这一级别的符号满足左结合性。因此从左向右计算，得到<code>11-7</code>；进一步得到结果<code>4</code>。</p><blockquote><p>括号无视优先级和结合律，可以考虑多使用括号。</p></blockquote><h3 id="求值顺序（P123，4-1-3）"><a href="#求值顺序（P123，4-1-3）" class="headerlink" title="求值顺序（P123，4.1.3）"></a>求值顺序（P123，4.1.3）</h3><p>一个表达式里如果运算对象都是函数返回的，都需要计算求值才知道对象的状态，函数调用符号优先级一致，中间隔着几个优先级低的其他符号连接操作对象，比如<code>int a=f()+g();</code>，这时候是函数f()先被调用还是g()先被调用呢？<font color="AA0AA0">答案是未定义。</font>C++语法没有规定这种情况应该谁先谁后。</p><p>就像下面的表达式<code>++i+i++</code>这个表达式中，优先级最高的表达式<code>++i</code>和<code>i++</code>中间隔着优先级低的运算符<code>+</code>，关于<code>++i</code>先计算还是<code>i++</code>先计算，这是<strong>未定义</strong>的，而因为这个表达式先计算<code>++i</code>或先计算<code>i++</code>的结果不同，<strong>所以这条表达式是错误的</strong>。<font color="AA0AA0">一个变量如果在同一个表达式里被多次改变，这个表达式的求值顺序又不一定，就会出现二义性。应该避免这样的写法。</font></p><p>目前只有四种运算符明确规定了求值顺序。</p><ol><li>逻辑运算符<code>&amp;&amp;</code>和<code>||</code>(P126)：这两个运算符先计算左边操作数的值。</li><li>条件运算符<code>?:</code>(P137)：条件运算符先计算？前的表达式，并求值，之后对视情况对：左右侧的表达式求值。</li><li>逗号运算符<code>，</code>(P140) ：这个运算符的求值顺序是从左至右。</li></ol><blockquote><p>处理复合表达式的两点建议：<br>①拿不准的时候最好用括号来强制让表达式的组合关系复合程序逻辑的要求；<br>②如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。例外：当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。</p></blockquote><h3 id="关于运算符，左值和右值的归纳"><a href="#关于运算符，左值和右值的归纳" class="headerlink" title="关于运算符，左值和右值的归纳"></a>关于运算符，左值和右值的归纳</h3><p>本章各种运算符形成的表达式所返回的值的属性和运算符需要的操作数的属性如下：</p><ul><li>算数/逻辑/位运算符： 操作对象和结果都是右值 </li><li>赋值运算符：左侧的操作对象必须是可以修改的左值，右侧的操作对象是右值，返回一个左值。 </li><li>递增/递减运算符： 前置版本的++/–返回左值，后置版本的++/–返回右值。操作对象都必须是左值。</li><li>箭头成员访问运算符： 作用于指针，表达式结果是一个左值。</li><li>点成员访问运算符: 这个成员所属的对象是左值，结果就是左值；这个成员所属的对象是右值，结果就是右值。 </li><li>条件运算符： 条件运算符的三个表达式都是左值或者都能转化成左值类型时，结果为左值；否则是右值。</li></ul><h2 id="算术运算符-P124-4-2"><a href="#算术运算符-P124-4-2" class="headerlink" title="算术运算符(P124, 4.2)"></a>算术运算符(P124, 4.2)</h2><h3 id="除法和取模的结果-（P125，4-2）"><a href="#除法和取模的结果-（P125，4-2）" class="headerlink" title="除法和取模的结果 （P125，4.2）"></a>除法和取模的结果 （P125，4.2）</h3><p>两个非浮点型变量/字面值相除，结果还是原来的类型，不会有原来操作数是整数，运算之后结果是小数的情况。<br>C++11中， 对于<strong>除运算符，结果向零取整（直接切掉小数部分，得到的数就是结果）</strong>。对于<strong>取模运算符，结果的符号和被除数的符号一致</strong>。（之前的语法标准里除法的结果可以选择是否向零取整，求模（模就是余数）运算可选符号）</p><blockquote><p>(-m)/n = -(m/n); m/(-n) = -(m/n);<br>m%(-n) = m%n; (-m)%n = -(m%n);</p></blockquote><h2 id="成员访问运算符-P133-4-6"><a href="#成员访问运算符-P133-4-6" class="headerlink" title="成员访问运算符(P133, 4.6)"></a>成员访问运算符(P133, 4.6)</h2><p>点运算符和箭头运算符都可以获取类对象的一个成员，<code>ptr-&gt;mem</code> 等价于 <code>(*ptr).mem</code>。</p><p>解引用运算符的优先级低于点运算符，所以<code>(*ptr).mem</code>中的括号不能省略，否则出错。</p><h2 id="条件运算符-P134-4-7"><a href="#条件运算符-P134-4-7" class="headerlink" title="条件运算符(P134, 4.7)"></a>条件运算符(P134, 4.7)</h2><p>条件运算符的格式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cond?expr1:expr2</div></pre></td></tr></table></figure></p><p>条件运算符允许嵌套。</p><h2 id="位运算符（P136，4-8）"><a href="#位运算符（P136，4-8）" class="headerlink" title="位运算符（P136，4.8）"></a>位运算符（P136，4.8）</h2><p><code>bitset</code>的标准库类型可以表示任意大小的二进制位集合。</p><blockquote><p>关于符号位没有明确的规定，因此强烈建议仅将位运算符用于处理无符号类型。</p></blockquote><p>左移运算符移动二进制数后会在右侧插入零，右移运算符在处理有符号类型的操作数（尤其是带负号的）时具体行为由环境决定。</p><table><thead><tr><th style="text-align:center">运算符</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">～</td><td>位求反</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td>左移</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td>右移</td></tr><tr><td style="text-align:center">&amp;</td><td>位与</td></tr><tr><td style="text-align:center">^</td><td>位异或</td></tr><tr><td style="text-align:center">&#124;</td><td>位或</td></tr></tbody></table><blockquote><p>【写博客相关】表格中竖号的打法：<code>&amp;#124;</code>，或者中文格式的<code>丨</code>（输入法输入“shu”查找）</p></blockquote><p>移位运算符（也叫IO运算符）满足左结合律。</p><h2 id="sizeof运算符（P139，4-9）"><a href="#sizeof运算符（P139，4-9）" class="headerlink" title="sizeof运算符（P139，4.9）"></a>sizeof运算符（P139，4.9）</h2><p>sizeof运算符有两种用法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sizeof</span>(type)</div><div class="line"><span class="keyword">sizeof</span> expr</div></pre></td></tr></table></figure></p><p>第一种是sizeof后面直接加一条表达式语句；第二种形如<code>sizeof (类型名)；</code>第二种形式后会得到该类对象所占空间的大小。<br>第一种形式中，如果表达式是指针类型，sizeof运算符会返回指针本身的大小。当有一个类名叫data，类中有一个成员叫做student时，可以使用作用域标识符和sizeof联动，使用<code>sizeof(data::student);</code>就可以计算出student占字节数。</p><h3 id="隐式类型转换（P141，4-11）"><a href="#隐式类型转换（P141，4-11）" class="headerlink" title="隐式类型转换（P141，4.11）"></a>隐式类型转换（P141，4.11）</h3><p>概述：在C++中，一些类型可以按照一定规则互相转换，很多时候语境中需要使用两个或多个相同的类型才能继续运算。因此这时一种类型的值会被自动转换成另一个类型的值。这个过程就是隐式转换，其中算术隐式转换较为常见。</p><p>主要的隐式转换发生的情况：</p><ol><li>大多数表达式中，比int小的类型会被提升为int型。</li><li>在条件中，非布尔值要转化成布尔值。</li><li>在初始化和赋值语句中，赋值符号的右侧对象的类型转换成左侧对象的类型进行运算。</li><li>算术/关系运算中对象有有多种类型的，转化成同一类型。</li><li>形参转化为实参的类型（第六章）。</li><li>数组名会被转换为指针。</li><li>0，nullptr会转为任何类型的指针。任何类型的指针都可以转化为（const）void *类型。</li></ol><p>算数转换时发生隐式转换的补充：<br>在算术运算符的作用下，不同的操作数要转换成同一个类型才能够进行计算。以<code>i+a；</code>这个表达式举例，了解算术转换的方式。</p><ol><li>首先，当i和a的类型占字节比int小，如<code>char、short</code>，把他们转换为int型。如果他们原来类型的最大值在当前系统里大于int型最大值，则转化成<code>unsigned int</code>型。</li><li>之后，如果i和a的类型相同，结束算数隐式转换，若i和a的类型不同，把占字节少的类型的对象转成占字节多的类型的对象。</li><li>如果占字节多的带符号类型的最大值小于占字节少的带转换对象的最大值，带符号类型将被转换为无符号类型。</li></ol><h3 id="显式转换（P144，4-11-3）"><a href="#显式转换（P144，4-11-3）" class="headerlink" title="显式转换（P144，4.11.3）"></a>显式转换（P144，4.11.3）</h3><p>显式转换就是强制类型转换(cast)。</p><p>一个命名的强制类型转换具有以下形式：<code>cast-name&lt;要转换成的类型&gt; （被转换的值）；</code>其中，cast-name是四种强制类型转换：<code>static_cast、dynamic_cast、const_cast</code>和<code>reinterpret_cast</code>之中的一种。</p><ul><li><code>static_cast</code>用于常见的强制类型转换。只要两个类型有关联，比如浮点数类型和整数类型，整数类型和布尔值类型，布尔值类型和指针类型，就可以使用static_cast。只是不能转换常量const到变量。</li><li><code>const_cast</code>用于去掉（或者加上）对象的底层const，要转换的类型和转换的类型都必须是指针或者引用类型。常用于将在第六章介绍的函数重载。当然，这个重载只能针对指针或者引用类型。</li><li><code>reinterpret_cast</code>依赖机器，是强行改变一个类型到另外一个不相干的类型。</li><li><code>dynamic_cast</code>支持运行时类型识别，在19章(P730)将会提到。</li></ul><blockquote><p>建议：避免强制类型转换。</p></blockquote><h2 id="运算符优先级列表的规律（P147-4-12）"><a href="#运算符优先级列表的规律（P147-4-12）" class="headerlink" title="运算符优先级列表的规律（P147,4.12）"></a>运算符优先级列表的规律（P147,4.12）</h2><p>优先级和结合性是第四章的重要内容，因此第四章之后给出了完整的优先级和结合性的参考表。这里是有一定的规律的。</p><ol><li>首先优先级最高的运算符都有这样的属性：单独拿出这个运算符左面的操作数和右面的操作数都没有意义。即运算符本身是连接两个名字组合一个概念的连接器。比如优先级最高的运算符::（作用域运算符），优先级比较高的点运算符（成员选择）下标运算符[]。</li><li>比连接不同名字形成概念的这种运算符稍微低一级别的就是计算对象本身的运算符，比如++，–，类型转换，位求反，逻辑非，解引用，取地址，求类型占的字节数这些运算符大多都是单目元素符，他们的运算目的一般是根据操作数本身的属性进行计算或者改变操作数本身。</li><li>算术运算符。</li><li>逻辑运算符。</li><li>条件运算符。</li><li>赋值运算符 。</li><li>复合赋值，抛出异常，逗号运算符等。</li></ol><h2 id="术语表-P149"><a href="#术语表-P149" class="headerlink" title="术语表(P149)"></a>术语表(P149)</h2><p>1.运算对象 operand<br>2.结果 result<br>3.一元运算符 unary operator<br>4.二元运算符 binary operator<br>5.优先级 precedence<br>6.结合律 associativity<br>7.求值顺序 order of evaluation<br>8.提升 promoted<br>9.重载运算符 overloaded operator<br>10.右值 rvalue<br>11.左值 lvalue<br>12.复合表达式 compound expression<br>13.短路求值 short-circuit evaluation<br>14.高位 high order position<br>15.逗号运算符 comma operator<br>16.相互转换 conversion<br>17.隐式转换 implicit conversion<br>18.算术转换 arithmetic conversion<br>19.整型提升 intergral promotion<br>20.运算对象 operand</p><h2 id="语句简介"><a href="#语句简介" class="headerlink" title="语句简介"></a>语句简介</h2><p>第五章是和语句有关的知识，语句也是C++的重要组分，本章由三部分组成：</p><ol><li>语句的概念，包括简单语句和语句作用域的概念。</li><li>条件/循环/跳转语句,条件语句主要包括if/else语句、switc语句和？：表达式条件语句；循环语句则是for语句和while语句；跳转语句包括continue、break和goto语句。</li><li>try/throw和异常处理，包括异常处理的使用方法。</li></ol><h2 id="语句作用域（P155，5-2）"><a href="#语句作用域（P155，5-2）" class="headerlink" title="语句作用域（P155，5.2）"></a>语句作用域（P155，5.2）</h2><p>用花括号括起来的块就是作用域的标志。在作用域中定义的对象只在作用域中起作用。块之外是没法访问和控制块内部的变量的。</p><p>尤其是在switch语句中，switch的执行过程可能跨过一些标签，当标签里声明并定义了一个对象，这个对象的作用域就延伸到了所有case标签里，如果case 1定义了int a；switch执行了case2，这时这个我们不想执行的语句却产生了自己的作用域，这显然是不行的。因此可以在case标签后使用大括号形成块，这样就不会出现作用域的问题。</p><p>goto也一样不能向前（代码的后几行）跳过对象的定义。不允许跨过变量的定义到达变量的作用域内。但是goto语句可以向后（代码的前几行）跳过定义。</p><blockquote><p>不要在程序中使用goto语句，它会使得程序既难理解又难修改。</p></blockquote><h2 id="try语句块和异常处理（P172，5-6）"><a href="#try语句块和异常处理（P172，5-6）" class="headerlink" title="try语句块和异常处理（P172，5.6）"></a>try语句块和异常处理（P172，5.6）</h2><p>可以用try\throw和catch联动进行异常处理，形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">&#123;待检测块&#125; <span class="comment">//待检测块里面包括throw语句来抛出异常</span></div><div class="line"><span class="keyword">catch</span> (异常类型 异常对象的对象名)</div><div class="line">&#123;异常处理语句 &#125;</div><div class="line"><span class="keyword">catch</span> （同上，可以写很多<span class="keyword">catch</span>）</div><div class="line">&#123;另一组异常处理语句&#125;</div></pre></td></tr></table></figure></p><p>throw抛出异常和catch处理异常的头文件都在<code>stdexcept</code>里定义。抛出异常的语句形如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> 异常类型（<span class="string">"异常文本"</span>）；</div></pre></td></tr></table></figure></p><p>异常类型一般只支持赋值，初始化，调用成员函数.what之类的几种操作。</p><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>1.控制流 flow-of-control<br>2.表达式语句 expression statement<br>3.空语句 null statement<br>4.复合语句 compound statement<br>5.悬垂else dangling else<br>6.case标签 case label<br>7.引发（异常） raise<br>8.catch子句 catch clause<br>9.异常处理代码 exception handler<br>10.异常安全（这不是特别安全的意思，而是在异常情况下也能保证程序执行预期的正确行为） exception safe</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>C++ Primer 中文版 第5版</li><li><a href="https://zhuanlan.zhihu.com/p/23535827" target="_blank" rel="external">C++Primer第5版学习笔记（四、五）</a></li><li><a href="https://www.zhihu.com/question/37542455" target="_blank" rel="external">用Markdown写Hexo博客时如何转义竖杠 | ？</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/05/CPP_04_05/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(三)字符串、向量和数组</title>
      <link>http://wangwlj.com/2018/01/04/CPP_03/</link>
      <guid>http://wangwlj.com/2018/01/04/CPP_03/</guid>
      <pubDate>Thu, 04 Jan 2018 13:36:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;第三章主要讲这么五个概念：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;using声明&lt;/strong&gt;，我知道挺多同学写代码练手都要在源文件前几句直接加using namespace std;然而using语句并不是什么情况都这么使用的，稍后我们将会看到详细的用法。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;标准库类型string&lt;/strong&gt;,和C的字符数组有区别的string，到底是怎么个构造，这章将会讲述。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;标准库类型vector&lt;/strong&gt;，vector和数组区别很大，这里将会提到，并引入一个“容器”的重要概念。&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;迭代器&lt;/strong&gt;，迭代器用来代替下标这种传统方式访问容器或一些支持迭代器的类型。&lt;/p&gt;
&lt;p&gt;5.&lt;strong&gt;数组和多维数组&lt;/strong&gt;，经典概念。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>第三章主要讲这么五个概念：</p><p>1.<strong>using声明</strong>，我知道挺多同学写代码练手都要在源文件前几句直接加using namespace std;然而using语句并不是什么情况都这么使用的，稍后我们将会看到详细的用法。</p><p>2.<strong>标准库类型string</strong>,和C的字符数组有区别的string，到底是怎么个构造，这章将会讲述。</p><p>3.<strong>标准库类型vector</strong>，vector和数组区别很大，这里将会提到，并引入一个“容器”的重要概念。</p><p>4.<strong>迭代器</strong>，迭代器用来代替下标这种传统方式访问容器或一些支持迭代器的类型。</p><p>5.<strong>数组和多维数组</strong>，经典概念。</p><a id="more"></a><h2 id="命名空间的using声明-P75-3-1"><a href="#命名空间的using声明-P75-3-1" class="headerlink" title="命名空间的using声明(P75,3.1)"></a>命名空间的using声明(P75,3.1)</h2><p>尽管我们可以在各种文件里都使用<code>using namespace std;</code>或者<code>using std::endl;</code>这种语句，但是，在头文件包含命名空间可能产生各种意外。因此，头文件不应包含using声明。</p><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>本节介绍最常用的操作，<em>9.5</em>节将介绍另外的。</p><h3 id="定义和初始化string对象-P76-3-2-1"><a href="#定义和初始化string对象-P76-3-2-1" class="headerlink" title="定义和初始化string对象(P76,3.2.1)"></a>定义和初始化string对象(P76,3.2.1)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div></pre></td></tr></table></figure><p>以下几种初始化语句被string支持：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s1;<span class="comment">//创建了一个空的字符串，对象名为s1，类型为string类型。</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//是s2的值与s1的值相等。</span></div><div class="line"><span class="built_in">string</span> s2=s1;<span class="comment">//同上一句，拷贝初始化。</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;<span class="comment">//直接用字符串字面值初始化string类型的对象。</span></div><div class="line"><span class="built_in">string</span> s3=<span class="string">"value"</span>;<span class="comment">//字符串字面值转化为string类型变量并赋值给string。</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//直接初始化string，操作后s4拥有10个字符，每个字符的值都是'c'。</span></div></pre></td></tr></table></figure><p>最后，其实<code>string s5={&quot;value&quot;}</code>和<code>string s3=&quot;value&quot;</code>一样，也是合法的。不过<strong>大括号初始化是严格检测匹配的</strong>，比如<code>int a={3.5};</code>就是错误的。</p><h3 id="string支持的操作-P77-3-2-2"><a href="#string支持的操作-P77-3-2-2" class="headerlink" title="string支持的操作(P77,3.2.2)"></a>string支持的操作(P77,3.2.2)</h3><h4 id="1-输入流中获取字符串"><a href="#1-输入流中获取字符串" class="headerlink" title="1.输入流中获取字符串"></a>1.输入流中获取字符串</h4><p>首先要强调是<code>cin&gt;&gt;string</code>的操作，这种操作就是从输入流中读字符串，值得注意的是这个过程会忽略掉开头输入的各种空白（我们说空白时是在说 <font color="00aa00"> <strong>空格，换行符，制表符</strong></font>）,读取输入流直到遇到字符后的第一个空白为止。</p><p>另一种<code>getline（cin,string）;</code>的操作(P78) 则可以读一行，也就是读入输入流的数据（包括空格，制表符），直到遇到<font color="00aa00"><strong>换行符</strong></font>为止，这里输入流中的换行符本身已经被读过了，但是字符串里不保存这个换行符。下次再从输入流里读什么数据至少也要从这个换行符后面对输入流进行操作了。</p><h4 id="2-string-type-size-P79"><a href="#2-string-type-size-P79" class="headerlink" title="2.string::type_size (P79)"></a>2.string::type_size (P79)</h4><p>为了更抽象，脱离机器特性，调用每个string对象的<strong>size成员函数</strong>，返回值都是一个<strong><code>string::type_size</code></strong>类型，这个类型拥有无符号整形数的一些性质。在string对下标的支持中，[ ]中的数字也会被转换为<code>string::type_size</code>类型。这里要强调的是<code>string::type_size</code>是一个<font color="00aa00"><strong>无符号类型</strong></font>。使用这个类型和int型这种有符号的类型一起进行计算可能出现一些错误。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> len = line.size(); <span class="comment">//len的类型是string::size_type</span></div></pre></td></tr></table></figure></p><blockquote><p>如果一个表达式中已经有了<code>size()</code>函数，就不要再使用<code>int</code>了，这样可以避免混用<code>int</code>和<code>unsigned</code>可能带来的问题。</p></blockquote><h4 id="3-string对象与字符串字面值相加-P80"><a href="#3-string对象与字符串字面值相加-P80" class="headerlink" title="3.string对象与字符串字面值相加 (P80)"></a>3.string对象与字符串字面值相加 (P80)</h4><p>字符串字面值是字符数组类型，字符串字面值和string类型的对象在一起计算时会被自动转换为string类型。</p><h4 id="4-其他支持的操作"><a href="#4-其他支持的操作" class="headerlink" title="4.其他支持的操作"></a>4.其他支持的操作</h4><p>包括下标运算符[ ]、重载的+、==、！=、&lt;、&gt;、&lt;=、&gt;=。</p><h3 id="处理每个字符的头文件cctype（P82-3-2-3）"><a href="#处理每个字符的头文件cctype（P82-3-2-3）" class="headerlink" title="处理每个字符的头文件cctype（P82, 3.2.3）"></a>处理每个字符的头文件cctype（P82, 3.2.3）</h3><p>我们可以通过引用头文件<code>&lt;cctype&gt;</code>的形式处理每一个字符。这个头文件包含很多方便处理字符的函数。列举如下：</p><ul><li>isalnum(c); //当c是字母或者数字时为真 </li><li>isalpha(c); //当c是字母时为真</li><li>iscntrl(c); //当c是控制字符时为真</li><li>isdigit(c); //当c是数字时为真</li><li>isgraph(c); //当c不是空格但是可打印时为真</li><li>islower(c); //当c是小写字母为真</li><li>isprint(c); //当c可打印时为真 </li><li>isupper(c); //当c是大写字符时为真</li><li>isxdigit(c); //当c是16位数字时为真</li><li>ispunct(c); //当c是标点符号时为真（一个字符除了控制字符，字母，数字，可打印空白就是标点符号）</li><li>isspace(c); //当c是空白时为真（空白包括空格，横向/纵向制表符，回车符，换行符，进纸符）</li><li>tolower(c); //把大写字符转换为小写字符，本来就是小写字符的不变，返回转换后的字符</li><li>toupper(c); //把小写字符转换为大写字符，本来就是大写字符的不变，返回转换后的字符</li></ul><blockquote><p>建议：使用C++版本的C标准库头文件。<br>C++标准库兼容了C语言的标准库。C语言的头文件形如<code>name.h</code>，C++则会将这些文件命名为<code>cname</code>。也就是去掉了<code>.h</code>后缀，在文件名前添加了字母c。</p></blockquote><h3 id="范围for（range-for）语句-P82，3-2-3"><a href="#范围for（range-for）语句-P82，3-2-3" class="headerlink" title="范围for（range for）语句(P82，3.2.3)"></a>范围for（range for）语句(P82，3.2.3)</h3><p><strong>范围for语句用于遍历元素</strong>。形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(一个用于访问序列中基础元素的变量a : 被访问的序列对象b)&#123;</div><div class="line">    statement..... blabla;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首次初始化，变量a的值会被初始化为对象b序列中的第一个元素，迭代之后每次访问下一个元素，直到序列被完全访问结束。</p><p>可以使用<code>auto &amp;a</code>的方式声明变量a,使变量绑定到具体的序列元素上，从而进行更改。如在<code>for(auto a : str){}</code>中，每次把a初始化的行为实质上是使a获得str每个元素的副本（拷贝），而<code>for(auto &amp;a ： str){}</code>这样的语句则使a成为了str对应的每个元素的”别名”,从而可以修改str。</p><p>使用范围for循环遍历多维数组，为了不手动打类名，也为了防止外层数组的名被auto类型转化成指针，要在对外层数组的访问上都加上&amp;绑定。</p><blockquote><p>范围for有空补，未详看。</p></blockquote><h2 id="标准库类型vector-P86-3-3"><a href="#标准库类型vector-P86-3-3" class="headerlink" title="标准库类型vector(P86, 3.3)"></a>标准库类型vector(P86, 3.3)</h2><h3 id="类模板、容器和实例化-P87-3-3"><a href="#类模板、容器和实例化-P87-3-3" class="headerlink" title="类模板、容器和实例化(P87, 3.3)"></a>类模板、容器和实例化(P87, 3.3)</h3><p>当我们在C++里面谈论容器这个概念时，我们应该知道容器是用来存储和组织一类特定对象的集合。下面提到的标准库类型<code>vector</code>，就是一个容器。</p><p>类模板一般用于按照模板规定好的规则生成不同的类。我们无需很麻烦的一个一个写类的定义，只需使用模板，给出指定的少量信息，类模板就会帮助我们自动生成一个我们可以直接使用的类。vector也是一个类模板。</p><p>通过类模板创建类的过程，或者通过类型创建对象的过程，就叫做<strong>实例化</strong>。</p><h3 id="定义和初始化vector对象-P87-3-3-1"><a href="#定义和初始化vector对象-P87-3-3-1" class="headerlink" title="定义和初始化vector对象(P87,3.3.1)"></a>定义和初始化vector对象(P87,3.3.1)</h3><p>与string的定义和初始化一样，我们也可以使用多种方式定义和初始化一个vector对象。</p><p>以下几种初始化语句被vector支持：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v1;<span class="comment">//创建了一个空的vector容器，这个容器是Type类型对象的集合，这个集合名字叫做为v1，执行默认初始化。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v2(v1);<span class="comment">//创建了一个叫做v2的vector容器，这个容器的内容和v1相同。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v2=v1;<span class="comment">//同上一句，拷贝初始化。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v3&#123;a,b,c,...&#125;;<span class="comment">//v3包含了初始值个数的元素。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;Type&gt; v4=&#123;a,b,c,...&#125;;<span class="comment">//同上。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;Type&gt; v5(n,val);<span class="comment">//直接初始化这个容器，操作后v5拥有n个元素，每个元素的值都是val。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;Type&gt; v5(n);<span class="comment">//直接初始化这个容器，操作后v5拥有n个元素，每个元素的值都被默认初始化。</span></div></pre></td></tr></table></figure><p>当我们使用圆括号<code>（）</code>初始化对象时，IDE会认为我们在通过语句<code>“构建”</code>(constract)这个对象 ；当我们使用花括号<code>{ }</code>初始化对象时，IDE会认为我们在列表初始化(list initialize)对象。</p><p>当我们使用等号=初始化对象时，我们就执行了“拷贝初始化”；当我们不使用=初始化对象时，我们就执行了“直接初始化”。</p><p>但是当我们在花括号里面给一个不符合对象类型的值，IDE就会认为我们正在<strong>构建而非初始化对象</strong>，一个体现就是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;</div></pre></td></tr></table></figure></p><p>这个语句中，10不能转换为string，因此被系统理解为“这个string容器里有10个元素”。<br>当然，像<code>vector &lt;string&gt;s1={10};</code>这样的语句是错误的，因为=就应该是拷贝初始化了，然而10并不能够被转化为string因此也无法赋值。</p><h3 id="向vector对象添加元素-P90-3-3-2"><a href="#向vector对象添加元素-P90-3-3-2" class="headerlink" title="向vector对象添加元素(P90, 3.3.2)"></a>向vector对象添加元素(P90, 3.3.2)</h3><font color="000aa0"><br>向vector对象添加元素：<strong>push_back</strong>。<br></font><blockquote><p>循环体内部包含向vector对象添加元素时，则不能使用<strong>范围for循环</strong>。</p></blockquote><h3 id="vector支持的操作-P91-3-3-3"><a href="#vector支持的操作-P91-3-3-3" class="headerlink" title="vector支持的操作(P91, 3.3.3)"></a>vector支持的操作(P91, 3.3.3)</h3><ol><li><p>向容器的后面添加元素：已存在<code>vector&lt;T&gt; v;</code>，可以使用 <code>v.push_back(vector&lt;T&gt; a)</code>的方式在集合v的尾部添加元素。</p></li><li><p><code>empty</code>和<code>size</code>函数成员：已存在<code>vector&lt;T&gt; v;</code>，可以使用 <code>v.empty()</code>的方式判断v是否为空，可以使用<code>v.size()</code>的方式返回v的大小。</p></li><li><p>重载的运算符：vector支持的运算符包括下标运算符<code>[ ]</code>、重载的+、<code>==、！=、&lt;、&gt;、&lt;=、&gt;=</code>。这一点和<code>string</code>类似。</p></li></ol><blockquote><p>不能用下标形式添加元素。<br>只能对确知已存在的元素执行下标操作！</p></blockquote><h2 id="迭代器介绍-3-4"><a href="#迭代器介绍-3-4" class="headerlink" title="迭代器介绍(3.4)"></a>迭代器介绍(3.4)</h2><p>为了访问容器的元素（有些容器可能不支持下标运算符），因此C++提供了迭代器(iterator)这个概念来访问容器中的指定元素。</p><p>支持迭代器的类都会提供名为begin和end的函数成员来供我们获取迭代器。如已定义<code>vector&lt;int&gt; i1(10);</code>，这时使用<code>auto ben=i1.begin();</code>这个语句获取指向第一个字符的迭代器，使用<code>auto end=i1.end();</code>获取指向i1容器最后一个元素的下一个元素的迭代器，术语“尾后迭代器”。两个迭代器可以相减，但是两个迭代器相加后的行为是未定义的。</p><p>当使用<code>vector &lt;int&gt;</code>创建类时，这个类的命名空间就是<code>vector &lt;int&gt;</code>，命名空间中的迭代器类型写作<code>vector&lt;int&gt;::iterator</code>。因为这个叫做<code>&quot;vector&lt;int&gt;::iterator&quot;</code>的迭代器类型名太长了也不好记，这里我们使用<code>auto</code>推导这个类型。用成员函数<code>cbegin</code>和<code>cend</code>可以推导出底层const迭代器，就是这个迭代器对迭代器指向的内容只读不写。第6章会详细说明。</p><p>迭代器 对 迭代器指向的容器内容 可以像 指针 对 指针指向的数组元素一样使用。</p><p>虽然数组不是直接支持迭代器的类型，但是可以引入<code>&lt;iterator&gt;</code>头文件，使用<code>begin(数组名)</code>和<code>end(数组名)</code>的方式获得指向数组第一个元素和尾后第一个元素的指针。因为大多数容器不支持下标运算符，所以使用迭代器访问容器等结构中的元素是最好的方法。</p><h2 id="数组-3-5-P101"><a href="#数组-3-5-P101" class="headerlink" title="数组(3.5, P101)"></a>数组(3.5, P101)</h2><h3 id="一维数组的定义和初始化-3-5-1-P102"><a href="#一维数组的定义和初始化-3-5-1-P102" class="headerlink" title="一维数组的定义和初始化(3.5.1,P102)"></a>一维数组的定义和初始化(3.5.1,P102)</h3><p>一维数组声明形式：<code>类型名 数组名[一个常量]</code>。比如<code>int a[15];</code>这里这个数组的名字是a，有15个元素，每个元素都是int型的。再比如<strong><code>int *a[15];</code></strong>这里<strong>a数组的15个元素都是<code>int *</code>型的，即指向int的指针</strong>，这样的指针有15个，构成了一个数组。虽然有指针数组，但是不存在元素都是引用类型的数组。</p><p>一维数组的初始化方式就是花括号初始化，形如<code>int a[n]={1,2,3};</code>，大括号里面的内容就是初始化列表，n为数组大小，可以缺省，缺省时数组长度由初始化列表的元素个数决定。当初始化列表的值的个数比数组长度小，数组剩下的元素被初始化为默认的值，比如对于有10个元素的int型数组，如果只给出第一个元素的值，后几个元素将被初始化为0。</p><p>当我们声明<code>int a[]</code>的时候代表通过数组名a访问这个数组。<br>我们也可以定义指向数组的指针和指向数组的引用来间接访问这个数组。<br>已有<code>int arr[10];</code>的情况下，<code>int (*ptr) [10]=&amp;arr;</code>这条语句可以使指针ptr指向arr这整个数组。<code>int (&amp;ref)[10]=arr;</code>则会使ref作为整个arr数组的引用。<code>int *(&amp;ref)[10]=arr;</code>这个语句则是说ref是arr的引用，这个被引用的数组的类型是指针数组。</p><p><code>auto a=一个数组名</code>，a的类型将会是这个指针，指针指向的类型就是数组元素的类型。<br>用<code>decltype(一个数组名) a;</code>这样的形式，a将会是和数组名属性一致的数组。<br>在大部分运算中，数组名都会被转化成相应的指针类型。如<code>*(ai+4)</code>中，数组名ai是指向整个数组首元素的指针，这个指针＋4就是向右侧移动4位，指针原来指向第一个元素，移动4位就指向了数组中的第五个元素。然后指向的值就是ai数组第五个元素的值，相当于ai[4]。</p><h3 id="用数组初始化vector对象和用string对象赋值字符数组-3-5-5-P111"><a href="#用数组初始化vector对象和用string对象赋值字符数组-3-5-5-P111" class="headerlink" title="用数组初始化vector对象和用string对象赋值字符数组(3.5.5, P111)"></a>用数组初始化vector对象和用string对象赋值字符数组(3.5.5, P111)</h3><p>作为与旧代码的接口，C++提供了方便的把数组转化为vector对象的方法。在声明vector对象时，我们可以通过迭代器用一个数组初始化vector。<br>在已经存在<code>int oldarray[10];</code>的情况下，声明的语句形如：<code>vector&lt;int&gt; arr( begin(oldarray) , end(oldarray) );</code>可以把arr初始化为oldarray。begin和end这两个函数在<code>&lt;iterator&gt;</code>头文件里，作用是返回数组的首元素/尾后指针。这种初始化接受两个参数：拷贝开始部分指针和结束部分的指针。<br>我们也可以写形如<code>int arr[10]={0}; vector &lt;int&gt; newarr( arr+1 , arr+6 );</code>这种方式拷贝数组arr的第2~第5号元素，并用它们初始化newarr。</p><p>类似地，我们可以通过<code>string a(&quot;23333333\n&quot;); const char *b=a.c_str();</code>这样的语句使string型的a被赋值给字符数组指针b。返回结果是const是为了确保我们不会通过这个指针改动返回的字符数组的值。</p><blockquote><p>建议： 尽量使用标准库类型而非数组</p><p>使用指针和数组容易出错。现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。</p></blockquote><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>1.拷贝初始化 copy initialization<br>2.直接初始化 direct initialization<br>3.范围for range for<br>4.容器 container<br>5.类模板 class template<br>6.实例化 instantiation<br>7.值初始化 value-initialized<br>8.构造 construct<br>9.列表初始化 list initialize<br>10.迭代器 iterator<br>11.迭代器运算 iterator arithmetic<br>12.C风格字符串 C-style character string<br>13.空字符 null terminated<br>14.缓冲区溢出 buffer overflow<br>15.编译器扩展 complier extension</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>C++ Primer 中文版 第5版</li><li><a href="https://zhuanlan.zhihu.com/p/23503699" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/23503699</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/04/CPP_03/#disqus_thread</comments>
    </item>
    
    <item>
      <title>西瓜书《机器学习》学习笔记(2)：比较检验与偏差方差</title>
      <link>http://wangwlj.com/2018/01/04/ML_chap2_02/</link>
      <guid>http://wangwlj.com/2018/01/04/ML_chap2_02/</guid>
      <pubDate>Thu, 04 Jan 2018 10:46:46 GMT</pubDate>
      <description>
      
        &lt;p&gt;本篇主要介绍比较检验、偏差与方差。&lt;br&gt;其中，比较检验分为如下四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设检验&lt;/li&gt;
&lt;li&gt;交差验证t检验&lt;/li&gt;
&lt;li&gt;McNeMar检验&lt;/li&gt;
&lt;li&gt;FriedMan检验与Nemenyi后续检验&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本篇主要介绍比较检验、偏差与方差。<br>其中，比较检验分为如下四类：</p><ul><li>假设检验</li><li>交差验证t检验</li><li>McNeMar检验</li><li>FriedMan检验与Nemenyi后续检验</li></ul><a id="more"></a><h2 id="比较检验-2-4-P37"><a href="#比较检验-2-4-P37" class="headerlink" title="比较检验(2.4, P37)"></a>比较检验(2.4, P37)</h2><p>在比较学习器泛化性能的过程中，<strong>统计假设检验（hypothesis test）</strong>为学习器性能比较提供了重要依据，即若A在某测试集上的性能优于B，那A学习器比B好的把握有多大。</p><h3 id="假设检验-2-4-1-P38"><a href="#假设检验-2-4-1-P38" class="headerlink" title="假设检验(2.4.1, P38)"></a>假设检验(2.4.1, P38)</h3><p>假设检验(Hypothesis Testing)是数理统计学中根据一定假设条件<strong>由样本推断总体</strong>的一种方法。</p><p>“假设”指的是对学习器泛化错误率分布的某种判断或猜想，如“$\epsilon = \epsilon_0 $”，现实任务中，我们并不知道学习器的泛化错误率$\epsilon$，但是可以通过测试错误率$\hat \epsilon$推算。</p><p>在包含了 m 个样本的测试集上，【泛化错误率为 $\epsilon$ 的学习器】被测得测试错误率为$ \hat \epsilon $的概率为：<br>$$P(\hat\epsilon;\epsilon) = \begin{pmatrix} m \\ \hat\epsilon\times m  \end{pmatrix} \epsilon^{\hat\epsilon\times m}(1-\epsilon)^{m-\hat\epsilon\times m}$$</p><blockquote><p>上式中的$\begin{pmatrix} m \\ \hat\epsilon\times m  \end{pmatrix} $表示$C_m^{m’}$，即从m个数中任取m’个数。</p></blockquote><p>这个概率，表达了【泛化错误率为 $\epsilon$ 的学习器】被测得【测试错误率】为 $\hat{\epsilon}$ 的可能性。 $\hat{\epsilon} $取0~100%。若以这个【可以测得的测试错误率$ \hat{\epsilon} $】作为自变量，以概率 $P(\hat{\epsilon};\epsilon) $为因变量，建立平面坐标图，则对于不同的测试错误率，有不同的可能性。在某点可能性越高，这个未知的【泛化错误率$ \epsilon $】和这个点代表的测试错误率的关系就越密切。</p><p>现在要找其可能性最高的点，就要对概率$ P(\hat{\epsilon};\epsilon)$ 求 $\epsilon$ 的导数，导数为0时，存在极值。</p><p>而对此概率函数求导并解出导函数等于0的式子之后，发现存在一个值 $\epsilon_0$ ，使得$P(\hat{\epsilon};\epsilon)$在$\epsilon=\epsilon_0$时最大，$|\epsilon-\epsilon_0|$ 增大时减小。整个图像其实是个山峰形状，符合二项分布。</p><p>那么此时也可以反过来讲，如果这个泛化错误率 $\epsilon$ 已知为 $\epsilon_0$ ，则理论上，横坐标为 $\epsilon_0$的概率值$P(\hat{\epsilon};\epsilon)$是最大的。</p><p>即：<strong>若泛化错误率为$ \epsilon_0$ ，则测试错误率也为 $\epsilon_0$ 的概率最大（可能性最高）</strong>。</p><p>此时，我们得到了泛化错误率为$ \epsilon_0$，我们可以用这个数值来进行假设，假设这个学习器的泛化错误率不会超过 $\epsilon_0$。</p><p>即假设：“$ H_0:\epsilon≤\epsilon_0$ ”。</p><p>到底要不要接受这个假设呢？</p><p>我们需要检验一下。</p><blockquote><p>显著度（显著性水平）是估计总体参数落在某一区间内，可能犯错误的概率，用$\alpha$表示。$\alpha$的常用取值很小，如0.05，0.1等。<br>$1-\alpha$则表示置信度(confidence)。</p></blockquote><p>通过二项检验(binomial test)，我们得到结论：在$\alpha$的显著度下，假设$ H_0:\epsilon≤\epsilon_0$ 不能被拒绝，能<strong>以$1-\alpha$的置信度认为，学习器的泛化错误率不大于$\epsilon_0$</strong>；否则假设被拒绝，即在$\alpha$的显著度下可认为该学习器的泛化错误率大于$\epsilon_0$。</p><hr><p>现实中我们并非仅作出一次留出法估计，而是做多次，所以会得到不同的多个测试错误率，假定为k个测试错误率： $\hat \epsilon_1$、$\hat \epsilon_2、\cdots 、\hat \epsilon_k$，则平均错误率$ \mu  $和方差$ \sigma^{2}$为：<br>$$\mu = \frac 1k \sum_{i=1}^k\hat \epsilon_i $$<br>$$ \sigma^2 = \frac{1}{k-1} \sum_{i=1}^k (\hat \epsilon_i - \mu)^2$$</p><blockquote><p>假设X服从标准正态分布N（0,1），Y服从$ \chi^2$分布，那么$ T=X/\sqrt{Y/n}$  的分布称为自由度为n的t分布,记为$T \sim t(n)$。</p><p>t分布这边需要一定的数学基础。默默记住吧。</p></blockquote><p>T 为自由度为 n 的 t 分布，变量 $\tau_{t}=(\sqrt{k}(\mu-\epsilon_0))/\sigma $服从自由度为 k-1 的 t 分布。（ $\mu-\epsilon_{0} $服从正态分布， $\sigma^{2} $服从自由度为 k-1 的$ \chi^2 $分布）</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3pvrkvwjj20em09pjrr.jpg" alt=""></p><p>由此图和 t 分布图的性质可知，最高点处就是测试错误率的最大值$\epsilon_0$ 。</p><p>现在要重新假设了，“ $H_1:\mu=\epsilon_0 $”。</p><p>接下来就是继续确定显著度 $\alpha$ ，确定门槛值（此处用双边假设），最后进行在置信度为 $1-\alpha$ 下的判断了。</p><h3 id="交叉验证-t-检验-2-4-2-P40"><a href="#交叉验证-t-检验-2-4-2-P40" class="headerlink" title="交叉验证 t 检验(2.4.2, P40)"></a>交叉验证 t 检验(2.4.2, P40)</h3><p>回顾一下上一篇中的<strong>k折交叉验证</strong>：</p><blockquote><p>“k折交叉验证法”(cross validation)先将数据集D划分为k个大小相似的互斥子集，即$D=D_1\cup D_2 \cup \cdots\cup D_k,D_i \cap D_j =\oslash (i\neq j)$</p></blockquote><p>如果说前一种的<strong>假设检验是得到单个学习器的泛化错误率的大致范围假设</strong>，那么<strong>“交叉验证t检验”方法就是在比较A、B两学习器性能的优劣</strong>了（不过偏向于验证A、B性能是否相同）。</p><p>现在有两个学习器A和B，使用 k 折交叉验证法得到测试错误率分别为 $\epsilon_{1}^{A},\epsilon_{2}^{A},\epsilon_{3}^{A},…\epsilon_{k}^{A}$ 和$\epsilon_{1}^{B},\epsilon_{2}^{B},\epsilon_{2}^{B},…\epsilon_{k}^{B} $。其中$ \epsilon_{i}^{A} $和 $\epsilon_{i}^{B} $是在相同的第 i 折训练/测试集上得到的结果。</p><blockquote><p>注意，此时的测试错误率和之前的假设检验那一节的测试错误率采用了不同的符号，此时由于没有提到泛化错误率，测试错误率被标记为$ \epsilon $，只不过增加了上下角标，请各位不要将其与上一节的泛化错误率混淆。</p></blockquote><p>基本思想：若两个学习器的性能相同，则它们使用的训练/测试集得到的测试错误率应相同，即 $\epsilon_{i}^{A}=\epsilon_{i}^{B} $。</p><p>实际上却不会像理想状态一样，两个学习器的测试错误率并不完全相同，而是存在一定的微小差值。我们想要判断两个学习器的性能是否有显著差别，就要利用这个差值进行假设检验。</p><p>若两个学习器性能相同，这个差值均值应该为0。因此可对这k个差值对“学习器A和B性能相同”这个假设做 t 检验。</p><p>1、先对每一对结果求差，$ \Delta_i=\epsilon_{i}^{A}-\epsilon_{i}^{B}$</p><p>2、计算出这$k$个差值的均值$ \mu $和方差 $\sigma^2$</p><p>3、根据 t 检验的公式$ T=X/\sqrt{Y/n} $，得 $\tau_t=|\frac{\sqrt{k}\mu}{\sigma}|$ ，满足自由度为 k-1 的 t 分布，故在显著度$ \alpha $，若其小于临界值 $t_{\alpha/2,k-1} $，则假设不能被拒绝，即认为两个学习器性能没有显著的差别。反之则认为平均错误率小的性能更优。</p><p>这里$t_{\alpha/2,k-1}$ 是分布上尾部累积分布为$\alpha/2$ 的临界值。</p><p>但是这样使用 k 折交叉验证法，通常情况下会因为样本有限，使得不同轮次的训练集产生一定程度的重叠。这样训练出来的学习器，会让得出的这组测试错误率无法做到彼此完全独立。</p><p>而进行有效的假设检验的一个重要的前提就是：测试错误率均为泛化错误率的独立采样。（例如 t 分布就需要随机变量X和Y相互独立。）</p><p>所以为了缓解这个问题，可采用“5×2交叉验证”法。</p><h4 id="5×2交叉验证-2-4-2-P41"><a href="#5×2交叉验证-2-4-2-P41" class="headerlink" title="5×2交叉验证(2.4.2, P41)"></a>5×2交叉验证(2.4.2, P41)</h4><p>待补。</p><h3 id="McNemar检验-2-4-3-P41"><a href="#McNemar检验-2-4-3-P41" class="headerlink" title="McNemar检验(2.4.3, P41)"></a>McNemar检验(2.4.3, P41)</h3><p>McNemar检验适用于二分类问题，与成对t检验一样也是用于比较两个学习器的性能大小。通过联列，可以获得学习器A和B的分类结果的差别。下表即为两分类器分类差别列联表， e 为样本数。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4g3oembgj20es08474e.jpg" alt="列联表"></p><p>主要思想是：若两学习器的性能相同，则A预测正确B预测错误数应等于B预测错误A预测正确数，即$e_{01}=e_{10}$，且$|e_{01}-e_{10}|$符合正态分布。</p><blockquote><p>$| e_{01}-e_{10}|$为什么符合正态分布？</p><p>按理说，实际生活中，凡自然状态下的整体数据分布几乎都符合<strong>正态分布</strong>，那么当假设两学习器性能相同的时候，如果用大量不同的测试集进行测试，这个差值应该就可能符合正态分布。</p></blockquote><p>McNemar检验考虑变量：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4gg36qwrj209902j3yb.jpg" alt="McNemar检验变量"></p><blockquote><p>但上式中的“-1”并非因为$ |e_{01}-e_{10}| $的均值 $\mu$ 为1，实际上均值$ \mu $应近似为0，这里的“-1”，是为了<strong>连续性校正</strong>。</p><p>什么是连续性校正？$2*2$列联表资料是分类资料,所以样本量较小时要进行连续性校正。。卡方检验要求：最好是大样本数据。一般每个个案最好出现一次，四分之一的个案至少出现五次。如果数据不符合要求，就要应用校正卡方。参见<a href="https://en.wikipedia.org/wiki/McNemar%27s_test#cite_note-Edwards1948-3" target="_blank" rel="external">维基百科</a></p></blockquote><p>上述变量$\tau_{\chi^2}$ 符合自由度为1 的$ \chi^2 $分布。</p><blockquote><p>$ \chi^2 $分布的定义：若k个独立的随机变量$Z_1,Z_2,⋯,Z_k$，且符合标准正态分布$N(0,1)$，则这k个随机变量的平方和 $X=∑_{i=1}^kZ^2_i$为服从自由度为k的卡方分布，记为： $X\sim \chi^2(k)$。<br>卡方分布的期望与方差分为为：<br>$E(\chi^2)=k，D(\chi^2)=2k$，其中k为卡方分布的自由度。</p></blockquote><p>给定显著度$\alpha $，当上述变量小于临界变量值的时候，不能拒绝假设，即认为两学习器的性能没有显著差别；否则拒绝假设，即认为两者性能有显著差别，平均错误率较小的学习器性能较好。这个过程也是自由度为1 的卡方检验。</p><blockquote><p>$\chi^2 $检验，中文名为<strong>卡方检验</strong>。卡方检验是一种用途很广的计数资料的假设检验方法。它属于非参数检验的范畴，主要是比较两个及两个以上样本率( 构成比）以及<strong>两个分类变量的关联性分析</strong>。其根本思想就是在于比较理论频数和实际频数的吻合程度或拟合优度问题。</p></blockquote><h3 id="Friedman检验与Nemenyi后续检验-2-4-4-P42"><a href="#Friedman检验与Nemenyi后续检验-2-4-4-P42" class="headerlink" title="Friedman检验与Nemenyi后续检验(2.4.4, P42)"></a>Friedman检验与Nemenyi后续检验(2.4.4, P42)</h3><p>上述的三种检验（假设检验、交叉验证t检验，McNemar检验）都只能在一组数据集上，Friedman检验则可以在多组数据集进行多个学习器性能的比较，基本思想是在同一组数据集上，根据测试结果（例：测试错误率）对学习器的性能进行排序，赋予<strong>序值1,2,3…</strong>，相同则平分序值，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4o1uvti5j20h005yglo.jpg" alt=""></p><blockquote><p>比如：D1数据集上，算法A的性能最好，其次算法B的性能，最差的是算法C的性能。<br>数字越小，代表该算法在该数据集上的表现越好。</p></blockquote><p><font color="000AA0">Friedman检验</font>：判断算法是否性能都相同。 检验变量$\tau_{\chi^2}$与F检验的临界值进行比较。</p><p>若<strong>“H0：所有算法的性能相同”</strong>这个假设被拒绝，则需要进行后续检验(post-hoc test)，来得到具体的算法之间的差异。常用的就是<strong>Nemenyi后续检验</strong>。</p><p>Nemenyi检验计算出平均序值差别的<strong>临界值域</strong>，<strong>若两个算法的平均序值差超出了临界值域CD，则相应的置信度1-α拒绝“两个算法性能相同”的假设</strong>。</p><p>总结一下多学习器的比较：</p><ul><li>Friedman + Nemenyi</li><li>Friedman 检验(基于序值，F检测，判断“是否都相同”)</li><li>Nemenyi 后续检验 (基于序值，进一步判断两两差别)</li></ul><blockquote><p>关于读音：（音译，仅供参考）<br>McNemar：mac呢嘛儿（mac:[mæk]，中文名：麦克尼马尔）<br>Friedman：free的们（free:[fri]，中文名：弗里德曼）<br>Nemenyi：呢曼里(y貌似不发音)</p></blockquote><h2 id="偏差与方差-2-5-P44"><a href="#偏差与方差-2-5-P44" class="headerlink" title="偏差与方差(2.5, P44)"></a>偏差与方差(2.5, P44)</h2><p>“偏差-方差分解”(bias-variance decomposition)是解释学习算法泛化性能的重要工具。</p><ul><li>测试样本：x</li><li>测试样本x在数据集中的标记： $y_D$</li><li>测试样本x的真实标记： y</li><li>训练集： D</li><li>从训练集 D 上学得的模型f</li><li>模型 f 在测试样本x上的预测输出$f(x;D) $</li></ul><p>根据上述变量，推导出学习算法的期望预测：<br>$$\bar f(x) = \mathbb{E}_D [f(x;D)] $$<br>使用样本数相同的不同训练集产生的<font color="00AA00"><strong>方差</strong></font>为：度量了同样大小的训练集的变动所导致的学习性能的变化，也就是<strong>数据扰动所造成的影响</strong>。<br>$$var(x) = \mathbb{E}_D [(f(x;D)- \bar f (x) )^2] $$</p><p><font color="00AA00"><strong>噪声</strong></font>(数据集标记和真实标记的方差)为：当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了<strong>学习问题本身的难度</strong>。<br>$$ \varepsilon^2 =  \mathbb{E}_D [(y_D - y)^2]$$</p><p><font color="00AA00"> <strong>Bias（偏差）</strong></font>：期望输出与真实标记的偏离程度，刻画了<strong>学习算法本身的拟合能力</strong>。<br>$$bias^2(x) = (\bar f (x) - y)^2 $$</p><p>对回归任务，泛化误差可通过“偏差-方差分解”拆解为：<br>$$E(f;D) = bias^2(x) + var(x) + \varepsilon^2 $$</p><p>也就是说，<strong>泛化误差可分解为 偏差、方差与噪声之和</strong>。<br>偏差-方差分解说明，<strong>泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的</strong>。</p><p>一般来说，偏差与方差是由冲突的，这称为“偏差-方差窘境”。<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4m77isg5j20k00fvt8z.jpg" alt="偏差-方差窘境"></p><p>随着训练程度的提升，期望预测值与真实值之间的差异越来越小，即偏差越来越小，但是另一方面，随着训练程度加大，学习算法对数据集的波动越来越敏感，方差值越来越大。换句话说：<strong>在欠拟合时，偏差主导泛化误差，而训练到一定程度后，偏差越来越小，方差主导了泛化误差</strong>。因此训练也不要贪杯，适度辄止。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志华《机器学习》</li><li><a href="https://zhuanlan.zhihu.com/p/29248751" target="_blank" rel="external">《机器学习》学习笔记与习题探讨（二）④</a></li><li><a href="http://blog.csdn.net/bitcarmanlee/article/details/52279907" target="_blank" rel="external">卡方分布与卡方检验</a></li><li><a href="http://blog.sina.com.cn/s/blog_4a0824490102v8tz.html" target="_blank" rel="external">卡方检验（Chi-square test）和费舍尔精确检验（Fisher exact test）</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/04/ML_chap2_02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>西瓜书《机器学习》学习笔记(1)：评估方法与度量指标</title>
      <link>http://wangwlj.com/2018/01/03/ML_chap2_01/</link>
      <guid>http://wangwlj.com/2018/01/03/ML_chap2_01/</guid>
      <pubDate>Wed, 03 Jan 2018 13:31:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;笔记直接跳过了第一章，从第二章开始。&lt;/p&gt;
&lt;p&gt;本次笔记主要回顾评估方法与性能度量指标。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>笔记直接跳过了第一章，从第二章开始。</p><p>本次笔记主要回顾评估方法与性能度量指标。<br><a id="more"></a></p><h2 id="经验误差与过拟合-2-1-P23"><a href="#经验误差与过拟合-2-1-P23" class="headerlink" title="经验误差与过拟合(2.1, P23)"></a>经验误差与过拟合(2.1, P23)</h2><p>学习器在训练集上的误差称为<strong>训练误差</strong>(training error)或<strong>经验误差</strong>(empirical error)，在新样本上的误差称为<strong>泛化误差</strong>(generalization error)，我们希望得到泛化误差小的学习器。</p><p>过拟合(overfitting)，欠拟合(underfitting)。</p><p>多种因素导致过拟合，最常见的就是由于学习能力过于强大，以至于把训练样本不太一般的特性都学到了。欠拟合相反。</p><p>欠拟合比较容易克服，如在决策树学习中学习扩展分支，在神经网络学习中增加训练轮数等。</p><p>过拟合无法彻底避免。只能“缓解”，减小风险。</p><h2 id="评估方法-2-2-P24"><a href="#评估方法-2-2-P24" class="headerlink" title="评估方法(2.2, P24)"></a>评估方法(2.2, P24)</h2><p>测试集(testing set)上的测试误差(testing error) 作为泛化误差的近似。</p><h3 id="留出法-2-2-1-P25"><a href="#留出法-2-2-1-P25" class="headerlink" title="留出法(2.2.1, P25)"></a>留出法(2.2.1, P25)</h3><p>“留出法”(hold-out) 将数据集D划分为两个<strong>互斥</strong>的集合，其中一个集合作为训练集S，另一个作为测试集T，即$D=S\cup T,S\cap T=\oslash $。</p><p>常见的划分为：大约2/3-4/5的样本用作训练，剩下的用作测试。</p><p>注意：</p><ul><li>训练/测试集的划分需要尽可能保持<strong>数据分布的一致性</strong>。</li><li>由于划分的随机性，单次留出法得到的评估结果往往不够稳定可靠，一般采用<strong>若干次随机划分、重复进行实验评估后取平均值</strong>。</li></ul><h3 id="交叉验证法-2-2-2-P26"><a href="#交叉验证法-2-2-2-P26" class="headerlink" title="交叉验证法(2.2.2, P26)"></a>交叉验证法(2.2.2, P26)</h3><p>“交叉验证法”(cross validation)先将数据集D划分为k个大小相似的互斥子集，即$D=D_1\cup D_2 \cup \cdots\cup D_k,D_i \cap D_j =\oslash (i\neq j)$</p><p>每次用k-1个子集作为训练集，余下的那个子集作为测试集；这样就可以得到k组训练/测试集。从而可进行k次训练和测试，最终返回k次测试结果的均值。</p><p>故通常把交叉验证法称为“k折交叉验证”(k-fold cross validation)。<br>10折交叉验证示意图：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3il11kesj20d706bdgd.jpg" alt="10折交叉验证示意图"></p><p>与留出法类似，将数据集D划分为K个子集的过程具有随机性，因此K折交叉验证通常也要重复p次，称为<strong>p次k折交叉验证</strong>，常见的是10次10折交叉验证，即进行了100次训练/测试。特殊地当划分的k个子集的每个子集中只有一个样本时，称为“留一法”，显然，留一法的评估结果比较准确，但对计算机的消耗也是巨大的。</p><h3 id="自助法-2-2-3-P27"><a href="#自助法-2-2-3-P27" class="headerlink" title="自助法(2.2.3, P27)"></a>自助法(2.2.3, P27)</h3><p>“自助法”(bootstrapping)以自助采样法(bootstrapping sampling)为基础。<br>每次随机从包含m个样本的数据集D中挑选一个样本，将其拷贝到$D’$，然后再将该样本放回D中，使得该样本下次采样时仍有可能被采到。<br>重复执行m次后，就得到包含m个样本的数据集$D’$。</p><p>我们将$D’$用作训练集，$D-D’$(D中除了$D’$以外的样本)用作测试集。</p><p>在m次采样中，样本始终不被采到的概率取极限为：<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3iphjqzuj206w01fdfm.jpg" alt=""></p><p>自助法在数据集较小、难以有效划分训练/测试集时很有用。</p><h3 id="调参与最终模型-2-2-4-P28"><a href="#调参与最终模型-2-2-4-P28" class="headerlink" title="调参与最终模型(2.2.4, P28)"></a>调参与最终模型(2.2.4, P28)</h3><p>大多数学习算法都有些参数(parameter) 需要设定，参数配置不同，学得模型的性能往往有显著差别，这就是通常所说的”参数调节”或简称”调参” (parameter tuning)。</p><p>当选定好模型和调参完成后，我们需要使用初始的数据集D重新训练模型，即让最初划分出来用于评估的测试集也被模型学习，增强模型的学习效果。</p><p>学得模型(训练后的模型)实际使用中遇到的数据称为测试数据，在模型评估选择中用于评估测试的数据集称为“验证集”(calidation set)。【和吴恩达讲得差不多(略有区别？)。吴恩达说，通常将数据分为三类：训练集，验证集与测试集。】</p><h2 id="性能度量performance-measure-2-3-P28"><a href="#性能度量performance-measure-2-3-P28" class="headerlink" title="性能度量performance measure(2.3, P28)"></a>性能度量performance measure(2.3, P28)</h2><p>分类和回归属于监督学习。</p><ul><li><p>【分类】：对是离散值的结果进行预测。</p></li><li><p>【回归】：对是连续值的结果进行预测。</p></li></ul><p>回归任务和分类任务的常用性能度量如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3mv5tkf5j20dw04zq3a.jpg" alt=""></p><p><del>预测任务：学习器预测结果$f(x)$与真实标记$y$进行比较。</del></p><p>回归任务：“均方误差”(mean squared error)<br>$$E(f;D) = \frac 1m \sum_{i=1}^m (f(x_i)-y_i)^2 $$</p><p>下面将依次介绍上图中分类任务的四类性能度量。</p><h3 id="错误率与精度-2-3-1-P29"><a href="#错误率与精度-2-3-1-P29" class="headerlink" title="错误率与精度(2.3.1, P29)"></a>错误率与精度(2.3.1, P29)</h3><p>错误率：分类错误的样本占样本总数的比例：<br>$$E(f;D) = \frac 1m \sum_{i=1}^m |(f(x_i)\neq y_i) $$<br>精度：分类正确的样本占样本总数的比例：<br>$$acc(f;D) = \frac 1m \sum_{i=1}^m |(f(x_i)= y_i) = 1-E(f;D)  $$</p><p>错误率+精度=1。</p><h3 id="查准率、查全率与F1-2-3-2-P30"><a href="#查准率、查全率与F1-2-3-2-P30" class="headerlink" title="查准率、查全率与F1(2.3.2, P30)"></a>查准率、查全率与F1(2.3.2, P30)</h3><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3j33r8v2j20c006v74f.jpg" alt=""></p><p>查准率就是准确率，查全率就是召回率。</p><p>更具体的，可参考我的这篇文章：<a href="http://wangwlj.com/2017/10/08/DL_Precision_and_Recall/">准确率、召回率与F1值</a><br>【重点，单独列出】</p><h3 id="ROC-与AUC-2-3-3-P33"><a href="#ROC-与AUC-2-3-3-P33" class="headerlink" title="ROC 与AUC(2.3.3, P33)"></a>ROC 与AUC(2.3.3, P33)</h3><p><strong>ROC：受试者工作特性(Receiver Operating Characteristic)。</strong><br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4csetqxzj20k009l0t5.jpg" alt=""><br>ROC图的纵坐标为“真正例率”，横坐标为“假正例率”。</p><blockquote><p>真正例率（TPR）：【真正例样本数】与【真实情况是正例的样本数】的比值。（查全率）</p><p>假正例率（FPR）：【假正例样本数】与【真实情况是反例的样本数】的比值。</p></blockquote><p>如图，理想模型是真正例率为100%，假正例率为0%的一点。随机猜测模型则是真正例率与假正例率持平的直线。由此可知，在随机猜测模型左上方的曲线和在其右下方的曲线都代表了什么。（右下方的模型，还不如随机猜测准。）</p><p>现实中通常是有限个测试样例来绘制ROC图。无法产生光滑的ROC曲线图。</p><p>同样地，进行模型的性能比较时，若一个学习器A的ROC曲线被另一个学习器B的ROC曲线完全包住，则称B的性能优于A。若A和B的曲线发生了交叉，则不太好判断。此时，AUC应运而生。</p><p>AUC(Area Under ROC Curve)：判断两个ROC曲线的性能，AUC计算的是ROC曲线下的面积。面积越大，性能越好。</p><h3 id="代价敏感错误率与代价曲线-2-3-4-P35"><a href="#代价敏感错误率与代价曲线-2-3-4-P35" class="headerlink" title="代价敏感错误率与代价曲线(2.3.4, P35)"></a>代价敏感错误率与代价曲线(2.3.4, P35)</h3><p>上面的方法中，将学习器的犯错同等对待，但在现实生活中，将正例预测成假例与将假例预测成正例的代价常常是不一样的，例如：将无疾病–&gt;有疾病只是增多了检查，但有疾病–&gt;无疾病却是增加了生命危险。以二分类为例，由此引入了“代价矩阵”（cost matrix）。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4d0hvlu2j20ak06w0sq.jpg" alt="二分类代价矩阵"></p><p>在非均等错误代价下，我们希望的是最小化“总体代价”，这样“代价敏感”(cost sensitive)的错误率为：<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3ji8c6pjj20jh02baa9.jpg" alt=""></p><p>同样对于ROC曲线，在非均等错误代价下，性能度量的方法演变成了<strong>“代价曲线”</strong>，代价曲线横轴是取值在[0,1]之间的正例概率代价，式中p表示正例的概率，纵轴是取值为[0,1]的归一化代价。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3lfih9eaj20cs0260sl.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3m2chlkwj20fo028glj.jpg" alt=""><br>代价曲线的绘制：设ROC曲线上一点的坐标为(TPR，FPR) ，则可相应计算出FNR，然后在代价平面上绘制一条从(0，FPR) 到(1，FNR) 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将ROC曲线上的每个点转化为代价平面上的一条线段，然后取<strong>所有线段的下界</strong>，围成的面积即为在所有条件下学习器的期望总体代价，如图所示：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3jugpwecj20fc09jaak.jpg" alt="代价曲线"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志华《机器学习》</li><li><a href="http://blog.csdn.net/u011826404/article/details/53229609" target="_blank" rel="external">http://blog.csdn.net/u011826404/article/details/53229609</a></li><li><a href="https://zhuanlan.zhihu.com/p/28482121" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/28482121</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/03/ML_chap2_01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>windows下的部分小技巧整理</title>
      <link>http://wangwlj.com/2017/12/29/practical_tricks/</link>
      <guid>http://wangwlj.com/2017/12/29/practical_tricks/</guid>
      <pubDate>Fri, 29 Dec 2017 05:33:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文主要是电脑使用中的一些小技巧的整理。&lt;br&gt;主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电脑常用的部分快捷键&lt;/li&gt;
&lt;li&gt;批处理乱码问题&lt;/li&gt;
&lt;li&gt;Photoshop文字添加、删除与旋转&lt;/li&gt;
&lt;li&gt;VMbox虚拟机问题&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本文主要是电脑使用中的一些小技巧的整理。<br>主要包括：</p><ul><li>电脑常用的部分快捷键</li><li>批处理乱码问题</li><li>Photoshop文字添加、删除与旋转</li><li>VMbox虚拟机问题</li></ul><a id="more"></a><h1 id="电脑操作"><a href="#电脑操作" class="headerlink" title="电脑操作"></a>电脑操作</h1><h2 id="打开“我的电脑”的快捷键"><a href="#打开“我的电脑”的快捷键" class="headerlink" title="打开“我的电脑”的快捷键"></a>打开“我的电脑”的快捷键</h2><p><code>winkey +E</code> :<br>打开我的电脑（资源管理器）。winkey指的是键盘上刻有windows徽标的键，就是左边ctrl 和alt中间那个(window标志)。</p><p>其他常用键组合：</p><p><code>winkey + d</code> :<br>这是高手最常用的第一快捷组合键。这个快捷键组合可以将桌面上的所有<strong>窗口瞬间最小化</strong>，无论是聊天的窗口还是游戏的窗口……只要<strong>再次按下这个组合键，刚才的所有窗口都回来了</strong>，而且激活的也正是你最小化之前在使用的窗口！ </p><p><code>winkey + r</code> :<br>在我们的文章中，你经常会看到这样的操作提示:“点击‘开始→运行’，打开‘运行’对话框……”。其实，还有一个更简单的办法，就是按winkey + r！ </p><p><code>alt + tab</code> 或者 <code>winkey + tab</code>:<br>如果打开的窗口太多，这个组合键就非常有用了，它可以在<strong>一个窗口中显示当前打开的所有窗口的名称和图标</strong>，选中自己希望要打开的窗口，松开这个组合键就可以了。而alt+tab+shift键则可以反向显示当前打开的窗口。 </p><p><code>ALT + F4</code> ：<br>关闭当前应用程序 </p><p><code>PRINT SCREEN</code> :<br>将当前屏幕以图象方式拷贝到剪贴板 </p><p>更多快捷键可参考：<a href="https://zhidao.baidu.com/question/100107981.html" target="_blank" rel="external">https://zhidao.baidu.com/question/100107981.html</a></p><h2 id="复制一个当前文件夹窗口的快捷键"><a href="#复制一个当前文件夹窗口的快捷键" class="headerlink" title="复制一个当前文件夹窗口的快捷键"></a>复制一个当前文件夹窗口的快捷键</h2><p><code>Ctrl + N</code></p><h2 id="批量查看照片尺寸"><a href="#批量查看照片尺寸" class="headerlink" title="批量查看照片尺寸"></a>批量查看照片尺寸</h2><p>在空白的地方右击，选择<strong>查看——详细信息</strong>;</p><p>照片就以列表的形式摆放了，但没有尺寸大小的信息~</p><p>再次在空白处右击，选择<strong>排列方式——更多</strong>，</p><p>将滑块往下滑动，<strong>找到尺寸，打上勾</strong>，按确定~</p><p>照片的尺寸信息就出现了~</p><p>若没有理解清楚，详细图文教程可参考：<a href="https://jingyan.baidu.com/article/67508eb4d4d3ff9ccb1ce459.html" target="_blank" rel="external">如何批量查看照片的尺寸</a></p><h2 id="awesomiumProcess是什么进程"><a href="#awesomiumProcess是什么进程" class="headerlink" title="awesomiumProcess是什么进程"></a>awesomiumProcess是什么进程</h2><p>在Windows任务管理器中的相应进程上右键–打开文件位置，发现是MarkDownPad2自带的程序。</p><p>推广一下，就是手动查看进程中是否存在可疑程序。。。</p><h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><h2 id="批处理脚本bat中文乱码"><a href="#批处理脚本bat中文乱码" class="headerlink" title="批处理脚本bat中文乱码"></a>批处理脚本bat中文乱码</h2><p>面对这个情况是编码不同问题，所以在最开始就应该把编码修正，支持中文的编码是<code>ANSI</code>。</p><p>我们第一步是<strong>新建一个txt文件</strong>。用记事本打开，将原来的bat文件内容拷贝过来，然后选择“<strong>文件”=&gt;“另存为”</strong>。</p><p>cmd中的编码方式为ANSI，若中文不是此编码方式则会出现乱码。所以我们<strong>在编码的时候选择“ANSI”</strong>。</p><h1 id="photoshop"><a href="#photoshop" class="headerlink" title="photoshop"></a>photoshop</h1><h2 id="ps修改图片上的文字"><a href="#ps修改图片上的文字" class="headerlink" title="ps修改图片上的文字"></a>ps修改图片上的文字</h2><h3 id="删去文字"><a href="#删去文字" class="headerlink" title="删去文字"></a>删去文字</h3><p>先选择图层，再选择一个区域后，按delete删除。</p><p>取消当前图层的选区： <code>ctrl + D</code><br>参考自：<a href="https://jingyan.baidu.com/article/456c463b6e5e3a0a5831440e.html" target="_blank" rel="external">ps取消选区快捷键</a></p><h3 id="添加横的文字"><a href="#添加横的文字" class="headerlink" title="添加横的文字"></a>添加横的文字</h3><p>选择添加文本的按钮输入文字，但是不可以旋转（我要变成竖直的文字）。</p><p>按组合键<code>Ctrl + T</code>或者点击编辑菜单下的【自由变换】，进入文字调整。<br>具体参考：<a href="https://zhidao.baidu.com/question/227531179.html" target="_blank" rel="external">ps怎么旋转一个字体</a></p><h1 id="vbox虚拟机"><a href="#vbox虚拟机" class="headerlink" title="vbox虚拟机"></a>vbox虚拟机</h1><h2 id="无法启动E-FAIL-0x80004005"><a href="#无法启动E-FAIL-0x80004005" class="headerlink" title="无法启动E_FAIL (0x80004005)"></a>无法启动E_FAIL (0x80004005)</h2><p>版本问题。回退到4.3.12之前。新版本问题多多。<br>具体参考：<a href="https://bbs.kafan.cn/thread-1798795-1-1.html" target="_blank" rel="external">Oracle VM VirtualBox 虚拟机 启动报错代码:E_FAIL (0x80004005)</a></p><h2 id="VirtualBox显示模式切换热键"><a href="#VirtualBox显示模式切换热键" class="headerlink" title="VirtualBox显示模式切换热键"></a>VirtualBox显示模式切换热键</h2><p>初用VirtualBox, 几个显示切换快捷键还是要记一下的:</p><p>Right Ctrl + F        – 切换到全屏模式<br>Right Ctrl + L        – 切换到无缝模式<br>Right Ctrl + C        – 切换到比例模式<br>Right Ctrl + Home – 显示控制菜单</p><h2 id="无缝模式是灰色的，怎么办"><a href="#无缝模式是灰色的，怎么办" class="headerlink" title="无缝模式是灰色的，怎么办"></a>无缝模式是灰色的，怎么办</h2><p>安装增强模式。相当于VMware里面的”VMware Tools”。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2017/12/29/practical_tricks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python中的部分tricks整理</title>
      <link>http://wangwlj.com/2017/12/29/python_tricks/</link>
      <guid>http://wangwlj.com/2017/12/29/python_tricks/</guid>
      <pubDate>Fri, 29 Dec 2017 03:38:07 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文整理了本人遇到的一些tricks。主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;pycharm快捷键整理&lt;/li&gt;
&lt;li&gt;爬虫中的日志记录(logging)、取消SSL警告、字符过滤(re.sub)与查找(find)、文件删除(os)与文件保存(pickle)、词云(wordcloud)的使用&lt;/li&gt;
&lt;li&gt;图像处理的部分基本操作(PIL,numpy)。&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本文整理了本人遇到的一些tricks。主要包括：</p><ul><li>pycharm快捷键整理</li><li>爬虫中的日志记录(logging)、取消SSL警告、字符过滤(re.sub)与查找(find)、文件删除(os)与文件保存(pickle)、词云(wordcloud)的使用</li><li>图像处理的部分基本操作(PIL,numpy)。</li></ul><a id="more"></a><h2 id="0-pycharm-快捷键"><a href="#0-pycharm-快捷键" class="headerlink" title="0 pycharm 快捷键"></a>0 pycharm 快捷键</h2><h3 id="注释-反注释"><a href="#注释-反注释" class="headerlink" title="注释/反注释"></a>注释/反注释</h3><p> <code>Ctrl+斜杠</code>，也就是 <code>Ctrl + /</code> 注释与反注释都是这个组合键。</p><h3 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a>块注释</h3><p><code>Ctrl+Shift+斜杠</code></p><h3 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h3><p><code>ctrl + alt + F</code>: 格式化代码(用了JetBrains的IDE之后就习惯性地格式化一下)，代码规范化。</p><h3 id="复制当前行"><a href="#复制当前行" class="headerlink" title="复制当前行"></a>复制当前行</h3><p><code>Ctrl + D</code>复制当前行</p><h3 id="另起一行"><a href="#另起一行" class="headerlink" title="另起一行"></a>另起一行</h3><p><code>shift + enter</code> : 向下另起一行，光标在行内任意位置都能另起一行，且不破坏当行结构<br><code>ctrl + alt + enter</code> : 向上另起一行</p><h3 id="查看注释"><a href="#查看注释" class="headerlink" title="查看注释"></a>查看注释</h3><p><code>Ctrl + q</code>: help 查注释，查询documentation</p><h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><p><code>ctrl + shift + a</code> : 搜索功能: 搜索IDE功能，比如想看看这个文件的历史，就键入history 可以找到 Local history</p><h3 id="万能提示键"><a href="#万能提示键" class="headerlink" title="万能提示键"></a>万能提示键</h3><p><code>ctrl + alt + space</code>: 万能提示键(在Keymap中搜索basic可以找到并修改它)PyCharm的会根据上下文提供补全。</p><h3 id="run相关的快捷键"><a href="#run相关的快捷键" class="headerlink" title="run相关的快捷键"></a>run相关的快捷键</h3><p>根据具体设置可能略有差异，笔者采用的是<br>VS风格（可在<code>File-&gt;Settings-&gt;Keymap</code>中设置）的快捷键。<br><code>ctrl + F9</code> : run the current file （跑当前页面的程序）<br><code>F9</code> :　resume the program (中断后)重新开始程序<br><code>ctrl + F5</code>: run the specific program(直接跑上一个程序)<br><code>F5</code>： debug（弹出debug目录，自行选择运行的文件）<br><code>alt + shift + F10</code> : 运行程序（弹出run目录）</p><h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><p><code>ctrl + shift + 数字键</code> 与 <code>ctrl + 数字键</code> : 书签功能<br><code>Ctrl + 鼠标点击</code>  ： 查看内置函数啥的<br><code>alt + 上下箭头</code> : <code>preview/next method (def/class)</code><br>debug的时候可以在断点打开Python console然后改变量值<br><code>Ctrl+ B</code>和<code>shift + →</code>，查看源码时很方便，至少在vim下看库的源码没那么容易。对Python程序员而言，看源码很重要<br><code>shift + F6</code> : 重命名，这太重要了，vim没有吧。即使有，那它也没法重构Flask和Django的template下的指令吧。</p><h2 id="1-python信息同时输出到控制台与文件"><a href="#1-python信息同时输出到控制台与文件" class="headerlink" title="1 python信息同时输出到控制台与文件"></a>1 python信息同时输出到控制台与文件</h2><h3 id="1-1-问题"><a href="#1-1-问题" class="headerlink" title="1.1 问题"></a>1.1 问题</h3><p>python编程中，往往需要将结果用print等输出，如果希望输出既可以显示到IDE的屏幕上，也能存到文件中（如txt）中，该怎么办呢？</p><h3 id="1-2-解决方案"><a href="#1-2-解决方案" class="headerlink" title="1.2 解决方案"></a>1.2 解决方案</h3><p>可通过日志<code>logging</code>模块输出信息到文件或屏幕。但可能要设置log的level或输出端，对于同时需要记录<code>debug error</code>等信息的较为合适，官方教程推荐学习用更规范的logger来操作。<br>例如,可参考来自官网的这段代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line">logging.basicConfig(filename=<span class="string">'log_examp.log'</span>,level=logging.DEBUG)</div><div class="line">logging.debug(<span class="string">'This message should go to the log file'</span>)</div><div class="line">logging.info(<span class="string">'So should this'</span>)</div><div class="line">logging.warning(<span class="string">'And this, too'</span>)</div></pre></td></tr></table></figure></p><p>其中的<code>level=logging.DEBUG</code>会显示Debug调试信息，若想显示普通的输出信息，可以换成<code>level=logging.INFO</code>。</p><table class="table table-bordered table-striped table-condensed"><br>    <tr><br>        <th>程度</th><br>        <th>使用场景</th><br>    </tr><br>    <tr><br>        <td>DEBUG</td><br>        <td>获得诊断问题是具体的信息</td><br>    </tr><br>    <tr><br>        <td>INFO</td><br>        <td>确认程序是否按正常工作</td><br>    </tr><br>    <tr><br>        <td>WARNING</td><br>        <td>在程序还正常运行时获取发生的意外的信息，这可能会在之后引发异常（例如磁盘空间不足）</td><br>    </tr><br>    <tr><br>        <td>ERROR</td><br>        <td>获取程序某些功能无法正常调用这类严重异常的信息</td><br>    </tr><br>    <tr><br>        <td>CRITICAL</td><br>        <td>获取程序无法继续运行的这类最严重异常信息</td><br>    </tr><br></table> <h3 id="1-3-改变默认输出信息的格式"><a href="#1-3-改变默认输出信息的格式" class="headerlink" title="1.3 改变默认输出信息的格式"></a>1.3 改变默认输出信息的格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging</div><div class="line"><span class="comment"># output format: output time - logging level - log messages</span></div><div class="line">logging.basicConfig(format=<span class="string">'%(asctime)s - %(levelname)s - %(message)s'</span>)</div><div class="line">logging.warning(<span class="string">'This message will appear in python console.'</span>)</div></pre></td></tr></table></figure><p>在<code>python console</code>中直接打印以下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2016-8-2 2:59:11, 510 - WARNING - This message will appear in python console</div></pre></td></tr></table></figure><h2 id="2-Python中将打印输出导向日志文件"><a href="#2-Python中将打印输出导向日志文件" class="headerlink" title="2 Python中将打印输出导向日志文件"></a>2 Python中将打印输出导向日志文件</h2><p>利用<code>sys.stdout</code>将print行导向到你定义的日志文件中，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="comment"># make a copy of original stdout route</span></div><div class="line">stdout_backup = sys.stdout</div><div class="line"><span class="comment"># define the log file that receives your log info</span></div><div class="line">log_file = open(<span class="string">"message.log"</span>, <span class="string">"w"</span>)</div><div class="line"><span class="comment"># redirect print output to log file</span></div><div class="line">sys.stdout = log_file</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Now all print info will be written to message.log"</span></div><div class="line"><span class="comment"># any command line that you will execute</span></div><div class="line">...</div><div class="line"></div><div class="line">log_file.close()</div><div class="line"><span class="comment"># restore the output to initial pattern</span></div><div class="line">sys.stdout = stdout_backup</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Now this will be presented on screen"</span></div></pre></td></tr></table></figure><p>这样子只会打印到日志文件，而控制台没有输出了，笔者一般不采用这种方法。</p><h2 id="3-python3使用requests请求HTTPS取消SSL验证警告"><a href="#3-python3使用requests请求HTTPS取消SSL验证警告" class="headerlink" title="3 python3使用requests请求HTTPS取消SSL验证警告"></a>3 python3使用requests请求HTTPS取消SSL验证警告</h2><h3 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a>3.1 问题描述</h3><p>使用<code>requests</code>库请求<code>HTTPS</code>时,因为忽略证书验证,导致每次运行时都会报错（警告）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">D:\python\Python35\lib\site-packages\urllib3\connectionpool.py:858: InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings</div><div class="line"> InsecureRequestWarning)</div></pre></td></tr></table></figure></p><h3 id="3-2-解决方法"><a href="#3-2-解决方法" class="headerlink" title="3.2 解决方法"></a>3.2 解决方法</h3><blockquote><p>虽然这并不影响结果的正确，但是这个提示一直存在，看着是真的别扭，尤其需要输出到报告或者是日志的时候。代码加入下面两行，取消这个警告。</p></blockquote><p>添加如下的这两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> requests.packages.urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning </div><div class="line"></div><div class="line">requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</div></pre></td></tr></table></figure><blockquote><p>python3也可以的。我的pycharm中会显示找不到该库，不过没问题，依旧可以跑，应该是pycharm本身的问题。</p></blockquote><h2 id="4-python过滤中文、英文标点特殊符号"><a href="#4-python过滤中文、英文标点特殊符号" class="headerlink" title="4. python过滤中文、英文标点特殊符号"></a>4. python过滤中文、英文标点特殊符号</h2><h3 id="4-1-垃圾邮件过滤实例"><a href="#4-1-垃圾邮件过滤实例" class="headerlink" title="4.1 垃圾邮件过滤实例"></a>4.1 垃圾邮件过滤实例</h3><p>下面是一封垃圾邮件的过滤实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;想做/ 兼_职/学生_/ 的 、加,我Q：  1 5.  8 0. ！！？？  8 6 。0.  2。 3     有,惊,喜,哦&quot;</div></pre></td></tr></table></figure><p>邮件中的“<code>！？。、</code>”都是中文的，而“/.”是英文的</p><p>下面是采用re正则项过滤方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">temp = <span class="string">"想做/ 兼_职/学生_/ 的 、加,我Q：  1 5.  8 0. ！！？？  8 6 。0.  2。 3     有,惊,喜,哦"</span></div><div class="line">temp = temp.decode(<span class="string">"utf8"</span>) </div><div class="line">string = re.sub(<span class="string">"[\s+\.\!\/_,$%^*(+\"\']+|[+——！，。？、~@#￥%……&amp;*（）]+"</span>, <span class="string">""</span>, temp) <span class="comment"># 将temp中若存在的前面的这一长串替换为空的。</span></div><div class="line">print(string)</div></pre></td></tr></table></figure><h3 id="4-2-目录名称过滤实例"><a href="#4-2-目录名称过滤实例" class="headerlink" title="4.2 目录名称过滤实例"></a>4.2 目录名称过滤实例</h3><p>此外，比如说目录命名时，也需要过滤掉<code>/|</code>等，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dirName = re.sub(<span class="string">"[\s+\.\!\/_,$%^*(+\"\'?]+|[+——！，。？、~@#￥%……&amp;*（）]+"</span>, <span class="string">""</span>, dirName)</div><div class="line">os.mkdir(dirName)</div></pre></td></tr></table></figure></p><h2 id="5-Markdown之表格table的处理"><a href="#5-Markdown之表格table的处理" class="headerlink" title="5. Markdown之表格table的处理"></a>5. Markdown之表格table的处理</h2><p>插入表格代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"table table-bordered table-striped table-condensed"</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>雾霾<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  </div><div class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>暴雨<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </div><div class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p><p>发现table加了个class属性，如果只是table标签 将不起作用。</p><pre><code>table-bordered：带圆角边框和竖线table-striped：奇偶行颜色不同table-condensed：压缩行距</code></pre><p>除了以上另外还有其他可供选择：</p><p>1、如果需要表头跟内容不一样，可以将<code>&lt;td&gt;</code>表头内容<code>&lt;/td&gt;</code>换成<code>&lt;th&gt;</code>表头内容<code>&lt;/th&gt;</code>。</p><p>2、如果表格内文需要换行，可以在要换行的内容后加入<code>&lt;br&gt;</code>，后面的内容就会跑到下一行。</p><p>3、如果内文中有代码，需要特别显示，可使用：<code>&lt;code&gt;代码&lt;/code&gt;</code>。</p><p>4、如果表格中有需要设为斜体的内容，可使用：<code>&lt;I&gt;要设为斜体的内容&lt;/I&gt;</code>。</p><p>5、如果有跨行或者跨列的单元格，可用<code>&lt;th colspan=&quot;跨列数&quot;&gt;内容&lt;/th&gt;</code>或<code>rowspan</code>。</p><p>6、如果要调整某一列的宽度，可使用：<code>&lt;th width=&quot;宽度值或百分比&quot;&gt;表头内容&lt;/th&gt;</code>。</p><h2 id="6-用numpy打开图像和保存图像"><a href="#6-用numpy打开图像和保存图像" class="headerlink" title="6. 用numpy打开图像和保存图像"></a>6. 用numpy打开图像和保存图像</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-    </span></div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image    </div><div class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *    </div><div class="line"><span class="keyword">from</span> PCV.tools <span class="keyword">import</span> imtools    </div><div class="line"><span class="keyword">import</span> numpy  </div><div class="line"></div><div class="line">im = array(Image.open(<span class="string">'C:/pic/train2/1.jpg'</span>).convert(<span class="string">'L'</span>))  <span class="comment"># 打开图像，并转成灰度图像    </span></div><div class="line">img11=Image.fromarray(uint8(im))  </div><div class="line">img11.save(<span class="string">"C:/pic/train2/10.jpg"</span>)<span class="comment"># 保存灰度图像</span></div></pre></td></tr></table></figure><p>补充用opencv打开和保存图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8    </span></div><div class="line"><span class="keyword">import</span> cv2    </div><div class="line"></div><div class="line">img = cv2.imread(<span class="string">"C:/pic/train1/2.jpg"</span>, <span class="number">0</span>)     </div><div class="line">cv2.imwrite(<span class="string">'C:/pic/1/5.jpg'</span>,img)</div></pre></td></tr></table></figure><h2 id="7-PIL-Image转换为OpenCV支持的Image格式"><a href="#7-PIL-Image转换为OpenCV支持的Image格式" class="headerlink" title="7. PIL.Image转换为OpenCV支持的Image格式"></a>7. PIL.Image转换为OpenCV支持的Image格式</h2><p>可参考：<a href="http://www.mobibrw.com/2017/7381" target="_blank" rel="external">http://www.mobibrw.com/2017/7381</a></p><p>后来放弃了。不太方便。</p><h2 id="8-使用pickle把数据保存到文件"><a href="#8-使用pickle把数据保存到文件" class="headerlink" title="8. 使用pickle把数据保存到文件"></a>8. 使用pickle把数据保存到文件</h2><h3 id="8-1-实例一"><a href="#8-1-实例一" class="headerlink" title="8.1 实例一"></a>8.1 实例一</h3><p>使用pickle模块从文件中重构python对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pprint, pickle</div><div class="line"></div><div class="line">pkl_file = open(<span class="string">'data.pkl'</span>, <span class="string">'rb'</span>)</div><div class="line"></div><div class="line">data1 = pickle.load(pkl_file)</div><div class="line">pprint.pprint(data1)</div><div class="line"></div><div class="line">data2 = pickle.load(pkl_file)</div><div class="line">pprint.pprint(data2)</div><div class="line"></div><div class="line">pkl_file.close()</div></pre></td></tr></table></figure></p><h3 id="8-2-实例二"><a href="#8-2-实例二" class="headerlink" title="8.2 实例二"></a>8.2 实例二</h3><p>其中，friend是从网页获得的数据，先保存下来，以备后续处理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取好友列表</span></div><div class="line">friends = itchat.get_friends(update=<span class="keyword">True</span>)[<span class="number">0</span>:]</div><div class="line"></div><div class="line">output = open(<span class="string">'data.pkl'</span>, <span class="string">'wb'</span>)</div><div class="line"><span class="comment"># Pickle dictionary using protocol 0.</span></div><div class="line">pickle.dump(friends, output)</div><div class="line">output.close()</div></pre></td></tr></table></figure></p><p>读取保存的文件，用于后续处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pickle, re</div><div class="line"></div><div class="line">pkl_file = open(<span class="string">'data.pkl'</span>, <span class="string">'rb'</span>)</div><div class="line">friends = pickle.load(pkl_file)</div></pre></td></tr></table></figure><h2 id="9-解决Python词云库wordcloud不显示中文的问题"><a href="#9-解决Python词云库wordcloud不显示中文的问题" class="headerlink" title="9. 解决Python词云库wordcloud不显示中文的问题"></a>9. 解决Python词云库wordcloud不显示中文的问题</h2><h3 id="9-1-安装"><a href="#9-1-安装" class="headerlink" title="9.1 安装"></a>9.1 安装</h3><p>安装命令：</p><blockquote><p>pip install wordcloud</p></blockquote><h3 id="9-2-解决方案"><a href="#9-2-解决方案" class="headerlink" title="9.2 解决方案"></a>9.2 解决方案</h3><p>实例代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">text = <span class="string">'''文案 文案</span></div><div class="line"><span class="string">The  抱抱 Zen of LOVE 抱抱 Python, 快乐 by Tim Peters</span></div><div class="line"><span class="string">公众号 公众号 Python 最好的 语言 语言</span></div><div class="line"><span class="string">一辈子 is better LOVE than 一辈子.</span></div><div class="line"><span class="string">喵小姐 is 爱你 than  implicit.爱你 喵小姐</span></div><div class="line"><span class="string">蟹先生 is 爱你 than complex.</span></div><div class="line"><span class="string">一辈子 is 蟹先生  than complicated.</span></div><div class="line"><span class="string">二中 is 喵小姐 我想你了 than nested. 二中 蟹先生</span></div><div class="line"><span class="string">清湖 is 胜于 than 清湖.</span></div><div class="line"><span class="string">思旺 counts. 想你</span></div><div class="line"><span class="string">Special 喵小姐 我想你了 aren't special enough 思旺 break 思旺 rules.</span></div><div class="line"><span class="string">别生气 practicality beats 厨艺好.</span></div><div class="line"><span class="string">Errors should 我想你了 never pass 小龙虾 silently. 运营</span></div><div class="line"><span class="string">别生气 explicitly 好不好. LOVE</span></div><div class="line"><span class="string">In the face of ambiguity, 程序员 the 厨艺好 to guess.龙华 龙华</span></div><div class="line"><span class="string">There 快乐 should be one-- 我想你了 and preferably 红烧肉 only one 小龙虾--obvious way to do it.运营</span></div><div class="line"><span class="string">Although 共享单车 way may not 我想你了 be obvious at first unless you're Dutch. 新媒体 地铁</span></div><div class="line"><span class="string">Now is better 红烧肉 than never.</span></div><div class="line"><span class="string">程序员 Although 共享单车 is often 高铁 than 东莞 now. 高铁 地铁</span></div><div class="line"><span class="string">If the implementation 想你 is hard to explain, it's a bad idea. 想你了</span></div><div class="line"><span class="string">If 成都 implementation is 想你 easy to explain, it may be a good idea.</span></div><div class="line"><span class="string">Namespaces are 端午one 端午 honking great idea -- 成都 do more of those! 想你了</span></div><div class="line"><span class="string">深圳 晚安 深圳 新媒体</span></div><div class="line"><span class="string">'''</span></div><div class="line"></div><div class="line"><span class="comment"># the font from github: https://github.com/adobe-fonts</span></div><div class="line">font = <span class="string">r'C:\Windows\Fonts\simfang.ttf'</span></div><div class="line">wc = WordCloud(collocations=<span class="keyword">False</span>, font_path=font, width=<span class="number">1400</span>, height=<span class="number">1400</span>, margin=<span class="number">2</span>).generate(text.lower())</div><div class="line"></div><div class="line">plt.imshow(wc)</div><div class="line">plt.axis(<span class="string">"off"</span>)</div><div class="line">plt.show()</div><div class="line"></div><div class="line">wc.to_file(<span class="string">'show_Chinese.png'</span>)  <span class="comment"># 把词云保存下来</span></div></pre></td></tr></table></figure></p><h2 id="10-PIL库图片基本操作"><a href="#10-PIL库图片基本操作" class="headerlink" title="10. PIL库图片基本操作"></a>10. PIL库图片基本操作</h2><p>1.打开图片<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Image</div><div class="line">img=Image.open(<span class="string">"code.jpg"</span>)</div></pre></td></tr></table></figure></p><p>注：有些图片名称是包含中文的，就需要在“”前加上u，例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">img=Image.open(<span class="string">u"阿布.jpg"</span>)</div></pre></td></tr></table></figure></p><p>2.展示图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">img.show()</div></pre></td></tr></table></figure><p>3.保存图片<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">img.save(<span class="string">"img1.png"</span>,<span class="string">"png"</span>)</div></pre></td></tr></table></figure></p><p>说明：img为一个图片，存为一个名叫img1的图片，格式为png。后面的png不写也可以，直接按照文件名的后缀.png存为相应格式了。</p><p>4.旋转图片rotate</p><pre><code>fixedIm=img.rotate(90)fixedIm.save(&quot;fixedIm.png&quot;,&quot;png&quot;)</code></pre><p>说明：<code>fixedIm=img.rotate(90)</code>，将图片img逆时针旋转90度，存到fixedIm中。</p><p>更多操作可参考:<br><a href="http://www.cnblogs.com/meitian/p/3699223.html" target="_blank" rel="external">http://www.cnblogs.com/meitian/p/3699223.html</a></p><h2 id="python删除文件"><a href="#python删除文件" class="headerlink" title="python删除文件"></a>python删除文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">   <span class="comment"># 删除文件： </span></div><div class="line">os.remove()</div><div class="line"><span class="comment">#删除空目录： </span></div><div class="line">os.rmdir()</div><div class="line">   <span class="comment"># 递归删除空目录： </span></div><div class="line">os.removedirs()</div></pre></td></tr></table></figure><p>递归删除目录和文件（类似DOS命令DeleteTree）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Delete everything reachable from the directory named in 'top',</span></div><div class="line"><span class="comment"># assuming there are no symbolic links.</span></div><div class="line"><span class="comment"># CAUTION:  This is dangerous!  For example, if top == '/', it</span></div><div class="line"><span class="comment"># could delete all your disk files.</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(top, topdown=<span class="keyword">False</span>):</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> files:</div><div class="line">        os.remove(os.path.join(root, name))</div><div class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> dirs:</div><div class="line">        os.rmdir(os.path.join(root, name))</div></pre></td></tr></table></figure></p><p>参考自：<a href="http://www.cnblogs.com/SophiaTang/archive/2012/01/16/2323467.html" target="_blank" rel="external">python 删除文件</a></p><h2 id="Python3-find-方法"><a href="#Python3-find-方法" class="headerlink" title="Python3 find()方法"></a>Python3 find()方法</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>find()</code>方法检测字符串中是否包含子字符串str，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定索引值，返回的是索引值在字符串中的起始位置。如果不包含索引值，返回-1。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>find()方法语法：</p><blockquote><p>str.find(str, beg=0, end=len(string))</p></blockquote><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>str：指定检索的字符串<br>beg：开始索引，默认为0。<br>end：结束索引，默认为字符串的长度。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>如果包含子字符串返回开始的索引值，否则返回-1。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例展示了find()方法的实例(Python 3.0+)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python3</span></div><div class="line"> </div><div class="line">str1 = <span class="string">"Runoob example....wow!!!"</span></div><div class="line">str2 = <span class="string">"exam"</span>;</div><div class="line"> </div><div class="line"><span class="keyword">print</span> (str1.find(str2))</div><div class="line"><span class="keyword">print</span> (str1.find(str2, <span class="number">5</span>))</div><div class="line"><span class="keyword">print</span> (str1.find(str2, <span class="number">10</span>))</div></pre></td></tr></table></figure><p>以上实例输出结果如下：</p><blockquote><p>7</p><p>7</p><p>-1</p></blockquote><p>实例(Python 3.0+)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;info = <span class="string">'abca'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(info.find(<span class="string">'a'</span>))      <span class="comment"># 从下标0开始，查找在字符串里第一个出现的子串，返回结果：0</span></div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(info.find(<span class="string">'a'</span>, <span class="number">1</span>))   <span class="comment"># 从下标1开始，查找在字符串里第一个出现的子串：返回结果3</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(info.find(<span class="string">'3'</span>))      <span class="comment"># 查找不到返回-1</span></div><div class="line"><span class="number">-1</span></div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://blog.csdn.net/woaik110/article/details/52444427" target="_blank" rel="external">python 信息同时输出到控制台与文件</a></li><li><a href="http://www.cnblogs.com/arkenstone/p/5727883.html" target="_blank" rel="external">Python中将打印输出导向日志文件</a></li><li><a href="http://blog.csdn.net/m1mory/article/details/56029638" target="_blank" rel="external">python requests报错InsecureRequestWarning的解决方案</a></li><li><a href="http://blog.csdn.net/xie_0723/article/details/53424809" target="_blank" rel="external">Python requests移除SSL认证，控制台输出InsecureRequestWarning取消方法</a></li><li><a href="http://blog.csdn.net/mach_learn/article/details/41744487" target="_blank" rel="external">python 过滤中文、英文标点特殊符号</a></li><li><a href="http://blog.csdn.net/itmyhome1990/article/details/44085539" target="_blank" rel="external">Markdown之表格table的处理</a></li><li><a href="http://blog.csdn.net/txiaomiao/article/details/50967223" target="_blank" rel="external">用numpy打开图像和保存图像</a></li><li><a href="http://www.cnblogs.com/pzxbc/archive/2012/03/18/2404715.html" target="_blank" rel="external">pickle模块的基本使用</a></li><li><a href="http://blog.csdn.net/xiemanr/article/details/72796739" target="_blank" rel="external">词云库wordcloud显示中文</a></li><li><a href="http://www.runoob.com/python3/python3-string-find.html" target="_blank" rel="external">Python3 find()方法</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2017/12/29/python_tricks/#disqus_thread</comments>
    </item>
    
    <item>
      <title>基于TensorFlow的简单语音识别</title>
      <link>http://wangwlj.com/2017/12/28/TensorFlow_speech_commands/</link>
      <guid>http://wangwlj.com/2017/12/28/TensorFlow_speech_commands/</guid>
      <pubDate>Thu, 28 Dec 2017 14:24:03 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;简单语音识别教程&quot;&gt;&lt;a href=&quot;#简单语音识别教程&quot; class=&quot;headerlink&quot; title=&quot;简单语音识别教程&quot;&gt;&lt;/a&gt;简单语音识别教程&lt;/h2&gt;&lt;p&gt;虽然真正的语音和音频识别系统要复杂得多，但是像MNIST（入门级的CV数据集）一样，本教程应该会让你对所涉技术有一个基本的了解。&lt;/p&gt;
&lt;p&gt;完成本教程后，你将可以尝试创建一个模型，将一秒钟的音频剪辑去噪，并且能识别如下单词： &lt;code&gt;“yes”，“no”，“up”，“down”，&amp;quot;left&amp;quot;，&amp;quot;right&amp;quot;，&amp;quot;on&amp;quot;，&amp;quot;off&amp;quot;，&amp;quot;stop&amp;quot;，or &amp;quot;go&amp;quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你也可以在Android应用程序中运行该模型。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简单语音识别教程"><a href="#简单语音识别教程" class="headerlink" title="简单语音识别教程"></a>简单语音识别教程</h2><p>虽然真正的语音和音频识别系统要复杂得多，但是像MNIST（入门级的CV数据集）一样，本教程应该会让你对所涉技术有一个基本的了解。</p><p>完成本教程后，你将可以尝试创建一个模型，将一秒钟的音频剪辑去噪，并且能识别如下单词： <code>“yes”，“no”，“up”，“down”，&quot;left&quot;，&quot;right&quot;，&quot;on&quot;，&quot;off&quot;，&quot;stop&quot;，or &quot;go&quot;</code>。</p><p>你也可以在Android应用程序中运行该模型。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>你要确保已经安装了TensorFlow，由于该版本下载了超过1GB的训练数据，因此你需要电脑有足够的内存，另外网速要快，训练过程可能需要几个小时。</p><h2 id="出错与解决"><a href="#出错与解决" class="headerlink" title="出错与解决"></a>出错与解决</h2><h3 id="找不到audio-ops"><a href="#找不到audio-ops" class="headerlink" title="找不到audio_ops"></a>找不到audio_ops</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"train.py"</span>, line <span class="number">79</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    <span class="keyword">import</span> input_data</div><div class="line">  File <span class="string">"/home/philglau/speech_commands/input_data.py"</span>, line <span class="number">35</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    <span class="keyword">from</span> tensorflow.contrib.framework.python.ops <span class="keyword">import</span> audio_ops <span class="keyword">as</span> contrib_audio</div><div class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">'audio_ops'</span></div></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个’audio_ops’只在TensorFlow1.4版本中有，所以，如果不是1.4的版本，一般都会有这个错误。</p><p>此时的解决方案，一是更新TensorFlow版本，二是使用如下命令安装tf-nightly即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tf-nightly</div></pre></td></tr></table></figure><p>详见参考连接三。</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>要开始训练过程，请访问<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">TensorFlow源代码树</a>下载并运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python tensorflow/examples/speech_commands/train.py</div></pre></td></tr></table></figure><p>训练过程将从下载“ 语音命令”数据集开始，该数据集由65000个WAVE音频文件组成，其中有30个不同的单词。</p><p>这些数据是由Google收集的，并根据CCBY许可证发布。存档超过1GB，所以下载可能需要一段时间，但你应该能看到进度日志，一旦下载完成，你就不用再次执行此步骤了。</p><p>下载完成后，你将看到如下所示的日志记录信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I0730 16:53:44.766740 55030 train.py:176] Training from step: 1</div><div class="line"></div><div class="line">I0730 16:53:47.289078 55030 train.py:217] Step #1: rate 0.001000, accuracy 7.0%, cross entropy 2.611571</div></pre></td></tr></table></figure><p>这表明初始化过程已经完成，循环训练已经开始。你会看到它输出每个训练步骤的信息。</p><p>步骤分解：</p><p>Step #1表明我们正在循环训练的第一步。在这种情况下，总共将有18000个步骤，所以你可以查看步骤号码，了解其完成程度有多接近。</p><p>rate 0.001000是控制网络权重更新速度的学习率。早期的这个数字是相对较高的（0.001），但是对于后来的训练周期，它会减少10倍到0.0001。</p><p><code>accuracy 7.0%</code>在这个训练步骤中正确地预测了有多少classes。value函数往往波动很大，但随着训练的进行，平均值会增加。该模型输出一个数字数组，每个标签一个，每个数字是该类输入的预测可能性。</p><p>通过选择具有最高分数的条目来选择预测的标签，分数总是在零和一之间。</p><p><code>cross entropy 2.611571</code>是我们用来指导培训过程的损失功能的结果。这是通过比较当前训练运动与正确标签的分数向量获得的分数，这在训练期间应该向下倾斜。</p><p>经过一百步，你应该看到这样的一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I0730 16:54:41.813438 55030 train.py:252] Saving to &quot;/tmp/speech_commands_train/conv.ckpt-100&quot;</div></pre></td></tr></table></figure></p><p>这是将当前训练的权重保存到checkpoint文件中。如果你的训练脚本中断，可以查找最后保存的checkpoint，然后：<br><code>--start_checkpoint=/tmp/speech_commands_train/conv.ckpt-100</code>使用命令行参数重新启动脚本， 从那里开始。</p><h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p>四百步后，将记录以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">I0730 16:57:38.073667 55030 train.py:243] Confusion Matrix:</div><div class="line"></div><div class="line">[[258 0  0  0  0 0  0 0  0  0 0 0]</div><div class="line"></div><div class="line">[  7  6  26 94  7 49 1 15 40 2 0 11]</div><div class="line"></div><div class="line">[ 10  1 107 80 13 22 0 13 10 1 0  4]</div><div class="line"></div><div class="line">[ 1  3  16 163  6 48 0  5 10 1 0  17]</div><div class="line"></div><div class="line">[ 15 1  17 114 55 13 0  9 22 5 0  9]</div><div class="line"></div><div class="line">[ 1  1  6  97  3  87 1 12 46 0 0  10]</div><div class="line"></div><div class="line">[ 8  6 86  84 13  24 1  9  9 1 0  6]</div><div class="line"></div><div class="line">[ 9  3 32 112  9  26 1 36 19 0 0  9]</div><div class="line"></div><div class="line">[ 8  2 12  94  9  52 0  6 72 0 0  2]</div><div class="line"></div><div class="line">[ 16 1 39  74 29  42 0  6 37 9 0  3]</div><div class="line"></div><div class="line">[ 15 6 17  71 50  37 0  6 32 2 1  9]</div><div class="line"></div><div class="line">[ 11 1  6 151 5   42 0  8 16 0 0 20]]</div></pre></td></tr></table></figure></p><p>第一部分是<strong>混淆矩阵</strong>。要了解这是什么意思，你首先需要知道正在使用的标签，在这种情况下，它们分别表示为<code>静音、未知yes、no、up、down、left、right、on、off、stop、go</code>。</p><p>第一行是所有的静音剪辑，第二个剪辑是未知的单词，第三个“yes”等。</p><p>该矩阵可以比单个准确率得分更有用，因为它可以很好地总结出网络发生的错误。在此示例中，你可以看到除了初始条目之外，第一行中的所有条目都为零。</p><p>因为第一行实际上都是静音的片段，所以这意味着它们都没有被错误的标注为文字，所以我们没有任何静音的否定。这表明网络已经越来越好地区分了静音与谈话。</p><p><strong>一个完美的模型将产生一个混淆矩阵，其中所有的条目都是从对角线穿过中心的零点</strong>。一旦你确定了可以通过添加更多数据来解决问题，该模型的方差可以帮助你了解模型怎样最容易混淆。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>混淆矩阵之后，你会看到如下一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I0730 16:57:38.073777 55030 train.py:245] Step 400: Validation accuracy = 26.3% (N=3093)</div></pre></td></tr></table></figure></p><p>将数据集分为三类是很好的做法。最大的（大约是数据的80％）用于训练网络，一个较小的集（10％ “validation”）被保留用于评估训练中的准确性，另一组10％，“testing”）用于在训练完成后评估准确度。</p><p>通过将数据集分类为训练集、验证集、测试集，你可以确保该模型适用于之前从未见过的数据。测试集是一个额外的保障措施，以确保不仅仅是以适用于训练和验证集拟合调整模型。</p><p>训练脚本将数据集自动分成这三个类别，上面的记录行显示了在验证集上运行时的模型准确率。理想情况下，这应该与训练准确性相当接近。如果训练准确性增加但验证不是这样，这表明过度拟合正在发生，你的模型只是学习关于训练剪辑的东西，而不是真正的训练模式。</p><h2 id="Tensorboard"><a href="#Tensorboard" class="headerlink" title="Tensorboard"></a>Tensorboard</h2><p>使用Tensorboard可以看出训练进展。默认情况下，脚本将事件保存到/ tmp / retrain_logs，可以通过运行以下命令来加载它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tensorboard --logdir /tmp/retrain_logs</div></pre></td></tr></table></figure></p><p>然后在浏览器中导航到<code>http：// localhost：6006</code>，将看到显示模型进度的图表。</p><h2 id="完成训练"><a href="#完成训练" class="headerlink" title="完成训练"></a>完成训练</h2><p>经过几个小时的训练（取决于你的电脑快慢），脚本应该已经完成了所有18000个步骤。它将识别出最终的混淆矩阵，以及准确率分数，全部运行在测试集上。使用默认设置，准确率在85％到90％之间。</p><p>因为音频识别在移动设备上特别有用，接下来我们将其导出为，在移动平台上易于使用的格式。要执行此操作，请运行以下命令行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">python tensorflow/examples/speech_commands/freeze.py</div><div class="line"></div><div class="line">--start_checkpoint=/tmp/speech_commands_train/conv.ckpt-18000</div><div class="line"></div><div class="line">--output_file=/tmp/my_frozen_graph.pb</div></pre></td></tr></table></figure></p><p>创建固定模型后，可以使用<code>label_wav.py</code>脚本进行测试，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">python tensorflow/examples/speech_commands/label_wav.py</div><div class="line"></div><div class="line">--graph=/tmp/my_frozen_graph.pb</div><div class="line"></div><div class="line">--labels=/tmp/speech_commands_train/conv_labels.txt</div><div class="line"></div><div class="line">--wav=/tmp/speech_dataset/left/a5d485dc_nohash_0.wav</div></pre></td></tr></table></figure></p><p>可以识别出三个标签：</p><p>left (score = 0.81477)</p><p>right (score = 0.14139)</p><p>_unknown_ (score = 0.03808)</p><p>更多内容请查看论文：<a href="http://suo.im/3PW89b" target="_blank" rel="external">http://suo.im/3PW89b</a></p><h2 id="在Android应用程序中运行模型"><a href="#在Android应用程序中运行模型" class="headerlink" title="在Android应用程序中运行模型"></a>在Android应用程序中运行模型</h2><p>查看此模型在真实应用程序中如何工作的最简单的方法是，下载预构建的<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android#prebuilt-components" target="_blank" rel="external">Android演示应用程序</a>并将其安装在手机上。</p><p>你会看到“TF Speech”出现在应用程序列表中，打开它将显示我们刚刚训练过单词列表，从“yes”和“no”开始。</p><p>你还可以自己构建此应用程序，因为它是开源的， 并可作为github上TensorFlow<a href="https://github.com/tensorflow/tensorflow/tree/master/tensorflow/examples/android#building-in-android-studio-using-the-tensorflow-aar-from-jcenter" target="_blank" rel="external">存储库的一部分使用</a>。<br>默认情况下，它从tensorflow.org下载一个预先训练的模型，但你可以轻松地用自己训练的模型替换它。</p><p>如果你自己创建的话，你需要确保SpeechActivity Java<a href="http://suo.im/2fWbai" target="_blank" rel="external">源文件</a>中的 SAMPLE_RATE，SAMPLE_DURATION符合你训练时的默认设置所做的任何更改。</p><p>你还会看到一个Java版本的<a href="http://suo.im/31vKvx" target="_blank" rel="external">Rec<br>ognizeCommands模块</a>。</p><p>这与本教程中的C++版本非常相似。如果你调整了参数，还可以在SpeechActivity中进行更新，以获得与服务器测试相同的结果。</p><p>演示应用程序，根据你在固定模型复制到模型中的标签文本文件，自动更新其用户界面列表，可以轻松地尝试不同的模型，而无需进行任何代码更改。如果你更改路径，需要update LABEL_FILENAME，MODEL_FILENAME添加到文件。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.tensorflow.org/versions/master/tutorials/audio_recognition" target="_blank" rel="external">TensorFlow官网教程：Simple Audio Recognition</a></li><li><a href="http://www.sohu.com/a/167209693_798050" target="_blank" rel="external">中文翻译参考</a></li><li><a href="https://stackoverflow.com/questions/45952387/anaconda-install-of-tensorflow-missing-audio-ops-from-contrib-framework" target="_blank" rel="external">Tensorflow missing ‘audio_ops’ from contrib framework</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2017/12/28/TensorFlow_speech_commands/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TensorFlow基础篇与搭建深层神经网络</title>
      <link>http://wangwlj.com/2017/12/28/tensorflow_base/</link>
      <guid>http://wangwlj.com/2017/12/28/tensorflow_base/</guid>
      <pubDate>Thu, 28 Dec 2017 14:24:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文是 Tensorflow：实战Google深度学习框架的第三章与第四章。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本文是 Tensorflow：实战Google深度学习框架的第三章与第四章。<br><a id="more"></a></p><h1 id="第3章-TensorFlow入门"><a href="#第3章-TensorFlow入门" class="headerlink" title="第3章 TensorFlow入门"></a>第3章 TensorFlow入门</h1><h2 id="0-1-查看已安装tensorflow版本"><a href="#0-1-查看已安装tensorflow版本" class="headerlink" title="0.1 查看已安装tensorflow版本"></a>0.1 查看已安装tensorflow版本</h2><p>由于tensorflow版本不同,可能一些函数的调用也有变换,这时候可能需要查看tensorflow版本,可以在终端输入查询命令如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python //windows下cmd进入python环境，linux下终端类似</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line">tf.__version__</div></pre></td></tr></table></figure></p><p>查询tensorflow安装路径为:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tf.__path__</div></pre></td></tr></table></figure></p><p>参考自：<a href="http://blog.csdn.net/u011961856/article/details/76861052" target="_blank" rel="external">查看已安装tensorflow版本</a></p><h2 id="0-2-Tensorflow：实战Google深度学习框架-源码下载"><a href="#0-2-Tensorflow：实战Google深度学习框架-源码下载" class="headerlink" title="0.2 Tensorflow：实战Google深度学习框架 源码下载"></a>0.2 Tensorflow：实战Google深度学习框架 源码下载</h2><ul><li><a href="http://www.broadview.com.cn/book/111" target="_blank" rel="external">Tensorflow：实战Google深度学习框架</a></li><li><a href="https://github.com/caicloud/tensorflow-tutorial/tree/master/Deep_Learning_with_TensorFlow" target="_blank" rel="external">caicloud/tensorflow-tutorial</a></li></ul><h2 id="3-2-TensorFlow数据模型——张量"><a href="#3-2-TensorFlow数据模型——张量" class="headerlink" title="3.2 TensorFlow数据模型——张量"></a>3.2 TensorFlow数据模型——张量</h2><h3 id="3-2-1-张量的概念"><a href="#3-2-1-张量的概念" class="headerlink" title="3.2.1 张量的概念"></a>3.2.1 张量的概念</h3><p>一个张量中主要保存了三个属性：名字（name）、维度（shape）、类型（type）。</p><h3 id="3-2-2-张量的使用"><a href="#3-2-2-张量的使用" class="headerlink" title="3.2.2 张量的使用"></a>3.2.2 张量的使用</h3><p>两大类。</p><p>一是对中间结果的引用。</p><p>二是用来获得计算的结果。tf.Session().run(result)</p><h2 id="3-3-TensorFlow运行模型——会话"><a href="#3-3-TensorFlow运行模型——会话" class="headerlink" title="3.3 TensorFlow运行模型——会话"></a>3.3 TensorFlow运行模型——会话</h2><h3 id="3-3-1-创建和关闭会话"><a href="#3-3-1-创建和关闭会话" class="headerlink" title="3.3.1 创建和关闭会话"></a>3.3.1 创建和关闭会话</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 创建一个会话。</span></div><div class="line">sess = tf.Session()</div><div class="line"></div><div class="line"><span class="comment"># 使用会话得到之前计算的结果。</span></div><div class="line">print(sess.run(result))</div><div class="line"></div><div class="line"><span class="comment"># 关闭会话使得本次运行中使用到的资源可以被释放。</span></div><div class="line">sess.close()</div></pre></td></tr></table></figure><h3 id="3-3-2-使用with-statement-来创建会话"><a href="#3-3-2-使用with-statement-来创建会话" class="headerlink" title="3.3.2 使用with statement 来创建会话"></a>3.3.2 使用with statement 来创建会话</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">   print(sess.run(result))</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 下面的两个命令有相同的功能。</span></div><div class="line">print(sess.run(result))</div><div class="line">print(result.eval(session=sess))</div></pre></td></tr></table></figure><h3 id="3-3-3-指定默认会话"><a href="#3-3-3-指定默认会话" class="headerlink" title="3.3.3 指定默认会话"></a>3.3.3 指定默认会话</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sess = tf.Session()</div><div class="line"></div><div class="line"><span class="comment"># 下面的两个命令有相同的功能。</span></div><div class="line">print(sess.run(result))</div><div class="line">print(result.eval(session=sess))</div></pre></td></tr></table></figure><h3 id="3-3-4-通过ConfigProto配置会话"><a href="#3-3-4-通过ConfigProto配置会话" class="headerlink" title="3.3.4 通过ConfigProto配置会话"></a>3.3.4 通过ConfigProto配置会话</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">config=tf.ConfigProto(allow_soft_placement=<span class="keyword">True</span>, log_device_placement=<span class="keyword">True</span>)</div><div class="line">sess1 = tf.InteractiveSession(config=config)</div><div class="line">sess2 = tf.Session(config=config)</div></pre></td></tr></table></figure><h2 id="3-4-TensorFlow实现神经网络"><a href="#3-4-TensorFlow实现神经网络" class="headerlink" title="3.4 TensorFlow实现神经网络"></a>3.4 TensorFlow实现神经网络</h2><h3 id="3-4-2-前向传播算法简介"><a href="#3-4-2-前向传播算法简介" class="headerlink" title="3.4.2 前向传播算法简介"></a>3.4.2 前向传播算法简介</h3><p>tf.matmul 矩阵乘法</p><h3 id="3-4-3-神经网络参数与tensorflow变量"><a href="#3-4-3-神经网络参数与tensorflow变量" class="headerlink" title="3.4.3 神经网络参数与tensorflow变量"></a>3.4.3 神经网络参数与tensorflow变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">weights = tf.Variable(tf.random_normal([<span class="number">2</span>, <span class="number">3</span>], stddev=<span class="number">2</span>))</div></pre></td></tr></table></figure><p>产生一个[2,3]的矩阵，矩阵中元素是均值为0，方差为2的随机数。</p><p> <strong>1.TensorFlow随机数生成函数</strong></p><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">随机数分布</th><th style="text-align:center">主要参数</th></tr></thead><tbody><tr><td style="text-align:center">tf.random_normal</td><td style="text-align:center">正态分布</td><td style="text-align:center">平均值、标准差、取值类型</td></tr><tr><td style="text-align:center">tf.truncated_normal</td><td style="text-align:center">正太分布,但如果随机出来的值离平均值超过2个标准差，那么这个数将会被重新随机</td><td style="text-align:center">平均值、标准差、取值类型</td></tr><tr><td style="text-align:center">tf.random_uniform</td><td style="text-align:center">平均分布</td><td style="text-align:center">最小、最大取值、取值类型</td></tr><tr><td style="text-align:center">tf.random_gramma</td><td style="text-align:center">Gramma分布</td><td style="text-align:center">形状参数alpha、尺度参数beta、取值类型</td></tr></tbody></table><p> <strong>2.TensorFlow常数生成函数</strong></p><table><thead><tr><th style="text-align:center">函数名称</th><th style="text-align:center">功能</th><th style="text-align:center">样例</th></tr></thead><tbody><tr><td style="text-align:center">tf.zeros</td><td style="text-align:center">产生全0的数组</td><td style="text-align:center">tf.zeros([2,3],int32)-&gt;[[0,0,0],[0,0,0]]</td></tr><tr><td style="text-align:center">tf.ones</td><td style="text-align:center">产生全1的数组</td><td style="text-align:center">tf.ones([2,3],int32)-&gt;[[1,1,1],[1,1,1]]</td></tr><tr><td style="text-align:center">tf.fill</td><td style="text-align:center">产生一个全部为给定数字的数组</td><td style="text-align:center">tf.fill([2,3],9)-&gt;[[9,9,9],[9,9,9]]</td></tr><tr><td style="text-align:center">tf.constant</td><td style="text-align:center">产生一个给定值的常量</td><td style="text-align:center">tf.constant([1,2,3])-&gt;[1,2,3]</td></tr></tbody></table><p>声明了变量之后，程序的第二步会声明一个会话（session）。并通过会话计算结果。</p><p>在真正开始计算之前，必须对变量进行初始化：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">init_op = tf.global_variables_initializer()  </div><div class="line">sess.run(init_op)</div></pre></td></tr></table></figure></p><p>变量分为需要优化的参数（比如神经网络中的参数）和其他参数。<br><code>trainable = True</code>，则该变量会加入<code>GraphKeys.TRAINABLE_VARIABLES</code>集合。</p><p>维度（shape）和类型（type）是变量最重要的两个属性。</p><h3 id="3-4-4-通过tensorflow训练神经网络模型"><a href="#3-4-4-通过tensorflow训练神经网络模型" class="headerlink" title="3.4.4 通过tensorflow训练神经网络模型"></a>3.4.4 通过tensorflow训练神经网络模型</h3><p>监督学习的思想。</p><p>神经网络优化算法中，最常用的是反向传播算法。</p><pre><code>x = tf.constant([[0.7, 0.9]])</code></pre><p>常量表示样例导致计算图特变大。使用<strong>placeholder机制</strong>提供输入数据。</p><p>在placeholder定义的时候，这个位置上的数据类型是需要指定的。和其他张量一样，placeholder的类型不可以被改变。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x = tf.placeholder(tf.float32, shape=(<span class="number">1</span>, <span class="number">2</span>), name=<span class="string">"input"</span>)</div><div class="line">a = tf.matmul(x, w1)</div><div class="line">y = tf.matmul(a, w2)</div><div class="line"></div><div class="line">sess = tf.Session()</div><div class="line"></div><div class="line">init_op = tf.global_variables_initializer()</div><div class="line">sess.run(init_op)</div><div class="line"></div><div class="line">print(sess.run(y, feed_dict=&#123;x: [[<span class="number">0.7</span>, <span class="number">0.9</span>]]&#125;))</div></pre></td></tr></table></figure></p><p>feed_dict时一个字典（map），在字典中需要给出每个用到的placeholder的取值，否则运行会报错。</p><p>输入的数据一般是一个batch，不止一个，placeholder也支持输入多个数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x = tf.placeholder(tf.float32, shape=(<span class="number">3</span>, <span class="number">2</span>), name=<span class="string">"input"</span>)</div><div class="line">a = tf.matmul(x, w1)</div><div class="line">y = tf.matmul(a, w2)</div><div class="line"></div><div class="line">sess = tf.Session()</div><div class="line"><span class="comment">#使用tf.global_variables_initializer()来初始化所有的变量</span></div><div class="line">init_op = tf.global_variables_initializer()  </div><div class="line">sess.run(init_op)</div><div class="line"></div><div class="line">print(sess.run(y, feed_dict=&#123;x: [[<span class="number">0.7</span>,<span class="number">0.9</span>],[<span class="number">0.1</span>,<span class="number">0.4</span>],[<span class="number">0.5</span>,<span class="number">0.8</span>]]&#125;))</div></pre></td></tr></table></figure></p><p>在得到一个batch的前向传播结果之后，需要<strong>定义一个损失函数</strong>来刻画当前的预测值与真实答案之间的差距。然后通过反向传播算法来调整网络参数之间的取值使得差距可以被缩小。</p><h3 id="3-4-5-完整的神经网络样例程序"><a href="#3-4-5-完整的神经网络样例程序" class="headerlink" title="3.4.5 完整的神经网络样例程序"></a>3.4.5 完整的神经网络样例程序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> RandomState</div><div class="line"></div><div class="line"><span class="comment"># 1. 定义神经网络的参数，输入和输出节点。</span></div><div class="line">batch_size = <span class="number">8</span></div><div class="line">w1 = tf.Variable(tf.random_normal([<span class="number">2</span>, <span class="number">3</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</div><div class="line">w2 = tf.Variable(tf.random_normal([<span class="number">3</span>, <span class="number">1</span>], stddev=<span class="number">1</span>, seed=<span class="number">1</span>))</div><div class="line">x = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">2</span>), name=<span class="string">"x-input"</span>)</div><div class="line">y_ = tf.placeholder(tf.float32, shape=(<span class="keyword">None</span>, <span class="number">1</span>), name=<span class="string">'y-input'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 2. 定义前向传播过程，损失函数及反向传播算法。</span></div><div class="line">a = tf.matmul(x, w1)</div><div class="line">y = tf.matmul(a, w2)</div><div class="line"><span class="comment"># tf.clip_by_value(A, min, max)：输入一个张量A，把A中的每一个元素的值都压缩在min和max之间。小于min的让它等于min，大于max的元素的值等于max。</span></div><div class="line">cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, <span class="number">1e-10</span>, <span class="number">1.0</span>)))</div><div class="line">train_step = tf.train.AdamOptimizer(<span class="number">0.001</span>).minimize(cross_entropy)</div><div class="line"></div><div class="line"><span class="comment"># 3. 生成模拟数据集。</span></div><div class="line">rdm = RandomState(<span class="number">1</span>)</div><div class="line">dataset_size = <span class="number">128</span></div><div class="line">X = rdm.rand(dataset_size, <span class="number">2</span>)</div><div class="line">Y = [[int(x1 + x2 &lt; <span class="number">1</span>)] <span class="keyword">for</span> (x1, x2) <span class="keyword">in</span> X]</div><div class="line"></div><div class="line"><span class="comment"># 4. 创建一个会话来运行TensorFlow程序。</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    init_op = tf.global_variables_initializer()</div><div class="line">    sess.run(init_op)</div><div class="line"></div><div class="line">    <span class="comment"># 输出目前（未经训练）的参数取值。</span></div><div class="line">    print(<span class="string">"w1:"</span>, sess.run(w1))</div><div class="line">    print(<span class="string">"w2:"</span>, sess.run(w2))</div><div class="line">    print(<span class="string">"\n"</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 训练模型。</span></div><div class="line">    STEPS = <span class="number">5000</span>  <span class="comment"># 设定训练的轮数</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(STEPS):</div><div class="line">        start = (i * batch_size) % <span class="number">128</span></div><div class="line">        end = (i * batch_size) % <span class="number">128</span> + batch_size</div><div class="line">        sess.run(train_step, feed_dict=&#123;x: X[start:end], y_: Y[start:end]&#125;)</div><div class="line">        <span class="keyword">if</span> i % <span class="number">1000</span> == <span class="number">0</span>:</div><div class="line">            total_cross_entropy = sess.run(cross_entropy, feed_dict=&#123;x: X, y_: Y&#125;)</div><div class="line">            print(<span class="string">"After %d training step(s), cross entropy on all data is %g"</span> % (i, total_cross_entropy))</div><div class="line"></div><div class="line">    <span class="comment"># 输出训练后的参数取值。</span></div><div class="line">    print(<span class="string">"\n"</span>)</div><div class="line">    print(<span class="string">"w1:"</span>, sess.run(w1))</div><div class="line">    print(<span class="string">"w2:"</span>, sess.run(w2))</div></pre></td></tr></table></figure><p>输出为：</p><p>训练之前的神经网络的参数值：</p><blockquote><p>w1: [[-0.81131822  1.48459876  0.06532937]<br> [-2.4427042   0.0992484   0.59122431]]</p><p>w2: [[-0.81131822]<br> [ 1.48459876]<br> [ 0.06532937]]</p></blockquote><p>可以发现，随着训练的进行，交叉熵是逐渐减小的。交叉熵越小说明预测的结果和真实的结果差距越小。</p><blockquote><p>After 0 training step(s), cross entropy on all data is 0.0674925</p><p>After 1000 training step(s), cross entropy on all data is 0.0163385</p><p>After 2000 training step(s), cross entropy on all data is 0.00907547</p><p>After 3000 training step(s), cross entropy on all data is 0.00714436</p><p>After 4000 training step(s), cross entropy on all data is 0.00578471<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line">训练之后的神经网络的参数值：</div><div class="line">&gt; </div><div class="line">&gt; w1: [[-1.9618274   2.58235407  1.68203783]</div><div class="line">&gt;  [-3.46817183  1.06982327  2.11789012]]</div><div class="line">&gt;  </div><div class="line">&gt; w2: [[-1.82471502]</div><div class="line">&gt;  [ 2.68546653]</div><div class="line">&gt;  [ 1.41819513]]</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 第4章 深层神经网络</div><div class="line"></div><div class="line">## 4.1 深度学习与深层神经网络</div><div class="line"></div><div class="line">### 4.1.1 线性模型的局限性</div><div class="line">### 4.1.2 激活函数实现去线性化</div><div class="line"></div><div class="line">激活函数：tf.nn.relu、tf.sigmoid和tf.tanh。</div><div class="line"></div><div class="line">### 4.1.3 多层网络解决异或运算</div><div class="line"></div><div class="line">单层感知机无法模拟异或运算。加入了隐含层之后，就可以解决异或问题。</div><div class="line"></div><div class="line">## 4.2损失函数的定义</div><div class="line"></div><div class="line">### 4.2.1 经典损失函数</div><div class="line"></div><div class="line">交叉熵(cross entropy)。用q来表示p的交叉熵为：</div><div class="line">$$H(p,q)=-\sum_x p(x)\text&#123;log&#125; q(x)$$</div><div class="line"></div><div class="line">p代表的是正确答案，q代表的是预测值。交叉熵刻画的是两个概率分布的距离，也就是说交叉熵越小，两个概率分布越接近。</div><div class="line"></div><div class="line">`softmax`回归：将神经网络的输出变成一个概率分布。</div><div class="line"></div><div class="line">交叉熵的代码实现：</div><div class="line"></div><div class="line">cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, 1e-10, 1.0)))</div><div class="line"></div><div class="line"></div><div class="line">其中，`tf.clip_by_value`的用法</div><div class="line"></div><div class="line">`tf.clip_by_value(A, min, max)：`输入一个张量A，把A中的每一个元素的值都压缩在`min`和`max`之间。小于`min`的让它等于`min`，大于`max`的元素的值等于`max`。</div><div class="line"></div><div class="line">import tensorflow as tf;  </div><div class="line">import numpy as np;  </div><div class="line">  </div><div class="line">A = np.array([[1,1,2,4], [3,4,8,5]])  </div><div class="line">  </div><div class="line">with tf.Session() as sess:  </div><div class="line">    print sess.run(tf.clip_by_value(A, 2, 5)) </div><div class="line"></div><div class="line">输出：</div><div class="line"></div><div class="line">&gt; [[2 2 2 4]</div><div class="line">&gt; </div><div class="line">&gt;  [3 4 5 5]]</div><div class="line"></div><div class="line">`tf.log`是对张量中所有元素依次求对数。</div><div class="line"></div><div class="line">`*`操作是元素之间直接相乘，矩阵乘法是`tf.matmul`。</div><div class="line"></div><div class="line">上面三个计算得到的结果是nxm的矩阵。</div><div class="line"></div><div class="line">`tf.reduce_mean`的用法。</div><div class="line"></div><div class="line">v = tf.constant([[1.0, 2.0, 3.0, 4.0], [4.0, 5.0, 6.0, 7.0]])</div><div class="line">sess = tf.Session()</div><div class="line">init_op = tf.global_variables_initializer()</div><div class="line">sess.run(init_op)</div><div class="line">print(tf.reduce_mean(v).eval(session=sess))</div><div class="line"># 程序输出为：4.0 = sum/8</div><div class="line"></div><div class="line">### 4.2.2 自定义损失函数</div><div class="line">当然tensorflow也支持自定义损失函数。</div><div class="line">## 4.3 神经网络优化算法</div><div class="line">假设用$\theta$表示神经网络中的参数，$J(\theta)$表示在给定的参数取值下，训练集上损失函数的大小，那么整个优化过程可以抽象为：寻找一个参数$\theta$，使得$J(\theta)$最小。</div><div class="line"></div><div class="line">对于参数$\theta$，其梯度为$\frac&#123;\partial&#125;&#123;\partial\theta&#125;J(\theta)$。有了梯度，还需要学习率$\eta $(learning rate)来控制每次参数更新的幅度。</div><div class="line">因此，参数更新的公式为：</div><div class="line">$$\theta_&#123;n+1&#125; = \theta_n -  \eta \frac&#123;\partial&#125;&#123;\partial\theta&#125;J(\theta)$$</div><div class="line"></div><div class="line">需要注意的是梯度下降算法并不能保证达到全局最优解，此外还存在计算时间过长的问题。</div><div class="line"></div><div class="line">为了加速训练过程，可以使用随机梯度下降(stochastic gradient descent)算法。每一轮迭代中随机优化某一条训练数据的损失函数。</div><div class="line"></div><div class="line">在实际应用中，采用折中的方法：**每次计算一小部分训练数据的损失函数**。这一小部分数据被称为&lt;font color=AA00AA&gt;**batch**&lt;/font&gt;。</div><div class="line"></div><div class="line">## 4.4 神经网络进一步优化</div><div class="line">### 4.4.1 学习率的设置</div><div class="line"></div><div class="line">假设我们要最小化函数  $y=x^2$, 选择初始点   $x_0=5$。</div><div class="line">#### 1. 学习率为1时</div><div class="line">```python</div><div class="line">import tensorflow as tf</div><div class="line">TRAINING_STEPS = 10</div><div class="line">LEARNING_RATE = 1</div><div class="line">x = tf.Variable(tf.constant(5, dtype=tf.float32), name=&quot;x&quot;)</div><div class="line">y = tf.square(x)</div><div class="line"></div><div class="line">train_op = tf.train.GradientDescentOptimizer(LEARNING_RATE).minimize(y)</div><div class="line"></div><div class="line">with tf.Session() as sess:</div><div class="line">    sess.run(tf.global_variables_initializer())</div><div class="line">    for i in range(TRAINING_STEPS):</div><div class="line">        sess.run(train_op)</div><div class="line">        x_value = sess.run(x)</div><div class="line">        print &quot;After %s iteration(s): x%s is %f.&quot;% (i+1, i+1, x_value)</div></pre></td></tr></table></figure></p></blockquote><p>结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">After 1 iteration(s): x1 is -5.000000.</div><div class="line">After 2 iteration(s): x2 is 5.000000.</div><div class="line">After 3 iteration(s): x3 is -5.000000.</div><div class="line">After 4 iteration(s): x4 is 5.000000.</div><div class="line">After 5 iteration(s): x5 is -5.000000.</div><div class="line">After 6 iteration(s): x6 is 5.000000.</div><div class="line">After 7 iteration(s): x7 is -5.000000.</div><div class="line">After 8 iteration(s): x8 is 5.000000.</div><div class="line">After 9 iteration(s): x9 is -5.000000.</div><div class="line">After 10 iteration(s): x10 is 5.000000.</div></pre></td></tr></table></figure></p><p>学习率为1的时候，x在5和-5之间震荡。</p><h4 id="2-学习率为0-001时"><a href="#2-学习率为0-001时" class="headerlink" title="2. 学习率为0.001时"></a>2. 学习率为0.001时</h4><p>将上述代码中的学习率设为0.001（很小），如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LEARNING_RATE = <span class="number">0.001</span></div></pre></td></tr></table></figure></p><p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">After 1 iteration(s): x1 is 4.990000.</div><div class="line">After 101 iteration(s): x101 is 4.084646.</div><div class="line">After 201 iteration(s): x201 is 3.343555.</div><div class="line">After 301 iteration(s): x301 is 2.736923.</div><div class="line">After 401 iteration(s): x401 is 2.240355.</div><div class="line">After 501 iteration(s): x501 is 1.833880.</div><div class="line">After 601 iteration(s): x601 is 1.501153.</div><div class="line">After 701 iteration(s): x701 is 1.228794.</div><div class="line">After 801 iteration(s): x801 is 1.005850.</div><div class="line">After 901 iteration(s): x901 is 0.823355.</div></pre></td></tr></table></figure></p><p>学习率为0.001的时候，下降速度过慢，在901轮时才收敛到0.823355。</p><h4 id="3-使用指数衰减的学习率"><a href="#3-使用指数衰减的学习率" class="headerlink" title="3. 使用指数衰减的学习率"></a>3. 使用指数衰减的学习率</h4><p>将上述代码中的学习率设为指数衰减的方式，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LEARNING_RATE = tf.train.exponential_decay(<span class="number">0.1</span>, global_step, <span class="number">1</span>, <span class="number">0.96</span>, staircase=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">After 1 iteration(s): x1 is 4.000000, learning rate is 0.096000.</div><div class="line">After 11 iteration(s): x11 is 0.690561, learning rate is 0.063824.</div><div class="line">After 21 iteration(s): x21 is 0.222583, learning rate is 0.042432.</div><div class="line">After 31 iteration(s): x31 is 0.106405, learning rate is 0.028210.</div><div class="line">After 41 iteration(s): x41 is 0.065548, learning rate is 0.018755.</div><div class="line">After 51 iteration(s): x51 is 0.047625, learning rate is 0.012469.</div><div class="line">After 61 iteration(s): x61 is 0.038558, learning rate is 0.008290.</div><div class="line">After 71 iteration(s): x71 is 0.033523, learning rate is 0.005511.</div><div class="line">After 81 iteration(s): x81 is 0.030553, learning rate is 0.003664.</div><div class="line">After 91 iteration(s): x91 is 0.028727, learning rate is 0.002436.</div></pre></td></tr></table></figure></p><p>使用指数衰减的学习率，在迭代初期得到较高的下降速度，可以在较小的训练轮数下取得不错的收敛程度。</p><h3 id="4-4-2-过拟合问题"><a href="#4-4-2-过拟合问题" class="headerlink" title="4.4.2 过拟合问题"></a>4.4.2 过拟合问题</h3><p>为了避免过拟合，一个非常常用的方法是正则化(regularization)，加入刻画模型复杂程度的指标$R(w)$，优化时优化$J(\theta)+\lambda R(w) $。</p><p>常用的正则化方法有：L1正则化和L2正则化。<br>$$R(w) =||w||_1 =\sum_i|w_i|$$<br>$$R(w) =||w||_2^2 =\sum_i|w_i^2|$$</p><p>无论哪一种正则化的方式，其思想都是通过限制权重的大小，使得模型不能任意拟合训练数据中的随机噪声。</p><p>区别在于，L1正则化会使得参数变得更加稀疏，而L2正则化则不会；此外，L1正则化的计算公式不可导，而L2正则化公式可导。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2017/12/28/tensorflow_base/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS2015 设置调试时不加载符号</title>
      <link>http://wangwlj.com/2017/12/27/CPP_VS2015_noPDB/</link>
      <guid>http://wangwlj.com/2017/12/27/CPP_VS2015_noPDB/</guid>
      <pubDate>Wed, 27 Dec 2017 13:53:16 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://images2.imgbox.com/1c/a2/uWHMn9oN_o.png&quot; alt=&quot;调试加载界面&quot;&gt;&lt;br&gt;人生苦短，消除等待！！&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://images2.imgbox.com/1c/a2/uWHMn9oN_o.png" alt="调试加载界面"><br>人生苦短，消除等待！！</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>用VS2015打开代码文件，按下F5进行调试，当电脑接入网络后系统会<strong>自动从Microsoft符号服务器加载PDB符号文件</strong>，而且是每次都会加载。如下图所示：<br><img src="https://images2.imgbox.com/1c/a2/uWHMn9oN_o.png" alt="调试加载界面"></p><p>此加载符号过程使得调试变得非常慢。</p><p>通过查阅得知，此类的pdb调试器在编写代码时对于新手来说，根本用不到。也就是说完全可以不需要加载。</p><p>那么如何避免VS2013调试时自动加载符号呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>打开VS的【工具】-【选项】：<br><img src="https://images2.imgbox.com/bc/8e/PXMTNcYk_o.png" alt="工具选项"></p></li><li><p>选择其中的【调试】-【符号】，并 取消勾选“Microsoft符号服务器” ：<br><img src="https://images2.imgbox.com/eb/35/XrMdw2M8_o.png" alt="取消勾选"></p></li><li><p>确定并退出即可，此后再次按F5进行调试。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://jingyan.baidu.com/article/fea4511a1a1040f7bb91251a.html" target="_blank" rel="external">VS2013代码调试：如何避免调试时加载符号</a></p></li><li><p><a href="http://blog.csdn.net/u010186001/article/details/52759945" target="_blank" rel="external">vs2015加载符号慢，请问怎么解决</a></p></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2017/12/27/CPP_VS2015_noPDB/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
