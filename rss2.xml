<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wangwlj&#39;s Blog</title>
    <link>http://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Tue, 09 Jan 2018 13:28:16 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>算法导论详解(5) 第六章堆排序</title>
      <link>http://wangwlj.com/2018/01/09/Algorithm_tutorial_charpter_6/</link>
      <guid>http://wangwlj.com/2018/01/09/Algorithm_tutorial_charpter_6/</guid>
      <pubDate>Tue, 09 Jan 2018 13:27:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;在第二章介绍了两种排序算法，第六章将介绍第三种排序算法：堆排序(heapsort)，以及基于堆排序的优先队列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fn9epgz0rbj20k006rjs1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在第二章介绍了两种排序算法，第六章将介绍第三种排序算法：堆排序(heapsort)，以及基于堆排序的优先队列。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn9epgz0rbj20k006rjs1.jpg" alt=""></p><a id="more"></a><p>空间原址性(in place)：仅有常数个元素需要在排序过程中存储在数组之外。</p><h2 id="堆-6-1-P84"><a href="#堆-6-1-P84" class="headerlink" title="堆(6.1, P84)"></a>堆(6.1, P84)</h2><p>堆，也叫 二叉堆，是一个数组，可以看作近似的完全二叉树，树的每个节点对应数组一个元素。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn9epgz0rbj20k006rjs1.jpg" alt=""></p><p>表示堆的数组<code>A</code>包括两个属性：<code>A.length</code>给出数组元素的个数；<code>A.heap-size</code>给出有多少个元素存储在该数组中。即heap-size是数组的有效元素。</p><p>给定下标<code>i</code>，很容易计算其父节点、左节点和右节点：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div></pre></td></tr></table></figure></p><blockquote><p>这三个函数通常以宏或者内联函数的方式实现。</p></blockquote><p>二叉堆分为两种形式：最大堆和最小堆。<br>最大堆满足：A[PARENT(i)] ≥ A[i] ，即：某个节点的值最多与其父节点一样大；最小堆满足：A[PARENT(i)] ≤ A[i]。</p><p>堆排序算法采用的是最大堆。最小堆通常用于构造优先队列。</p><p>堆的高度为：$Θ(lgn)$</p><h2 id="维持堆的性质（6-2，P86）"><a href="#维持堆的性质（6-2，P86）" class="headerlink" title="维持堆的性质（6.2，P86）"></a>维持堆的性质（6.2，P86）</h2><p><code>MAX-HEAPIFY</code>：输入为一个数组A和一个下标i，A[i]有可能小于其孩子，通过让A[i]在数组中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆的性质。</p><p>该函数伪码表示为：<br><img src="https://images2.imgbox.com/54/2c/3rWF8zSL_o.png" alt="MAX-HEAPIFY伪码"></p><p>算法图示：<br><img src="https://images2.imgbox.com/71/85/6tJrJVIS_o.png" alt=""></p><p>Python实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= len(A) <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= len(A) <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest)</div></pre></td></tr></table></figure></p><p>每个孩子的子树最多为2n/3（不太理解这句话？？）。<br>所以，在最差情况下（最底层恰好半满）运行时间为：<br>$$T(n) = T(2n/3)+ \Theta(1)$$<br>上述递归式的解为：$T(n) = \text{O} (\text{lg}n)$</p><h2 id="建堆-6-3-P87"><a href="#建堆-6-3-P87" class="headerlink" title="建堆(6.3, P87)"></a>建堆(6.3, P87)</h2><p>子数组元素$A[ (\lfloor n/2\rfloor +1),\cdots,n]$是树中的所有叶节点。<br><code>BUILD_MAX_HEAP</code>从非叶节点开始一直循环到根节点。</p><p><img src="https://images2.imgbox.com/02/43/BH6sysvA_o.png" alt=""></p><p>Python实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUILD_MAX_HEAP</span><span class="params">(A)</span>:</span></div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(floor(heap_size / <span class="number">2</span>)), <span class="number">0</span>, <span class="number">-1</span>):</div><div class="line">        MAX_HEAPIFY(A, i)</div></pre></td></tr></table></figure></p><p><code>BUILD_MAX_HEAP</code> 的时间复杂度为$T(n) = \text{O}(n)$</p><h2 id="堆排序算法-6-4，P89"><a href="#堆排序算法-6-4，P89" class="headerlink" title="堆排序算法(6.4，P89)"></a>堆排序算法(6.4，P89)</h2><p>伪代码：<br><img src="https://images2.imgbox.com/5d/94/xcT4QVgb_o.png" alt=""></p><p>Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAPSORT</span><span class="params">(A)</span>:</span></div><div class="line">    BUILD_MAX_HEAP(A)</div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A), <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">        A[<span class="number">1</span> - <span class="number">1</span>], A[i - <span class="number">1</span>] = A[i - <span class="number">1</span>], A[<span class="number">1</span> - <span class="number">1</span>]  <span class="comment"># exchage A[i] with A[1]</span></div><div class="line">        heap_size = heap_size - <span class="number">1</span></div><div class="line">        MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div></pre></td></tr></table></figure></p><p><code>HEAPSORT</code>过程的时间复杂度为：$\text{O}(n\text{lg}n)$，因为<code>BUILD_MAX_HEAP</code>的时间复杂度为$\text{O}(n)$，n-1次调用<code>MAX_HEAPIFY</code>，每次时间为$\text{O}(\text{lg}n)$。</p><h2 id="堆排序的Python完整实现"><a href="#堆排序的Python完整实现" class="headerlink" title="堆排序的Python完整实现"></a>堆排序的Python完整实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i, size)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= size <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= size <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest, size)</div><div class="line">        </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUILD_MAX_HEAP</span><span class="params">(A)</span>:</span></div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(floor(heap_size / <span class="number">2</span>)), <span class="number">0</span>, <span class="number">-1</span>):</div><div class="line">        MAX_HEAPIFY(A, i, heap_size)</div><div class="line">        </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAPSORT</span><span class="params">(A)</span>:</span></div><div class="line">    BUILD_MAX_HEAP(A)</div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A), <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">        A[<span class="number">1</span> - <span class="number">1</span>], A[i - <span class="number">1</span>] = A[i - <span class="number">1</span>], A[<span class="number">1</span> - <span class="number">1</span>]  <span class="comment"># exchage A[i] with A[1]</span></div><div class="line">        heap_size = heap_size - <span class="number">1</span></div><div class="line">        MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># A = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]</span></div><div class="line">    <span class="comment"># MAX_HEAPIFY(A, 2)</span></div><div class="line">    <span class="comment"># for i in range(0, len(A)):</span></div><div class="line">    <span class="comment">#     print(A[i], end=" ")</span></div><div class="line">    <span class="comment"># A = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7]</span></div><div class="line">    <span class="comment"># BUILD_MAX_HEAP(A)</span></div><div class="line">    <span class="comment"># for i in range(0, len(A)):</span></div><div class="line">    <span class="comment">#     print(A[i], end=" ")</span></div><div class="line">    A = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</div><div class="line">    HEAPSORT(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">" "</span>)</div></pre></td></tr></table></figure><h2 id="优先队列-6-5，P90"><a href="#优先队列-6-5，P90" class="headerlink" title="优先队列(6.5，P90)"></a>优先队列(6.5，P90)</h2><p>优先队列：是一种用来维护由一组元素构成的集合S的数据结果，其中的每个元素都有一个相关的值，称为关键字。优先队列也有两种形式：最大优先队列和最小优先队列。</p><p>最大优先队列的应用：共享计算机系统的作业调度。<br>最小优先队列被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生事件作为关键词。</p><p>优先队列可以用堆来实现。优先队列的元素对应应用程序的对象，堆中每个元素存储对象的句柄(handle)。</p><p>最大优先队列支持：</p><ul><li>对最大优先队列进行插入，<code>MaxHeapInsert</code>；</li><li>返回最大优先队列的最大值，<code>HeapMax</code>；</li><li>去掉最大值并且返回该值，<code>HeapExtractMax</code>；</li><li>将第x个元素的值改为k，其中k&gt;=x的原来的值，<code>HeapIncreaseKey</code>；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_MAXIMUM</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">return</span> A[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_EXTRACT_MAX</span><span class="params">(A, heap_size)</span>:</span></div><div class="line">    <span class="keyword">if</span> heap_size &lt; <span class="number">1</span>:</div><div class="line">        print(<span class="string">"ERROR!! Heap underflow!!"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    max_A = A[<span class="number">1</span> - <span class="number">1</span>]</div><div class="line">    A[<span class="number">1</span> - <span class="number">1</span>] = A[heap_size - <span class="number">1</span>]</div><div class="line">    heap_size = heap_size - <span class="number">1</span></div><div class="line">    MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line">    <span class="keyword">return</span> max_A</div></pre></td></tr></table></figure><p><code>HeapExtractMax</code>的操作复杂度为$\text{O}(\text{lg}n)$（也就是<code>MAX_HEAPIFY</code>的复杂度）。</p><h2 id="最大优先队列的Python完整实现："><a href="#最大优先队列的Python完整实现：" class="headerlink" title="最大优先队列的Python完整实现："></a>最大优先队列的Python完整实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i, heap_size)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= heap_size <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= heap_size <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest, heap_size)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_MAXIMUM</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">return</span> A[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_EXTRACT_MAX</span><span class="params">(A, heap_size)</span>:</span></div><div class="line">    <span class="keyword">if</span> heap_size &lt; <span class="number">1</span>:</div><div class="line">        print(<span class="string">"ERROR!! Heap underflow!!"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    max_A = A[<span class="number">1</span> - <span class="number">1</span>]</div><div class="line">    A[<span class="number">1</span> - <span class="number">1</span>] = A[heap_size - <span class="number">1</span>]</div><div class="line">    heap_size = heap_size - <span class="number">1</span></div><div class="line">    MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line">    <span class="keyword">return</span> max_A</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_INCREASE_KEY</span><span class="params">(A, i, key)</span>:</span></div><div class="line">    <span class="keyword">if</span> key &lt; A[i - <span class="number">1</span>]:</div><div class="line">        print(<span class="string">"ERROR!! New key is smaller than current key!!!"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    A[i - <span class="number">1</span>] = key</div><div class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span> <span class="keyword">and</span> A[int(PARENT(i) - <span class="number">1</span>)] &lt; A[int(i - <span class="number">1</span>)]:</div><div class="line">        A[int(PARENT(i) - <span class="number">1</span>)], A[int(i - <span class="number">1</span>)] = A[int(i - <span class="number">1</span>)], A[int(PARENT(i) - <span class="number">1</span>)]</div><div class="line">        i = PARENT(i)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAP_INSERT</span><span class="params">(A, key)</span>:</span></div><div class="line">    MAX_INT = <span class="number">0x7fffffff</span></div><div class="line">    heap_size = len(A) + <span class="number">1</span></div><div class="line">    A.append(- MAX_INT)  <span class="comment"># 尾部追加元素</span></div><div class="line">    HEAP_INCREASE_KEY(A, heap_size, key)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">16</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</div><div class="line">    MAX_HEAP_INSERT(A, <span class="number">9</span>)  <span class="comment"># 调用的数值都是从1开始。</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">" "</span>)</div></pre></td></tr></table></figure><p>算法基本思想：在末尾新插入一个元素，按照最大堆的要求排列好就行。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>算法导论 中文 第三版</li><li><a href="http://blog.csdn.net/u010183397/article/details/46882099" target="_blank" rel="external">算法导论 第六章：堆排序</a></li><li><a href="http://blog.csdn.net/xjm199/article/details/18039023" target="_blank" rel="external">最大优先队列–【算法导论】</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/09/Algorithm_tutorial_charpter_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>动手实现atoi函数—— Leetcode(8)</title>
      <link>http://wangwlj.com/2018/01/09/leetcode_8/</link>
      <guid>http://wangwlj.com/2018/01/09/leetcode_8/</guid>
      <pubDate>Tue, 09 Jan 2018 07:32:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;8. String to Integer (atoi)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Implement atoi to convert a string to an integer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hint&lt;/strong&gt;: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/string-to-integer-atoi/description/" target="_blank" rel="external">8. String to Integer (atoi)</a></p><p>Implement atoi to convert a string to an integer.</p><p><strong>Hint</strong>: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现将<code>string</code>转化为<code>int</code>的<code>atoi</code>函数。这题需要充分考虑各种不规范输入的情况，主要有以下几种情况：</p><ol><li>忽略前面的所有空格直到非空格出现。从该字符开始，有可能是正负号，然后紧跟着一系列数字。</li><li>在数字的尾部有可能有一些无关的附加字符，也需要忽略它们。</li><li>如果第一个非空格字符不是有效数（即不是+-或者数字），则返回0。</li><li>如果string为空，或者仅有空格，则返回0。</li><li>如果最终结果超过int的范围，则返回int的最大/最小值。</li></ol><p>提供几个测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Input:&quot;2147483648&quot;     Expected:2147483647  //溢出的情况</div><div class="line">//Input:&quot;+&quot;              Expected:0 //不合法的情况 </div><div class="line">//Input:&quot;+-2&quot;            Expected:0 //不合法的情况 </div><div class="line">// Input: &quot;  123&quot; //有空格的情况</div><div class="line">// Input:&quot;-123&quot;   //有负数的情况</div><div class="line">// Input:&quot;+123&quot;   //有+号的情况</div></pre></td></tr></table></figure></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>先给出我自己折腾的一个解法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_atoi</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INT_MAX = <span class="number">0x7fffffff</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INT_MIN = <span class="number">0x80000000</span>;</div><div class="line">    <span class="keyword">int</span> len = str.size();</div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(str[index] == <span class="string">' '</span> &amp;&amp; index &lt; len)&#123;</div><div class="line">        index ++; <span class="comment">// 跳过空格</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>; <span class="comment">//符号位</span></div><div class="line">    <span class="keyword">long</span> l = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt; len; ++i)&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)</div><div class="line">            <span class="keyword">if</span>(<span class="string">'0'</span>&lt;= str[i+<span class="number">1</span>] &amp;&amp; str[i+<span class="number">1</span>] &lt;= <span class="string">'9'</span>)</div><div class="line">                sign = (str[i] == <span class="string">'-'</span>)? <span class="number">-1</span> : <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'0'</span>&lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) </div><div class="line">        &#123;</div><div class="line">            l = l * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>); <span class="comment">// 字符0对应的10进制为48，可以直接减去48</span></div><div class="line">            <span class="keyword">if</span>(l * sign &gt; INT_MAX)&#123;</div><div class="line">                <span class="keyword">return</span> INT_MAX;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l * sign &lt; INT_MIN)&#123;</div><div class="line">                <span class="keyword">return</span> INT_MIN;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> l  * sign;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>主要思路就是：从左向右，先忽略空格；然后空格之后第一位有三种可能：</p><ul><li>如果是“+-”号，则第二位必须是数字才记上正负号，否则返回0；</li><li>如果是数字，直到遇到非数字结束；</li><li>如果不是上述情况，则返回0。</li></ul><p>这边再给出一个<a href="https://leetcode.com/problems/string-to-integer-atoi/discuss/4642" target="_blank" rel="external">简洁的写法</a>，具体思路类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_atoi</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> indicator = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=str.size();)</div><div class="line">    &#123;</div><div class="line">        i = str.find_first_not_of(<span class="string">' '</span>);</div><div class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)</div><div class="line">            indicator = (str[i++] == <span class="string">'-'</span>)? <span class="number">-1</span> : <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="string">'0'</span>&lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) </div><div class="line">        &#123;</div><div class="line">            result = result*<span class="number">10</span> + (str[i++]-<span class="string">'0'</span>);</div><div class="line">            <span class="keyword">if</span>(result*indicator &gt;= INT_MAX) <span class="keyword">return</span> INT_MAX;</div><div class="line">            <span class="keyword">if</span>(result*indicator &lt;= INT_MIN) <span class="keyword">return</span> INT_MIN;                </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result*indicator;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注：原先<code>for(int i = 0; i&lt;=str.size();)</code>中并不包含等号，会导致空串时无返回值的错误。因此加上等于号。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/09/leetcode_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo博客彻底解决置顶问题</title>
      <link>http://wangwlj.com/2018/01/09/blog_pin_post/</link>
      <guid>http://wangwlj.com/2018/01/09/blog_pin_post/</guid>
      <pubDate>Tue, 09 Jan 2018 02:53:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://images2.imgbox.com/e8/af/g8uPUalf_o.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://images2.imgbox.com/e8/af/g8uPUalf_o.png" alt=""><br><a id="more"></a></p><h2 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h2><p>一种方法是手动对相关文件进行修改，具体可参考<a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="external">这篇文章</a>。</p><p>另一种方法就是，目前已经有修改后支持置顶的<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="external">仓库</a>，可以直接用以下命令安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> npm uninstall hexo-generator-index --save</div><div class="line"><span class="meta">$</span> npm install hexo-generator-index-pin-top --save</div></pre></td></tr></table></figure><p>然后在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code>即可。比如下面这篇文章：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">---</span></div><div class="line"><span class="attr">title:</span> <span class="string">hexo+GitHub博客搭建实战</span></div><div class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-09</span><span class="bullet">-08</span> <span class="number">12</span><span class="string">:00:25</span></div><div class="line"><span class="attr">categories:</span> <span class="string">博客搭建系列</span></div><div class="line"><span class="attr">top:</span> <span class="literal">true</span></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></figure><p>到目前为止，置顶功能已经可以实现了。所有相关博文到这边就结束了。</p><p>不过置顶的文章显示在最上面之后，如果没有明确的置顶标志，是不是感觉有点怪怪的呢？</p><h2 id="设置置顶标志"><a href="#设置置顶标志" class="headerlink" title="设置置顶标志"></a>设置置顶标志</h2><p>打开：<code>/blog/themes/next/layout/_macro</code> 目录下的<code>post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入如下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;% if post.top %&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-thumb-tack"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p><p>效果展示：<br><img src="https://images2.imgbox.com/e8/af/g8uPUalf_o.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="external">解决Hexo博客文章置顶问题</a></li><li><a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="external">解决Hexo置顶问题</a></li><li><a href="http://jinfang.life/posts/e0bb97e1/" target="_blank" rel="external">Hexo主题的数据封装，样式渲染和扩展实例</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/09/blog_pin_post/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(3) 第四章分治策略</title>
      <link>http://wangwlj.com/2018/01/08/algorithm_tutorial_chapter_4/</link>
      <guid>http://wangwlj.com/2018/01/08/algorithm_tutorial_chapter_4/</guid>
      <pubDate>Mon, 08 Jan 2018 08:43:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;本章讲解更多关于分治策略的算法。第一个算法是求解最大子数组的问题，然后是求解$n\times n$矩阵乘法问题的分治算法，最后介绍了主方法。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本章讲解更多关于分治策略的算法。第一个算法是求解最大子数组的问题，然后是求解$n\times n$矩阵乘法问题的分治算法，最后介绍了主方法。</p><a id="more"></a><h2 id="分治策略简介"><a href="#分治策略简介" class="headerlink" title="分治策略简介"></a>分治策略简介</h2><p>分治策略在每层递归时都有三个步骤：</p><ul><li>分解原问题为若干子问题；子问题的形式与原问题一样，只是规模更小。</li><li>解决这些子问题，递归地求解各子问题。如果子问题的规模足够小，则停止递归，直接求解。</li><li>合并这些子问题的解成原问题的解。</li></ul><p>递归情况(recursive case)<br>基本情况(base case)：子问题足够小的时候，递归已经“触底”时。</p><p>递归式：我们用递归式描述了MERGE-SORT过程的最坏情况运行时间$T(n)$：<br>$$T(n) =<br> \begin{cases}<br>  \Theta(1) &amp; 若n=1 \\<br> 2T(n/2)+f(n) &amp;  若n&gt;1\\<br>  \end{cases}<br>$$<br>求解递归式的方法：代入法（猜测）；递归树法；主方法。本书使用主方法。</p><p>主方法可求解形如下面公式的递归式的界：<br>$$T(n) = aT(n/b)+f(n)$$<br>其中，$a\geqslant 1,b&gt;1,f(n)$是一个给定的函数。</p><p>递归式的技术细节</p><ul><li>忽略递归式声明和求解的一些细节，如MERGE-SORT的最坏情况运行时间准确的递归式为：</li></ul><p>$$T(n) =<br> \begin{cases}<br>  \Theta(1) &amp; 若n=1 \\<br> T(\lceil n/2\rceil )+T(\lfloor n/2\rfloor )+\Theta(n) &amp;  若n&gt;1\\<br>  \end{cases}<br>$$</p><ul><li>边界条件是我们通常忽略的细节。</li><li>当声明、求解递归式时，我们常常忽略向下取整、向上取整及边界条件。</li></ul><p>本章讲解更多关于分治策略的算法。第一个算法是求解最大子数组的问题，然后是求解$n\times n$矩阵乘法问题的分治算法。</p><h2 id="最大子数组问题-4-1，P38"><a href="#最大子数组问题-4-1，P38" class="headerlink" title="最大子数组问题(4.1，P38)"></a>最大子数组问题(4.1，P38)</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>买股票（低价买入，高价卖出）。给定一段时间，选取最大收益。</p><h3 id="问题变换"><a href="#问题变换" class="headerlink" title="问题变换"></a>问题变换</h3><p>不关注每天的价格，而是关注每日价格变化。<br>那么问题就转化为寻求价格变化数组A的最大非空连续子数组。<br>称这样的连续子数组为<strong>最大子数组</strong>。</p><h3 id="使用分治策略的求解方法"><a href="#使用分治策略的求解方法" class="headerlink" title="使用分治策略的求解方法"></a>使用分治策略的求解方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="comment"># MAX = 1 &lt;&lt; 31</span></div><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_crossing_subarray</span><span class="params">(A, low, mid, high)</span>:</span></div><div class="line">    max_left = mid</div><div class="line">    max_right = mid</div><div class="line">    left_sum = <span class="number">0</span>  <span class="comment"># original version init with -max, now is zero,because minimum is zero</span></div><div class="line">    all_sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid - <span class="number">1</span>, low - <span class="number">1</span>, <span class="number">-1</span>):  <span class="comment"># 左边不经过mid</span></div><div class="line">        all_sum += A[i]</div><div class="line">        <span class="keyword">if</span> all_sum &gt; left_sum:</div><div class="line">            left_sum = all_sum</div><div class="line">            max_left = i</div><div class="line">    right_sum = A[mid]  <span class="comment"># original version init with -max, now is A[mid],because A[mid] must be included.</span></div><div class="line">    all_sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid, high + <span class="number">1</span>):</div><div class="line">        all_sum += A[i]</div><div class="line">        <span class="keyword">if</span> all_sum &gt; right_sum:</div><div class="line">            right_sum = all_sum</div><div class="line">            max_right = i</div><div class="line">    <span class="comment"># print([low, mid, high], [max_left, max_right, left_sum + right_sum])</span></div><div class="line">    <span class="keyword">return</span> [max_left, max_right, left_sum + right_sum]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray</span><span class="params">(A, low, high)</span>:</span></div><div class="line">    <span class="keyword">if</span> high == low:</div><div class="line">        <span class="keyword">return</span> [low, high, A[low]]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        mid = math.floor((low + high) / <span class="number">2</span>)</div><div class="line">        left_low, left_high, left_sum = find_maximum_subarray(A, low, mid)</div><div class="line">        right_low, right_high, right_sum = find_maximum_subarray(A, mid + <span class="number">1</span>, high)</div><div class="line">        cross_low, cross_high, cross_sum = find_max_crossing_subarray(A, low, mid, high)</div><div class="line">        <span class="keyword">if</span> left_sum &gt;= right_sum <span class="keyword">and</span> left_sum &gt;= cross_sum:</div><div class="line">            <span class="keyword">return</span> [left_low, left_high, left_sum]</div><div class="line">        <span class="keyword">elif</span> right_sum &gt;= left_sum <span class="keyword">and</span> right_sum &gt;= cross_sum:</div><div class="line">            <span class="keyword">return</span> [right_low, right_high, right_sum]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> [cross_low, cross_high, cross_sum]</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">1</span>, <span class="number">-3</span>, <span class="number">7</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">-5</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">9</span>]</div><div class="line">    <span class="comment"># A = [1, -3, 7, -5, -4, -1, -9, -3, 1, -3, -5, -9]</span></div><div class="line">    <span class="comment"># print(find_max_crossing_subarray(A, 0, 6, len(A) - 1))</span></div><div class="line">    print(find_maximum_subarray(A, <span class="number">0</span>, len(A) - <span class="number">1</span>))</div></pre></td></tr></table></figure><h3 id="分治算法的分析"><a href="#分治算法的分析" class="headerlink" title="分治算法的分析"></a>分治算法的分析</h3><p>假设问题规模为2的幂，这样所有问题的规模都是整数。</p><p>在<code>find_maximum_subarray</code>函数中，需要求解两个子问题——左数组和右数组(分别为5/6行)，每个子问题的运行时间为$T(n/2)$，两个子问题加起来就是$2T(n/2)$。<br>第7行，<code>find_max_crossing_subarray</code>函数求解跨越中点的子数组，花费线性的时间，为$\Theta (n)$。</p><p>总的运行时间递归式为：<br>$$T(n) = \begin{cases}<br>\Theta (1) &amp; if\ \ n=1\\<br>2T(n/2)+\Theta (n) &amp; if\ \  n&gt;1<br>\end{cases}<br>$$<br>与鬼归并排序的递归式相同。在4.5节用主方法求解该递归式，其解为$T(n) =\Theta (n\ \text{lg}n) $。</p><h3 id="线性复杂度的解法–习题4-1-5-P42"><a href="#线性复杂度的解法–习题4-1-5-P42" class="headerlink" title="线性复杂度的解法–习题4.1-5(P42)"></a>线性复杂度的解法–习题4.1-5(P42)</h3><p>主要思想：从左到右处理，记录目前为止已经处理的最大子数组。非递归、线性复杂度。</p><p>从左到右累加，如果当前子数组的累加和小于零，则意味着最大子数组(maximun subarray)肯定不包括该子数组，所以果断舍弃，重新开始累加。</p><p>该解法的python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray</span><span class="params">(A)</span>:</span></div><div class="line">   j = <span class="number">0</span></div><div class="line">   max_sum = <span class="number">0</span></div><div class="line">   left = <span class="number">-1</span></div><div class="line">   cur_left = <span class="number">0</span></div><div class="line">   right = <span class="number">-1</span></div><div class="line">   sum = <span class="number">0</span></div><div class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">       sum = sum + A[j]</div><div class="line">       <span class="keyword">if</span> sum &gt; max_sum:</div><div class="line">           max_sum = sum</div><div class="line">           left = cur_left</div><div class="line">           right = j</div><div class="line">       <span class="keyword">elif</span> sum &lt; <span class="number">0</span>:</div><div class="line">           sum = <span class="number">0</span></div><div class="line">           cur_left = j + <span class="number">1</span></div><div class="line">   <span class="keyword">if</span> max_sum &gt; <span class="number">0</span>:</div><div class="line">       <span class="keyword">return</span> left, right, max_sum</div><div class="line">   <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure></p><h2 id="矩阵乘法的Strassen算法-4-2，P43"><a href="#矩阵乘法的Strassen算法-4-2，P43" class="headerlink" title="矩阵乘法的Strassen算法(4.2，P43)"></a>矩阵乘法的Strassen算法(4.2，P43)</h2><p>若$A=(a_{ij}),B=(b_{ij})$是$nxn$的方阵，则对$i,j=1,2,\cdots ,n$,定义矩阵乘积$C=A\cdot B$中的$c_{ij}$为：<br>$$c_{ij} = \sum_{k=1}^n a_{ik} b_{kj}$$</p><p>写成程序，是一个三重循环，因此，复杂度为$\Theta (n^3)$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">SQUARE_MATRIX_MULTIPLY</span><span class="params">(A, B)</span>:</span>  </div><div class="line">    <span class="keyword">assert</span>(len(A) == len(B))  </div><div class="line">    n = len(A)  </div><div class="line">    C = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(n)] <span class="keyword">for</span> row <span class="keyword">in</span> range(n)]  </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):  </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n):  </div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, n):  </div><div class="line">                C[i][j]= C[i][j] + A[i][k]*B[k][j]  </div><div class="line">    <span class="keyword">return</span> C</div></pre></td></tr></table></figure><h3 id="一个简单的分治算法-4-2，P43"><a href="#一个简单的分治算法-4-2，P43" class="headerlink" title="一个简单的分治算法(4.2，P43)"></a>一个简单的分治算法(4.2，P43)</h3><p>假定三个矩阵均为$n\times n$矩阵，其中n为2的幂。在每个分解步骤中，$n\times n$矩阵都被划分为4个$n/2 \times n/2$的子矩阵，如下：<br>$$A = \begin{bmatrix}<br>A_{11} &amp; A_{12}\\A_{21} &amp; A_{22}<br>\end{bmatrix},<br>B = \begin{bmatrix}<br>B_{11} &amp; B_{12}\\B_{21} &amp; B_{22}<br>\end{bmatrix},<br>C = \begin{bmatrix}<br>C_{11} &amp; C_{12}\\C_{21} &amp; C_{22}<br>\end{bmatrix}<br>$$<br>因此，公式$C=A\cdot B$改写成：<br>$$\begin{bmatrix}<br>C_{11} &amp; C_{12}\\C_{21} &amp; C_{22}<br>\end{bmatrix}= \begin{bmatrix}<br>A_{11} &amp; A_{12}\\A_{21} &amp; A_{22}<br>\end{bmatrix} \cdot<br>\begin{bmatrix}<br>B_{11} &amp; B_{12}\\B_{21} &amp; B_{22}<br>\end{bmatrix}<br>$$<br>等价于：<br>$$\begin{matrix}<br>C_{11} = A_{11}\cdot B_{11} + A_{12}\cdot B_{21} \\<br>C_{12} = A_{11}\cdot B_{12} + A_{12}\cdot B_{22} \\<br>C_{21} = A_{21}\cdot B_{11} + A_{22}\cdot B_{21} \\<br>C_{22} = A_{21}\cdot B_{12} + A_{22}\cdot B_{22}<br>\end{matrix}$$</p><p>该简单分治算法的总运行时间递归式为：<br>$$T(n) = \begin{cases}<br>\Theta (1) &amp; if\ \ n=1\\<br>8T(n/2)+\Theta (n^2) &amp; if\ \  n&gt;1<br>\end{cases}<br>$$</p><h3 id="Strassen-方法-4-2，P45"><a href="#Strassen-方法-4-2，P45" class="headerlink" title="Strassen 方法(4.2，P45)"></a>Strassen 方法(4.2，P45)</h3><p>为减小时间复杂度，采用Strassen 法，其原理仍将讲矩阵A,B,C划分成n/2 x n/2 ,然后按如下计算：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn945rgi23j20bx08575e.jpg" alt=""></p><p>即：先创建10个矩阵$S_1,\cdots,S_{10} $，由于进行了10次$n/2\times n/2$矩阵的加减法，所以该步骤花费$\Theta(n^2)$时间。</p><p>接着，递归地计算七次$n/2\times n/2$矩阵的乘法，即计算$P_1,\cdots,P_{7}$矩阵。</p><p>最后计算结果矩阵C的子矩阵$C_{11},C_{12},C_{21},C_{22}$。</p><p>其时间复杂度为：</p><p>$$T(n)= \begin{cases}<br>\Theta (1) &amp; if\ \ n=1\\<br>7T(n/2)+\Theta (n^2) &amp; if\ \  n&gt;1<br>\end{cases}<br>$$</p><p>利用4.5节的主方法，可以求出上述的解为：<br>$$T(n)= \Theta(n^{\text{lg}7}) $$</p><h2 id="用主方法求解递归式-4-5，P53"><a href="#用主方法求解递归式-4-5，P53" class="headerlink" title="用主方法求解递归式(4.5，P53)"></a>用主方法求解递归式(4.5，P53)</h2><p>主方法依赖于主定理。</p><h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>令$a\geqslant 1$和$b&gt;1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式：<br>$$T(n)= aT(n/b)+f(n)$$</p><p>其中，我们将$n/b$解释为$\lfloor n/b \rfloor$或$\lceil n/b \rceil$。那么$T(n)$有如下的渐近界：</p><ol><li><p>若对某个常数$\epsilon &gt; 0$有$f(n) = \text{O}(n^{\text{log}_ba - \epsilon})$，则$T(n)=\Theta(n^{\text{log}_ba} )$</p></li><li><p>若$f(n) = \Theta(n^{\text{log}_ba})$，则$T(n)=\Theta(n^{\text{log}_ba} \text{lg}n)$</p></li><li>若对某个常数$\epsilon &gt; 0$有$f(n) = \Omega(n^{\text{log}_ba + \epsilon})$，且对某个常数$c&lt;1$和所有足够大的n有$aT(n/b)\leqslant cf(n)$，则$T(n)=\Theta(f(n) )$</li></ol><p>以上就是主定理的完整叙述。</p><p>解释：我们将函数$f(n)$和$n^{\text{log}_ba}$进行比较。直觉上，两个函数较大者决定了递归式的解。<br>情况1表示：函数$n^{log_ba}$更大，则解为$T(n)=\Theta(n^{\text{log}_ba} )$；<br>情况3表示：函数$f(n)$更大，则解为$T(n)=\Theta(f(n) )$。<br>情况2表示：当两个函数大小相当，则乘上一个对数因子，解为$T(n)=\Theta(n^{\text{log}_ba} \text{lg}n)$。</p><blockquote><p>上述的大于/小于都是多项式意义上的，也就是渐近小于(大于)。每种情况之间都有一定的间隙。若$f(n)$落在间隙中，就不能使用主方法。</p></blockquote><h3 id="使用主方法"><a href="#使用主方法" class="headerlink" title="使用主方法"></a>使用主方法</h3><p>使用主方法，只需要确定主定理的哪种情况成立，即可以得到解。</p><p>下面举几个例子。</p><p>$$T(n)= 9T(n/3)+n$$<br>上式中，$a=9,b=3,f(n) = n$，因此，$n^{\text{log}_ba} =n^{\text{log}_39} = \Theta(n^2) $。由于$f(n) = \text{O}(n^{\text{log}_39 - \epsilon})$，其中$\epsilon = 1$，所以应用主定理的情况1，从而得到$T(n) = \Theta(n^2) $</p><p>$$T(n)= T(2n/3)+1$$<br>上式中，$a=1,b=3/2,f(n) = 1$，因此，$n^{\text{log}_ba} =n^{\text{log}_{3/2}1} =n^0 = 1 $，由于$f(n) = \Theta(n^{\text{log}_ba}) = \Theta (1)$，所以，适用于情况二，从而得到最终解为$T(n) = \Theta(\text{lg} n ) $</p><p>归并排序和最大子数组方法的运行时间的递归式：<br>$$ T(n)= 2T(n/2)+\Theta(n)$$<br>同理，$n^{\text{log}_ba} =n^{\text{log}_{2}2} =n $， 由于$f(n) = \Theta(n)$，所以应用情况2，得到解$T(n) = \Theta(n\text{lg} n ) $</p><p>矩阵乘法的第一个分治算法的运行时间：<br>$$ T(n)= 8T(n/2)+\Theta(n^2)$$<br>上式，有：$n^{\text{log}_ba} =n^{\text{log}_{2}8} =n^3 $，$n^3$多项式意义上大于$f(n)$，因此应用情况1，解为$T(n) = \Theta(n^3) $</p><p>矩阵乘法的Strassen算法运行时间：<br>$$ T(n)= 7T(n/2)+\Theta(n^2)$$<br>上式中，有$n^{\text{log}_ba} =n^{\text{log}_{2}7} = n^{\text{lg}7}$，由于$2.80&lt;lg7&lt;2.81$，对$\epsilon = 0.8$，有$f(n) = \text{O}(n^{\text{lg}7-\epsilon})$，故应用情况1，得到：$T(n) = \Theta(n^{\text{lg}7}) $</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>算法导论 中文版 原书第三版</li><li><a href="http://blog.csdn.net/u010183397/article/details/46866577" target="_blank" rel="external">算法导论 第四章：分治法(二)</a></li><li><a href="http://blog.csdn.net/sushauai/article/details/50491477" target="_blank" rel="external">算法导论课后习题解析 第四章 上</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/08/algorithm_tutorial_chapter_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>判断回文数（三种解法）—— Leetcode(9)</title>
      <link>http://wangwlj.com/2018/01/08/Leetcode_9/</link>
      <guid>http://wangwlj.com/2018/01/08/Leetcode_9/</guid>
      <pubDate>Mon, 08 Jan 2018 07:32:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;Leetcode链接：&lt;a href=&quot;https://leetcode.com/problems/palindrome-number&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;9. Palindrome Number&lt;/a&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Leetcode链接：<a href="https://leetcode.com/problems/palindrome-number" target="_blank" rel="external">9. Palindrome Number</a></p><a id="more"></a><p>Palindrome Number，即判断是否为回文数，并且题目要求不能使用额外的空间。<br>即，不能使用回文串的方法。</p><p>在本题中，负数不作为回文数考虑范围之内，但是输入依然可能为负，此时直接返回false即可。</p><p>首先，一种容易想到的方法是：将整个数取反后看和原来的数是否相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>)  </div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum =<span class="number">0</span>;  </div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> origin = x;  </div><div class="line">        <span class="keyword">while</span>(x)  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">int</span> num = x %<span class="number">10</span>;  </div><div class="line">            sum = sum*<span class="number">10</span> + num;  </div><div class="line">            x/=<span class="number">10</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span>(sum == origin)  </div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>我采用另外一种方法：根据回文数的特点，我们只需要判断左边一半和翻转后的右边一半是否相等即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="comment">// 负数肯定不是，以及首尾不对称的非0数</span></div><div class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> ( x &gt; rev)&#123;</div><div class="line">            rev = rev * <span class="number">10</span> + x % <span class="number">10</span>; <span class="comment">//将低位一半的数取反。</span></div><div class="line">            x = <span class="keyword">int</span> (x / <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//有rev &gt;= x， 奇数情况下需要除去10</span></div><div class="line">        <span class="keyword">return</span> x == rev || x == <span class="keyword">int</span>(rev/<span class="number">10</span>); </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>还有另外一种解法：<br>类似与采用两个指针。<br>在循环体中，不断地比较第i位和倒数第i位，直到遇到最中间的1个数字(输入为奇数个数字)或者遇到最中间的2个数字(输入为偶数个数字)时结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </div><div class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">  <span class="keyword">int</span> div = <span class="number">1</span>;  </div><div class="line">  <span class="keyword">while</span> (x / div &gt;= <span class="number">10</span>) &#123;  </div><div class="line">    div *= <span class="number">10</span>;  </div><div class="line">  &#125;          </div><div class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;  </div><div class="line">    <span class="keyword">int</span> l = x / div;  </div><div class="line">    <span class="keyword">int</span> r = x % <span class="number">10</span>;  </div><div class="line">    <span class="keyword">if</span> (l != r) <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">    x = (x % div) / <span class="number">10</span>;  <span class="comment">//去掉两边的数</span></div><div class="line">    div /= <span class="number">100</span>;  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参考链接：</p><ul><li><a href="http://blog.csdn.net/feliciafay/article/details/17134663" target="_blank" rel="external">LeetCode(9)PalindromeNumber</a></li><li><a href="http://blog.csdn.net/zhangxiao93/article/details/48751493" target="_blank" rel="external">leetcode9</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/08/Leetcode_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(六)函数</title>
      <link>http://wangwlj.com/2018/01/06/CPP_06/</link>
      <guid>http://wangwlj.com/2018/01/06/CPP_06/</guid>
      <pubDate>Sat, 06 Jan 2018 08:55:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;第六章是和函数有关的知识，函数就是命名了的计算单元，对程序的结构化非常重要。&lt;br&gt;本章内容包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数的概念基础，包括函数的定义声明以及函数如何生成值和返回结果。&lt;/li&gt;
&lt;li&gt;函数重载,重载可以使函数接受不同种类或者数量不同的参数。&lt;/li&gt;
&lt;li&gt;函数指针，指向函数的一类特殊指针。&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>第六章是和函数有关的知识，函数就是命名了的计算单元，对程序的结构化非常重要。<br>本章内容包括：</p><ol><li>函数的概念基础，包括函数的定义声明以及函数如何生成值和返回结果。</li><li>函数重载,重载可以使函数接受不同种类或者数量不同的参数。</li><li>函数指针，指向函数的一类特殊指针。</li></ol><a id="more"></a><h2 id="函数基础（P182，6-1）"><a href="#函数基础（P182，6-1）" class="headerlink" title="函数基础（P182，6.1）"></a>函数基础（P182，6.1）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c)</span> <span class="comment">// 形参  </span></span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    func(<span class="number">1</span>, <span class="string">'a'</span>); <span class="comment">// 实参，与形参的类型、数量相匹配  </span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在调用函数时，第一步编译器会隐式的定义并初始化它的形参。比如一个函数<code>void f(int a);</code>，形参<code>int a</code>会被用户传入的实参初始化，此时形参是实参的一个副本。当有多个形参时，形参对应的实参的求值顺序是不一定的。实参的类型必须和形参的类型一致或能转化为形参声明的类型。</p><p>函数可以返回空值。返回函数指针和数组的特殊函数类型将在之后提到。</p><h3 id="局部静态对象（P185，6-1-1）"><a href="#局部静态对象（P185，6-1-1）" class="headerlink" title="局部静态对象（P185，6.1.1）"></a>局部静态对象（P185，6.1.1）</h3><p>一个对象的名字有作用域，对象本身也有生命周期。名字的作用域是我们可以通过名字访问对象的的区间。相对的，生命周期是指对象的产生和销毁的过程。</p><p>定义在所有函数外部的变量叫做<strong>全局变量</strong>，在整个程序的执行过程中一直存在。这种对象在程序启动时被创建，直到程序结束才会被销毁。</p><p>定义在函数体内的对象或者函数的形参都是<strong>局部变量</strong>。当函数执行路径经过该对象的定义语句时才会自动开始创建该对象，在对应的块结束时，这个对象会被销毁。</p><p>有时候我们有必要使局部变量的生命周期贯穿函数调用及之后的时间，所以我们可以将局部对象定义成<code>static</code>对象，定义语句形如<code>static int a=1;</code>，这样我们就可以在程序的别的地方（只要是在这个static对象的作用域内访问它）操作这个局部静态对象。</p><p>在一个程序中多次定义局部静态对象仍然是不被允许的。但是当一个函数里的对象被定义为局部静态对象，<font color="00A00A">多次调用这个函数并不会重置这个局部静态对象的值</font>。它自己会记得上一次被函数调用之后的值并继承这个值，不被第二次函数调用的变量定义初始化，这就是它静态的特性。</p><blockquote><p>局部静态变量若没有显式的初始化，则执行值初始化，内置类型的局部静态变量初始化为0。</p></blockquote><h3 id="函数声明（P186，6-1-2）"><a href="#函数声明（P186，6-1-2）" class="headerlink" title="函数声明（P186，6.1.2）"></a>函数声明（P186，6.1.2）</h3><p>函数声明要在使用这个函数之前。规范的形式是通常放在头文件里。函数声明可以不写形参的名字，只写形参的类型。</p><p>函数声明也称作函数原型(function prototype)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数的声明，必须要写在函数第一次被调用之前。  </span></div><div class="line"> <span class="comment">// 这部分的代码可放到头文件中，用的时候include进来就可以了(分离式编译)  </span></div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">int</span>)</span></span>;  </div><div class="line">  </div><div class="line"> <span class="comment">// 只要函数在被调用前声明了，那函数的定义可以写在声明之后的任意的位置，  </span></div><div class="line"> <span class="comment">// 如这里的func就可以在声明之后、main函数之前定义；  </span></div><div class="line"> <span class="comment">// 如果func没有在调用前声明，则必须要在被调用前定义(相当于把main函数后面的func那段代码放在这里实现)  </span></div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </div><div class="line">     <span class="keyword">return</span> func(<span class="string">'a'</span>, <span class="string">'1'</span>); <span class="comment">// 函数的调用，虽然func在main后定义，但是因为之前对func进行了声明，所以编译器知道这个函数的三要素是啥  </span></div><div class="line"> &#125;  </div><div class="line">  </div><div class="line"> <span class="comment">/* </span></div><div class="line"><span class="comment">  * 函数的定义的参数列表中各参数的类型、数量以及位置等需要和声明时的相匹配 </span></div><div class="line"><span class="comment">  */</span>  </div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> i)</span>  </span></div><div class="line"><span class="function"> </span>&#123;  </div><div class="line">     <span class="comment">// do something  </span></div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h3 id="传引用调用（P189，6-2-2）"><a href="#传引用调用（P189，6-2-2）" class="headerlink" title="传引用调用（P189，6.2.2）"></a>传引用调用（P189，6.2.2）</h3><p>当函数的形参是一个引用类型的时候，在使用函数时，这个函数的引用形参就绑定在了传入的实参上，这种函数调用就叫做<strong>传引用调用</strong>。在函数涉及到一些比较大的类型对象作为参数的时候，通常地我们使用传引用调用，这样就可以避免实参初始化形参带来的拷贝。在C语言里经常传入指针避免拷贝，在C++里，一般使用引用。</p><p>大多数情况下函数只能有一个返回值，因此在我们需要的时候，我们可以<strong>传一个额外的引用的参数在函数里面。这样函数体内就可以改变引用的值进而改变函数外部被引用连接的对象的值，从而返回多个数值</strong>。</p><h3 id="const形参和实参（-P190，6-2-2）"><a href="#const形参和实参（-P190，6-2-2）" class="headerlink" title="const形参和实参（ P190，6.2.2）"></a>const形参和实参（ P190，6.2.2）</h3><p>函数形参的类型也可以是带const的类型。</p><blockquote><p>顶层const作用于对象本身（离对象最近的const），实参初始化形参的时候会忽略掉顶层const。即<strong>形参的顶层const被忽略掉了</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>; <span class="comment">//fcn 能读取i，但不能向i写值。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">//错误，重复定义了fcn(int)。</span></div></pre></td></tr></table></figure><p>因为顶层const被忽略掉了，所以第二个fcn是错误的。</p><p>形参的初始化方式与变量的初始化方式一样。先回顾一下变量的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int i  = 42;</div><div class="line">const int *cp = &amp;i; //正确，但是cp不能改变i</div><div class="line">const int &amp;r = i;   //正确，但是r不能改变i</div><div class="line">const int &amp;r2 = 42; //正确，参见P55。</div><div class="line"></div><div class="line">int *p = cp;        //错误，p的类型和cp的类型不匹配</div><div class="line">int &amp;r3 = r;        //r3的类型和r的类型不匹配</div><div class="line">int &amp;4 = 42;        //错误，不能用字面值常量初始化一个非常量引用（参见P45）</div></pre></td></tr></table></figure></p><p>将同样的初始化规则应用到参数传递上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</div><div class="line"><span class="built_in">string</span>::size_type ctr = <span class="number">0</span>;</div><div class="line">reset(&amp;i);  <span class="comment">//调用形参类型是int *的函数</span></div><div class="line">reset(&amp;ci);  <span class="comment">//错误：不能用指向const int对象的指针初始化int *</span></div><div class="line"></div><div class="line">reset(i);  <span class="comment">//调用形参类型是int &amp;的函数</span></div><div class="line">reset(ci);  <span class="comment">//错误：不能把普通引用绑定到const对象ci上</span></div><div class="line">reset(<span class="number">42</span>);  <span class="comment">//错误：不能把普通引用绑定到字面值上</span></div><div class="line">reset(ctr);  <span class="comment">//错误：类型不匹配，ctr是无符号类型</span></div></pre></td></tr></table></figure></p><p><strong><font color="00A00A">我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。</font></strong></p><hr><p><strong>当我们接受函数的参数是为了完成比较或者判断等操作，而不需要改变参数的值，我们应该使用带const的参数来确保参数不会被更改</strong>。另外，const类型的形参能比普通类型的形参接受更多种类的参数。比如<code>void fn(const string&amp;);</code>这个函数，字符串字面值是<code>const char [ ]</code>类型，因此fn这个函数接受字符串字面值。但是如果声明成了<code>void fn(string&amp;);</code>，那么这个函数就没有办法接受字符串字面值（类似：<code>“string”</code>这样的值就是字符串字面值）。另外，带const的形参也接受带底层const的对象。</p><h3 id="传递数组作为参数（P193，6-2-4）"><a href="#传递数组作为参数（P193，6-2-4）" class="headerlink" title="传递数组作为参数（P193，6.2.4）"></a>传递数组作为参数（P193，6.2.4）</h3><p>又是我们想要向函数传递一个数组，但是数组是不可拷贝的，因此我们不能够通过值传递的方式传递一个数组到函数里，另外，如果数组的内容很大，传递数组的每个元素会带来不必要的拷贝。</p><p>以下的方法都基于或类似<strong><font color="00A00A">传递数组的指针</font></strong>。一维数组的指针指向数组的第一个元素。我们可以声明类似如下的形式传递一个数组指针到函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span> [])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span> [<span class="number">10</span>])</span></span>;</div></pre></td></tr></table></figure></p><p>这三者是等价的。传递之后形参的类型都是<code>int *</code>类型。</p><p>但是正因为数组的信息是以指针的形式传递给函数的，所以函数只得到一个地址，并不知道数组的大小，因此也就很容易访问到未定义的内存区域，因此在传递数组指针的基础上，我们可以通过手动标志数组大小等方法保证函数访问的内存是合法的不越界的。因此衍生出以下几种方法。</p><ol><li>第一种方法：<strong>在数组的末尾加标记。</strong>这种方法类似于C风格字符串，末尾会自动加’\0’来告诉大家这个字符串结束了。在数组末尾加特殊的标记来使数组不越界是简单易用的方法。</li><li>第二种方法：<strong>使用标准库规范中的begin和end函数。</strong>头文件<code>iterator</code>里有针对数组的begin和end函数，返回数组的首指针和尾后指针，指针指向数组元素的类型，这种方法也可以检测越界。</li><li>第三种方法：<strong>传递一个表示数组大小的参数。</strong>这样构建函数时就知道数组有多大了。如<code>print(j, end(j)-begin(j));</code></li><li>第四种方法：<strong>传递数组的引用。</strong>除了使用指针，我们还可以使用引用来得到一个完整数组的引用（别名）。声明格式类似下面这种：<code>void fx(int (&amp;arr)[10]);</code>，这里形参的名字是<code>arr</code>，<code>arr</code>前面的<code>&amp;</code>符号代表它是引用类型，引用了一个实参数组，这个数组必须只有10个元素（因为arr后面的[10]也是构成引用声明的必要部分。）</li></ol><blockquote><p>注意<code>void fx(int &amp;arr[10]);</code>这个去掉括号的写法是错误的，不存在引用的数组。</p></blockquote><hr><p><strong>传递多维数组</strong>：有时我们也需要向一个函数传递多维数组。多维数组的实质是数组的数组，一维数组的名是指向数组元素的指针，二维数组是指向数组元素的指针的指针。因此想要一个函数传递多维数组的形参声明如下：<code>void fx(int (*arr)[10]);</code>这时arr指向有10个int型元素的数组。当我们把arr+1，它就又指向了新的10个元素，因此arr相当于二维数组的数组名（两者都是指向包含的一维数组首元素的指针）。</p><p>也可以用<code>int arr[][10]</code>代替<code>int (*arr)[10]</code>，因为它们是等价的，都是二维数组名。用<code>int arr[][10]</code>这种方式定义形参时，要标出除了第一个维度以外的每个维度。（假设有一个数组<code>int b[2][3]</code>，就说明b有两列，每列3个元素，这里的2就是第一个维度。指向一维数组的指针不关心在这个维度上有几个元素，因此忽略）。</p><h3 id="main函数的命令行选项（P196，6-2-5）"><a href="#main函数的命令行选项（P196，6-2-5）" class="headerlink" title="main函数的命令行选项（P196，6.2.5）"></a>main函数的命令行选项（P196，6.2.5）</h3><p>最开始我们使用<code>UNIX</code>或<code>LINUX</code>系统编程时经常使用没有图形界面的编译器来把写好的代码编译成obj文件，这时候我们使用命令行来编译一份源代码文件，我们需要在终端里输入类似“<code>prog -d -o oflie data0</code>”的命令行来进行命令行控制。</p><p>现在我们看到的main函数一般都是<code>int main()</code>，括号里面什么也不写，我们也可以给main传递上述的那个命令行参数。形如：<code>int main(int argc,char *argv[])</code>。 main可以什么参数也不接受，也可以接受一个int和一个指向字符串的指针这两个参数。main没有第三种形式了。</p><p><code>int argc</code>是表示后面的argv一共指向几个字符串用的。<code>char *argv[]</code>里面的每一个字符串都顺序对应着命令行的参数。这些参数的字符串数组的第一个元素应该是可执行文件的名字或者空参数，最后一个字符串的值必须为<code>0</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对于命令”prog -d -o oflie data0“：</span></div><div class="line">argc = <span class="number">5</span>;</div><div class="line">argv[<span class="number">0</span>] = <span class="string">"prog"</span>;</div><div class="line">argv[<span class="number">1</span>] = <span class="string">"-d"</span>;</div><div class="line">argv[<span class="number">2</span>] = <span class="string">"-o"</span>;</div><div class="line">argv[<span class="number">3</span>] = <span class="string">"0file"</span>;</div><div class="line">argv[<span class="number">4</span>] = <span class="string">"data0"</span>;</div><div class="line">argv[<span class="number">5</span>] = <span class="number">0</span>;</div></pre></td></tr></table></figure></p><p>有关命令行的更多选项和argv参数的具体用法，可以参照对应的编译器文档。</p><h3 id="含有可变形参的函数（P197，6-2-6）"><a href="#含有可变形参的函数（P197，6-2-6）" class="headerlink" title="含有可变形参的函数（P197，6.2.6）"></a>含有可变形参的函数（P197，6.2.6）</h3><p>到现在我们定义的函数都是固定参数的，但是有时候我们无法预知向函数传递几个参数，又想使用一个函数接受这种变化，我们就可以使用C++指定的两种方法来定义含有可变形参的函数。</p><ul><li>第一种方法是当参数个数不一定，但是<strong>参数类型都相同</strong>时，我们可以<strong>传递一个initializer_list参数</strong>。这是标准库设施中的一部分。</li><li>第二种方法在当我们想传递不确定个数的<strong>不同类型的实参</strong>时要使用的技术：<strong>可变参数模板。</strong>这个16章才介绍。</li></ul><p>其实还有一种方法使函数接受多种形参，不过这种方法多用于和C语言旧代码对接时使用。<strong>这个方法用省略符来传递可变数量的形参</strong>。</p><blockquote><p>常见的应用场景：日志的打印</p></blockquote><h3 id="initializer-list（P197，6-2-6）"><a href="#initializer-list（P197，6-2-6）" class="headerlink" title="initializer_list（P197，6.2.6）"></a>initializer_list（P197，6.2.6）</h3><p>下面是关于定义可变形参函数的第一种方法——<code>initializer_list</code>参数的介绍：</p><p><code>initializer_list</code>类似<code>vector</code>，是一种容器，接纳一种同样类型的元素。initializer_list定义在同名的<code>&lt;initializer_list &gt;</code>中，我们可以把任意数量，同样类型的参数传递给这个容器使函数能够处理多个元素。</p><p>initializer_list支持的操作包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">initializer_list&lt;容器内元素的类型名&gt; 容器名 //默认初始化一个 initializer_list空容器</div><div class="line">initializer_list&lt;容器内元素的类型名&gt; 容器名&#123;元素值1，元素值2，元素值2...&#125; //大括号初始化</div><div class="line">initializer_list 容器名1（已被定义的initializer_list 容器的容器名2 ）//使容器1的内容和容器二一致，两个容器共享容器二里面的元素。不会形成拷贝，（也可以用initializer_list 容器名1=initializer_list 容器名2）</div><div class="line">initializer_list 容器名.size() //元素数量</div><div class="line">initializer_list 容器名.begin() //指向首元素的迭代器</div><div class="line">initializer_list 容器名.end() //尾后迭代器</div></pre></td></tr></table></figure></p><p>initializer_list里面元素的值永远是常量不能被更改，如果里面的元素是指针或引用，这个元素的属性将被自动加上底层const。<br>当我们声明一个接受 <code>initializer_list</code>类型的函数 <code>void fa(initializer_list&lt;int&gt; list1);</code>的时候，我们需要使用大括号来调用这个函数，形如fa({2,3,4});这样我们就向initializer_list传递了一个值的序列。<br>我们也可以声明<code>void fa(string b,initializer_list&lt;int&gt; list1);</code>这种函数。</p><h3 id="省略符形参（P199，6-2-6）"><a href="#省略符形参（P199，6-2-6）" class="headerlink" title="省略符形参（P199，6.2.6）"></a>省略符形参（P199，6.2.6）</h3><p>下面是关于定义可变形参函数的第三种方法——省略符形参的介绍。</p><p>省略符形参有下列两种形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">( parm_list , ...)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">( ... )</span></span>;</div></pre></td></tr></table></figure></p><p>第一种形式为特定数目的形参提供了声明。在这种情况下，当函数被调用时，对于与显示声明的形参相对应的实参进行类型检查，而对于与省略符对应的实参则暂停类型检查。在第一种形式中，形参声明后面的逗号是可选的。如果没有逗号，相应地，就变成了第二种情况。</p><blockquote><p>省略符形参应该仅仅用于C和C++通用的类型。<br>特别注意的是，大多数类型的对象在传递给省略符形参时都无法正确拷贝。<br>（感慨：所以说有什么用？还是用<code>intializer_list</code>吧？）</p></blockquote><p>你可以传递任意数量的参数给省略符形参。要注意省略号的优先级别最低，所以在函数解析时，只有当其它所有的函数都无法调用时，编译器才会考虑调用省略号函数的。<br>(optional)首先，如果要用省略符的方式处理不定参数的函数要包含头文件：<code>#include &lt;stdarg.h&gt;</code> （C语言中）或者<code>#include &lt;cstdarg&gt;</code>（C++中）。 然后利用va_list类型和va_start、va_arg、va_end 3个宏读取传递到函数中的参数值。<br>用省略符处理不定参数的函数基于C语言的方法，在C++中不建议使用。（使用了C语言标准库功能varargs）。</p><h2 id="返回值（P202，6-3）"><a href="#返回值（P202，6-3）" class="headerlink" title="返回值（P202，6.3）"></a>返回值（P202，6.3）</h2><p>在void返回值的语句最后会隐式地有<code>return;</code>语句，这时函数什么也不返回。</p><blockquote><p>不要返回局部对象的引用或指针。</p></blockquote><p>函数可以返回一个<strong>非常量引用</strong>作为左值。也可以返回一个花括号括起来的列表，来初始化vector等类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; test()  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>main函数的return语句可以不写，编译器会带为隐式补充。</p><blockquote><p>main 函数不能调用自己。</p></blockquote><h3 id="返回数组指针（P205，6-3-3）"><a href="#返回数组指针（P205，6-3-3）" class="headerlink" title="返回数组指针（P205，6.3.3）"></a>返回数组指针（P205，6.3.3）</h3><p>虽然我们不能直接让函数返回一个数组，但是我们可以设定函数返回一个指针的类型。函数会返回数组的指针。返回数组指针的函数定义语句如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">数组元素类型 （*函数名 （参数列表））[ 数组大小 ]</div></pre></td></tr></table></figure></p><p>当然，返回一个临时量或者局部对象的引用/指针都是错误的行为，如果你在函数里普通地定义了一个数组，那么这个数组的生命周期在函数返回时就结束了，会被内存中释放，因此可能需要用static使这个数组静态。静态对象只是延长了对象的生命周期，但是无论如何在函数内部定义的对象在外部都无法访问，除非使用返回指针的方法。</p><p>一条<code>double (*func(int a))[10]</code>这种语句来说明函数接受一个<code>int a</code>形参并且返回一个带有10个元素的double数组，这种语句在写法上比较乱，因此<code>C++11</code>提供了<strong><font color="00A00A">尾置返回</font></strong>的方法让程序员不必要非要迁就编译器的理解能力，上一条语句等价于这样：<code>auto func(int a)-&gt;double(*)[10]</code>我们使用<code>-&gt;</code>符号把返回值类型的描述放在了参数列表后面并和函数声明分离开让函数看起来不那么乱。</p><p>我们也可以使用<code>decltype</code>语句返回数组指针。<code>decltype</code>后面的括号可以括起一个现有的数组推导数组类型。我们再手动加<code>*</code>得到数组指针类型的返回值。在已有<code>int a[10];</code>的情况下，我们可以使用<code>decltype(a) *fn(int b)</code>这种形式定义一个返回指向数组的指针的返回值类型。</p><h2 id="函数重载（P207，6-4）"><a href="#函数重载（P207，6-4）" class="headerlink" title="函数重载（P207，6.4）"></a>函数重载（P207，6.4）</h2><p>我们可以定义一组功能类似，函数名一致，但是接受的参数类型或数量不同的函数。定义多个这种函数就叫做<strong>函数重载</strong>。函数重载可以提供给我们用一个函数名处理多种参数形式的情况。</p><p>定义重载函数要能重传入的参数里区别出实质不同的重载函数，如函数A的定义为<code>int fa(const int a);</code>和函数<code>B int fa(int b);</code>这两个函数函数名一样，形参类型不同，但仍然无法作为重载函数。因为我们传入一个int值时，fa不知道应该执行第一种还是第二种。所以<strong>只有参数顶层const属性不同的几个函数不是重载函数。</strong></p><blockquote><p>形参相同，但返回类型不同的函数也不能构成重载。</p></blockquote><p>当然，对于底层const，比如参数列表为<code>const int *a</code>的函数和参数列表为int a的函数能被看出不同，因为对于一个传入的const常量指针，这个实参只能初始化<code>const int *a</code>，不能被初始化<code>int a</code>。当同时有这两种形式的重载函数时，当传入一个非常量，IDE会优先选择为它匹配形参为<code>int a</code>版本的普通变量形参函数。</p><blockquote><p>形参是某种类型的引用或指针，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载。（此时的const是底层的）</p></blockquote><h3 id="const-cast和函数（P209，6-4）"><a href="#const-cast和函数（P209，6-4）" class="headerlink" title="const_cast和函数（P209，6.4）"></a>const_cast和函数（P209，6.4）</h3><p>这里主要介绍<code>const_cast</code>类型强制转换是如何在函数中被使用的。在第四章(4.11.3, P145)第一次接触<code>const_cast</code>的时候我们提到过这个常被用于函数里。这里我们就看看怎么使用。</p><p>之前说过，向函数传递参数时最好传递<code>const</code>型参数使其能够接受多种参数，这里我们可以在函数体内使用<code>const</code>再把参数变回普通的变量，这样就可以返回一个<code>非const</code>值了。</p><h3 id="重载和作用域（P210，6-4）"><a href="#重载和作用域（P210，6-4）" class="headerlink" title="重载和作用域（P210，6.4）"></a>重载和作用域（P210，6.4）</h3><p>声明变量时，变量的作用域就在块里，声明函数也一样，而且里层的作用域会隐藏外部的作用域。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">int a=0; //这里是a的外层作用域</div><div class="line">    &#123;</div><div class="line">    double a=1.2; //外边已经有a了，这里又声明了一个a，因此这个a的作用域覆盖了前面的int a；</div><div class="line">    cout&lt;&lt;a&lt;&lt;endl; //输出的会是1.2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>函数声明也一样，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    int fa(int b); //这里是函数fa的外层作用域</div><div class="line">    double fa(double b); //重载了函数fa使它能够接受double</div><div class="line">    &#123;</div><div class="line">        double fa(string &amp; c); //外边已经有fa了，这里又声明了一个fa，因此这个fa的作用域覆盖了前面的;</div><div class="line">        fa(2.3); //错误，原型为double fa(double b)的函数声明作用域被double fa(string &amp; c);覆盖，匹配不到函数</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>C++中，名字查找发生在类型检查之前。</p></blockquote><h2 id="特殊用途语言特性（6-5）"><a href="#特殊用途语言特性（6-5）" class="headerlink" title="特殊用途语言特性（6.5）"></a>特殊用途语言特性（6.5）</h2><h3 id="默认实参（P211，6-5-1）"><a href="#默认实参（P211，6-5-1）" class="headerlink" title="默认实参（P211，6.5.1）"></a>默认实参（P211，6.5.1）</h3><p>有时候一些函数我们每次调用它总会向它传递一些特殊的值。我们可以声明带有默认实参的函数。默认实参如果没有明确说明，默认实参会被自动当做函数的初始值传递进去。<br>形如<code>int fn(int a,int b=2,double c=3.3)</code>这样定义函数头的方式就给了b和c默认的实参，注意，<strong>当一个形参被给了默认实参，它后面的所有参数都要有默认实参才行。</strong></p><p>当我们想使用默认实参的时候，只要调用函数的时候使用这种对应的实参就行了，默认实参会用来填补缺少的尾部实参，上面的定义的函数如果这么调用：<code>fn(1,2);</code>，<code>double c</code>的值会被自动设为3.3。书写这种函数时要尽量保证要经常用到的默认实参放在参数列表的更后面一点，这样才合理。</p><p>可以只在函数声明里标注默认实参不在函数定义里这样写，结果仍然将是正确的。<code>void fn(int = 1, int = 2, int =3);</code>这种函数声明语句省略了形参的名字，不过也是可以的。</p><blockquote><p>通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p></blockquote><p>局部变量不能做默认实参，默认实参的定义在函数体之外。另外，<strong>默认实参是可以在名字的作用域内通过名字更改的</strong>。</p><h3 id="内联函数（P213，6-5-2）"><a href="#内联函数（P213，6-5-2）" class="headerlink" title="内联函数（P213，6.5.2）"></a>内联函数（P213，6.5.2）</h3><p>有时我们要频繁调用一个优化规模小，流程直接，频繁被调用的函数，定义函数时我们可以在返回值类型前面加上关键字<code>inline</code>使它成为内联函数，减少运行时的开销。</p><blockquote><p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p></blockquote><h3 id="constexpr函数（P214，6-5-2）"><a href="#constexpr函数（P214，6-5-2）" class="headerlink" title="constexpr函数（P214，6.5.2）"></a>constexpr函数（P214，6.5.2）</h3><p>这是一种能够被用在常量表达式的函数，但是函数的返回值类型和形参类型必须都是字面值。<strong>函数体中必须有且只有一条<code>return</code>语句，<code>constexpr</code>函数被隐式的指定为内联函数。</strong>const函数中也可以有类型别名，使用作用域声明等不执行操作的其他语句。这里没有赋值，没有构建对象。同时<code>constexpr</code>可以返回计算后的结果。如<code>constexpr int fn(int a){return a+22;}</code>，这条定义是正确的，前提是调用函数这个函数fn时，传入的实参是一个常量。比如<code>fn(3);</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> </span>&#123; <span class="keyword">return</span> new_sz() * cnt; &#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)]; <span class="comment">//正确，scale(2)是常量表达式</span></div><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line"><span class="keyword">int</span> a2[scale(i)]; <span class="comment">//错误，scale(i)不是常量表达式</span></div></pre></td></tr></table></figure></p><blockquote><p>内联函数和constexpr函数通常定义在头文件中。</p></blockquote><h3 id="调试帮助（P215，6-5-3）"><a href="#调试帮助（P215，6-5-3）" class="headerlink" title="调试帮助（P215，6.5.3）"></a>调试帮助（P215，6.5.3）</h3><p>程序员在写程序时可能涉及到一些调试中的代码，这些代码只在开发程序时使用，当即将发布程序的时候，要暂时屏蔽掉正在调试中的代码。C++提供了<code>assert</code>和<code>NDEBUG</code>两个预处理功能屏蔽测试代码。</p><h4 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h4><p>assert这个宏定义在<code>cassert</code>头文件中，assert使用一个表达式作为它的条件，形如<code>assert(expr);</code>首先对expr或者表达式求值，如果结果为真（非0），那么assert什么都不做。如果结果为假(表达式值为0)，那么assert输出信息并且终止程序的执行。</p><p>assert经常用于处理不能发生的条件，如果你写了一段代码，代码没测试越界，你就可以用assert，当它越界了我们就结束程序的执行。</p><h4 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h4><p><code>NDEBUG</code>宏定义可以影响assert的行为，这个默认是没被定义的。当我们宏定义了<code>NDEBUG</code>，就屏蔽掉了assert的功能。</p><p>可以使用<code>NDEBUG</code>编写自己的调试代码。</p><p>此外，IDE还提供了<code>__FILE__</code>(这里是两个英文下划线，这个存放文件名) 、<code>__func__</code>（这个存放所在的函数名) 、 <code>__LINE__</code>（这个存放所在的行数) 、<code>__TIME__</code>（这个存放调试的时间) 、 <code>__DATE__</code>（这个存放调试的日期) 这五种静态数组来提供错误信息。</p><h2 id="函数匹配（P217，6-6）"><a href="#函数匹配（P217，6-6）" class="headerlink" title="函数匹配（P217，6.6）"></a>函数匹配（P217，6.6）</h2><p>程序员定义重载函数之后就可以使用它们了，挑选到底使用哪个版本的函数是一个过程，这个过程叫做函数匹配。</p><ol><li>函数匹配的第一步是在调用时先找与与调用函数同名的函数名。且调用点在函数作用域内。这一步筛选出的函数叫做<strong>候选函数</strong>。</li><li>函数匹配的第二步是从候选函数中选择出能够被本次函数调用的实参传入的函数，函数名一致的前提下还要求函数的形参个数和实参一致，实参能够转化成（或者就是）形参规定的类型。这一步筛选出的函数叫做<strong>可行函数</strong>。</li><li><strong>寻找最佳匹配。</strong>当<code>有int fn(int a);</code>和<code>int fn(double a,double b=1.0)</code>时，我们调用函数fn形如<code>fn(3.4);</code>显然这两种函数都是可行函数，这是我们再寻找最佳的匹配，因为<code>fn(3.4);</code>对应<code>fn(double,double=1.0);</code>的话无需转化，因此是最佳匹配。当有多个最佳匹配的时候函数将停止调用。</li></ol><p>为了划分最佳匹配的各种情况，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示：</p><ol><li>精确匹配：<br>精确匹配可以包含以下情况：数组名转化成数组指针的匹配，函数类型转换成函数指针的匹配，实参类型与形参类型相同。另外，像实参添加顶层const或者忽略实参赋值给形参的顶层const也属于精确匹配。</li><li>通过指针的转换把非常量指针转换成常量指针。</li><li>通过类型提升实现的匹配。</li><li>通过算数类型转换或指针转换实现的匹配</li><li>通过类类型转换实现匹配（类类型转换还没有讲）</li></ol><p>要注意小整数字面值会被自动转换成int，而带小数点的字面值会被默认转换成doube。</p><h2 id="函数指针（P221，6-7）"><a href="#函数指针（P221，6-7）" class="headerlink" title="函数指针（P221，6.7）"></a>函数指针（P221，6.7）</h2><p>声明一条函数指针的语句如下: <code>int (*PtrOfFunc)(参数列表)</code>，其中<code>PtrOfFunc</code>就是<strong><font color="00A00A">指向函数的指针</font></strong>。我们可以把函数名赋值给定义的函数指针的名字。</p><blockquote><p><code>*PtrOfFunc</code>两端 的括号不能少。</p></blockquote><p>返回函数指针的形参定义为<code>double(*fn(int a)) (int d,char b);</code>这里声明的函数是fn，函数的形参是<code>int a</code>，返回值是函数指针类型的，返回的函数指针对应的函数的返回类型是double，参数是int d,char b。</p><p>和处理数组一样，我们也可以<strong>使用尾置</strong>返回来返回一个函数指针，尾置返回函数指针的声明是<code>auto fn(int a)-&gt;double (*)(int d,char b);</code>尾置返回适合用来返回复杂的类型比如数组，函数指针等等。</p><p>遇到<code>double(*fn(int a)) (int d,char b);</code>这种复杂的表达式，应该以定义的变量名为中心，从里往外一层层往外扩展。这个函数的定义语句里面，fn就是其中的变量名，看它右侧，有<code>（int a）</code>,这（<code>int a）</code>是一个形参列表。因此得出结论fn的本质是一个函数，再看左侧，<code>*</code>代表这个函数返回一个指针，这个指针的类型在更外层<code>（double (*) (int d,char b)）</code>型。</p><p>当然这种声明/定义容易让人心累，所以这种情况下使用<code>auto fn(int a)-&gt;double (*)(int d,char b)</code>是不错的选择。如果这样还是觉得太长了，可以使用typdef，USING等重命名语句加上decltype推导。比如<code>tpyedef double func (int d,char b);</code>这样的语句之后，func就是一个函数类型。</p><p>也可以使用<code>tpyedef decltype(fn) func2;</code>这条语句等价于上面的语句。<br>对于using语句，<code>using Func2 = double (int d,char b);</code>即可。<br>可见typedef和using的替换原则是不同的，在涉及到复杂类型的时候，类似数组，函数指针，tpyedef的替换名要和被替换的类型一起被声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>); <span class="comment">//F是函数类型，不是指针</span></div><div class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span> (*) (<span class="keyword">int</span> *, <span class="keyword">int</span>); <span class="comment">// PF是指针类型</span></div><div class="line"></div><div class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//正确，PF是指向函数的指针，f1返回指向函数的指针。</span></div><div class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//错误，F是函数类型，f1不能返回一个函数</span></div><div class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//正确，显式地指定返回类型是指向函数的指针。</span></div><div class="line"></div><div class="line"><span class="comment">// 当然也可以使用下面的形式直接声明f1</span></div><div class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span> *, <span class="keyword">int</span>);</div></pre></td></tr></table></figure><h2 id="术语表-P225"><a href="#术语表-P225" class="headerlink" title="术语表(P225)"></a>术语表(P225)</h2><p>1.函数 function<br>2.形参 parameter<br>3.调用运算符（一个动作） call operator<br>4.实参 argument<br>5.主调函数 calling function<br>6.被调函数 called function<br>7.生命周期 lifetime<br>8.局部变量 local variable<br>9.自动对象 automatic object<br>10.局部静态对象 local static object<br>11.函数原型 function prototype<br>12.分离式编译 separate compilation<br>13.可执行文件 executable file<br>14.引用传递 passed by reference<br>15.传引用调用 called by reference<br>16.值传递 passed by value<br>17.传值调用 called by value<br>18.重载 overloaded<br>19.函数匹配 function matching<br>20.重载确定 overloaded resolution<br>21.最佳匹配 best match<br>22.二义性调用 ambiguous call<br>23.默认实参 default argument<br>24.预处理宏 preprocessor marco<br>25.候选函数 candidate function<br>26.可行函数 viable function<br>27.递归循环 recursion loop<br>28.递归函数 recursive function<br>29.尾置返回类型 trailing return type</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>C++ Primer 中文版 第5版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49760521" target="_blank" rel="external">C++primer第五版第六章学习笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/23536587" target="_blank" rel="external">C++Primer第5版学习笔记（六）</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/06/CPP_06/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(四/五)表达式和语句</title>
      <link>http://wangwlj.com/2018/01/05/CPP_04_05/</link>
      <guid>http://wangwlj.com/2018/01/05/CPP_04_05/</guid>
      <pubDate>Fri, 05 Jan 2018 07:51:49 GMT</pubDate>
      <description>
      
        &lt;p&gt;第四章是和表达式有关的知识，表达式是C++的基础设施，本章由三部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表达式概念基础，包括表达式的基本概念，左值和右值的概念，优先级结合律，求值顺序。&lt;/li&gt;
&lt;li&gt;各种运算符,主要包括算数\关系\逻辑\赋值\递增递减\成员访问\条件\位运算\sizeof\逗号运算符 这10种运算符。&lt;/li&gt;
&lt;li&gt;类型转换，包括隐式和显式两种转换的规则。&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>第四章是和表达式有关的知识，表达式是C++的基础设施，本章由三部分组成：</p><ol><li>表达式概念基础，包括表达式的基本概念，左值和右值的概念，优先级结合律，求值顺序。</li><li>各种运算符,主要包括算数\关系\逻辑\赋值\递增递减\成员访问\条件\位运算\sizeof\逗号运算符 这10种运算符。</li><li>类型转换，包括隐式和显式两种转换的规则。</li></ol><a id="more"></a><h2 id="表达式基础"><a href="#表达式基础" class="headerlink" title="表达式基础"></a>表达式基础</h2><h3 id="表达式的基本概念-P120，4-1-1"><a href="#表达式的基本概念-P120，4-1-1" class="headerlink" title="表达式的基本概念(P120，4.1.1)"></a>表达式的基本概念(P120，4.1.1)</h3><p>表达式由一个或者多个运算对象组成，多个对象组成表达式时，对象之间用运算符连接形成复杂表达式。</p><p>运算符中，需要两个对象和运算符连接形成表达式的这种运算符叫做二元（双目，二目）运算符。</p><p>分析一个表达式，必须先了解运算对象的含义、运算符的优先级(precedence)、结合律(associativity)和运算符的求值顺序(order of evaluation)。</p><ol><li>对于含有子表达式的复杂表达式，应该按照求值顺序，看看应该先求哪一个子表达式的值。</li><li>对于不那么复杂的子表达式，应该按照优先级，查看表达式中的每个操作数（对象）应该先跟那一个运算符在一起运算。</li><li>如果有优先级相同的运算符同时在同一个运算对象左右，应该按照结合律选定结合顺序是从右向左还是从左向右计算表达式的值。</li></ol><h3 id="左值和右值-P121，4-1-1"><a href="#左值和右值-P121，4-1-1" class="headerlink" title="左值和右值(P121，4.1.1)"></a>左值和右值(P121，4.1.1)</h3><p><strong>起源</strong>：左值和右值原来是C语言中的概念，特指赋值运算符左右两段的表达式。C语言中，能放在赋值运算符左侧被赋值的对象就是左值，反过来在赋值运算符右侧的对象就是右值。C++中的这两个概念的词义发生了改变。</p><p><strong>概述</strong>：可以暂时概述一下C++中左值和右值的概念。从性质上来看，当一个对象做右值时，我们使用的是这个对象的内容（值）；当一个对象做左值时，我们使用的是它对象的身份（在内存中的位置）。</p><p><strong>应用</strong>：表达式中有的位置需要的是左值，有的位置需要的是右值。表达式的值本身也有左右的分别。<br><strong>赋值运算符</strong>中左侧操作数和表达式结果都是左值。<br><strong>取地址符</strong>的操作对象是左值，得到的是右值。<br><strong>解引用、下标运算符</strong>的求值结果是左值。<br><strong>decltype</strong>作用于表达式时，如果表达式的结果是一个左值，decltype会返回一个引用类型。</p><h3 id="优先级和结合律（P122，4-1-2）"><a href="#优先级和结合律（P122，4-1-2）" class="headerlink" title="优先级和结合律（P122，4.1.2）"></a>优先级和结合律（P122，4.1.2）</h3><p>1.<font color="AA0AA0">优先级</font> 复杂表达式中一个运算对象连接多个不同运算符时，哪个运算符优先级高，就先计算哪个运算符和对象作用后的值。</p><p>2.<font color="AA0AA0">结合律</font> 复杂表达式中一个运算对象连接多个优先级相同的运算符时，根据这一优先级对应的结合律，按从右至左或者从左至右的顺序计算表达式的值。</p><p>如<code>3+2*4-7；</code>这个表达式是一个复杂表达式，因为表达式里<code>*</code>号优先级比较高，所以先计算<code>2*4</code>，得到<code>3+8-7</code>；得到的新表达式更简洁了，只剩下+-两个符号，这两个符号优先级相同，因此查看这个优先级对应的结合律可知这一级别的符号满足左结合性。因此从左向右计算，得到<code>11-7</code>；进一步得到结果<code>4</code>。</p><blockquote><p>括号无视优先级和结合律，可以考虑多使用括号。</p></blockquote><h3 id="求值顺序（P123，4-1-3）"><a href="#求值顺序（P123，4-1-3）" class="headerlink" title="求值顺序（P123，4.1.3）"></a>求值顺序（P123，4.1.3）</h3><p>一个表达式里如果运算对象都是函数返回的，都需要计算求值才知道对象的状态，函数调用符号优先级一致，中间隔着几个优先级低的其他符号连接操作对象，比如<code>int a=f()+g();</code>，这时候是函数f()先被调用还是g()先被调用呢？<font color="AA0AA0">答案是未定义。</font>C++语法没有规定这种情况应该谁先谁后。</p><p>就像下面的表达式<code>++i+i++</code>这个表达式中，优先级最高的表达式<code>++i</code>和<code>i++</code>中间隔着优先级低的运算符<code>+</code>，关于<code>++i</code>先计算还是<code>i++</code>先计算，这是<strong>未定义</strong>的，而因为这个表达式先计算<code>++i</code>或先计算<code>i++</code>的结果不同，<strong>所以这条表达式是错误的</strong>。<font color="AA0AA0">一个变量如果在同一个表达式里被多次改变，这个表达式的求值顺序又不一定，就会出现二义性。应该避免这样的写法。</font></p><p>目前只有四种运算符明确规定了求值顺序。</p><ol><li>逻辑运算符<code>&amp;&amp;</code>和<code>||</code>(P126)：这两个运算符先计算左边操作数的值。</li><li>条件运算符<code>?:</code>(P137)：条件运算符先计算？前的表达式，并求值，之后对视情况对：左右侧的表达式求值。</li><li>逗号运算符<code>，</code>(P140) ：这个运算符的求值顺序是从左至右。</li></ol><blockquote><p>处理复合表达式的两点建议：<br>①拿不准的时候最好用括号来强制让表达式的组合关系复合程序逻辑的要求；<br>②如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。例外：当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。</p></blockquote><h3 id="关于运算符，左值和右值的归纳"><a href="#关于运算符，左值和右值的归纳" class="headerlink" title="关于运算符，左值和右值的归纳"></a>关于运算符，左值和右值的归纳</h3><p>本章各种运算符形成的表达式所返回的值的属性和运算符需要的操作数的属性如下：</p><ul><li>算数/逻辑/位运算符： 操作对象和结果都是右值 </li><li>赋值运算符：左侧的操作对象必须是可以修改的左值，右侧的操作对象是右值，返回一个左值。 </li><li>递增/递减运算符： 前置版本的++/–返回左值，后置版本的++/–返回右值。操作对象都必须是左值。</li><li>箭头成员访问运算符： 作用于指针，表达式结果是一个左值。</li><li>点成员访问运算符: 这个成员所属的对象是左值，结果就是左值；这个成员所属的对象是右值，结果就是右值。 </li><li>条件运算符： 条件运算符的三个表达式都是左值或者都能转化成左值类型时，结果为左值；否则是右值。</li></ul><h2 id="算术运算符-P124-4-2"><a href="#算术运算符-P124-4-2" class="headerlink" title="算术运算符(P124, 4.2)"></a>算术运算符(P124, 4.2)</h2><h3 id="除法和取模的结果-（P125，4-2）"><a href="#除法和取模的结果-（P125，4-2）" class="headerlink" title="除法和取模的结果 （P125，4.2）"></a>除法和取模的结果 （P125，4.2）</h3><p>两个非浮点型变量/字面值相除，结果还是原来的类型，不会有原来操作数是整数，运算之后结果是小数的情况。<br>C++11中， 对于<strong>除运算符，结果向零取整（直接切掉小数部分，得到的数就是结果）</strong>。对于<strong>取模运算符，结果的符号和被除数的符号一致</strong>。（之前的语法标准里除法的结果可以选择是否向零取整，求模（模就是余数）运算可选符号）</p><blockquote><p>(-m)/n = -(m/n); m/(-n) = -(m/n);<br>m%(-n) = m%n; (-m)%n = -(m%n);</p></blockquote><h2 id="成员访问运算符-P133-4-6"><a href="#成员访问运算符-P133-4-6" class="headerlink" title="成员访问运算符(P133, 4.6)"></a>成员访问运算符(P133, 4.6)</h2><p>点运算符和箭头运算符都可以获取类对象的一个成员，<code>ptr-&gt;mem</code> 等价于 <code>(*ptr).mem</code>。</p><p>解引用运算符的优先级低于点运算符，所以<code>(*ptr).mem</code>中的括号不能省略，否则出错。</p><h2 id="条件运算符-P134-4-7"><a href="#条件运算符-P134-4-7" class="headerlink" title="条件运算符(P134, 4.7)"></a>条件运算符(P134, 4.7)</h2><p>条件运算符的格式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cond?expr1:expr2</div></pre></td></tr></table></figure></p><p>条件运算符允许嵌套。</p><h2 id="位运算符（P136，4-8）"><a href="#位运算符（P136，4-8）" class="headerlink" title="位运算符（P136，4.8）"></a>位运算符（P136，4.8）</h2><p><code>bitset</code>的标准库类型可以表示任意大小的二进制位集合。</p><blockquote><p>关于符号位没有明确的规定，因此强烈建议仅将位运算符用于处理无符号类型。</p></blockquote><p>左移运算符移动二进制数后会在右侧插入零，右移运算符在处理有符号类型的操作数（尤其是带负号的）时具体行为由环境决定。</p><table><thead><tr><th style="text-align:center">运算符</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">～</td><td>位求反</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td>左移</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td>右移</td></tr><tr><td style="text-align:center">&amp;</td><td>位与</td></tr><tr><td style="text-align:center">^</td><td>位异或</td></tr><tr><td style="text-align:center">&#124;</td><td>位或</td></tr></tbody></table><blockquote><p>【写博客相关】表格中竖号的打法：<code>&amp;#124;</code>，或者中文格式的<code>丨</code>（输入法输入“shu”查找）</p></blockquote><p>移位运算符（也叫IO运算符）满足左结合律。</p><h2 id="sizeof运算符（P139，4-9）"><a href="#sizeof运算符（P139，4-9）" class="headerlink" title="sizeof运算符（P139，4.9）"></a>sizeof运算符（P139，4.9）</h2><p>sizeof运算符有两种用法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sizeof</span>(type)</div><div class="line"><span class="keyword">sizeof</span> expr</div></pre></td></tr></table></figure></p><p>第一种是sizeof后面直接加一条表达式语句；第二种形如<code>sizeof (类型名)；</code>第二种形式后会得到该类对象所占空间的大小。<br>第一种形式中，如果表达式是指针类型，sizeof运算符会返回指针本身的大小。当有一个类名叫data，类中有一个成员叫做student时，可以使用作用域标识符和sizeof联动，使用<code>sizeof(data::student);</code>就可以计算出student占字节数。</p><h3 id="隐式类型转换（P141，4-11）"><a href="#隐式类型转换（P141，4-11）" class="headerlink" title="隐式类型转换（P141，4.11）"></a>隐式类型转换（P141，4.11）</h3><p>概述：在C++中，一些类型可以按照一定规则互相转换，很多时候语境中需要使用两个或多个相同的类型才能继续运算。因此这时一种类型的值会被自动转换成另一个类型的值。这个过程就是隐式转换，其中算术隐式转换较为常见。</p><p>主要的隐式转换发生的情况：</p><ol><li>大多数表达式中，比int小的类型会被提升为int型。</li><li>在条件中，非布尔值要转化成布尔值。</li><li>在初始化和赋值语句中，赋值符号的右侧对象的类型转换成左侧对象的类型进行运算。</li><li>算术/关系运算中对象有有多种类型的，转化成同一类型。</li><li>形参转化为实参的类型（第六章）。</li><li>数组名会被转换为指针。</li><li>0，nullptr会转为任何类型的指针。任何类型的指针都可以转化为（const）void *类型。</li></ol><p>算数转换时发生隐式转换的补充：<br>在算术运算符的作用下，不同的操作数要转换成同一个类型才能够进行计算。以<code>i+a；</code>这个表达式举例，了解算术转换的方式。</p><ol><li>首先，当i和a的类型占字节比int小，如<code>char、short</code>，把他们转换为int型。如果他们原来类型的最大值在当前系统里大于int型最大值，则转化成<code>unsigned int</code>型。</li><li>之后，如果i和a的类型相同，结束算数隐式转换，若i和a的类型不同，把占字节少的类型的对象转成占字节多的类型的对象。</li><li>如果占字节多的带符号类型的最大值小于占字节少的带转换对象的最大值，带符号类型将被转换为无符号类型。</li></ol><h3 id="显式转换（P144，4-11-3）"><a href="#显式转换（P144，4-11-3）" class="headerlink" title="显式转换（P144，4.11.3）"></a>显式转换（P144，4.11.3）</h3><p>显式转换就是强制类型转换(cast)。</p><p>一个命名的强制类型转换具有以下形式：<code>cast-name&lt;要转换成的类型&gt; （被转换的值）；</code>其中，cast-name是四种强制类型转换：<code>static_cast、dynamic_cast、const_cast</code>和<code>reinterpret_cast</code>之中的一种。</p><ul><li><code>static_cast</code>用于常见的强制类型转换。只要两个类型有关联，比如浮点数类型和整数类型，整数类型和布尔值类型，布尔值类型和指针类型，就可以使用static_cast。只是不能转换常量const到变量。</li><li><code>const_cast</code>用于去掉（或者加上）对象的底层const，要转换的类型和转换的类型都必须是指针或者引用类型。常用于将在第六章介绍的函数重载。当然，这个重载只能针对指针或者引用类型。</li><li><code>reinterpret_cast</code>依赖机器，是强行改变一个类型到另外一个不相干的类型。</li><li><code>dynamic_cast</code>支持运行时类型识别，在19章(P730)将会提到。</li></ul><blockquote><p>建议：避免强制类型转换。</p></blockquote><h2 id="运算符优先级列表的规律（P147-4-12）"><a href="#运算符优先级列表的规律（P147-4-12）" class="headerlink" title="运算符优先级列表的规律（P147,4.12）"></a>运算符优先级列表的规律（P147,4.12）</h2><p>优先级和结合性是第四章的重要内容，因此第四章之后给出了完整的优先级和结合性的参考表。这里是有一定的规律的。</p><ol><li>首先优先级最高的运算符都有这样的属性：单独拿出这个运算符左面的操作数和右面的操作数都没有意义。即运算符本身是连接两个名字组合一个概念的连接器。比如优先级最高的运算符::（作用域运算符），优先级比较高的点运算符（成员选择）下标运算符[]。</li><li>比连接不同名字形成概念的这种运算符稍微低一级别的就是计算对象本身的运算符，比如++，–，类型转换，位求反，逻辑非，解引用，取地址，求类型占的字节数这些运算符大多都是单目元素符，他们的运算目的一般是根据操作数本身的属性进行计算或者改变操作数本身。</li><li>算术运算符。</li><li>逻辑运算符。</li><li>条件运算符。</li><li>赋值运算符 。</li><li>复合赋值，抛出异常，逗号运算符等。</li></ol><h2 id="术语表-P149"><a href="#术语表-P149" class="headerlink" title="术语表(P149)"></a>术语表(P149)</h2><p>1.运算对象 operand<br>2.结果 result<br>3.一元运算符 unary operator<br>4.二元运算符 binary operator<br>5.优先级 precedence<br>6.结合律 associativity<br>7.求值顺序 order of evaluation<br>8.提升 promoted<br>9.重载运算符 overloaded operator<br>10.右值 rvalue<br>11.左值 lvalue<br>12.复合表达式 compound expression<br>13.短路求值 short-circuit evaluation<br>14.高位 high order position<br>15.逗号运算符 comma operator<br>16.相互转换 conversion<br>17.隐式转换 implicit conversion<br>18.算术转换 arithmetic conversion<br>19.整型提升 intergral promotion<br>20.运算对象 operand</p><h2 id="语句简介"><a href="#语句简介" class="headerlink" title="语句简介"></a>语句简介</h2><p>第五章是和语句有关的知识，语句也是C++的重要组分，本章由三部分组成：</p><ol><li>语句的概念，包括简单语句和语句作用域的概念。</li><li>条件/循环/跳转语句,条件语句主要包括if/else语句、switc语句和？：表达式条件语句；循环语句则是for语句和while语句；跳转语句包括continue、break和goto语句。</li><li>try/throw和异常处理，包括异常处理的使用方法。</li></ol><h2 id="语句作用域（P155，5-2）"><a href="#语句作用域（P155，5-2）" class="headerlink" title="语句作用域（P155，5.2）"></a>语句作用域（P155，5.2）</h2><p>用花括号括起来的块就是作用域的标志。在作用域中定义的对象只在作用域中起作用。块之外是没法访问和控制块内部的变量的。</p><p>尤其是在switch语句中，switch的执行过程可能跨过一些标签，当标签里声明并定义了一个对象，这个对象的作用域就延伸到了所有case标签里，如果case 1定义了int a；switch执行了case2，这时这个我们不想执行的语句却产生了自己的作用域，这显然是不行的。因此可以在case标签后使用大括号形成块，这样就不会出现作用域的问题。</p><p>goto也一样不能向前（代码的后几行）跳过对象的定义。不允许跨过变量的定义到达变量的作用域内。但是goto语句可以向后（代码的前几行）跳过定义。</p><blockquote><p>不要在程序中使用goto语句，它会使得程序既难理解又难修改。</p></blockquote><h2 id="try语句块和异常处理（P172，5-6）"><a href="#try语句块和异常处理（P172，5-6）" class="headerlink" title="try语句块和异常处理（P172，5.6）"></a>try语句块和异常处理（P172，5.6）</h2><p>可以用try\throw和catch联动进行异常处理，形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">&#123;待检测块&#125; <span class="comment">//待检测块里面包括throw语句来抛出异常</span></div><div class="line"><span class="keyword">catch</span> (异常类型 异常对象的对象名)</div><div class="line">&#123;异常处理语句 &#125;</div><div class="line"><span class="keyword">catch</span> （同上，可以写很多<span class="keyword">catch</span>）</div><div class="line">&#123;另一组异常处理语句&#125;</div></pre></td></tr></table></figure></p><p>throw抛出异常和catch处理异常的头文件都在<code>stdexcept</code>里定义。抛出异常的语句形如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> 异常类型（<span class="string">"异常文本"</span>）；</div></pre></td></tr></table></figure></p><p>异常类型一般只支持赋值，初始化，调用成员函数.what之类的几种操作。</p><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>1.控制流 flow-of-control<br>2.表达式语句 expression statement<br>3.空语句 null statement<br>4.复合语句 compound statement<br>5.悬垂else dangling else<br>6.case标签 case label<br>7.引发（异常） raise<br>8.catch子句 catch clause<br>9.异常处理代码 exception handler<br>10.异常安全（这不是特别安全的意思，而是在异常情况下也能保证程序执行预期的正确行为） exception safe</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>C++ Primer 中文版 第5版</li><li><a href="https://zhuanlan.zhihu.com/p/23535827" target="_blank" rel="external">C++Primer第5版学习笔记（四、五）</a></li><li><a href="https://www.zhihu.com/question/37542455" target="_blank" rel="external">用Markdown写Hexo博客时如何转义竖杠 | ？</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/05/CPP_04_05/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(三)字符串、向量和数组</title>
      <link>http://wangwlj.com/2018/01/04/CPP_03/</link>
      <guid>http://wangwlj.com/2018/01/04/CPP_03/</guid>
      <pubDate>Thu, 04 Jan 2018 13:36:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;第三章主要讲这么五个概念：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;using声明&lt;/strong&gt;，我知道挺多同学写代码练手都要在源文件前几句直接加using namespace std;然而using语句并不是什么情况都这么使用的，稍后我们将会看到详细的用法。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;标准库类型string&lt;/strong&gt;,和C的字符数组有区别的string，到底是怎么个构造，这章将会讲述。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;标准库类型vector&lt;/strong&gt;，vector和数组区别很大，这里将会提到，并引入一个“容器”的重要概念。&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;迭代器&lt;/strong&gt;，迭代器用来代替下标这种传统方式访问容器或一些支持迭代器的类型。&lt;/p&gt;
&lt;p&gt;5.&lt;strong&gt;数组和多维数组&lt;/strong&gt;，经典概念。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>第三章主要讲这么五个概念：</p><p>1.<strong>using声明</strong>，我知道挺多同学写代码练手都要在源文件前几句直接加using namespace std;然而using语句并不是什么情况都这么使用的，稍后我们将会看到详细的用法。</p><p>2.<strong>标准库类型string</strong>,和C的字符数组有区别的string，到底是怎么个构造，这章将会讲述。</p><p>3.<strong>标准库类型vector</strong>，vector和数组区别很大，这里将会提到，并引入一个“容器”的重要概念。</p><p>4.<strong>迭代器</strong>，迭代器用来代替下标这种传统方式访问容器或一些支持迭代器的类型。</p><p>5.<strong>数组和多维数组</strong>，经典概念。</p><a id="more"></a><h2 id="命名空间的using声明-P75-3-1"><a href="#命名空间的using声明-P75-3-1" class="headerlink" title="命名空间的using声明(P75,3.1)"></a>命名空间的using声明(P75,3.1)</h2><p>尽管我们可以在各种文件里都使用<code>using namespace std;</code>或者<code>using std::endl;</code>这种语句，但是，在头文件包含命名空间可能产生各种意外。因此，头文件不应包含using声明。</p><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>本节介绍最常用的操作，<em>9.5</em>节将介绍另外的。</p><h3 id="定义和初始化string对象-P76-3-2-1"><a href="#定义和初始化string对象-P76-3-2-1" class="headerlink" title="定义和初始化string对象(P76,3.2.1)"></a>定义和初始化string对象(P76,3.2.1)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div></pre></td></tr></table></figure><p>以下几种初始化语句被string支持：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> s1;<span class="comment">//创建了一个空的字符串，对象名为s1，类型为string类型。</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//是s2的值与s1的值相等。</span></div><div class="line"><span class="built_in">string</span> s2=s1;<span class="comment">//同上一句，拷贝初始化。</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"value"</span>)</span></span>;<span class="comment">//直接用字符串字面值初始化string类型的对象。</span></div><div class="line"><span class="built_in">string</span> s3=<span class="string">"value"</span>;<span class="comment">//字符串字面值转化为string类型变量并赋值给string。</span></div><div class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;<span class="comment">//直接初始化string，操作后s4拥有10个字符，每个字符的值都是'c'。</span></div></pre></td></tr></table></figure><p>最后，其实<code>string s5={&quot;value&quot;}</code>和<code>string s3=&quot;value&quot;</code>一样，也是合法的。不过<strong>大括号初始化是严格检测匹配的</strong>，比如<code>int a={3.5};</code>就是错误的。</p><h3 id="string支持的操作-P77-3-2-2"><a href="#string支持的操作-P77-3-2-2" class="headerlink" title="string支持的操作(P77,3.2.2)"></a>string支持的操作(P77,3.2.2)</h3><h4 id="1-输入流中获取字符串"><a href="#1-输入流中获取字符串" class="headerlink" title="1.输入流中获取字符串"></a>1.输入流中获取字符串</h4><p>首先要强调是<code>cin&gt;&gt;string</code>的操作，这种操作就是从输入流中读字符串，值得注意的是这个过程会忽略掉开头输入的各种空白（我们说空白时是在说 <font color="00aa00"> <strong>空格，换行符，制表符</strong></font>）,读取输入流直到遇到字符后的第一个空白为止。</p><p>另一种<code>getline（cin,string）;</code>的操作(P78) 则可以读一行，也就是读入输入流的数据（包括空格，制表符），直到遇到<font color="00aa00"><strong>换行符</strong></font>为止，这里输入流中的换行符本身已经被读过了，但是字符串里不保存这个换行符。下次再从输入流里读什么数据至少也要从这个换行符后面对输入流进行操作了。</p><h4 id="2-string-type-size-P79"><a href="#2-string-type-size-P79" class="headerlink" title="2.string::type_size (P79)"></a>2.string::type_size (P79)</h4><p>为了更抽象，脱离机器特性，调用每个string对象的<strong>size成员函数</strong>，返回值都是一个<strong><code>string::type_size</code></strong>类型，这个类型拥有无符号整形数的一些性质。在string对下标的支持中，[ ]中的数字也会被转换为<code>string::type_size</code>类型。这里要强调的是<code>string::type_size</code>是一个<font color="00aa00"><strong>无符号类型</strong></font>。使用这个类型和int型这种有符号的类型一起进行计算可能出现一些错误。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> len = line.size(); <span class="comment">//len的类型是string::size_type</span></div></pre></td></tr></table></figure></p><blockquote><p>如果一个表达式中已经有了<code>size()</code>函数，就不要再使用<code>int</code>了，这样可以避免混用<code>int</code>和<code>unsigned</code>可能带来的问题。</p></blockquote><h4 id="3-string对象与字符串字面值相加-P80"><a href="#3-string对象与字符串字面值相加-P80" class="headerlink" title="3.string对象与字符串字面值相加 (P80)"></a>3.string对象与字符串字面值相加 (P80)</h4><p>字符串字面值是字符数组类型，字符串字面值和string类型的对象在一起计算时会被自动转换为string类型。</p><h4 id="4-其他支持的操作"><a href="#4-其他支持的操作" class="headerlink" title="4.其他支持的操作"></a>4.其他支持的操作</h4><p>包括下标运算符[ ]、重载的+、==、！=、&lt;、&gt;、&lt;=、&gt;=。</p><h3 id="处理每个字符的头文件cctype（P82-3-2-3）"><a href="#处理每个字符的头文件cctype（P82-3-2-3）" class="headerlink" title="处理每个字符的头文件cctype（P82, 3.2.3）"></a>处理每个字符的头文件cctype（P82, 3.2.3）</h3><p>我们可以通过引用头文件<code>&lt;cctype&gt;</code>的形式处理每一个字符。这个头文件包含很多方便处理字符的函数。列举如下：</p><ul><li>isalnum(c); //当c是字母或者数字时为真 </li><li>isalpha(c); //当c是字母时为真</li><li>iscntrl(c); //当c是控制字符时为真</li><li>isdigit(c); //当c是数字时为真</li><li>isgraph(c); //当c不是空格但是可打印时为真</li><li>islower(c); //当c是小写字母为真</li><li>isprint(c); //当c可打印时为真 </li><li>isupper(c); //当c是大写字符时为真</li><li>isxdigit(c); //当c是16位数字时为真</li><li>ispunct(c); //当c是标点符号时为真（一个字符除了控制字符，字母，数字，可打印空白就是标点符号）</li><li>isspace(c); //当c是空白时为真（空白包括空格，横向/纵向制表符，回车符，换行符，进纸符）</li><li>tolower(c); //把大写字符转换为小写字符，本来就是小写字符的不变，返回转换后的字符</li><li>toupper(c); //把小写字符转换为大写字符，本来就是大写字符的不变，返回转换后的字符</li></ul><blockquote><p>建议：使用C++版本的C标准库头文件。<br>C++标准库兼容了C语言的标准库。C语言的头文件形如<code>name.h</code>，C++则会将这些文件命名为<code>cname</code>。也就是去掉了<code>.h</code>后缀，在文件名前添加了字母c。</p></blockquote><h3 id="范围for（range-for）语句-P82，3-2-3"><a href="#范围for（range-for）语句-P82，3-2-3" class="headerlink" title="范围for（range for）语句(P82，3.2.3)"></a>范围for（range for）语句(P82，3.2.3)</h3><p><strong>范围for语句用于遍历元素</strong>。形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(一个用于访问序列中基础元素的变量a : 被访问的序列对象b)&#123;</div><div class="line">    statement..... blabla;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首次初始化，变量a的值会被初始化为对象b序列中的第一个元素，迭代之后每次访问下一个元素，直到序列被完全访问结束。</p><p>可以使用<code>auto &amp;a</code>的方式声明变量a,使变量绑定到具体的序列元素上，从而进行更改。如在<code>for(auto a : str){}</code>中，每次把a初始化的行为实质上是使a获得str每个元素的副本（拷贝），而<code>for(auto &amp;a ： str){}</code>这样的语句则使a成为了str对应的每个元素的”别名”,从而可以修改str。</p><p>使用范围for循环遍历多维数组，为了不手动打类名，也为了防止外层数组的名被auto类型转化成指针，要在对外层数组的访问上都加上&amp;绑定。</p><blockquote><p>范围for有空补，未详看。</p></blockquote><h2 id="标准库类型vector-P86-3-3"><a href="#标准库类型vector-P86-3-3" class="headerlink" title="标准库类型vector(P86, 3.3)"></a>标准库类型vector(P86, 3.3)</h2><h3 id="类模板、容器和实例化-P87-3-3"><a href="#类模板、容器和实例化-P87-3-3" class="headerlink" title="类模板、容器和实例化(P87, 3.3)"></a>类模板、容器和实例化(P87, 3.3)</h3><p>当我们在C++里面谈论容器这个概念时，我们应该知道容器是用来存储和组织一类特定对象的集合。下面提到的标准库类型<code>vector</code>，就是一个容器。</p><p>类模板一般用于按照模板规定好的规则生成不同的类。我们无需很麻烦的一个一个写类的定义，只需使用模板，给出指定的少量信息，类模板就会帮助我们自动生成一个我们可以直接使用的类。vector也是一个类模板。</p><p>通过类模板创建类的过程，或者通过类型创建对象的过程，就叫做<strong>实例化</strong>。</p><h3 id="定义和初始化vector对象-P87-3-3-1"><a href="#定义和初始化vector对象-P87-3-3-1" class="headerlink" title="定义和初始化vector对象(P87,3.3.1)"></a>定义和初始化vector对象(P87,3.3.1)</h3><p>与string的定义和初始化一样，我们也可以使用多种方式定义和初始化一个vector对象。</p><p>以下几种初始化语句被vector支持：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v1;<span class="comment">//创建了一个空的vector容器，这个容器是Type类型对象的集合，这个集合名字叫做为v1，执行默认初始化。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v2(v1);<span class="comment">//创建了一个叫做v2的vector容器，这个容器的内容和v1相同。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v2=v1;<span class="comment">//同上一句，拷贝初始化。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;Type&gt; v3&#123;a,b,c,...&#125;;<span class="comment">//v3包含了初始值个数的元素。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;Type&gt; v4=&#123;a,b,c,...&#125;;<span class="comment">//同上。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;Type&gt; v5(n,val);<span class="comment">//直接初始化这个容器，操作后v5拥有n个元素，每个元素的值都是val。</span></div><div class="line"></div><div class="line"><span class="built_in">vector</span> &lt;Type&gt; v5(n);<span class="comment">//直接初始化这个容器，操作后v5拥有n个元素，每个元素的值都被默认初始化。</span></div></pre></td></tr></table></figure><p>当我们使用圆括号<code>（）</code>初始化对象时，IDE会认为我们在通过语句<code>“构建”</code>(constract)这个对象 ；当我们使用花括号<code>{ }</code>初始化对象时，IDE会认为我们在列表初始化(list initialize)对象。</p><p>当我们使用等号=初始化对象时，我们就执行了“拷贝初始化”；当我们不使用=初始化对象时，我们就执行了“直接初始化”。</p><p>但是当我们在花括号里面给一个不符合对象类型的值，IDE就会认为我们正在<strong>构建而非初始化对象</strong>，一个体现就是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;</div></pre></td></tr></table></figure></p><p>这个语句中，10不能转换为string，因此被系统理解为“这个string容器里有10个元素”。<br>当然，像<code>vector &lt;string&gt;s1={10};</code>这样的语句是错误的，因为=就应该是拷贝初始化了，然而10并不能够被转化为string因此也无法赋值。</p><h3 id="向vector对象添加元素-P90-3-3-2"><a href="#向vector对象添加元素-P90-3-3-2" class="headerlink" title="向vector对象添加元素(P90, 3.3.2)"></a>向vector对象添加元素(P90, 3.3.2)</h3><font color="000aa0"><br>向vector对象添加元素：<strong>push_back</strong>。<br></font><blockquote><p>循环体内部包含向vector对象添加元素时，则不能使用<strong>范围for循环</strong>。</p></blockquote><h3 id="vector支持的操作-P91-3-3-3"><a href="#vector支持的操作-P91-3-3-3" class="headerlink" title="vector支持的操作(P91, 3.3.3)"></a>vector支持的操作(P91, 3.3.3)</h3><ol><li><p>向容器的后面添加元素：已存在<code>vector&lt;T&gt; v;</code>，可以使用 <code>v.push_back(vector&lt;T&gt; a)</code>的方式在集合v的尾部添加元素。</p></li><li><p><code>empty</code>和<code>size</code>函数成员：已存在<code>vector&lt;T&gt; v;</code>，可以使用 <code>v.empty()</code>的方式判断v是否为空，可以使用<code>v.size()</code>的方式返回v的大小。</p></li><li><p>重载的运算符：vector支持的运算符包括下标运算符<code>[ ]</code>、重载的+、<code>==、！=、&lt;、&gt;、&lt;=、&gt;=</code>。这一点和<code>string</code>类似。</p></li></ol><blockquote><p>不能用下标形式添加元素。<br>只能对确知已存在的元素执行下标操作！</p></blockquote><h2 id="迭代器介绍-3-4"><a href="#迭代器介绍-3-4" class="headerlink" title="迭代器介绍(3.4)"></a>迭代器介绍(3.4)</h2><p>为了访问容器的元素（有些容器可能不支持下标运算符），因此C++提供了迭代器(iterator)这个概念来访问容器中的指定元素。</p><p>支持迭代器的类都会提供名为begin和end的函数成员来供我们获取迭代器。如已定义<code>vector&lt;int&gt; i1(10);</code>，这时使用<code>auto ben=i1.begin();</code>这个语句获取指向第一个字符的迭代器，使用<code>auto end=i1.end();</code>获取指向i1容器最后一个元素的下一个元素的迭代器，术语“尾后迭代器”。两个迭代器可以相减，但是两个迭代器相加后的行为是未定义的。</p><p>当使用<code>vector &lt;int&gt;</code>创建类时，这个类的命名空间就是<code>vector &lt;int&gt;</code>，命名空间中的迭代器类型写作<code>vector&lt;int&gt;::iterator</code>。因为这个叫做<code>&quot;vector&lt;int&gt;::iterator&quot;</code>的迭代器类型名太长了也不好记，这里我们使用<code>auto</code>推导这个类型。用成员函数<code>cbegin</code>和<code>cend</code>可以推导出底层const迭代器，就是这个迭代器对迭代器指向的内容只读不写。第6章会详细说明。</p><p>迭代器 对 迭代器指向的容器内容 可以像 指针 对 指针指向的数组元素一样使用。</p><p>虽然数组不是直接支持迭代器的类型，但是可以引入<code>&lt;iterator&gt;</code>头文件，使用<code>begin(数组名)</code>和<code>end(数组名)</code>的方式获得指向数组第一个元素和尾后第一个元素的指针。因为大多数容器不支持下标运算符，所以使用迭代器访问容器等结构中的元素是最好的方法。</p><h2 id="数组-3-5-P101"><a href="#数组-3-5-P101" class="headerlink" title="数组(3.5, P101)"></a>数组(3.5, P101)</h2><h3 id="一维数组的定义和初始化-3-5-1-P102"><a href="#一维数组的定义和初始化-3-5-1-P102" class="headerlink" title="一维数组的定义和初始化(3.5.1,P102)"></a>一维数组的定义和初始化(3.5.1,P102)</h3><p>一维数组声明形式：<code>类型名 数组名[一个常量]</code>。比如<code>int a[15];</code>这里这个数组的名字是a，有15个元素，每个元素都是int型的。再比如<strong><code>int *a[15];</code></strong>这里<strong>a数组的15个元素都是<code>int *</code>型的，即指向int的指针</strong>，这样的指针有15个，构成了一个数组。虽然有指针数组，但是不存在元素都是引用类型的数组。</p><p>一维数组的初始化方式就是花括号初始化，形如<code>int a[n]={1,2,3};</code>，大括号里面的内容就是初始化列表，n为数组大小，可以缺省，缺省时数组长度由初始化列表的元素个数决定。当初始化列表的值的个数比数组长度小，数组剩下的元素被初始化为默认的值，比如对于有10个元素的int型数组，如果只给出第一个元素的值，后几个元素将被初始化为0。</p><p>当我们声明<code>int a[]</code>的时候代表通过数组名a访问这个数组。<br>我们也可以定义指向数组的指针和指向数组的引用来间接访问这个数组。<br>已有<code>int arr[10];</code>的情况下，<code>int (*ptr) [10]=&amp;arr;</code>这条语句可以使指针ptr指向arr这整个数组。<code>int (&amp;ref)[10]=arr;</code>则会使ref作为整个arr数组的引用。<code>int *(&amp;ref)[10]=arr;</code>这个语句则是说ref是arr的引用，这个被引用的数组的类型是指针数组。</p><p><code>auto a=一个数组名</code>，a的类型将会是这个指针，指针指向的类型就是数组元素的类型。<br>用<code>decltype(一个数组名) a;</code>这样的形式，a将会是和数组名属性一致的数组。<br>在大部分运算中，数组名都会被转化成相应的指针类型。如<code>*(ai+4)</code>中，数组名ai是指向整个数组首元素的指针，这个指针＋4就是向右侧移动4位，指针原来指向第一个元素，移动4位就指向了数组中的第五个元素。然后指向的值就是ai数组第五个元素的值，相当于ai[4]。</p><h3 id="用数组初始化vector对象和用string对象赋值字符数组-3-5-5-P111"><a href="#用数组初始化vector对象和用string对象赋值字符数组-3-5-5-P111" class="headerlink" title="用数组初始化vector对象和用string对象赋值字符数组(3.5.5, P111)"></a>用数组初始化vector对象和用string对象赋值字符数组(3.5.5, P111)</h3><p>作为与旧代码的接口，C++提供了方便的把数组转化为vector对象的方法。在声明vector对象时，我们可以通过迭代器用一个数组初始化vector。<br>在已经存在<code>int oldarray[10];</code>的情况下，声明的语句形如：<code>vector&lt;int&gt; arr( begin(oldarray) , end(oldarray) );</code>可以把arr初始化为oldarray。begin和end这两个函数在<code>&lt;iterator&gt;</code>头文件里，作用是返回数组的首元素/尾后指针。这种初始化接受两个参数：拷贝开始部分指针和结束部分的指针。<br>我们也可以写形如<code>int arr[10]={0}; vector &lt;int&gt; newarr( arr+1 , arr+6 );</code>这种方式拷贝数组arr的第2~第5号元素，并用它们初始化newarr。</p><p>类似地，我们可以通过<code>string a(&quot;23333333\n&quot;); const char *b=a.c_str();</code>这样的语句使string型的a被赋值给字符数组指针b。返回结果是const是为了确保我们不会通过这个指针改动返回的字符数组的值。</p><blockquote><p>建议： 尽量使用标准库类型而非数组</p><p>使用指针和数组容易出错。现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。</p></blockquote><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>1.拷贝初始化 copy initialization<br>2.直接初始化 direct initialization<br>3.范围for range for<br>4.容器 container<br>5.类模板 class template<br>6.实例化 instantiation<br>7.值初始化 value-initialized<br>8.构造 construct<br>9.列表初始化 list initialize<br>10.迭代器 iterator<br>11.迭代器运算 iterator arithmetic<br>12.C风格字符串 C-style character string<br>13.空字符 null terminated<br>14.缓冲区溢出 buffer overflow<br>15.编译器扩展 complier extension</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>C++ Primer 中文版 第5版</li><li><a href="https://zhuanlan.zhihu.com/p/23503699" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/23503699</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/04/CPP_03/#disqus_thread</comments>
    </item>
    
    <item>
      <title>西瓜书《机器学习》学习笔记(2)：比较检验与偏差方差</title>
      <link>http://wangwlj.com/2018/01/04/ML_chap2_02/</link>
      <guid>http://wangwlj.com/2018/01/04/ML_chap2_02/</guid>
      <pubDate>Thu, 04 Jan 2018 10:46:46 GMT</pubDate>
      <description>
      
        &lt;p&gt;本篇主要介绍比较检验、偏差与方差。&lt;br&gt;其中，比较检验分为如下四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设检验&lt;/li&gt;
&lt;li&gt;交差验证t检验&lt;/li&gt;
&lt;li&gt;McNeMar检验&lt;/li&gt;
&lt;li&gt;FriedMan检验与Nemenyi后续检验&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本篇主要介绍比较检验、偏差与方差。<br>其中，比较检验分为如下四类：</p><ul><li>假设检验</li><li>交差验证t检验</li><li>McNeMar检验</li><li>FriedMan检验与Nemenyi后续检验</li></ul><a id="more"></a><h2 id="比较检验-2-4-P37"><a href="#比较检验-2-4-P37" class="headerlink" title="比较检验(2.4, P37)"></a>比较检验(2.4, P37)</h2><p>在比较学习器泛化性能的过程中，<strong>统计假设检验（hypothesis test）</strong>为学习器性能比较提供了重要依据，即若A在某测试集上的性能优于B，那A学习器比B好的把握有多大。</p><h3 id="假设检验-2-4-1-P38"><a href="#假设检验-2-4-1-P38" class="headerlink" title="假设检验(2.4.1, P38)"></a>假设检验(2.4.1, P38)</h3><p>假设检验(Hypothesis Testing)是数理统计学中根据一定假设条件<strong>由样本推断总体</strong>的一种方法。</p><p>“假设”指的是对学习器泛化错误率分布的某种判断或猜想，如“$\epsilon = \epsilon_0 $”，现实任务中，我们并不知道学习器的泛化错误率$\epsilon$，但是可以通过测试错误率$\hat \epsilon$推算。</p><p>在包含了 m 个样本的测试集上，【泛化错误率为 $\epsilon$ 的学习器】被测得测试错误率为$ \hat \epsilon $的概率为：<br>$$P(\hat\epsilon;\epsilon) = \begin{pmatrix} m \\ \hat\epsilon\times m  \end{pmatrix} \epsilon^{\hat\epsilon\times m}(1-\epsilon)^{m-\hat\epsilon\times m}$$</p><blockquote><p>上式中的$\begin{pmatrix} m \\ \hat\epsilon\times m  \end{pmatrix} $表示$C_m^{m’}$，即从m个数中任取m’个数。</p></blockquote><p>这个概率，表达了【泛化错误率为 $\epsilon$ 的学习器】被测得【测试错误率】为 $\hat{\epsilon}$ 的可能性。 $\hat{\epsilon} $取0~100%。若以这个【可以测得的测试错误率$ \hat{\epsilon} $】作为自变量，以概率 $P(\hat{\epsilon};\epsilon) $为因变量，建立平面坐标图，则对于不同的测试错误率，有不同的可能性。在某点可能性越高，这个未知的【泛化错误率$ \epsilon $】和这个点代表的测试错误率的关系就越密切。</p><p>现在要找其可能性最高的点，就要对概率$ P(\hat{\epsilon};\epsilon)$ 求 $\epsilon$ 的导数，导数为0时，存在极值。</p><p>而对此概率函数求导并解出导函数等于0的式子之后，发现存在一个值 $\epsilon_0$ ，使得$P(\hat{\epsilon};\epsilon)$在$\epsilon=\epsilon_0$时最大，$|\epsilon-\epsilon_0|$ 增大时减小。整个图像其实是个山峰形状，符合二项分布。</p><p>那么此时也可以反过来讲，如果这个泛化错误率 $\epsilon$ 已知为 $\epsilon_0$ ，则理论上，横坐标为 $\epsilon_0$的概率值$P(\hat{\epsilon};\epsilon)$是最大的。</p><p>即：<strong>若泛化错误率为$ \epsilon_0$ ，则测试错误率也为 $\epsilon_0$ 的概率最大（可能性最高）</strong>。</p><p>此时，我们得到了泛化错误率为$ \epsilon_0$，我们可以用这个数值来进行假设，假设这个学习器的泛化错误率不会超过 $\epsilon_0$。</p><p>即假设：“$ H_0:\epsilon≤\epsilon_0$ ”。</p><p>到底要不要接受这个假设呢？</p><p>我们需要检验一下。</p><blockquote><p>显著度（显著性水平）是估计总体参数落在某一区间内，可能犯错误的概率，用$\alpha$表示。$\alpha$的常用取值很小，如0.05，0.1等。<br>$1-\alpha$则表示置信度(confidence)。</p></blockquote><p>通过二项检验(binomial test)，我们得到结论：在$\alpha$的显著度下，假设$ H_0:\epsilon≤\epsilon_0$ 不能被拒绝，能<strong>以$1-\alpha$的置信度认为，学习器的泛化错误率不大于$\epsilon_0$</strong>；否则假设被拒绝，即在$\alpha$的显著度下可认为该学习器的泛化错误率大于$\epsilon_0$。</p><hr><p>现实中我们并非仅作出一次留出法估计，而是做多次，所以会得到不同的多个测试错误率，假定为k个测试错误率： $\hat \epsilon_1$、$\hat \epsilon_2、\cdots 、\hat \epsilon_k$，则平均错误率$ \mu  $和方差$ \sigma^{2}$为：<br>$$\mu = \frac 1k \sum_{i=1}^k\hat \epsilon_i $$<br>$$ \sigma^2 = \frac{1}{k-1} \sum_{i=1}^k (\hat \epsilon_i - \mu)^2$$</p><blockquote><p>假设X服从标准正态分布N（0,1），Y服从$ \chi^2$分布，那么$ T=X/\sqrt{Y/n}$  的分布称为自由度为n的t分布,记为$T \sim t(n)$。</p><p>t分布这边需要一定的数学基础。默默记住吧。</p></blockquote><p>T 为自由度为 n 的 t 分布，变量 $\tau_{t}=(\sqrt{k}(\mu-\epsilon_0))/\sigma $服从自由度为 k-1 的 t 分布。（ $\mu-\epsilon_{0} $服从正态分布， $\sigma^{2} $服从自由度为 k-1 的$ \chi^2 $分布）</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3pvrkvwjj20em09pjrr.jpg" alt=""></p><p>由此图和 t 分布图的性质可知，最高点处就是测试错误率的最大值$\epsilon_0$ 。</p><p>现在要重新假设了，“ $H_1:\mu=\epsilon_0 $”。</p><p>接下来就是继续确定显著度 $\alpha$ ，确定门槛值（此处用双边假设），最后进行在置信度为 $1-\alpha$ 下的判断了。</p><h3 id="交叉验证-t-检验-2-4-2-P40"><a href="#交叉验证-t-检验-2-4-2-P40" class="headerlink" title="交叉验证 t 检验(2.4.2, P40)"></a>交叉验证 t 检验(2.4.2, P40)</h3><p>回顾一下上一篇中的<strong>k折交叉验证</strong>：</p><blockquote><p>“k折交叉验证法”(cross validation)先将数据集D划分为k个大小相似的互斥子集，即$D=D_1\cup D_2 \cup \cdots\cup D_k,D_i \cap D_j =\oslash (i\neq j)$</p></blockquote><p>如果说前一种的<strong>假设检验是得到单个学习器的泛化错误率的大致范围假设</strong>，那么<strong>“交叉验证t检验”方法就是在比较A、B两学习器性能的优劣</strong>了（不过偏向于验证A、B性能是否相同）。</p><p>现在有两个学习器A和B，使用 k 折交叉验证法得到测试错误率分别为 $\epsilon_{1}^{A},\epsilon_{2}^{A},\epsilon_{3}^{A},…\epsilon_{k}^{A}$ 和$\epsilon_{1}^{B},\epsilon_{2}^{B},\epsilon_{2}^{B},…\epsilon_{k}^{B} $。其中$ \epsilon_{i}^{A} $和 $\epsilon_{i}^{B} $是在相同的第 i 折训练/测试集上得到的结果。</p><blockquote><p>注意，此时的测试错误率和之前的假设检验那一节的测试错误率采用了不同的符号，此时由于没有提到泛化错误率，测试错误率被标记为$ \epsilon $，只不过增加了上下角标，请各位不要将其与上一节的泛化错误率混淆。</p></blockquote><p>基本思想：若两个学习器的性能相同，则它们使用的训练/测试集得到的测试错误率应相同，即 $\epsilon_{i}^{A}=\epsilon_{i}^{B} $。</p><p>实际上却不会像理想状态一样，两个学习器的测试错误率并不完全相同，而是存在一定的微小差值。我们想要判断两个学习器的性能是否有显著差别，就要利用这个差值进行假设检验。</p><p>若两个学习器性能相同，这个差值均值应该为0。因此可对这k个差值对“学习器A和B性能相同”这个假设做 t 检验。</p><p>1、先对每一对结果求差，$ \Delta_i=\epsilon_{i}^{A}-\epsilon_{i}^{B}$</p><p>2、计算出这$k$个差值的均值$ \mu $和方差 $\sigma^2$</p><p>3、根据 t 检验的公式$ T=X/\sqrt{Y/n} $，得 $\tau_t=|\frac{\sqrt{k}\mu}{\sigma}|$ ，满足自由度为 k-1 的 t 分布，故在显著度$ \alpha $，若其小于临界值 $t_{\alpha/2,k-1} $，则假设不能被拒绝，即认为两个学习器性能没有显著的差别。反之则认为平均错误率小的性能更优。</p><p>这里$t_{\alpha/2,k-1}$ 是分布上尾部累积分布为$\alpha/2$ 的临界值。</p><p>但是这样使用 k 折交叉验证法，通常情况下会因为样本有限，使得不同轮次的训练集产生一定程度的重叠。这样训练出来的学习器，会让得出的这组测试错误率无法做到彼此完全独立。</p><p>而进行有效的假设检验的一个重要的前提就是：测试错误率均为泛化错误率的独立采样。（例如 t 分布就需要随机变量X和Y相互独立。）</p><p>所以为了缓解这个问题，可采用“5×2交叉验证”法。</p><h4 id="5×2交叉验证-2-4-2-P41"><a href="#5×2交叉验证-2-4-2-P41" class="headerlink" title="5×2交叉验证(2.4.2, P41)"></a>5×2交叉验证(2.4.2, P41)</h4><p>待补。</p><h3 id="McNemar检验-2-4-3-P41"><a href="#McNemar检验-2-4-3-P41" class="headerlink" title="McNemar检验(2.4.3, P41)"></a>McNemar检验(2.4.3, P41)</h3><p>McNemar检验适用于二分类问题，与成对t检验一样也是用于比较两个学习器的性能大小。通过联列，可以获得学习器A和B的分类结果的差别。下表即为两分类器分类差别列联表， e 为样本数。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4g3oembgj20es08474e.jpg" alt="列联表"></p><p>主要思想是：若两学习器的性能相同，则A预测正确B预测错误数应等于B预测错误A预测正确数，即$e_{01}=e_{10}$，且$|e_{01}-e_{10}|$符合正态分布。</p><blockquote><p>$| e_{01}-e_{10}|$为什么符合正态分布？</p><p>按理说，实际生活中，凡自然状态下的整体数据分布几乎都符合<strong>正态分布</strong>，那么当假设两学习器性能相同的时候，如果用大量不同的测试集进行测试，这个差值应该就可能符合正态分布。</p></blockquote><p>McNemar检验考虑变量：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4gg36qwrj209902j3yb.jpg" alt="McNemar检验变量"></p><blockquote><p>但上式中的“-1”并非因为$ |e_{01}-e_{10}| $的均值 $\mu$ 为1，实际上均值$ \mu $应近似为0，这里的“-1”，是为了<strong>连续性校正</strong>。</p><p>什么是连续性校正？$2*2$列联表资料是分类资料,所以样本量较小时要进行连续性校正。。卡方检验要求：最好是大样本数据。一般每个个案最好出现一次，四分之一的个案至少出现五次。如果数据不符合要求，就要应用校正卡方。参见<a href="https://en.wikipedia.org/wiki/McNemar%27s_test#cite_note-Edwards1948-3" target="_blank" rel="external">维基百科</a></p></blockquote><p>上述变量$\tau_{\chi^2}$ 符合自由度为1 的$ \chi^2 $分布。</p><blockquote><p>$ \chi^2 $分布的定义：若k个独立的随机变量$Z_1,Z_2,⋯,Z_k$，且符合标准正态分布$N(0,1)$，则这k个随机变量的平方和 $X=∑_{i=1}^kZ^2_i$为服从自由度为k的卡方分布，记为： $X\sim \chi^2(k)$。<br>卡方分布的期望与方差分为为：<br>$E(\chi^2)=k，D(\chi^2)=2k$，其中k为卡方分布的自由度。</p></blockquote><p>给定显著度$\alpha $，当上述变量小于临界变量值的时候，不能拒绝假设，即认为两学习器的性能没有显著差别；否则拒绝假设，即认为两者性能有显著差别，平均错误率较小的学习器性能较好。这个过程也是自由度为1 的卡方检验。</p><blockquote><p>$\chi^2 $检验，中文名为<strong>卡方检验</strong>。卡方检验是一种用途很广的计数资料的假设检验方法。它属于非参数检验的范畴，主要是比较两个及两个以上样本率( 构成比）以及<strong>两个分类变量的关联性分析</strong>。其根本思想就是在于比较理论频数和实际频数的吻合程度或拟合优度问题。</p></blockquote><h3 id="Friedman检验与Nemenyi后续检验-2-4-4-P42"><a href="#Friedman检验与Nemenyi后续检验-2-4-4-P42" class="headerlink" title="Friedman检验与Nemenyi后续检验(2.4.4, P42)"></a>Friedman检验与Nemenyi后续检验(2.4.4, P42)</h3><p>上述的三种检验（假设检验、交叉验证t检验，McNemar检验）都只能在一组数据集上，Friedman检验则可以在多组数据集进行多个学习器性能的比较，基本思想是在同一组数据集上，根据测试结果（例：测试错误率）对学习器的性能进行排序，赋予<strong>序值1,2,3…</strong>，相同则平分序值，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4o1uvti5j20h005yglo.jpg" alt=""></p><blockquote><p>比如：D1数据集上，算法A的性能最好，其次算法B的性能，最差的是算法C的性能。<br>数字越小，代表该算法在该数据集上的表现越好。</p></blockquote><p><font color="000AA0">Friedman检验</font>：判断算法是否性能都相同。 检验变量$\tau_{\chi^2}$与F检验的临界值进行比较。</p><p>若<strong>“H0：所有算法的性能相同”</strong>这个假设被拒绝，则需要进行后续检验(post-hoc test)，来得到具体的算法之间的差异。常用的就是<strong>Nemenyi后续检验</strong>。</p><p>Nemenyi检验计算出平均序值差别的<strong>临界值域</strong>，<strong>若两个算法的平均序值差超出了临界值域CD，则相应的置信度1-α拒绝“两个算法性能相同”的假设</strong>。</p><p>总结一下多学习器的比较：</p><ul><li>Friedman + Nemenyi</li><li>Friedman 检验(基于序值，F检测，判断“是否都相同”)</li><li>Nemenyi 后续检验 (基于序值，进一步判断两两差别)</li></ul><blockquote><p>关于读音：（音译，仅供参考）<br>McNemar：mac呢嘛儿（mac:[mæk]，中文名：麦克尼马尔）<br>Friedman：free的们（free:[fri]，中文名：弗里德曼）<br>Nemenyi：呢曼里(y貌似不发音)</p></blockquote><h2 id="偏差与方差-2-5-P44"><a href="#偏差与方差-2-5-P44" class="headerlink" title="偏差与方差(2.5, P44)"></a>偏差与方差(2.5, P44)</h2><p>“偏差-方差分解”(bias-variance decomposition)是解释学习算法泛化性能的重要工具。</p><ul><li>测试样本：x</li><li>测试样本x在数据集中的标记： $y_D$</li><li>测试样本x的真实标记： y</li><li>训练集： D</li><li>从训练集 D 上学得的模型f</li><li>模型 f 在测试样本x上的预测输出$f(x;D) $</li></ul><p>根据上述变量，推导出学习算法的期望预测：<br>$$\bar f(x) = \mathbb{E}_D [f(x;D)] $$<br>使用样本数相同的不同训练集产生的<font color="00AA00"><strong>方差</strong></font>为：度量了同样大小的训练集的变动所导致的学习性能的变化，也就是<strong>数据扰动所造成的影响</strong>。<br>$$var(x) = \mathbb{E}_D [(f(x;D)- \bar f (x) )^2] $$</p><p><font color="00AA00"><strong>噪声</strong></font>(数据集标记和真实标记的方差)为：当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了<strong>学习问题本身的难度</strong>。<br>$$ \varepsilon^2 =  \mathbb{E}_D [(y_D - y)^2]$$</p><p><font color="00AA00"> <strong>Bias（偏差）</strong></font>：期望输出与真实标记的偏离程度，刻画了<strong>学习算法本身的拟合能力</strong>。<br>$$bias^2(x) = (\bar f (x) - y)^2 $$</p><p>对回归任务，泛化误差可通过“偏差-方差分解”拆解为：<br>$$E(f;D) = bias^2(x) + var(x) + \varepsilon^2 $$</p><p>也就是说，<strong>泛化误差可分解为 偏差、方差与噪声之和</strong>。<br>偏差-方差分解说明，<strong>泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的</strong>。</p><p>一般来说，偏差与方差是由冲突的，这称为“偏差-方差窘境”。<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4m77isg5j20k00fvt8z.jpg" alt="偏差-方差窘境"></p><p>随着训练程度的提升，期望预测值与真实值之间的差异越来越小，即偏差越来越小，但是另一方面，随着训练程度加大，学习算法对数据集的波动越来越敏感，方差值越来越大。换句话说：<strong>在欠拟合时，偏差主导泛化误差，而训练到一定程度后，偏差越来越小，方差主导了泛化误差</strong>。因此训练也不要贪杯，适度辄止。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志华《机器学习》</li><li><a href="https://zhuanlan.zhihu.com/p/29248751" target="_blank" rel="external">《机器学习》学习笔记与习题探讨（二）④</a></li><li><a href="http://blog.csdn.net/bitcarmanlee/article/details/52279907" target="_blank" rel="external">卡方分布与卡方检验</a></li><li><a href="http://blog.sina.com.cn/s/blog_4a0824490102v8tz.html" target="_blank" rel="external">卡方检验（Chi-square test）和费舍尔精确检验（Fisher exact test）</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/04/ML_chap2_02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>西瓜书《机器学习》学习笔记(1)：评估方法与度量指标</title>
      <link>http://wangwlj.com/2018/01/03/ML_chap2_01/</link>
      <guid>http://wangwlj.com/2018/01/03/ML_chap2_01/</guid>
      <pubDate>Wed, 03 Jan 2018 13:31:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;笔记直接跳过了第一章，从第二章开始。&lt;/p&gt;
&lt;p&gt;本次笔记主要回顾评估方法与性能度量指标。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>笔记直接跳过了第一章，从第二章开始。</p><p>本次笔记主要回顾评估方法与性能度量指标。<br><a id="more"></a></p><h2 id="经验误差与过拟合-2-1-P23"><a href="#经验误差与过拟合-2-1-P23" class="headerlink" title="经验误差与过拟合(2.1, P23)"></a>经验误差与过拟合(2.1, P23)</h2><p>学习器在训练集上的误差称为<strong>训练误差</strong>(training error)或<strong>经验误差</strong>(empirical error)，在新样本上的误差称为<strong>泛化误差</strong>(generalization error)，我们希望得到泛化误差小的学习器。</p><p>过拟合(overfitting)，欠拟合(underfitting)。</p><p>多种因素导致过拟合，最常见的就是由于学习能力过于强大，以至于把训练样本不太一般的特性都学到了。欠拟合相反。</p><p>欠拟合比较容易克服，如在决策树学习中学习扩展分支，在神经网络学习中增加训练轮数等。</p><p>过拟合无法彻底避免。只能“缓解”，减小风险。</p><h2 id="评估方法-2-2-P24"><a href="#评估方法-2-2-P24" class="headerlink" title="评估方法(2.2, P24)"></a>评估方法(2.2, P24)</h2><p>测试集(testing set)上的测试误差(testing error) 作为泛化误差的近似。</p><h3 id="留出法-2-2-1-P25"><a href="#留出法-2-2-1-P25" class="headerlink" title="留出法(2.2.1, P25)"></a>留出法(2.2.1, P25)</h3><p>“留出法”(hold-out) 将数据集D划分为两个<strong>互斥</strong>的集合，其中一个集合作为训练集S，另一个作为测试集T，即$D=S\cup T,S\cap T=\oslash $。</p><p>常见的划分为：大约2/3-4/5的样本用作训练，剩下的用作测试。</p><p>注意：</p><ul><li>训练/测试集的划分需要尽可能保持<strong>数据分布的一致性</strong>。</li><li>由于划分的随机性，单次留出法得到的评估结果往往不够稳定可靠，一般采用<strong>若干次随机划分、重复进行实验评估后取平均值</strong>。</li></ul><h3 id="交叉验证法-2-2-2-P26"><a href="#交叉验证法-2-2-2-P26" class="headerlink" title="交叉验证法(2.2.2, P26)"></a>交叉验证法(2.2.2, P26)</h3><p>“交叉验证法”(cross validation)先将数据集D划分为k个大小相似的互斥子集，即$D=D_1\cup D_2 \cup \cdots\cup D_k,D_i \cap D_j =\oslash (i\neq j)$</p><p>每次用k-1个子集作为训练集，余下的那个子集作为测试集；这样就可以得到k组训练/测试集。从而可进行k次训练和测试，最终返回k次测试结果的均值。</p><p>故通常把交叉验证法称为“k折交叉验证”(k-fold cross validation)。<br>10折交叉验证示意图：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3il11kesj20d706bdgd.jpg" alt="10折交叉验证示意图"></p><p>与留出法类似，将数据集D划分为K个子集的过程具有随机性，因此K折交叉验证通常也要重复p次，称为<strong>p次k折交叉验证</strong>，常见的是10次10折交叉验证，即进行了100次训练/测试。特殊地当划分的k个子集的每个子集中只有一个样本时，称为“留一法”，显然，留一法的评估结果比较准确，但对计算机的消耗也是巨大的。</p><h3 id="自助法-2-2-3-P27"><a href="#自助法-2-2-3-P27" class="headerlink" title="自助法(2.2.3, P27)"></a>自助法(2.2.3, P27)</h3><p>“自助法”(bootstrapping)以自助采样法(bootstrapping sampling)为基础。<br>每次随机从包含m个样本的数据集D中挑选一个样本，将其拷贝到$D’$，然后再将该样本放回D中，使得该样本下次采样时仍有可能被采到。<br>重复执行m次后，就得到包含m个样本的数据集$D’$。</p><p>我们将$D’$用作训练集，$D-D’$(D中除了$D’$以外的样本)用作测试集。</p><p>在m次采样中，样本始终不被采到的概率取极限为：<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3iphjqzuj206w01fdfm.jpg" alt=""></p><p>自助法在数据集较小、难以有效划分训练/测试集时很有用。</p><h3 id="调参与最终模型-2-2-4-P28"><a href="#调参与最终模型-2-2-4-P28" class="headerlink" title="调参与最终模型(2.2.4, P28)"></a>调参与最终模型(2.2.4, P28)</h3><p>大多数学习算法都有些参数(parameter) 需要设定，参数配置不同，学得模型的性能往往有显著差别，这就是通常所说的”参数调节”或简称”调参” (parameter tuning)。</p><p>当选定好模型和调参完成后，我们需要使用初始的数据集D重新训练模型，即让最初划分出来用于评估的测试集也被模型学习，增强模型的学习效果。</p><p>学得模型(训练后的模型)实际使用中遇到的数据称为测试数据，在模型评估选择中用于评估测试的数据集称为“验证集”(calidation set)。【和吴恩达讲得差不多(略有区别？)。吴恩达说，通常将数据分为三类：训练集，验证集与测试集。】</p><h2 id="性能度量performance-measure-2-3-P28"><a href="#性能度量performance-measure-2-3-P28" class="headerlink" title="性能度量performance measure(2.3, P28)"></a>性能度量performance measure(2.3, P28)</h2><p>分类和回归属于监督学习。</p><ul><li><p>【分类】：对是离散值的结果进行预测。</p></li><li><p>【回归】：对是连续值的结果进行预测。</p></li></ul><p>回归任务和分类任务的常用性能度量如下图所示。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3mv5tkf5j20dw04zq3a.jpg" alt=""></p><p><del>预测任务：学习器预测结果$f(x)$与真实标记$y$进行比较。</del></p><p>回归任务：“均方误差”(mean squared error)<br>$$E(f;D) = \frac 1m \sum_{i=1}^m (f(x_i)-y_i)^2 $$</p><p>下面将依次介绍上图中分类任务的四类性能度量。</p><h3 id="错误率与精度-2-3-1-P29"><a href="#错误率与精度-2-3-1-P29" class="headerlink" title="错误率与精度(2.3.1, P29)"></a>错误率与精度(2.3.1, P29)</h3><p>错误率：分类错误的样本占样本总数的比例：<br>$$E(f;D) = \frac 1m \sum_{i=1}^m |(f(x_i)\neq y_i) $$<br>精度：分类正确的样本占样本总数的比例：<br>$$acc(f;D) = \frac 1m \sum_{i=1}^m |(f(x_i)= y_i) = 1-E(f;D)  $$</p><p>错误率+精度=1。</p><h3 id="查准率、查全率与F1-2-3-2-P30"><a href="#查准率、查全率与F1-2-3-2-P30" class="headerlink" title="查准率、查全率与F1(2.3.2, P30)"></a>查准率、查全率与F1(2.3.2, P30)</h3><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3j33r8v2j20c006v74f.jpg" alt=""></p><p>查准率就是准确率，查全率就是召回率。</p><p>更具体的，可参考我的这篇文章：<a href="http://wangwlj.com/2017/10/08/DL_Precision_and_Recall/">准确率、召回率与F1值</a><br>【重点，单独列出】</p><h3 id="ROC-与AUC-2-3-3-P33"><a href="#ROC-与AUC-2-3-3-P33" class="headerlink" title="ROC 与AUC(2.3.3, P33)"></a>ROC 与AUC(2.3.3, P33)</h3><p><strong>ROC：受试者工作特性(Receiver Operating Characteristic)。</strong><br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4csetqxzj20k009l0t5.jpg" alt=""><br>ROC图的纵坐标为“真正例率”，横坐标为“假正例率”。</p><blockquote><p>真正例率（TPR）：【真正例样本数】与【真实情况是正例的样本数】的比值。（查全率）</p><p>假正例率（FPR）：【假正例样本数】与【真实情况是反例的样本数】的比值。</p></blockquote><p>如图，理想模型是真正例率为100%，假正例率为0%的一点。随机猜测模型则是真正例率与假正例率持平的直线。由此可知，在随机猜测模型左上方的曲线和在其右下方的曲线都代表了什么。（右下方的模型，还不如随机猜测准。）</p><p>现实中通常是有限个测试样例来绘制ROC图。无法产生光滑的ROC曲线图。</p><p>同样地，进行模型的性能比较时，若一个学习器A的ROC曲线被另一个学习器B的ROC曲线完全包住，则称B的性能优于A。若A和B的曲线发生了交叉，则不太好判断。此时，AUC应运而生。</p><p>AUC(Area Under ROC Curve)：判断两个ROC曲线的性能，AUC计算的是ROC曲线下的面积。面积越大，性能越好。</p><h3 id="代价敏感错误率与代价曲线-2-3-4-P35"><a href="#代价敏感错误率与代价曲线-2-3-4-P35" class="headerlink" title="代价敏感错误率与代价曲线(2.3.4, P35)"></a>代价敏感错误率与代价曲线(2.3.4, P35)</h3><p>上面的方法中，将学习器的犯错同等对待，但在现实生活中，将正例预测成假例与将假例预测成正例的代价常常是不一样的，例如：将无疾病–&gt;有疾病只是增多了检查，但有疾病–&gt;无疾病却是增加了生命危险。以二分类为例，由此引入了“代价矩阵”（cost matrix）。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn4d0hvlu2j20ak06w0sq.jpg" alt="二分类代价矩阵"></p><p>在非均等错误代价下，我们希望的是最小化“总体代价”，这样“代价敏感”(cost sensitive)的错误率为：<br><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3ji8c6pjj20jh02baa9.jpg" alt=""></p><p>同样对于ROC曲线，在非均等错误代价下，性能度量的方法演变成了<strong>“代价曲线”</strong>，代价曲线横轴是取值在[0,1]之间的正例概率代价，式中p表示正例的概率，纵轴是取值为[0,1]的归一化代价。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3lfih9eaj20cs0260sl.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3m2chlkwj20fo028glj.jpg" alt=""><br>代价曲线的绘制：设ROC曲线上一点的坐标为(TPR，FPR) ，则可相应计算出FNR，然后在代价平面上绘制一条从(0，FPR) 到(1，FNR) 的线段，线段下的面积即表示了该条件下的期望总体代价；如此将ROC曲线上的每个点转化为代价平面上的一条线段，然后取<strong>所有线段的下界</strong>，围成的面积即为在所有条件下学习器的期望总体代价，如图所示：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn3jugpwecj20fc09jaak.jpg" alt="代价曲线"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>周志华《机器学习》</li><li><a href="http://blog.csdn.net/u011826404/article/details/53229609" target="_blank" rel="external">http://blog.csdn.net/u011826404/article/details/53229609</a></li><li><a href="https://zhuanlan.zhihu.com/p/28482121" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/28482121</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/03/ML_chap2_01/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
