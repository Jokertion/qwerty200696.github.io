<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wangwlj&#39;s Blog</title>
    <link>http://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Sat, 13 Jan 2018 07:05:12 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Git入门使用指南</title>
      <link>http://wangwlj.com/2018/01/13/Git_usage/</link>
      <guid>http://wangwlj.com/2018/01/13/Git_usage/</guid>
      <pubDate>Sat, 13 Jan 2018 07:04:26 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h2&gt;&lt;p&gt;下面是摘自官网的一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，Git是一个优秀的分布式版本管理软件。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>下面是摘自官网的一段话：</p><blockquote><p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p></blockquote><p>简而言之，Git是一个优秀的分布式版本管理软件。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开Git官网：<a href="https://git-scm.com/" target="_blank" rel="external">git-scm.com</a>，下载并安装。<br>Debian或<code>Ubuntu Linux</code>，通过一条<code>sudo apt-get install git</code>就可以直接完成<code>Git</code>的安装。</p><p>安装完成后，windows打开<code>git-bash</code>，linux直接打开<code>terminal</code>。</p><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>配置用户信息（和Github上一致）：用户名和邮箱地址：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name "qwerty200696"</div><div class="line">git config --global user.email "wang@126.com"</div></pre></td></tr></table></figure></p><p>如果之前已经配置好了，可以使用如下命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config user.name</div><div class="line">git config user.email</div></pre></td></tr></table></figure><p>还可以配置颜色和行尾。不同平台的行尾是有显著区别的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git config --global core.autocrlf true</div><div class="line">git config --global core.autocrlf input</div><div class="line"></div><div class="line">git config --global color.ui auto</div></pre></td></tr></table></figure><p>其他配置：<br>配置的级别分为：<code>global</code> 、<code>local</code>与<code>system</code>三种级别，<code>local</code>会覆盖<code>global</code>。就像面向对象的继承那样，最近的是最有效的，也就是<code>local</code>。</p><h2 id="init-amp-add——开始与添加"><a href="#init-amp-add——开始与添加" class="headerlink" title="init&amp;add——开始与添加"></a>init&amp;add——开始与添加</h2><p>选择需要版本控制的文件夹，打开终端(linux)或者Git Bash(windows)。</p><p>初始化Git：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure></p><blockquote><p>最好的方法是在开始一个项目之前，通过<code>git init xxx</code>来新建一个项目目录<code>xxx</code>。git会自动创建该<code>xxx</code>目录。</p></blockquote><p>假设文件夹下存在需要版本管理的文件，使用如下命令查看是否已经被管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure><p>添加需要管理的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add 1.py # 某个具体的文件</div><div class="line">git add .  # 添加文件夹下所有的文件</div></pre></td></tr></table></figure></p><p>可以在目录下创建一个名为<code>.gitignore</code>的文件，在其中输入需要忽略的文件。</p><h2 id="commit——提交修改"><a href="#commit——提交修改" class="headerlink" title="commit——提交修改"></a>commit——提交修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;first commit&quot;</div></pre></td></tr></table></figure><p>修改内容之后，使用<code>commit</code>提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure><p><code>log</code>命令可以查看每次的更改。</p><p>目前都是在本地化的版本管理。</p><h2 id="diff——显示不同"><a href="#diff——显示不同" class="headerlink" title="diff——显示不同"></a>diff——显示不同</h2><p>现在假设你修改了一个文件，但是过去了一段时间后忘记修改在什么地方了，此时你需要“diff”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git diff  # 文件的最新改动</div><div class="line">git diff --staged  # 已经暂存的和最近历史的改动。</div><div class="line">git diff HEAD # HEAD提交历史中，最近一次的别名，最新的修改与最近历史的改动。跳过了暂存的修改，直接与最近一次提交的比较。</div><div class="line"></div><div class="line">git diff --color-words  # 只对修改的地方用不同颜色标记，而不是整行。</div><div class="line">git diff --word-diff # 对长行的小改动更加清晰明了。</div><div class="line">git diff --stat  # 极简输出，只输出改动的文件，阻止其他输出。</div></pre></td></tr></table></figure></p><h2 id="log——查看修改"><a href="#log——查看修改" class="headerlink" title="log——查看修改"></a>log——查看修改</h2><p>log是一个非常强大的明了，不仅可以查看提交的历史记录，而且是了解仓库的进展、提交的内容以及文件的好帮手。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git log</div><div class="line">git log --oneline  # 更常用！</div><div class="line">git log --stat #可以查看修改的文件。</div><div class="line">git log --patch # 可以查看文件中具体的修改内容。</div><div class="line"></div><div class="line">git log --graph --all --decorate --oneline  # z展示每次提交的一行概括。</div></pre></td></tr></table></figure></p><h2 id="remove——删除文件"><a href="#remove——删除文件" class="headerlink" title="remove——删除文件"></a>remove——删除文件</h2><p>删除文件。两种方式，一种是<code>git rm</code>，一种是<code>git add</code></p><p><code>git rm</code> 用来删除一个文件；并且会自动暂存修改。</p><p>此外，如果用<code>rm</code>删除了一个文件，可以使用<code>git rm</code>再次暂存修改。</p><p>现实情况中，往往会有很多文件被删除了，不可能通过命令行一个个修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Git add -u .  # 注意，最后的dot不能省略哦，表示当前目录</div></pre></td></tr></table></figure></p><p>改命令会遍历文件夹，并且查找出所有删除的文件，并且暂存。</p><p>有时候只是想要从git中删除，但是本地文件不删除，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rm --cached xxx_file</div></pre></td></tr></table></figure></p><p>你是真的想在所有历史记录中删除这个文件的记录吗？这是另一个主题中会讲。或者你是不想要某个文件被追踪，之后也是这样，那么可以使用<code>git ignore</code>文件，在之后也会介绍。</p><h2 id="move——移动文件"><a href="#move——移动文件" class="headerlink" title="move——移动文件"></a>move——移动文件</h2><p> 移动文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git mv xxx_file otherPath/xxx.file</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add -A .</div></pre></td></tr></table></figure><p>找出所有的移动过的文件。（包括修改之后移动的文件）</p><p>追踪移动过的文件的历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git log -- path/file # 只会追踪到该目录下的历史，历史会终止在移动的时候。</div><div class="line"></div><div class="line">git log --stat -M --follow -- path/file # 跨目录追踪历史，文件在移动过程中也追踪。</div></pre></td></tr></table></figure></p><p>在移动文件之后，commit给我们一个数字来告诉我们文件在移动前后的相似度。Git提供的默认阈值是50%的相似度，超过50%，在移动前后就会继续追踪该文件。</p><h2 id="ignore——忽略文件"><a href="#ignore——忽略文件" class="headerlink" title="ignore——忽略文件"></a>ignore——忽略文件</h2><p>可以在目录/子目录下创建一个名为<code>.gitignore</code>的文件，在其中输入需要忽略的文件/文件夹。</p><p>只能对当前目录的文件/文件夹进行忽略。 可以使用匹配符，在当前目录/子目录都有效。</p><p><del>子目录中，需要路径优先级？？</del><br>也可以使用“！”反忽略某一个特定的文件。<br>注释行用“#”号开头。</p><p>查看忽略了的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git ls-files --others --ignored --exclude-standard  ## 查看忽略的文件</div><div class="line"></div><div class="line">git ls-files  --ignored --exclude-standard</div></pre></td></tr></table></figure></p><p><del>为什么我感觉不需要加上 <code>--others</code>也可以。而且第二个命令更靠谱。</del></p><p>以上述的第一个命令为主。<br>如果你感觉第一个命令不行的话，那是因为在某些文件先前已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的push，这样就不会出现忽略的文件了。git清除本地缓存命令如下：【参考资料二】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git rm -r --cached .</div><div class="line">git add .</div><div class="line">git commit -m &apos;update .gitignore&apos;</div></pre></td></tr></table></figure></p><p>关于ignore规则的详细介绍，可参考<a href="https://www.cnblogs.com/kevingrace/p/5690241.html" target="_blank" rel="external">这篇博文</a>，写得很详细。</p><h2 id="branch——开始新分支"><a href="#branch——开始新分支" class="headerlink" title="branch——开始新分支"></a>branch——开始新分支</h2><h3 id="创建与删除"><a href="#创建与删除" class="headerlink" title="创建与删除"></a>创建与删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git branch newBranchName  ## 创键分支</div><div class="line">git branch -d existedBranchname  ## 删除分支，没有合并的话会出错</div><div class="line">git branch -D existedBranchname  ## 删除分支，强制删除</div></pre></td></tr></table></figure><h3 id="switch——切换分支"><a href="#switch——切换分支" class="headerlink" title="switch——切换分支"></a>switch——切换分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout existedBranchname</div></pre></td></tr></table></figure><h2 id="checkout的其他用法"><a href="#checkout的其他用法" class="headerlink" title="checkout的其他用法"></a>checkout的其他用法</h2><p>最主要的作用就是切换分支，上面已经讲过了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch</div><div class="line">git status</div></pre></td></tr></table></figure></p><p>都可以查看目前处于那个分支上面。</p><p>撤销内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- filename.txt</div></pre></td></tr></table></figure></p><p>会清理掉最后一次commit的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b newBranchName</div></pre></td></tr></table></figure><p>一步到位，既创建了一个新的branch，也转移到了新的branch。</p><p>如果在使用<code>checkout</code>命令的时候，不小心将头指针分离了，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wangwlj@myUbuntu:~/文档/py_prog/py3_prog$ git branch -a</div><div class="line">* （头指针分离于 ee74fc7）</div><div class="line">  master</div><div class="line">  program</div></pre></td></tr></table></figure></p><p>当我们发现头指针游离于分支之外的时候，不要惊慌，再次<code>git checkout program</code>切换到已经存在的分支即可。</p><h2 id="merge——分支合并"><a href="#merge——分支合并" class="headerlink" title="merge——分支合并"></a>merge——分支合并</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master  ## 切换到主分支</div><div class="line">git merge branchNeedToMerge ## 将分支branchNeedToMerge的修改合并到master</div></pre></td></tr></table></figure><h3 id="merge冲突的解决"><a href="#merge冲突的解决" class="headerlink" title="merge冲突的解决"></a>merge冲突的解决</h3><p>merge冲突：两个文件都有变化，Git无法确定该怎么合并。该如何解决呢？</p><p>先用<code>git status</code>查看是哪个文件冲突 ，然后用编辑器打开，进行修改。</p><p>先查找<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>标志，表明是当前branch上的内容，直到<code>=======</code>标志结束。<br>在<code>=======</code>标志的下方，直到<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; branchNeedToMerge</code>标志结束，是另一个分支的内容。</p><p>找到位置后，需要手动地解决冲突：编辑文件，删去冲突的标签，决定该删去或保留哪些内容，保存即可。最后重新add、commit提交。</p><h3 id="abort——放弃冲突"><a href="#abort——放弃冲突" class="headerlink" title="abort——放弃冲突"></a>abort——放弃冲突</h3><p>放弃这个冲突（不重要），从上次commit开始，并且清除暂存区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --abort</div></pre></td></tr></table></figure></p><h3 id="squash压缩"><a href="#squash压缩" class="headerlink" title="squash压缩"></a>squash压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git merge --squash branchNeedToMerge</div><div class="line">git commit -m &quot;some message&quot;</div></pre></td></tr></table></figure><p>意思是 你在分支<code>branchNeedToMerge</code>里面做了很多次commit修改，但是修改很零碎；在master分支里只想要一次commit就更新到<code>branchNeedToMerge</code>分支的进度。此时就可以使用<code>--squash</code>参数。</p><blockquote><p>判断是否使用<code>--squash</code>选项最根本的标准是，待合并分支上的历史是否有意义。</p></blockquote><p>关于<code>--squash</code> 参数的举例可参考<a href="http://blog.csdn.net/rockrockwu/article/details/33740711" target="_blank" rel="external">这篇文章</a>。</p><h3 id="d-删除分支"><a href="#d-删除分支" class="headerlink" title="-d 删除分支"></a>-d 删除分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d branchNeedToMerge</div></pre></td></tr></table></figure><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><h3 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin &lt;server&gt;</div></pre></td></tr></table></figure><p><code>&lt;server&gt;</code>是远程服务器的地址、目的地的url。<br>如果输错了或者忘记了也不要紧，可以输入如下命令重新设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote set-url origin &lt;new-server&gt;</div></pre></td></tr></table></figure></p><p>查看远程的地址有哪些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure></p><p>最后删除远端地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rm origin</div></pre></td></tr></table></figure></p><h3 id="fetch-pull-push"><a href="#fetch-pull-push" class="headerlink" title="fetch/pull/push"></a>fetch/pull/push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git fetch origin</div><div class="line">git pull origin</div><div class="line">git push origin</div></pre></td></tr></table></figure><p>fetch:去github.com上面下载信息，放在远程追踪分支。，<br>pull：与fetch非常像，下载下来放到远程，并且合并到本地。<br>push：电脑上完成了工作，发送到github上面。</p><h2 id="fork-pull-requests"><a href="#fork-pull-requests" class="headerlink" title="fork/pull requests"></a>fork/pull requests</h2><p>fork:拷贝到自己的仓库进行修改，最好新建分支。<br>pull requests:对他人的代码进行修改，提意见</p><h2 id="reset——重置"><a href="#reset——重置" class="headerlink" title="reset——重置"></a>reset——重置</h2><p>reset有三个等级，默认的是<code>mixed</code>，除此之外还有<code>soft</code>与<code>hard</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git reset --soft HEAD~5  # 选择需要重置commit的次数</div><div class="line">git status</div><div class="line">git commit -m&quot;new message&quot;  # 重新提交</div></pre></td></tr></table></figure><p>reset在对仓库历史提交的处理上比较有用，当然也是一个危险的命令啦。</p><p>checkout可以做类似的事情，<code>checkout</code>更加关注的是一个目录或者文件级别的精度。也就是说，可以把某个文件拉回到几次提交之前的状态。</p><h2 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h2><p>包括<code>reset</code>做的那些不可恢复的操作，<code>reflog</code>都有记录。<br>但默认提供的是30天的保存时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure><p>也可以图形化查看历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitk --all `git reflog | cut c1-7`&amp;</div></pre></td></tr></table></figure></p><p><code>reflog</code>让我们有动力地去多做commit，commit了就有保障了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000" target="_blank" rel="external">忽略特殊文件</a></li><li><a href="https://www.cnblogs.com/zzcc/p/5695883.html" target="_blank" rel="external">Git中.gitignore文件不起作用的解决</a></li><li><a href="https://www.nowcoder.com/courses/2" target="_blank" rel="external">GitHub&amp;Git入门基础</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/Git_usage/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ubuntu下必备软件及安装总结</title>
      <link>http://wangwlj.com/2018/01/13/ubuntu_software_summary/</link>
      <guid>http://wangwlj.com/2018/01/13/ubuntu_software_summary/</guid>
      <pubDate>Sat, 13 Jan 2018 05:51:37 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;安装ubuntu&quot;&gt;&lt;a href=&quot;#安装ubuntu&quot; class=&quot;headerlink&quot; title=&quot;安装ubuntu&quot;&gt;&lt;/a&gt;安装ubuntu&lt;/h2&gt;&lt;p&gt;本文以&lt;code&gt;Ubuntu 16.04&lt;/code&gt;为例。&lt;/p&gt;
&lt;p&gt;制作U盘启动盘、安装Ubuntu系统。是装双系统还是只装linux。&lt;/p&gt;
&lt;p&gt;安装时，需要注意的两点。一是手动/自动分区，若手动分区，最好将&lt;code&gt;/home&lt;/code&gt;分区独立出来；二是系统语言选择中文还是英文，推荐中文。其他的就随意即可。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="安装ubuntu"><a href="#安装ubuntu" class="headerlink" title="安装ubuntu"></a>安装ubuntu</h2><p>本文以<code>Ubuntu 16.04</code>为例。</p><p>制作U盘启动盘、安装Ubuntu系统。是装双系统还是只装linux。</p><p>安装时，需要注意的两点。一是手动/自动分区，若手动分区，最好将<code>/home</code>分区独立出来；二是系统语言选择中文还是英文，推荐中文。其他的就随意即可。</p><a id="more"></a><p>给出几个参考链接：</p><ul><li><a href="http://blog.csdn.net/yaoyut/article/details/78003061" target="_blank" rel="external">用UltraISO制作Ubuntu16.04 U盘启动盘</a></li><li><a href="https://www.zhihu.com/question/19867618" target="_blank" rel="external">怎样安装 Windows 7 与 Linux 的双系统？</a><br>双系统是比较特殊的，双系统可以，单系统也没问题。</li></ul><h2 id="软件安装前的设置"><a href="#软件安装前的设置" class="headerlink" title="软件安装前的设置"></a>软件安装前的设置</h2><p>假设现在已经有了一个全新的<code>Ubuntu</code>系统，此时你需要先换源。</p><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>系统自带的源速度不快，因此考虑换成国内源。笔者采用的是阿里云的源，还是不错的。</p><ul><li><p><a href="http://blog.csdn.net/happywho250/article/details/52506321" target="_blank" rel="external">ubuntu16.04换源</a></p></li><li><p><a href="http://blog.csdn.net/u011557212/article/details/53233944" target="_blank" rel="external">Ubuntu16.04常用源</a></p></li></ul><h3 id="主文件夹下的中文目录改为英文目录"><a href="#主文件夹下的中文目录改为英文目录" class="headerlink" title="主文件夹下的中文目录改为英文目录"></a>主文件夹下的中文目录改为英文目录</h3><blockquote><p>可选项。主文件夹下的中文目录名其实也不错。</p></blockquote><p>Linux下使用命令行是很正常的事情，<code>cd ~/桌面</code> 需要切换输入法，可能会显得不那么流畅，因此，可以考虑将主文件夹下的中文目录设置为英文。</p><p>参考这篇文章：<br><a href="http://blog.csdn.net/l0605020112/article/details/20285239" target="_blank" rel="external">将Ubuntu主文件夹里的中文文件夹名称改成英文</a></p><p>我采用的是第一种方法。换了之后建议重启一下。</p><p>笔者不是一开始就改的，所以导致换目录名后出现了一系列问题。一开始就换会比较好。</p><h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><h2 id="安装必备软件"><a href="#安装必备软件" class="headerlink" title="安装必备软件"></a>安装必备软件</h2><p>在对Ubuntu换源之后，就可以开始安装一些必备而的软件了。Ubuntu下软件的安装都不难，可以根据需求选择安装相应的软件。</p><h3 id="1-搜狗输入法"><a href="#1-搜狗输入法" class="headerlink" title="1. 搜狗输入法"></a>1. 搜狗输入法</h3><p>输入法必备，放在第一个吧。</p><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>官网下载linux版本的dev包：<a href="http://pinyin.sogou.com/linux/" target="_blank" rel="external">pinyin.sogou.com/linux</a><br>进入下载目录，在终端执行安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> sudo dpkg  -i   sogoupinyin_2.2.0.0102_amd64.deb</div></pre></td></tr></table></figure></p><p>安装过程会出现 依赖关系问题（未安装成功，依赖库不全），不要担心，接着执行下面的命令就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span>sudo apt-get install -f</div></pre></td></tr></table></figure><p>等待完成后，搜狗拼音输入法就安装好了。</p><blockquote><p>上述两条命令都是常用命令，需要记住。</p></blockquote><h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p> 下面对输入法进行系统配置，具体流程如下：</p><ul><li>桌面右上角面板的<code>开关机的按钮</code>，选择<code>系统设置</code>；</li><li>进入系统设置后，点击<code>语言支持</code>，键盘输入方式系统中选择 <code>fcitx</code>；</li><li>注销系统用户，重新登陆进入桌面后看看，熟悉的搜狗输入法出现了吧。</li></ul><p>参考自：<a href="https://jingyan.baidu.com/article/a3aad71aa1abe7b1fa009641.html" target="_blank" rel="external">ubuntu安装配置搜狗拼音输入法</a></p><h3 id="2-网易云音乐"><a href="#2-网易云音乐" class="headerlink" title="2. 网易云音乐"></a>2. 网易云音乐</h3><p>网易云音乐，大家都知道的，无需过多介绍，虽然现在由于版权问题好多歌曲都下架了，不过<code>Linux</code>下的网易云做得非常好。</p><p>只需要简单地下载、安装即可。具体请参考：<a href="http://blog.csdn.net/u011557212/article/details/53234134" target="_blank" rel="external">ubuntu16.04安装网易云音乐</a></p><blockquote><p>别人写得很详细的教程，我就只放链接了。</p></blockquote><h3 id="3-chrome浏览器"><a href="#3-chrome浏览器" class="headerlink" title="3. chrome浏览器"></a>3. chrome浏览器</h3><p>Linux下谷歌浏览器是必备的。</p><p>安装谷歌浏览器，只需要三行代码：<br>打开终端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /tmp</div></pre></td></tr></table></figure></p><p>对于谷歌Chrome32位版本，使用如下链接：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb</div></pre></td></tr></table></figure></p><p>对于64位版本可以使用如下链接下载：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</div></pre></td></tr></table></figure></p><p>下载完后，运行如下命令安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dpkg -i google-chrome*; sudo apt-get -f install</div></pre></td></tr></table></figure></p><p>然后，就可以去搜索使用了。<br>是不是很方便？</p><p>参考自：<a href="http://www.linuxidc.com/Linux/2013-10/91857.htm" target="_blank" rel="external">安装谷歌Chrome浏览器</a></p><h3 id="4-Guake-Terminal-optional"><a href="#4-Guake-Terminal-optional" class="headerlink" title="4. Guake Terminal (optional)"></a>4. Guake Terminal (optional)</h3><h4 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h4><p><code>Guake Terminal</code>顾名思义，是一个终端。功能只有一个, 按 <code>F12</code> 时从屏幕顶部 嗖! 地下来一个。</p><p>可到官网：<a href="http://guake-project.org/" target="_blank" rel="external">guake-project.org</a> 查看详细说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/Guake/guake.git</div><div class="line">$ cd guake</div><div class="line"></div><div class="line"># For Ubuntu user, we have a script that does all these steps for you. Use:</div><div class="line">$ ./dev.sh</div></pre></td></tr></table></figure><p>如果上述第三条命令出错的话，请尝试以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./dev.sh --install</div></pre></td></tr></table></figure></p><p>期间，会自动安装一些库，如<code>git</code>之类的。</p><h4 id="设置与自启动"><a href="#设置与自启动" class="headerlink" title="设置与自启动"></a>设置与自启动</h4><p>安装完成后，可以在终端输入<code>guake</code>查看效果，输入<code>guake --preferences</code>进行相关的配置。<br><code>guake</code>启动后，按下<code>F12</code>显示终端，再按<code>F12</code>消失。可以设置焦点失去时隐藏，这样就不用反复点<code>F12</code>了。</p><p>自启动设置：</p><p>点击最左上角的<code>Dash</code>图标(用于查找文件与程序的nage)，输入<code>启动</code>二字查看搜索结果，点击“启动应用程序”，按下图设置：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fneyjbeucgj20gn0daabi.jpg" alt=""></p><h3 id="5-思维导图xmind"><a href="#5-思维导图xmind" class="headerlink" title="5. 思维导图xmind"></a>5. 思维导图xmind</h3><p><code>xmind</code>和<code>MindManager</code>都是优秀的思维导图软件，linux下只有<code>xmind</code>。</p><p>具体的安装步骤：</p><p>1、去官网下载<a href="http://www.xmind.net/download/linux/" target="_blank" rel="external">http://www.xmind.net/download/linux/</a></p><p>2、下载完后解压，进入解压后目录，在命令行输入<code>sudo ./setup</code>，这个是用来安装软件相关的依赖；然后进入<code>xmind_amd64</code>（64位系统）或者<code>xmind_i386</code>(32位系统)</p><p>3、在目录中直接双击<code>XMind</code>文件，或者在命令行中输入 <code>sudo ./XMind</code>。这样XMind就可以直接运行。由于XMInd8的ubuntu版本是用JAVA来开发的，所以可以直接打开，无需安装。</p><p>参考自：<a href="http://blog.csdn.net/faryang/article/details/70238326" target="_blank" rel="external">ubuntu16.04安装xmind8</a></p><h3 id="6-pycharm"><a href="#6-pycharm" class="headerlink" title="6. pycharm"></a>6. pycharm</h3><p>需要使用Python的话可以考虑安装Pycharm。</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>打开<a href="https://www.jetbrains.com/pycharm/download/#section=linux" target="_blank" rel="external">pycharm官网</a></p><p>下载linux版本的pycharm。</p><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p>打开刚才下载的目录。右击文件，点击提取到此处（这与Windows的解压是一个意思）</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>解压完成后，打开刚才解压好的文件夹，然后再打开bin目录。</p><p>在文件夹空白处右击，在此处打开终端然后输入：<code>sh ./pycharm.sh</code> 回车</p><p>接着就打开了pycharm。</p><p>如果你需要导入之前安装版本的设置的话，可以选择第一个选项；如果没有的话，默认不导入设置就可以了。</p><p>点击同意，然后激活<code>pycharm</code>就可以使用了。</p><p>详情可参考：<br><a href="https://jingyan.baidu.com/article/60ccbceb4e3b0e64cab19733.html" target="_blank" rel="external">Ubuntu系统安装PyCharm教程（详细图文）</a></p><p>另附：学生可以免费注册pycharm，学生版也可以使用专业版的pycharm，没有什么区别。</p><h3 id="7-WPS"><a href="#7-WPS" class="headerlink" title="7. WPS"></a>7. WPS</h3><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><p>进入WPS官网下载deb包：<a href="http://linux.wps.cn/" target="_blank" rel="external">http://linux.wps.cn/</a></p><p>安装，打开终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd 下载</div><div class="line">sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb</div></pre></td></tr></table></figure><h4 id="解决打开WPS时出现的系统缺失字体问题"><a href="#解决打开WPS时出现的系统缺失字体问题" class="headerlink" title="解决打开WPS时出现的系统缺失字体问题"></a>解决打开WPS时出现的系统缺失字体问题</h4><p>下载wps_symbol_fonts.zip: <a href="https://pan.baidu.com/s/1eS6xIzo" target="_blank" rel="external">https://pan.baidu.com/s/1eS6xIzo</a></p><p>将<code>wps_symbol_fonts.zip</code>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd wps_symbol_fontsls</div></pre></td></tr></table></figure></p><p>将目录中所有文件复制到<code>/usr/share/fonts</code>下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cp mtextra.ttf  symbol.ttf  WEBDINGS.TTF  wingding.ttf  WINGDNG2.ttf  WINGDNG3.ttf  /usr/share/fonts</div></pre></td></tr></table></figure><p>重新打开WPS，问题解决。</p><h4 id="删除libreOffice-optional"><a href="#删除libreOffice-optional" class="headerlink" title="删除libreOffice (optional)"></a>删除libreOffice (optional)</h4><p>另外，安装完WPS后就没有必要保留<code>libreOffice</code></p><p>卸载<code>libreOffice</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get remove libreoffice-common</div></pre></td></tr></table></figure></p><p>顺便把Amazon链接删除了吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    sudo apt-get remove unity-webapps-common</div><div class="line">    sudo apt autoremove</div><div class="line">```       </div><div class="line">参考自：[Ubuntu16.04安装wps并解决系统缺失字体问题](https://www.cnblogs.com/liutongqing/p/6388160.html)</div><div class="line"></div><div class="line">### 8. 图片编辑工具GIMP</div><div class="line"></div><div class="line">`GIMP`虽然不能完全替代`PS`，但是也能弥补一下。系统默认源中已经包含了GIMP，不需要使用PPA这些。</div><div class="line"></div><div class="line">安装：</div></pre></td></tr></table></figure></p><pre><code>sudo apt-get install gimp</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">启动：</div><div class="line"></div><div class="line">通过Dash搜索`GIMP`即可。或者命令行输入GIMP也行。</div><div class="line"></div><div class="line">参考：</div><div class="line"></div><div class="line">- https://www.gimp.org/downloads/</div><div class="line">- https://www.cnblogs.com/EasonJim/p/7121885.html</div><div class="line"></div><div class="line"></div><div class="line">### 9. indicator-sysmonitor</div><div class="line"></div><div class="line">先看一下效果图：</div><div class="line">![1](http://ww1.sinaimg.cn/large/c38a0784ly1fndxu83315j20fr02zglt.jpg)</div><div class="line"></div><div class="line">图中的“CPU，温度，内存”部分就是该软件的作用了。</div><div class="line"></div><div class="line">想要安装可参考：[Ubuntu 16.04安装indicator-sysmonitor实现导航条显示上下行网速/CPU/内存使用率](http://www.cnblogs.com/EasonJim/p/7130171.html)</div><div class="line"></div><div class="line">### 10. 主题管理工具unity tweak tool</div><div class="line"></div><div class="line">主题管理工具`unity tweak tool`</div><div class="line"></div><div class="line">1,    添加源</div></pre></td></tr></table></figure><p>sudo add-apt-repository ppa:freyja-dev/unity-tweak-tool-daily<br>sudo apt-get update<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2,安装</div></pre></td></tr></table></figure></p><p>　　sudo apt-get install unity-tweak-tool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,卸载</div></pre></td></tr></table></figure></p><p>　　sudo apt-get remove unity-tweak-tool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">4,搜索`unity tweak tool`运行</div><div class="line"></div><div class="line">5,若出现以下问题，终端输入`sudo apt-get install unity-webapps-service `即可</div><div class="line"></div><div class="line">![](http://ww1.sinaimg.cn/large/c38a0784ly1fne74thxbkj20j006ojrk.jpg)</div><div class="line"></div><div class="line"></div><div class="line">### 11. docky</div><div class="line"></div><div class="line">经常使用Mac者的福音。实现效果如下图：</div><div class="line"></div><div class="line">![](http://ww1.sinaimg.cn/large/c38a0784ly1fne792nqnfj20jj032mzj.jpg)</div><div class="line"></div><div class="line">一句话安装：</div></pre></td></tr></table></figure></p><p>sudo apt install ducky<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用方法：</div><div class="line"></div><div class="line">- 删除图标：拖到回收站上面就可以。</div><div class="line">- 添加图标：打开程序的时候会自动加载到docky中，此时右键选择锁定。</div><div class="line"></div><div class="line">图标模糊：下载高清图标，替换掉。具体可查看知乎问题“Docky中程序的图标太模糊，如何替换Docky中程序的图标？”的[回答](https://www.zhihu.com/question/22892627/answer/64026877)。</div><div class="line"></div><div class="line">### 12. teamviewer</div><div class="line"></div><div class="line">`teamviewer`的作用：与其他主机互传文件或者控制远程主机。</div><div class="line"></div><div class="line">安装过程如下：</div><div class="line"></div><div class="line">1、下载安装程序(32位和64位Ubuntu通用)</div><div class="line">https://www.teamviewer.com/zhcn/download/linux/</div><div class="line"></div><div class="line">选择下载对应版本。</div><div class="line"></div><div class="line">2、在终端中执行如下命令进行安装</div></pre></td></tr></table></figure></p><pre><code>sudo dpkg -i teamviewer_i386.deb</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3、使用如下命令处理依赖问题</div></pre></td></tr></table></figure><pre><code>sudo apt-get install –f </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">参考链接：[Ubuntu 16中如何安装TeamViewer 12](http://blog.csdn.net/zuochao_2013/article/details/53671245)</div><div class="line"></div><div class="line">使用部分不难，简单易上手。可以注册一个`teamview`账号，还是很方便的。</div><div class="line"></div><div class="line"></div><div class="line">### 13. 截图工具shutter</div><div class="line"></div><div class="line">`shutter`安装可参考：[ubuntu 安装截图工具 Shutter，并设置快捷键 Ctrl+Alt+A](http://blog.csdn.net/hanshileiai/article/details/46843713)</div><div class="line"></div><div class="line">其实`ubuntu`有自带的截图工具，不支持修改文件而已。</div></pre></td></tr></table></figure><pre><code>printscreen -- 全屏alt + printscreen -- 当前活动截图shift + printscreen -- 自选矩形截图</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">自带的截图工具配合第八个软件GIMP一起使用，也还是不错的。</div><div class="line"></div><div class="line">### 14. Markdown编辑器 </div><div class="line"></div><div class="line">我选择的是[Moeditor](https://github.com/Moeditor/Moeditor)。</div><div class="line"></div><div class="line">类似的`markdown`编辑器还有：[Atom](https://atom.io/) (Github出品)，Vim+Markdown，[Remarkable - Linux](https://remarkableapp.github.io/linux.html) （据说有点小bug），[Haroopad - The Next Document processor based on Markdown](http://pad.haroopress.com/user.html) ，[typora.io](https://www.typora.io/#linux) ， SublimeText3+插件，[StackEdit](https://stackedit.io/)  (网页版)，[小书匠markdown编辑器](http://markdown.xiaoshujiang.com/) ，马克飞象，VS Code，reText等等。</div><div class="line"></div><div class="line"></div><div class="line">`Moeditor`下载地址：https://github.com/Moeditor/Moeditor/releases</div><div class="line"></div><div class="line">安装： `sudo dpkg -i xxxx.deb`</div><div class="line"></div><div class="line">使用： 简单易上手。简洁。右上角分别为：最小化和全屏。菜单在左下角（新建，保存，另存为之类的）和右下角（切换编辑模式）。</div><div class="line"></div><div class="line">### 15. shadowsocks</div><div class="line"></div><div class="line">算是必备的吧。科研(?)利器。</div><div class="line">#### 安装软件</div><div class="line"></div><div class="line">ubuntu16.04 直接一句话安装：</div></pre></td></tr></table></figure><p>sudo apt install shadowsocks<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">提示需要安装一些依赖库，选择`yes`即可。</div><div class="line"></div><div class="line">我们可以在`/home/wangwlj/` 下新建个文件`shadowsocks.json`  (`wangwlj`是我在我电脑上的用户名，这里路径你自己看你的)。内容是这样：</div></pre></td></tr></table></figure></p><p>{<br>    “server”:”11.22.33.44”,<br>    “server_port”:50003,<br>    “local_port”:1080,<br>    “password”:”123456”,<br>    “timeout”:600,<br>    “method”:”aes-256-cfb”<br>}</p><p>上面的各项参数含义如下：<br>server  你服务端的IP<br>servier_port  你服务端的端口<br>local_port  本地端口，一般默认1080<br>passwd  ss服务端设置的密码<br>timeout  超时设置 和服务端一样<br>method  加密方法 和服务端一样<br>```</p><p>确定上面的配置文件没有问题，然后我们就可以在终端输入<code>sslocal -c /home/wangwlj/shadowsocks.json</code> 回车运行。如果没有问题的话，下面会是这样…</p><h4 id="chrome插件SwithyOmega配置"><a href="#chrome插件SwithyOmega配置" class="headerlink" title="chrome插件SwithyOmega配置"></a>chrome插件SwithyOmega配置</h4><p>这里就不详写了，看这篇，写的很详细：<a href="http://www.sundabao.com/ubuntu%E4%BD%BF%E7%94%A8shadowsocks/" target="_blank" rel="external">ubuntu使用shadowsocks</a></p><p>还是简要附上几点吧。</p><p>新建一个模式，代理服务器，代理协议<code>SOCKS5</code>，代理服务器<code>127.0.0.1</code>，端口<code>1080</code></p><p><code>auto switch</code>中，上述模式对应的是：(按照规则列表匹配请求)使用shadowsocks访问的规则列表：<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="external">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a><br>，其余情况为直接访问。</p><blockquote><p>PS：windows下的chrome插件SwithyOmega的配置与Ubuntu一样。</p></blockquote><h3 id="Updating-1"><a href="#Updating-1" class="headerlink" title="Updating"></a>Updating</h3><p>将在个人博客中持续更新……</p><p>为了查找安装方便，所有参考链接均在对应位置处，就不放在最后了。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/ubuntu_software_summary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(6) 第七章快速排序</title>
      <link>http://wangwlj.com/2018/01/11/algorithm_tutorial_charpter_7/</link>
      <guid>http://wangwlj.com/2018/01/11/algorithm_tutorial_charpter_7/</guid>
      <pubDate>Thu, 11 Jan 2018 13:54:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;快速排序简介&quot;&gt;&lt;a href=&quot;#快速排序简介&quot; class=&quot;headerlink&quot; title=&quot;快速排序简介&quot;&gt;&lt;/a&gt;快速排序简介&lt;/h2&gt;&lt;p&gt;快排最坏情况$O( n^2 )$，但平均效率$O(n lg n)$，而且$O(n lg n)$隐含的常数因子
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="快速排序简介"><a href="#快速排序简介" class="headerlink" title="快速排序简介"></a>快速排序简介</h2><p>快排最坏情况$O( n^2 )$，但平均效率$O(n lg n)$，而且$O(n lg n)$隐含的常数因子很小，快排可以说是最快的排序算法，并非浪得虚名。另外它还是原址排序。</p><p>快速排序是基于分治模式的：</p><ul><li>分解：数组A【p..r】被划分成两个（可能空）子数组A【p..q-1】和A【q+1..r】，使得A【p..q-1】中的每个元素都小于等于A(q)，而且，小于等于A【q+1..r】中的元素。计算下标q也是划分过程中的一部分。</li><li>解决：通过递归调用快速排序，对子数组A【p..q-1】和A【q+1..r】排序。</li><li>合并：因为两个子数组是原址排序的，将它们的合并不需要操作：整个数组A【p..r】已排序。</li></ul><p>快排的伪码：<br><img src="https://images2.imgbox.com/e6/39/ffgJfqit_o.jpg" alt=""></p><p>其中对数组的划分：<code>Partition</code>是快排算法的关键，，它对子数组A【p..r】进行原址重排）。<br><img src="https://images2.imgbox.com/7e/a5/T2zKB1UV_o.jpg" alt=""></p><h2 id="快速排序Python实现"><a href="#快速排序Python实现" class="headerlink" title="快速排序Python实现"></a>快速排序Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    x = A[r]</div><div class="line">    i = p - <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):  <span class="comment"># not r-1, but r</span></div><div class="line">        <span class="keyword">if</span> A[j] &lt; x:</div><div class="line">            i = i + <span class="number">1</span></div><div class="line">            A[i], A[j] = A[j], A[i]</div><div class="line">    A[r], A[i + <span class="number">1</span>] = A[i + <span class="number">1</span>], A[r]</div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">QUICKSORT</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = PARTITION(A, p, r)</div><div class="line">        QUICKSORT(A, p, q - <span class="number">1</span>)</div><div class="line">        QUICKSORT(A, q + <span class="number">1</span>, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</div><div class="line">    QUICKSORT(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)  <span class="comment"># all start from 0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">"  "</span>)</div></pre></td></tr></table></figure><h2 id="快速排序性能分析"><a href="#快速排序性能分析" class="headerlink" title="快速排序性能分析"></a>快速排序性能分析</h2><p>当数据量很小的时候，大概就十来个元素的小型序列，快排的优势并不明显，甚至比插入排序慢。但是一旦数据多，它的优势就充分发挥出来了。</p><p>举一个例子，<code>C++ STL</code> 中的<code>sort</code>函数，就充分发挥了快排的优势，并且取长补短，在数据量大时采用<code>QuickSort</code>，分段递归排序。一旦分段后的数据量小于某个门槛，为避免<code>QuickSort</code>递归调用带来过大的额外负荷，就改用插入排序。如果递归层次过深，还会改用<code>HeapSort</code>(堆排序，第六章刚讲)。所以说，C++的“混合兵种”sort的性能肯定会比C的qsort好。</p><p>快排的运行时间与Partition的划分有关：</p><ul><li><strong>最坏情况</strong>是输入的数组已经完全排好序，那么每次划分的左、右两个区域分别为n-1和0，效率为$O( n^2 )$.</li><li>而对于其他<strong>常数比例划分</strong>，哪怕是左右按9:1的比例划分，效果都是和在正中间划分一样快的（算法导论上有详细分析）</li><li>即，<strong>任何一种按照常数比例进行划分，总运行时间都是$\text{O}(n \text{lg} n)$</strong>。</li></ul><h2 id="快速排序的随机化版本"><a href="#快速排序的随机化版本" class="headerlink" title="快速排序的随机化版本"></a>快速排序的随机化版本</h2><p>随机抽样(random sampling):从$A[p..r]$中随机选一个元素作为主元，而不是始终采用$A[r]$作为主元。</p><p>随机化的快排的伪码如下：</p><p><img src="https://images2.imgbox.com/53/ea/JY82TS9f_o.jpg" alt="快速排序的随机化版本"></p><p>Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    x = A[r]</div><div class="line">    i = p - <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):  <span class="comment"># not r-1, but r</span></div><div class="line">        <span class="keyword">if</span> A[j] &lt; x:</div><div class="line">            i = i + <span class="number">1</span></div><div class="line">            A[i], A[j] = A[j], A[i]</div><div class="line">    A[r], A[i + <span class="number">1</span>] = A[i + <span class="number">1</span>], A[r]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RANDOMIZED_PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    rand_i = random.random()</div><div class="line">    <span class="comment"># print(round(a *(r - p)) + p)</span></div><div class="line">    rand_i = round(rand_i * (r - p) + p)  <span class="comment"># 区间的计算需要注意，否则不对</span></div><div class="line">    A[rand_i], A[r] = A[r], A[rand_i]</div><div class="line">    <span class="keyword">return</span> PARTITION(A, p, r)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RANDOMIZED_QUICKSORT</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = RANDOMIZED_PARTITION(A, p, r)</div><div class="line">        RANDOMIZED_QUICKSORT(A, p, q - <span class="number">1</span>)</div><div class="line">        RANDOMIZED_QUICKSORT(A, q + <span class="number">1</span>, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</div><div class="line">    RANDOMIZED_QUICKSORT(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)  <span class="comment"># all start from 0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">"  "</span>)</div></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>算法导论 中文 第三版</li><li><a href="http://blog.csdn.net/shuangde800/article/details/7599509" target="_blank" rel="external">【算法导论】排序 （三）：快速排序 深入分析</a></li><li><a href="http://www.runoob.com/python/func-number-random.html" target="_blank" rel="external">Python random() 函数</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/11/algorithm_tutorial_charpter_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(5) 第六章堆排序</title>
      <link>http://wangwlj.com/2018/01/09/algorithm_tutorial_charpter_6/</link>
      <guid>http://wangwlj.com/2018/01/09/algorithm_tutorial_charpter_6/</guid>
      <pubDate>Tue, 09 Jan 2018 13:27:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;在第二章介绍了两种排序算法，第六章将介绍第三种排序算法：堆排序(heapsort)，以及基于堆排序的优先队列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fn9epgz0rbj20k006rjs1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在第二章介绍了两种排序算法，第六章将介绍第三种排序算法：堆排序(heapsort)，以及基于堆排序的优先队列。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn9epgz0rbj20k006rjs1.jpg" alt=""></p><a id="more"></a><p>空间原址性(in place)：仅有常数个元素需要在排序过程中存储在数组之外。</p><h2 id="堆-6-1-P84"><a href="#堆-6-1-P84" class="headerlink" title="堆(6.1, P84)"></a>堆(6.1, P84)</h2><p>堆，也叫 二叉堆，是一个数组，可以看作近似的完全二叉树，树的每个节点对应数组一个元素。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn9epgz0rbj20k006rjs1.jpg" alt=""></p><p>表示堆的数组<code>A</code>包括两个属性：<code>A.length</code>给出数组元素的个数；<code>A.heap-size</code>给出有多少个元素存储在该数组中。即heap-size是数组的有效元素。</p><p>给定下标<code>i</code>，很容易计算其父节点、左节点和右节点：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div></pre></td></tr></table></figure></p><blockquote><p>这三个函数通常以宏或者内联函数的方式实现。</p></blockquote><p>二叉堆分为两种形式：最大堆和最小堆。<br>最大堆满足：A[PARENT(i)] ≥ A[i] ，即：某个节点的值最多与其父节点一样大；最小堆满足：A[PARENT(i)] ≤ A[i]。</p><p>堆排序算法采用的是最大堆。最小堆通常用于构造优先队列。</p><p>堆的高度为：$Θ(lgn)$</p><h2 id="维持堆的性质（6-2，P86）"><a href="#维持堆的性质（6-2，P86）" class="headerlink" title="维持堆的性质（6.2，P86）"></a>维持堆的性质（6.2，P86）</h2><p><code>MAX-HEAPIFY</code>：输入为一个数组A和一个下标i，A[i]有可能小于其孩子，通过让A[i]在数组中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆的性质。</p><p>该函数伪码表示为：<br><img src="https://images2.imgbox.com/54/2c/3rWF8zSL_o.png" alt="MAX-HEAPIFY伪码"></p><p>算法图示：<br><img src="https://images2.imgbox.com/71/85/6tJrJVIS_o.png" alt=""></p><p>Python实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= len(A) <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= len(A) <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest)</div></pre></td></tr></table></figure></p><p>每个孩子的子树最多为2n/3（不太理解这句话？？）。<br>所以，在最差情况下（最底层恰好半满）运行时间为：<br>$$T(n) = T(2n/3)+ \Theta(1)$$<br>上述递归式的解为：$T(n) = \text{O} (\text{lg}n)$</p><h2 id="建堆-6-3-P87"><a href="#建堆-6-3-P87" class="headerlink" title="建堆(6.3, P87)"></a>建堆(6.3, P87)</h2><p>子数组元素$A[ (\lfloor n/2\rfloor +1),\cdots,n]$是树中的所有叶节点。<br><code>BUILD_MAX_HEAP</code>从非叶节点开始一直循环到根节点。</p><p><img src="https://images2.imgbox.com/02/43/BH6sysvA_o.png" alt=""></p><p>Python实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUILD_MAX_HEAP</span><span class="params">(A)</span>:</span></div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(floor(heap_size / <span class="number">2</span>)), <span class="number">0</span>, <span class="number">-1</span>):</div><div class="line">        MAX_HEAPIFY(A, i)</div></pre></td></tr></table></figure></p><p><code>BUILD_MAX_HEAP</code> 的时间复杂度为$T(n) = \text{O}(n)$</p><h2 id="堆排序算法-6-4，P89"><a href="#堆排序算法-6-4，P89" class="headerlink" title="堆排序算法(6.4，P89)"></a>堆排序算法(6.4，P89)</h2><p>伪代码：<br><img src="https://images2.imgbox.com/5d/94/xcT4QVgb_o.png" alt=""></p><p>Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAPSORT</span><span class="params">(A)</span>:</span></div><div class="line">    BUILD_MAX_HEAP(A)</div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A), <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">        A[<span class="number">1</span> - <span class="number">1</span>], A[i - <span class="number">1</span>] = A[i - <span class="number">1</span>], A[<span class="number">1</span> - <span class="number">1</span>]  <span class="comment"># exchage A[i] with A[1]</span></div><div class="line">        heap_size = heap_size - <span class="number">1</span></div><div class="line">        MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div></pre></td></tr></table></figure></p><p><code>HEAPSORT</code>过程的时间复杂度为：$\text{O}(n\text{lg}n)$，因为<code>BUILD_MAX_HEAP</code>的时间复杂度为$\text{O}(n)$，n-1次调用<code>MAX_HEAPIFY</code>，每次时间为$\text{O}(\text{lg}n)$。</p><h2 id="堆排序的Python完整实现"><a href="#堆排序的Python完整实现" class="headerlink" title="堆排序的Python完整实现"></a>堆排序的Python完整实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i, size)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= size <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= size <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest, size)</div><div class="line">        </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUILD_MAX_HEAP</span><span class="params">(A)</span>:</span></div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(floor(heap_size / <span class="number">2</span>)), <span class="number">0</span>, <span class="number">-1</span>):</div><div class="line">        MAX_HEAPIFY(A, i, heap_size)</div><div class="line">        </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAPSORT</span><span class="params">(A)</span>:</span></div><div class="line">    BUILD_MAX_HEAP(A)</div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A), <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">        A[<span class="number">1</span> - <span class="number">1</span>], A[i - <span class="number">1</span>] = A[i - <span class="number">1</span>], A[<span class="number">1</span> - <span class="number">1</span>]  <span class="comment"># exchage A[i] with A[1]</span></div><div class="line">        heap_size = heap_size - <span class="number">1</span></div><div class="line">        MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># A = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]</span></div><div class="line">    <span class="comment"># MAX_HEAPIFY(A, 2)</span></div><div class="line">    <span class="comment"># for i in range(0, len(A)):</span></div><div class="line">    <span class="comment">#     print(A[i], end=" ")</span></div><div class="line">    <span class="comment"># A = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7]</span></div><div class="line">    <span class="comment"># BUILD_MAX_HEAP(A)</span></div><div class="line">    <span class="comment"># for i in range(0, len(A)):</span></div><div class="line">    <span class="comment">#     print(A[i], end=" ")</span></div><div class="line">    A = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</div><div class="line">    HEAPSORT(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">" "</span>)</div></pre></td></tr></table></figure><h2 id="优先队列-6-5，P90"><a href="#优先队列-6-5，P90" class="headerlink" title="优先队列(6.5，P90)"></a>优先队列(6.5，P90)</h2><p>优先队列：是一种用来维护由一组元素构成的集合S的数据结果，其中的每个元素都有一个相关的值，称为关键字。优先队列也有两种形式：最大优先队列和最小优先队列。</p><p>最大优先队列的应用：共享计算机系统的作业调度。<br>最小优先队列被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生事件作为关键词。</p><p>优先队列可以用堆来实现。优先队列的元素对应应用程序的对象，堆中每个元素存储对象的句柄(handle)。</p><p>最大优先队列支持：</p><ul><li>对最大优先队列进行插入，<code>MaxHeapInsert</code>；</li><li>返回最大优先队列的最大值，<code>HeapMax</code>；</li><li>去掉最大值并且返回该值，<code>HeapExtractMax</code>；</li><li>将第x个元素的值改为k，其中k&gt;=x的原来的值，<code>HeapIncreaseKey</code>；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_MAXIMUM</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">return</span> A[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_EXTRACT_MAX</span><span class="params">(A, heap_size)</span>:</span></div><div class="line">    <span class="keyword">if</span> heap_size &lt; <span class="number">1</span>:</div><div class="line">        print(<span class="string">"ERROR!! Heap underflow!!"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    max_A = A[<span class="number">1</span> - <span class="number">1</span>]</div><div class="line">    A[<span class="number">1</span> - <span class="number">1</span>] = A[heap_size - <span class="number">1</span>]</div><div class="line">    heap_size = heap_size - <span class="number">1</span></div><div class="line">    MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line">    <span class="keyword">return</span> max_A</div></pre></td></tr></table></figure><p><code>HeapExtractMax</code>的操作复杂度为$\text{O}(\text{lg}n)$（也就是<code>MAX_HEAPIFY</code>的复杂度）。</p><h2 id="最大优先队列的Python完整实现："><a href="#最大优先队列的Python完整实现：" class="headerlink" title="最大优先队列的Python完整实现："></a>最大优先队列的Python完整实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i, heap_size)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= heap_size <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= heap_size <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest, heap_size)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_MAXIMUM</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">return</span> A[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_EXTRACT_MAX</span><span class="params">(A, heap_size)</span>:</span></div><div class="line">    <span class="keyword">if</span> heap_size &lt; <span class="number">1</span>:</div><div class="line">        print(<span class="string">"ERROR!! Heap underflow!!"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    max_A = A[<span class="number">1</span> - <span class="number">1</span>]</div><div class="line">    A[<span class="number">1</span> - <span class="number">1</span>] = A[heap_size - <span class="number">1</span>]</div><div class="line">    heap_size = heap_size - <span class="number">1</span></div><div class="line">    MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line">    <span class="keyword">return</span> max_A</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_INCREASE_KEY</span><span class="params">(A, i, key)</span>:</span></div><div class="line">    <span class="keyword">if</span> key &lt; A[i - <span class="number">1</span>]:</div><div class="line">        print(<span class="string">"ERROR!! New key is smaller than current key!!!"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    A[i - <span class="number">1</span>] = key</div><div class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span> <span class="keyword">and</span> A[int(PARENT(i) - <span class="number">1</span>)] &lt; A[int(i - <span class="number">1</span>)]:</div><div class="line">        A[int(PARENT(i) - <span class="number">1</span>)], A[int(i - <span class="number">1</span>)] = A[int(i - <span class="number">1</span>)], A[int(PARENT(i) - <span class="number">1</span>)]</div><div class="line">        i = PARENT(i)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAP_INSERT</span><span class="params">(A, key)</span>:</span></div><div class="line">    MAX_INT = <span class="number">0x7fffffff</span></div><div class="line">    heap_size = len(A) + <span class="number">1</span></div><div class="line">    A.append(- MAX_INT)  <span class="comment"># 尾部追加元素</span></div><div class="line">    HEAP_INCREASE_KEY(A, heap_size, key)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">16</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</div><div class="line">    MAX_HEAP_INSERT(A, <span class="number">9</span>)  <span class="comment"># 调用的数值都是从1开始。</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">" "</span>)</div></pre></td></tr></table></figure><p>算法基本思想：在末尾新插入一个元素，按照最大堆的要求排列好就行。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>算法导论 中文 第三版</li><li><a href="http://blog.csdn.net/u010183397/article/details/46882099" target="_blank" rel="external">算法导论 第六章：堆排序</a></li><li><a href="http://blog.csdn.net/xjm199/article/details/18039023" target="_blank" rel="external">最大优先队列–【算法导论】</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/09/algorithm_tutorial_charpter_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>动手实现atoi函数—— Leetcode(8)</title>
      <link>http://wangwlj.com/2018/01/09/leetcode_8/</link>
      <guid>http://wangwlj.com/2018/01/09/leetcode_8/</guid>
      <pubDate>Tue, 09 Jan 2018 07:32:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;8. String to Integer (atoi)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Implement atoi to convert a string to an integer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hint&lt;/strong&gt;: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/string-to-integer-atoi/description/" target="_blank" rel="external">8. String to Integer (atoi)</a></p><p>Implement atoi to convert a string to an integer.</p><p><strong>Hint</strong>: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现将<code>string</code>转化为<code>int</code>的<code>atoi</code>函数。这题需要充分考虑各种不规范输入的情况，主要有以下几种情况：</p><ol><li>忽略前面的所有空格直到非空格出现。从该字符开始，有可能是正负号，然后紧跟着一系列数字。</li><li>在数字的尾部有可能有一些无关的附加字符，也需要忽略它们。</li><li>如果第一个非空格字符不是有效数（即不是+-或者数字），则返回0。</li><li>如果string为空，或者仅有空格，则返回0。</li><li>如果最终结果超过int的范围，则返回int的最大/最小值。</li></ol><p>提供几个测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Input:&quot;2147483648&quot;     Expected:2147483647  //溢出的情况</div><div class="line">//Input:&quot;+&quot;              Expected:0 //不合法的情况 </div><div class="line">//Input:&quot;+-2&quot;            Expected:0 //不合法的情况 </div><div class="line">// Input: &quot;  123&quot; //有空格的情况</div><div class="line">// Input:&quot;-123&quot;   //有负数的情况</div><div class="line">// Input:&quot;+123&quot;   //有+号的情况</div></pre></td></tr></table></figure></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>先给出我自己折腾的一个解法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_atoi</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INT_MAX = <span class="number">0x7fffffff</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INT_MIN = <span class="number">0x80000000</span>;</div><div class="line">    <span class="keyword">int</span> len = str.size();</div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(str[index] == <span class="string">' '</span> &amp;&amp; index &lt; len)&#123;</div><div class="line">        index ++; <span class="comment">// 跳过空格</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>; <span class="comment">//符号位</span></div><div class="line">    <span class="keyword">long</span> l = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt; len; ++i)&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)</div><div class="line">            <span class="keyword">if</span>(<span class="string">'0'</span>&lt;= str[i+<span class="number">1</span>] &amp;&amp; str[i+<span class="number">1</span>] &lt;= <span class="string">'9'</span>)</div><div class="line">                sign = (str[i] == <span class="string">'-'</span>)? <span class="number">-1</span> : <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'0'</span>&lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) </div><div class="line">        &#123;</div><div class="line">            l = l * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>); <span class="comment">// 字符0对应的10进制为48，可以直接减去48</span></div><div class="line">            <span class="keyword">if</span>(l * sign &gt; INT_MAX)&#123;</div><div class="line">                <span class="keyword">return</span> INT_MAX;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l * sign &lt; INT_MIN)&#123;</div><div class="line">                <span class="keyword">return</span> INT_MIN;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> l  * sign;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>主要思路就是：从左向右，先忽略空格；然后空格之后第一位有三种可能：</p><ul><li>如果是“+-”号，则第二位必须是数字才记上正负号，否则返回0；</li><li>如果是数字，直到遇到非数字结束；</li><li>如果不是上述情况，则返回0。</li></ul><p>这边再给出一个<a href="https://leetcode.com/problems/string-to-integer-atoi/discuss/4642" target="_blank" rel="external">简洁的写法</a>，具体思路类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_atoi</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> indicator = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=str.size();)</div><div class="line">    &#123;</div><div class="line">        i = str.find_first_not_of(<span class="string">' '</span>);</div><div class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)</div><div class="line">            indicator = (str[i++] == <span class="string">'-'</span>)? <span class="number">-1</span> : <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="string">'0'</span>&lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) </div><div class="line">        &#123;</div><div class="line">            result = result*<span class="number">10</span> + (str[i++]-<span class="string">'0'</span>);</div><div class="line">            <span class="keyword">if</span>(result*indicator &gt;= INT_MAX) <span class="keyword">return</span> INT_MAX;</div><div class="line">            <span class="keyword">if</span>(result*indicator &lt;= INT_MIN) <span class="keyword">return</span> INT_MIN;                </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result*indicator;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注：原先<code>for(int i = 0; i&lt;=str.size();)</code>中并不包含等号，会导致空串时无返回值的错误。因此加上等于号。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/09/leetcode_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo博客彻底解决置顶问题</title>
      <link>http://wangwlj.com/2018/01/09/blog_pin_post/</link>
      <guid>http://wangwlj.com/2018/01/09/blog_pin_post/</guid>
      <pubDate>Tue, 09 Jan 2018 02:53:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://images2.imgbox.com/e8/af/g8uPUalf_o.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://images2.imgbox.com/e8/af/g8uPUalf_o.png" alt=""><br><a id="more"></a></p><h2 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h2><p>一种方法是手动对相关文件进行修改，具体可参考<a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="external">这篇文章</a>。</p><p>另一种方法就是，目前已经有修改后支持置顶的<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="external">仓库</a>，可以直接用以下命令安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> npm uninstall hexo-generator-index --save</div><div class="line"><span class="meta">$</span> npm install hexo-generator-index-pin-top --save</div></pre></td></tr></table></figure><p>然后在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code>即可。比如下面这篇文章：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">---</span></div><div class="line"><span class="attr">title:</span> <span class="string">hexo+GitHub博客搭建实战</span></div><div class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-09</span><span class="bullet">-08</span> <span class="number">12</span><span class="string">:00:25</span></div><div class="line"><span class="attr">categories:</span> <span class="string">博客搭建系列</span></div><div class="line"><span class="attr">top:</span> <span class="literal">true</span></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></figure><p>到目前为止，置顶功能已经可以实现了。所有相关博文到这边就结束了。</p><p>不过置顶的文章显示在最上面之后，如果没有明确的置顶标志，是不是感觉有点怪怪的呢？</p><h2 id="设置置顶标志"><a href="#设置置顶标志" class="headerlink" title="设置置顶标志"></a>设置置顶标志</h2><p>打开：<code>/blog/themes/next/layout/_macro</code> 目录下的<code>post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入如下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;% if post.top %&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-thumb-tack"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p><p>效果展示：<br><img src="https://images2.imgbox.com/e8/af/g8uPUalf_o.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="external">解决Hexo博客文章置顶问题</a></li><li><a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="external">解决Hexo置顶问题</a></li><li><a href="http://jinfang.life/posts/e0bb97e1/" target="_blank" rel="external">Hexo主题的数据封装，样式渲染和扩展实例</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/09/blog_pin_post/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(3) 第四章分治策略</title>
      <link>http://wangwlj.com/2018/01/08/algorithm_tutorial_chapter_4/</link>
      <guid>http://wangwlj.com/2018/01/08/algorithm_tutorial_chapter_4/</guid>
      <pubDate>Mon, 08 Jan 2018 08:43:37 GMT</pubDate>
      <description>
      
        &lt;p&gt;本章讲解更多关于分治策略的算法。第一个算法是求解最大子数组的问题，然后是求解$n\times n$矩阵乘法问题的分治算法，最后介绍了主方法。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本章讲解更多关于分治策略的算法。第一个算法是求解最大子数组的问题，然后是求解$n\times n$矩阵乘法问题的分治算法，最后介绍了主方法。</p><a id="more"></a><h2 id="分治策略简介"><a href="#分治策略简介" class="headerlink" title="分治策略简介"></a>分治策略简介</h2><p>分治策略在每层递归时都有三个步骤：</p><ul><li>分解原问题为若干子问题；子问题的形式与原问题一样，只是规模更小。</li><li>解决这些子问题，递归地求解各子问题。如果子问题的规模足够小，则停止递归，直接求解。</li><li>合并这些子问题的解成原问题的解。</li></ul><p>递归情况(recursive case)<br>基本情况(base case)：子问题足够小的时候，递归已经“触底”时。</p><p>递归式：我们用递归式描述了MERGE-SORT过程的最坏情况运行时间$T(n)$：<br>$$T(n) =<br> \begin{cases}<br>  \Theta(1) &amp; 若n=1 \\<br> 2T(n/2)+f(n) &amp;  若n&gt;1\\<br>  \end{cases}<br>$$<br>求解递归式的方法：代入法（猜测）；递归树法；主方法。本书使用主方法。</p><p>主方法可求解形如下面公式的递归式的界：<br>$$T(n) = aT(n/b)+f(n)$$<br>其中，$a\geqslant 1,b&gt;1,f(n)$是一个给定的函数。</p><p>递归式的技术细节</p><ul><li>忽略递归式声明和求解的一些细节，如MERGE-SORT的最坏情况运行时间准确的递归式为：</li></ul><p>$$T(n) =<br> \begin{cases}<br>  \Theta(1) &amp; 若n=1 \\<br> T(\lceil n/2\rceil )+T(\lfloor n/2\rfloor )+\Theta(n) &amp;  若n&gt;1\\<br>  \end{cases}<br>$$</p><ul><li>边界条件是我们通常忽略的细节。</li><li>当声明、求解递归式时，我们常常忽略向下取整、向上取整及边界条件。</li></ul><p>本章讲解更多关于分治策略的算法。第一个算法是求解最大子数组的问题，然后是求解$n\times n$矩阵乘法问题的分治算法。</p><h2 id="最大子数组问题-4-1，P38"><a href="#最大子数组问题-4-1，P38" class="headerlink" title="最大子数组问题(4.1，P38)"></a>最大子数组问题(4.1，P38)</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>买股票（低价买入，高价卖出）。给定一段时间，选取最大收益。</p><h3 id="问题变换"><a href="#问题变换" class="headerlink" title="问题变换"></a>问题变换</h3><p>不关注每天的价格，而是关注每日价格变化。<br>那么问题就转化为寻求价格变化数组A的最大非空连续子数组。<br>称这样的连续子数组为<strong>最大子数组</strong>。</p><h3 id="使用分治策略的求解方法"><a href="#使用分治策略的求解方法" class="headerlink" title="使用分治策略的求解方法"></a>使用分治策略的求解方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="comment"># MAX = 1 &lt;&lt; 31</span></div><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_crossing_subarray</span><span class="params">(A, low, mid, high)</span>:</span></div><div class="line">    max_left = mid</div><div class="line">    max_right = mid</div><div class="line">    left_sum = <span class="number">0</span>  <span class="comment"># original version init with -max, now is zero,because minimum is zero</span></div><div class="line">    all_sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid - <span class="number">1</span>, low - <span class="number">1</span>, <span class="number">-1</span>):  <span class="comment"># 左边不经过mid</span></div><div class="line">        all_sum += A[i]</div><div class="line">        <span class="keyword">if</span> all_sum &gt; left_sum:</div><div class="line">            left_sum = all_sum</div><div class="line">            max_left = i</div><div class="line">    right_sum = A[mid]  <span class="comment"># original version init with -max, now is A[mid],because A[mid] must be included.</span></div><div class="line">    all_sum = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid, high + <span class="number">1</span>):</div><div class="line">        all_sum += A[i]</div><div class="line">        <span class="keyword">if</span> all_sum &gt; right_sum:</div><div class="line">            right_sum = all_sum</div><div class="line">            max_right = i</div><div class="line">    <span class="comment"># print([low, mid, high], [max_left, max_right, left_sum + right_sum])</span></div><div class="line">    <span class="keyword">return</span> [max_left, max_right, left_sum + right_sum]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray</span><span class="params">(A, low, high)</span>:</span></div><div class="line">    <span class="keyword">if</span> high == low:</div><div class="line">        <span class="keyword">return</span> [low, high, A[low]]</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        mid = math.floor((low + high) / <span class="number">2</span>)</div><div class="line">        left_low, left_high, left_sum = find_maximum_subarray(A, low, mid)</div><div class="line">        right_low, right_high, right_sum = find_maximum_subarray(A, mid + <span class="number">1</span>, high)</div><div class="line">        cross_low, cross_high, cross_sum = find_max_crossing_subarray(A, low, mid, high)</div><div class="line">        <span class="keyword">if</span> left_sum &gt;= right_sum <span class="keyword">and</span> left_sum &gt;= cross_sum:</div><div class="line">            <span class="keyword">return</span> [left_low, left_high, left_sum]</div><div class="line">        <span class="keyword">elif</span> right_sum &gt;= left_sum <span class="keyword">and</span> right_sum &gt;= cross_sum:</div><div class="line">            <span class="keyword">return</span> [right_low, right_high, right_sum]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> [cross_low, cross_high, cross_sum]</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">1</span>, <span class="number">-3</span>, <span class="number">7</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">-5</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">-5</span>, <span class="number">9</span>]</div><div class="line">    <span class="comment"># A = [1, -3, 7, -5, -4, -1, -9, -3, 1, -3, -5, -9]</span></div><div class="line">    <span class="comment"># print(find_max_crossing_subarray(A, 0, 6, len(A) - 1))</span></div><div class="line">    print(find_maximum_subarray(A, <span class="number">0</span>, len(A) - <span class="number">1</span>))</div></pre></td></tr></table></figure><h3 id="分治算法的分析"><a href="#分治算法的分析" class="headerlink" title="分治算法的分析"></a>分治算法的分析</h3><p>假设问题规模为2的幂，这样所有问题的规模都是整数。</p><p>在<code>find_maximum_subarray</code>函数中，需要求解两个子问题——左数组和右数组(分别为5/6行)，每个子问题的运行时间为$T(n/2)$，两个子问题加起来就是$2T(n/2)$。<br>第7行，<code>find_max_crossing_subarray</code>函数求解跨越中点的子数组，花费线性的时间，为$\Theta (n)$。</p><p>总的运行时间递归式为：<br>$$T(n) = \begin{cases}<br>\Theta (1) &amp; if\ \ n=1\\<br>2T(n/2)+\Theta (n) &amp; if\ \  n&gt;1<br>\end{cases}<br>$$<br>与鬼归并排序的递归式相同。在4.5节用主方法求解该递归式，其解为$T(n) =\Theta (n\ \text{lg}n) $。</p><h3 id="线性复杂度的解法–习题4-1-5-P42"><a href="#线性复杂度的解法–习题4-1-5-P42" class="headerlink" title="线性复杂度的解法–习题4.1-5(P42)"></a>线性复杂度的解法–习题4.1-5(P42)</h3><p>主要思想：从左到右处理，记录目前为止已经处理的最大子数组。非递归、线性复杂度。</p><p>从左到右累加，如果当前子数组的累加和小于零，则意味着最大子数组(maximun subarray)肯定不包括该子数组，所以果断舍弃，重新开始累加。</p><p>该解法的python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray</span><span class="params">(A)</span>:</span></div><div class="line">   j = <span class="number">0</span></div><div class="line">   max_sum = <span class="number">0</span></div><div class="line">   left = <span class="number">-1</span></div><div class="line">   cur_left = <span class="number">0</span></div><div class="line">   right = <span class="number">-1</span></div><div class="line">   sum = <span class="number">0</span></div><div class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">       sum = sum + A[j]</div><div class="line">       <span class="keyword">if</span> sum &gt; max_sum:</div><div class="line">           max_sum = sum</div><div class="line">           left = cur_left</div><div class="line">           right = j</div><div class="line">       <span class="keyword">elif</span> sum &lt; <span class="number">0</span>:</div><div class="line">           sum = <span class="number">0</span></div><div class="line">           cur_left = j + <span class="number">1</span></div><div class="line">   <span class="keyword">if</span> max_sum &gt; <span class="number">0</span>:</div><div class="line">       <span class="keyword">return</span> left, right, max_sum</div><div class="line">   <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure></p><h2 id="矩阵乘法的Strassen算法-4-2，P43"><a href="#矩阵乘法的Strassen算法-4-2，P43" class="headerlink" title="矩阵乘法的Strassen算法(4.2，P43)"></a>矩阵乘法的Strassen算法(4.2，P43)</h2><p>若$A=(a_{ij}),B=(b_{ij})$是$nxn$的方阵，则对$i,j=1,2,\cdots ,n$,定义矩阵乘积$C=A\cdot B$中的$c_{ij}$为：<br>$$c_{ij} = \sum_{k=1}^n a_{ik} b_{kj}$$</p><p>写成程序，是一个三重循环，因此，复杂度为$\Theta (n^3)$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">SQUARE_MATRIX_MULTIPLY</span><span class="params">(A, B)</span>:</span>  </div><div class="line">    <span class="keyword">assert</span>(len(A) == len(B))  </div><div class="line">    n = len(A)  </div><div class="line">    C = [[<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(n)] <span class="keyword">for</span> row <span class="keyword">in</span> range(n)]  </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):  </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, n):  </div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>, n):  </div><div class="line">                C[i][j]= C[i][j] + A[i][k]*B[k][j]  </div><div class="line">    <span class="keyword">return</span> C</div></pre></td></tr></table></figure><h3 id="一个简单的分治算法-4-2，P43"><a href="#一个简单的分治算法-4-2，P43" class="headerlink" title="一个简单的分治算法(4.2，P43)"></a>一个简单的分治算法(4.2，P43)</h3><p>假定三个矩阵均为$n\times n$矩阵，其中n为2的幂。在每个分解步骤中，$n\times n$矩阵都被划分为4个$n/2 \times n/2$的子矩阵，如下：<br>$$A = \begin{bmatrix}<br>A_{11} &amp; A_{12}\\A_{21} &amp; A_{22}<br>\end{bmatrix},<br>B = \begin{bmatrix}<br>B_{11} &amp; B_{12}\\B_{21} &amp; B_{22}<br>\end{bmatrix},<br>C = \begin{bmatrix}<br>C_{11} &amp; C_{12}\\C_{21} &amp; C_{22}<br>\end{bmatrix}<br>$$<br>因此，公式$C=A\cdot B$改写成：<br>$$\begin{bmatrix}<br>C_{11} &amp; C_{12}\\C_{21} &amp; C_{22}<br>\end{bmatrix}= \begin{bmatrix}<br>A_{11} &amp; A_{12}\\A_{21} &amp; A_{22}<br>\end{bmatrix} \cdot<br>\begin{bmatrix}<br>B_{11} &amp; B_{12}\\B_{21} &amp; B_{22}<br>\end{bmatrix}<br>$$<br>等价于：<br>$$\begin{matrix}<br>C_{11} = A_{11}\cdot B_{11} + A_{12}\cdot B_{21} \\<br>C_{12} = A_{11}\cdot B_{12} + A_{12}\cdot B_{22} \\<br>C_{21} = A_{21}\cdot B_{11} + A_{22}\cdot B_{21} \\<br>C_{22} = A_{21}\cdot B_{12} + A_{22}\cdot B_{22}<br>\end{matrix}$$</p><p>该简单分治算法的总运行时间递归式为：<br>$$T(n) = \begin{cases}<br>\Theta (1) &amp; if\ \ n=1\\<br>8T(n/2)+\Theta (n^2) &amp; if\ \  n&gt;1<br>\end{cases}<br>$$</p><h3 id="Strassen-方法-4-2，P45"><a href="#Strassen-方法-4-2，P45" class="headerlink" title="Strassen 方法(4.2，P45)"></a>Strassen 方法(4.2，P45)</h3><p>为减小时间复杂度，采用Strassen 法，其原理仍将讲矩阵A,B,C划分成n/2 x n/2 ,然后按如下计算：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn945rgi23j20bx08575e.jpg" alt=""></p><p>即：先创建10个矩阵$S_1,\cdots,S_{10} $，由于进行了10次$n/2\times n/2$矩阵的加减法，所以该步骤花费$\Theta(n^2)$时间。</p><p>接着，递归地计算七次$n/2\times n/2$矩阵的乘法，即计算$P_1,\cdots,P_{7}$矩阵。</p><p>最后计算结果矩阵C的子矩阵$C_{11},C_{12},C_{21},C_{22}$。</p><p>其时间复杂度为：</p><p>$$T(n)= \begin{cases}<br>\Theta (1) &amp; if\ \ n=1\\<br>7T(n/2)+\Theta (n^2) &amp; if\ \  n&gt;1<br>\end{cases}<br>$$</p><p>利用4.5节的主方法，可以求出上述的解为：<br>$$T(n)= \Theta(n^{\text{lg}7}) $$</p><h2 id="用主方法求解递归式-4-5，P53"><a href="#用主方法求解递归式-4-5，P53" class="headerlink" title="用主方法求解递归式(4.5，P53)"></a>用主方法求解递归式(4.5，P53)</h2><p>主方法依赖于主定理。</p><h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>令$a\geqslant 1$和$b&gt;1$是常数，$f(n)$是一个函数，$T(n)$是定义在非负整数上的递归式：<br>$$T(n)= aT(n/b)+f(n)$$</p><p>其中，我们将$n/b$解释为$\lfloor n/b \rfloor$或$\lceil n/b \rceil$。那么$T(n)$有如下的渐近界：</p><ol><li><p>若对某个常数$\epsilon &gt; 0$有$f(n) = \text{O}(n^{\text{log}_ba - \epsilon})$，则$T(n)=\Theta(n^{\text{log}_ba} )$</p></li><li><p>若$f(n) = \Theta(n^{\text{log}_ba})$，则$T(n)=\Theta(n^{\text{log}_ba} \text{lg}n)$</p></li><li>若对某个常数$\epsilon &gt; 0$有$f(n) = \Omega(n^{\text{log}_ba + \epsilon})$，且对某个常数$c&lt;1$和所有足够大的n有$aT(n/b)\leqslant cf(n)$，则$T(n)=\Theta(f(n) )$</li></ol><p>以上就是主定理的完整叙述。</p><p>解释：我们将函数$f(n)$和$n^{\text{log}_ba}$进行比较。直觉上，两个函数较大者决定了递归式的解。<br>情况1表示：函数$n^{log_ba}$更大，则解为$T(n)=\Theta(n^{\text{log}_ba} )$；<br>情况3表示：函数$f(n)$更大，则解为$T(n)=\Theta(f(n) )$。<br>情况2表示：当两个函数大小相当，则乘上一个对数因子，解为$T(n)=\Theta(n^{\text{log}_ba} \text{lg}n)$。</p><blockquote><p>上述的大于/小于都是多项式意义上的，也就是渐近小于(大于)。每种情况之间都有一定的间隙。若$f(n)$落在间隙中，就不能使用主方法。</p></blockquote><h3 id="使用主方法"><a href="#使用主方法" class="headerlink" title="使用主方法"></a>使用主方法</h3><p>使用主方法，只需要确定主定理的哪种情况成立，即可以得到解。</p><p>下面举几个例子。</p><p>$$T(n)= 9T(n/3)+n$$<br>上式中，$a=9,b=3,f(n) = n$，因此，$n^{\text{log}_ba} =n^{\text{log}_39} = \Theta(n^2) $。由于$f(n) = \text{O}(n^{\text{log}_39 - \epsilon})$，其中$\epsilon = 1$，所以应用主定理的情况1，从而得到$T(n) = \Theta(n^2) $</p><p>$$T(n)= T(2n/3)+1$$<br>上式中，$a=1,b=3/2,f(n) = 1$，因此，$n^{\text{log}_ba} =n^{\text{log}_{3/2}1} =n^0 = 1 $，由于$f(n) = \Theta(n^{\text{log}_ba}) = \Theta (1)$，所以，适用于情况二，从而得到最终解为$T(n) = \Theta(\text{lg} n ) $</p><p>归并排序和最大子数组方法的运行时间的递归式：<br>$$ T(n)= 2T(n/2)+\Theta(n)$$<br>同理，$n^{\text{log}_ba} =n^{\text{log}_{2}2} =n $， 由于$f(n) = \Theta(n)$，所以应用情况2，得到解$T(n) = \Theta(n\text{lg} n ) $</p><p>矩阵乘法的第一个分治算法的运行时间：<br>$$ T(n)= 8T(n/2)+\Theta(n^2)$$<br>上式，有：$n^{\text{log}_ba} =n^{\text{log}_{2}8} =n^3 $，$n^3$多项式意义上大于$f(n)$，因此应用情况1，解为$T(n) = \Theta(n^3) $</p><p>矩阵乘法的Strassen算法运行时间：<br>$$ T(n)= 7T(n/2)+\Theta(n^2)$$<br>上式中，有$n^{\text{log}_ba} =n^{\text{log}_{2}7} = n^{\text{lg}7}$，由于$2.80&lt;lg7&lt;2.81$，对$\epsilon = 0.8$，有$f(n) = \text{O}(n^{\text{lg}7-\epsilon})$，故应用情况1，得到：$T(n) = \Theta(n^{\text{lg}7}) $</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>算法导论 中文版 原书第三版</li><li><a href="http://blog.csdn.net/u010183397/article/details/46866577" target="_blank" rel="external">算法导论 第四章：分治法(二)</a></li><li><a href="http://blog.csdn.net/sushauai/article/details/50491477" target="_blank" rel="external">算法导论课后习题解析 第四章 上</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/08/algorithm_tutorial_chapter_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>判断回文数（三种解法）—— Leetcode(9)</title>
      <link>http://wangwlj.com/2018/01/08/Leetcode_9/</link>
      <guid>http://wangwlj.com/2018/01/08/Leetcode_9/</guid>
      <pubDate>Mon, 08 Jan 2018 07:32:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;Leetcode链接：&lt;a href=&quot;https://leetcode.com/problems/palindrome-number&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;9. Palindrome Number&lt;/a&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Leetcode链接：<a href="https://leetcode.com/problems/palindrome-number" target="_blank" rel="external">9. Palindrome Number</a></p><a id="more"></a><p>Palindrome Number，即判断是否为回文数，并且题目要求不能使用额外的空间。<br>即，不能使用回文串的方法。</p><p>在本题中，负数不作为回文数考虑范围之内，但是输入依然可能为负，此时直接返回false即可。</p><p>首先，一种容易想到的方法是：将整个数取反后看和原来的数是否相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>)  </div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum =<span class="number">0</span>;  </div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> origin = x;  </div><div class="line">        <span class="keyword">while</span>(x)  </div><div class="line">        &#123;  </div><div class="line">            <span class="keyword">int</span> num = x %<span class="number">10</span>;  </div><div class="line">            sum = sum*<span class="number">10</span> + num;  </div><div class="line">            x/=<span class="number">10</span>;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span>(sum == origin)  </div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>我采用另外一种方法：根据回文数的特点，我们只需要判断左边一半和翻转后的右边一半是否相等即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="comment">// 负数肯定不是，以及首尾不对称的非0数</span></div><div class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>))</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> rev = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> ( x &gt; rev)&#123;</div><div class="line">            rev = rev * <span class="number">10</span> + x % <span class="number">10</span>; <span class="comment">//将低位一半的数取反。</span></div><div class="line">            x = <span class="keyword">int</span> (x / <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//有rev &gt;= x， 奇数情况下需要除去10</span></div><div class="line">        <span class="keyword">return</span> x == rev || x == <span class="keyword">int</span>(rev/<span class="number">10</span>); </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>还有另外一种解法：<br>类似与采用两个指针。<br>在循环体中，不断地比较第i位和倒数第i位，直到遇到最中间的1个数字(输入为奇数个数字)或者遇到最中间的2个数字(输入为偶数个数字)时结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </div><div class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">  <span class="keyword">int</span> div = <span class="number">1</span>;  </div><div class="line">  <span class="keyword">while</span> (x / div &gt;= <span class="number">10</span>) &#123;  </div><div class="line">    div *= <span class="number">10</span>;  </div><div class="line">  &#125;          </div><div class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;  </div><div class="line">    <span class="keyword">int</span> l = x / div;  </div><div class="line">    <span class="keyword">int</span> r = x % <span class="number">10</span>;  </div><div class="line">    <span class="keyword">if</span> (l != r) <span class="keyword">return</span> <span class="literal">false</span>;  </div><div class="line">    x = (x % div) / <span class="number">10</span>;  <span class="comment">//去掉两边的数</span></div><div class="line">    div /= <span class="number">100</span>;  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参考链接：</p><ul><li><a href="http://blog.csdn.net/feliciafay/article/details/17134663" target="_blank" rel="external">LeetCode(9)PalindromeNumber</a></li><li><a href="http://blog.csdn.net/zhangxiao93/article/details/48751493" target="_blank" rel="external">leetcode9</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/08/Leetcode_9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(六)函数</title>
      <link>http://wangwlj.com/2018/01/06/CPP_06/</link>
      <guid>http://wangwlj.com/2018/01/06/CPP_06/</guid>
      <pubDate>Sat, 06 Jan 2018 08:55:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;第六章是和函数有关的知识，函数就是命名了的计算单元，对程序的结构化非常重要。&lt;br&gt;本章内容包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数的概念基础，包括函数的定义声明以及函数如何生成值和返回结果。&lt;/li&gt;
&lt;li&gt;函数重载,重载可以使函数接受不同种类或者数量不同的参数。&lt;/li&gt;
&lt;li&gt;函数指针，指向函数的一类特殊指针。&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>第六章是和函数有关的知识，函数就是命名了的计算单元，对程序的结构化非常重要。<br>本章内容包括：</p><ol><li>函数的概念基础，包括函数的定义声明以及函数如何生成值和返回结果。</li><li>函数重载,重载可以使函数接受不同种类或者数量不同的参数。</li><li>函数指针，指向函数的一类特殊指针。</li></ol><a id="more"></a><h2 id="函数基础（P182，6-1）"><a href="#函数基础（P182，6-1）" class="headerlink" title="函数基础（P182，6.1）"></a>函数基础（P182，6.1）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> c)</span> <span class="comment">// 形参  </span></span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    func(<span class="number">1</span>, <span class="string">'a'</span>); <span class="comment">// 实参，与形参的类型、数量相匹配  </span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在调用函数时，第一步编译器会隐式的定义并初始化它的形参。比如一个函数<code>void f(int a);</code>，形参<code>int a</code>会被用户传入的实参初始化，此时形参是实参的一个副本。当有多个形参时，形参对应的实参的求值顺序是不一定的。实参的类型必须和形参的类型一致或能转化为形参声明的类型。</p><p>函数可以返回空值。返回函数指针和数组的特殊函数类型将在之后提到。</p><h3 id="局部静态对象（P185，6-1-1）"><a href="#局部静态对象（P185，6-1-1）" class="headerlink" title="局部静态对象（P185，6.1.1）"></a>局部静态对象（P185，6.1.1）</h3><p>一个对象的名字有作用域，对象本身也有生命周期。名字的作用域是我们可以通过名字访问对象的的区间。相对的，生命周期是指对象的产生和销毁的过程。</p><p>定义在所有函数外部的变量叫做<strong>全局变量</strong>，在整个程序的执行过程中一直存在。这种对象在程序启动时被创建，直到程序结束才会被销毁。</p><p>定义在函数体内的对象或者函数的形参都是<strong>局部变量</strong>。当函数执行路径经过该对象的定义语句时才会自动开始创建该对象，在对应的块结束时，这个对象会被销毁。</p><p>有时候我们有必要使局部变量的生命周期贯穿函数调用及之后的时间，所以我们可以将局部对象定义成<code>static</code>对象，定义语句形如<code>static int a=1;</code>，这样我们就可以在程序的别的地方（只要是在这个static对象的作用域内访问它）操作这个局部静态对象。</p><p>在一个程序中多次定义局部静态对象仍然是不被允许的。但是当一个函数里的对象被定义为局部静态对象，<font color="00A00A">多次调用这个函数并不会重置这个局部静态对象的值</font>。它自己会记得上一次被函数调用之后的值并继承这个值，不被第二次函数调用的变量定义初始化，这就是它静态的特性。</p><blockquote><p>局部静态变量若没有显式的初始化，则执行值初始化，内置类型的局部静态变量初始化为0。</p></blockquote><h3 id="函数声明（P186，6-1-2）"><a href="#函数声明（P186，6-1-2）" class="headerlink" title="函数声明（P186，6.1.2）"></a>函数声明（P186，6.1.2）</h3><p>函数声明要在使用这个函数之前。规范的形式是通常放在头文件里。函数声明可以不写形参的名字，只写形参的类型。</p><p>函数声明也称作函数原型(function prototype)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数的声明，必须要写在函数第一次被调用之前。  </span></div><div class="line"> <span class="comment">// 这部分的代码可放到头文件中，用的时候include进来就可以了(分离式编译)  </span></div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span>, <span class="keyword">int</span>)</span></span>;  </div><div class="line">  </div><div class="line"> <span class="comment">// 只要函数在被调用前声明了，那函数的定义可以写在声明之后的任意的位置，  </span></div><div class="line"> <span class="comment">// 如这里的func就可以在声明之后、main函数之前定义；  </span></div><div class="line"> <span class="comment">// 如果func没有在调用前声明，则必须要在被调用前定义(相当于把main函数后面的func那段代码放在这里实现)  </span></div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </div><div class="line">     <span class="keyword">return</span> func(<span class="string">'a'</span>, <span class="string">'1'</span>); <span class="comment">// 函数的调用，虽然func在main后定义，但是因为之前对func进行了声明，所以编译器知道这个函数的三要素是啥  </span></div><div class="line"> &#125;  </div><div class="line">  </div><div class="line"> <span class="comment">/* </span></div><div class="line"><span class="comment">  * 函数的定义的参数列表中各参数的类型、数量以及位置等需要和声明时的相匹配 </span></div><div class="line"><span class="comment">  */</span>  </div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> i)</span>  </span></div><div class="line"><span class="function"> </span>&#123;  </div><div class="line">     <span class="comment">// do something  </span></div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h3 id="传引用调用（P189，6-2-2）"><a href="#传引用调用（P189，6-2-2）" class="headerlink" title="传引用调用（P189，6.2.2）"></a>传引用调用（P189，6.2.2）</h3><p>当函数的形参是一个引用类型的时候，在使用函数时，这个函数的引用形参就绑定在了传入的实参上，这种函数调用就叫做<strong>传引用调用</strong>。在函数涉及到一些比较大的类型对象作为参数的时候，通常地我们使用传引用调用，这样就可以避免实参初始化形参带来的拷贝。在C语言里经常传入指针避免拷贝，在C++里，一般使用引用。</p><p>大多数情况下函数只能有一个返回值，因此在我们需要的时候，我们可以<strong>传一个额外的引用的参数在函数里面。这样函数体内就可以改变引用的值进而改变函数外部被引用连接的对象的值，从而返回多个数值</strong>。</p><h3 id="const形参和实参（-P190，6-2-2）"><a href="#const形参和实参（-P190，6-2-2）" class="headerlink" title="const形参和实参（ P190，6.2.2）"></a>const形参和实参（ P190，6.2.2）</h3><p>函数形参的类型也可以是带const的类型。</p><blockquote><p>顶层const作用于对象本身（离对象最近的const），实参初始化形参的时候会忽略掉顶层const。即<strong>形参的顶层const被忽略掉了</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>; <span class="comment">//fcn 能读取i，但不能向i写值。</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">//错误，重复定义了fcn(int)。</span></div></pre></td></tr></table></figure><p>因为顶层const被忽略掉了，所以第二个fcn是错误的。</p><p>形参的初始化方式与变量的初始化方式一样。先回顾一下变量的初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int i  = 42;</div><div class="line">const int *cp = &amp;i; //正确，但是cp不能改变i</div><div class="line">const int &amp;r = i;   //正确，但是r不能改变i</div><div class="line">const int &amp;r2 = 42; //正确，参见P55。</div><div class="line"></div><div class="line">int *p = cp;        //错误，p的类型和cp的类型不匹配</div><div class="line">int &amp;r3 = r;        //r3的类型和r的类型不匹配</div><div class="line">int &amp;4 = 42;        //错误，不能用字面值常量初始化一个非常量引用（参见P45）</div></pre></td></tr></table></figure></p><p>将同样的初始化规则应用到参数传递上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</div><div class="line"><span class="built_in">string</span>::size_type ctr = <span class="number">0</span>;</div><div class="line">reset(&amp;i);  <span class="comment">//调用形参类型是int *的函数</span></div><div class="line">reset(&amp;ci);  <span class="comment">//错误：不能用指向const int对象的指针初始化int *</span></div><div class="line"></div><div class="line">reset(i);  <span class="comment">//调用形参类型是int &amp;的函数</span></div><div class="line">reset(ci);  <span class="comment">//错误：不能把普通引用绑定到const对象ci上</span></div><div class="line">reset(<span class="number">42</span>);  <span class="comment">//错误：不能把普通引用绑定到字面值上</span></div><div class="line">reset(ctr);  <span class="comment">//错误：类型不匹配，ctr是无符号类型</span></div></pre></td></tr></table></figure></p><p><strong><font color="00A00A">我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。</font></strong></p><hr><p><strong>当我们接受函数的参数是为了完成比较或者判断等操作，而不需要改变参数的值，我们应该使用带const的参数来确保参数不会被更改</strong>。另外，const类型的形参能比普通类型的形参接受更多种类的参数。比如<code>void fn(const string&amp;);</code>这个函数，字符串字面值是<code>const char [ ]</code>类型，因此fn这个函数接受字符串字面值。但是如果声明成了<code>void fn(string&amp;);</code>，那么这个函数就没有办法接受字符串字面值（类似：<code>“string”</code>这样的值就是字符串字面值）。另外，带const的形参也接受带底层const的对象。</p><h3 id="传递数组作为参数（P193，6-2-4）"><a href="#传递数组作为参数（P193，6-2-4）" class="headerlink" title="传递数组作为参数（P193，6.2.4）"></a>传递数组作为参数（P193，6.2.4）</h3><p>又是我们想要向函数传递一个数组，但是数组是不可拷贝的，因此我们不能够通过值传递的方式传递一个数组到函数里，另外，如果数组的内容很大，传递数组的每个元素会带来不必要的拷贝。</p><p>以下的方法都基于或类似<strong><font color="00A00A">传递数组的指针</font></strong>。一维数组的指针指向数组的第一个元素。我们可以声明类似如下的形式传递一个数组指针到函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span> [])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pri</span><span class="params">(<span class="keyword">int</span> [<span class="number">10</span>])</span></span>;</div></pre></td></tr></table></figure></p><p>这三者是等价的。传递之后形参的类型都是<code>int *</code>类型。</p><p>但是正因为数组的信息是以指针的形式传递给函数的，所以函数只得到一个地址，并不知道数组的大小，因此也就很容易访问到未定义的内存区域，因此在传递数组指针的基础上，我们可以通过手动标志数组大小等方法保证函数访问的内存是合法的不越界的。因此衍生出以下几种方法。</p><ol><li>第一种方法：<strong>在数组的末尾加标记。</strong>这种方法类似于C风格字符串，末尾会自动加’\0’来告诉大家这个字符串结束了。在数组末尾加特殊的标记来使数组不越界是简单易用的方法。</li><li>第二种方法：<strong>使用标准库规范中的begin和end函数。</strong>头文件<code>iterator</code>里有针对数组的begin和end函数，返回数组的首指针和尾后指针，指针指向数组元素的类型，这种方法也可以检测越界。</li><li>第三种方法：<strong>传递一个表示数组大小的参数。</strong>这样构建函数时就知道数组有多大了。如<code>print(j, end(j)-begin(j));</code></li><li>第四种方法：<strong>传递数组的引用。</strong>除了使用指针，我们还可以使用引用来得到一个完整数组的引用（别名）。声明格式类似下面这种：<code>void fx(int (&amp;arr)[10]);</code>，这里形参的名字是<code>arr</code>，<code>arr</code>前面的<code>&amp;</code>符号代表它是引用类型，引用了一个实参数组，这个数组必须只有10个元素（因为arr后面的[10]也是构成引用声明的必要部分。）</li></ol><blockquote><p>注意<code>void fx(int &amp;arr[10]);</code>这个去掉括号的写法是错误的，不存在引用的数组。</p></blockquote><hr><p><strong>传递多维数组</strong>：有时我们也需要向一个函数传递多维数组。多维数组的实质是数组的数组，一维数组的名是指向数组元素的指针，二维数组是指向数组元素的指针的指针。因此想要一个函数传递多维数组的形参声明如下：<code>void fx(int (*arr)[10]);</code>这时arr指向有10个int型元素的数组。当我们把arr+1，它就又指向了新的10个元素，因此arr相当于二维数组的数组名（两者都是指向包含的一维数组首元素的指针）。</p><p>也可以用<code>int arr[][10]</code>代替<code>int (*arr)[10]</code>，因为它们是等价的，都是二维数组名。用<code>int arr[][10]</code>这种方式定义形参时，要标出除了第一个维度以外的每个维度。（假设有一个数组<code>int b[2][3]</code>，就说明b有两列，每列3个元素，这里的2就是第一个维度。指向一维数组的指针不关心在这个维度上有几个元素，因此忽略）。</p><h3 id="main函数的命令行选项（P196，6-2-5）"><a href="#main函数的命令行选项（P196，6-2-5）" class="headerlink" title="main函数的命令行选项（P196，6.2.5）"></a>main函数的命令行选项（P196，6.2.5）</h3><p>最开始我们使用<code>UNIX</code>或<code>LINUX</code>系统编程时经常使用没有图形界面的编译器来把写好的代码编译成obj文件，这时候我们使用命令行来编译一份源代码文件，我们需要在终端里输入类似“<code>prog -d -o oflie data0</code>”的命令行来进行命令行控制。</p><p>现在我们看到的main函数一般都是<code>int main()</code>，括号里面什么也不写，我们也可以给main传递上述的那个命令行参数。形如：<code>int main(int argc,char *argv[])</code>。 main可以什么参数也不接受，也可以接受一个int和一个指向字符串的指针这两个参数。main没有第三种形式了。</p><p><code>int argc</code>是表示后面的argv一共指向几个字符串用的。<code>char *argv[]</code>里面的每一个字符串都顺序对应着命令行的参数。这些参数的字符串数组的第一个元素应该是可执行文件的名字或者空参数，最后一个字符串的值必须为<code>0</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//对于命令”prog -d -o oflie data0“：</span></div><div class="line">argc = <span class="number">5</span>;</div><div class="line">argv[<span class="number">0</span>] = <span class="string">"prog"</span>;</div><div class="line">argv[<span class="number">1</span>] = <span class="string">"-d"</span>;</div><div class="line">argv[<span class="number">2</span>] = <span class="string">"-o"</span>;</div><div class="line">argv[<span class="number">3</span>] = <span class="string">"0file"</span>;</div><div class="line">argv[<span class="number">4</span>] = <span class="string">"data0"</span>;</div><div class="line">argv[<span class="number">5</span>] = <span class="number">0</span>;</div></pre></td></tr></table></figure></p><p>有关命令行的更多选项和argv参数的具体用法，可以参照对应的编译器文档。</p><h3 id="含有可变形参的函数（P197，6-2-6）"><a href="#含有可变形参的函数（P197，6-2-6）" class="headerlink" title="含有可变形参的函数（P197，6.2.6）"></a>含有可变形参的函数（P197，6.2.6）</h3><p>到现在我们定义的函数都是固定参数的，但是有时候我们无法预知向函数传递几个参数，又想使用一个函数接受这种变化，我们就可以使用C++指定的两种方法来定义含有可变形参的函数。</p><ul><li>第一种方法是当参数个数不一定，但是<strong>参数类型都相同</strong>时，我们可以<strong>传递一个initializer_list参数</strong>。这是标准库设施中的一部分。</li><li>第二种方法在当我们想传递不确定个数的<strong>不同类型的实参</strong>时要使用的技术：<strong>可变参数模板。</strong>这个16章才介绍。</li></ul><p>其实还有一种方法使函数接受多种形参，不过这种方法多用于和C语言旧代码对接时使用。<strong>这个方法用省略符来传递可变数量的形参</strong>。</p><blockquote><p>常见的应用场景：日志的打印</p></blockquote><h3 id="initializer-list（P197，6-2-6）"><a href="#initializer-list（P197，6-2-6）" class="headerlink" title="initializer_list（P197，6.2.6）"></a>initializer_list（P197，6.2.6）</h3><p>下面是关于定义可变形参函数的第一种方法——<code>initializer_list</code>参数的介绍：</p><p><code>initializer_list</code>类似<code>vector</code>，是一种容器，接纳一种同样类型的元素。initializer_list定义在同名的<code>&lt;initializer_list &gt;</code>中，我们可以把任意数量，同样类型的参数传递给这个容器使函数能够处理多个元素。</p><p>initializer_list支持的操作包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">initializer_list&lt;容器内元素的类型名&gt; 容器名 //默认初始化一个 initializer_list空容器</div><div class="line">initializer_list&lt;容器内元素的类型名&gt; 容器名&#123;元素值1，元素值2，元素值2...&#125; //大括号初始化</div><div class="line">initializer_list 容器名1（已被定义的initializer_list 容器的容器名2 ）//使容器1的内容和容器二一致，两个容器共享容器二里面的元素。不会形成拷贝，（也可以用initializer_list 容器名1=initializer_list 容器名2）</div><div class="line">initializer_list 容器名.size() //元素数量</div><div class="line">initializer_list 容器名.begin() //指向首元素的迭代器</div><div class="line">initializer_list 容器名.end() //尾后迭代器</div></pre></td></tr></table></figure></p><p>initializer_list里面元素的值永远是常量不能被更改，如果里面的元素是指针或引用，这个元素的属性将被自动加上底层const。<br>当我们声明一个接受 <code>initializer_list</code>类型的函数 <code>void fa(initializer_list&lt;int&gt; list1);</code>的时候，我们需要使用大括号来调用这个函数，形如fa({2,3,4});这样我们就向initializer_list传递了一个值的序列。<br>我们也可以声明<code>void fa(string b,initializer_list&lt;int&gt; list1);</code>这种函数。</p><h3 id="省略符形参（P199，6-2-6）"><a href="#省略符形参（P199，6-2-6）" class="headerlink" title="省略符形参（P199，6.2.6）"></a>省略符形参（P199，6.2.6）</h3><p>下面是关于定义可变形参函数的第三种方法——省略符形参的介绍。</p><p>省略符形参有下列两种形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">( parm_list , ...)</span></span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">( ... )</span></span>;</div></pre></td></tr></table></figure></p><p>第一种形式为特定数目的形参提供了声明。在这种情况下，当函数被调用时，对于与显示声明的形参相对应的实参进行类型检查，而对于与省略符对应的实参则暂停类型检查。在第一种形式中，形参声明后面的逗号是可选的。如果没有逗号，相应地，就变成了第二种情况。</p><blockquote><p>省略符形参应该仅仅用于C和C++通用的类型。<br>特别注意的是，大多数类型的对象在传递给省略符形参时都无法正确拷贝。<br>（感慨：所以说有什么用？还是用<code>intializer_list</code>吧？）</p></blockquote><p>你可以传递任意数量的参数给省略符形参。要注意省略号的优先级别最低，所以在函数解析时，只有当其它所有的函数都无法调用时，编译器才会考虑调用省略号函数的。<br>(optional)首先，如果要用省略符的方式处理不定参数的函数要包含头文件：<code>#include &lt;stdarg.h&gt;</code> （C语言中）或者<code>#include &lt;cstdarg&gt;</code>（C++中）。 然后利用va_list类型和va_start、va_arg、va_end 3个宏读取传递到函数中的参数值。<br>用省略符处理不定参数的函数基于C语言的方法，在C++中不建议使用。（使用了C语言标准库功能varargs）。</p><h2 id="返回值（P202，6-3）"><a href="#返回值（P202，6-3）" class="headerlink" title="返回值（P202，6.3）"></a>返回值（P202，6.3）</h2><p>在void返回值的语句最后会隐式地有<code>return;</code>语句，这时函数什么也不返回。</p><blockquote><p>不要返回局部对象的引用或指针。</p></blockquote><p>函数可以返回一个<strong>非常量引用</strong>作为左值。也可以返回一个花括号括起来的列表，来初始化vector等类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; test()  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">return</span> &#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>main函数的return语句可以不写，编译器会带为隐式补充。</p><blockquote><p>main 函数不能调用自己。</p></blockquote><h3 id="返回数组指针（P205，6-3-3）"><a href="#返回数组指针（P205，6-3-3）" class="headerlink" title="返回数组指针（P205，6.3.3）"></a>返回数组指针（P205，6.3.3）</h3><p>虽然我们不能直接让函数返回一个数组，但是我们可以设定函数返回一个指针的类型。函数会返回数组的指针。返回数组指针的函数定义语句如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">数组元素类型 （*函数名 （参数列表））[ 数组大小 ]</div></pre></td></tr></table></figure></p><p>当然，返回一个临时量或者局部对象的引用/指针都是错误的行为，如果你在函数里普通地定义了一个数组，那么这个数组的生命周期在函数返回时就结束了，会被内存中释放，因此可能需要用static使这个数组静态。静态对象只是延长了对象的生命周期，但是无论如何在函数内部定义的对象在外部都无法访问，除非使用返回指针的方法。</p><p>一条<code>double (*func(int a))[10]</code>这种语句来说明函数接受一个<code>int a</code>形参并且返回一个带有10个元素的double数组，这种语句在写法上比较乱，因此<code>C++11</code>提供了<strong><font color="00A00A">尾置返回</font></strong>的方法让程序员不必要非要迁就编译器的理解能力，上一条语句等价于这样：<code>auto func(int a)-&gt;double(*)[10]</code>我们使用<code>-&gt;</code>符号把返回值类型的描述放在了参数列表后面并和函数声明分离开让函数看起来不那么乱。</p><p>我们也可以使用<code>decltype</code>语句返回数组指针。<code>decltype</code>后面的括号可以括起一个现有的数组推导数组类型。我们再手动加<code>*</code>得到数组指针类型的返回值。在已有<code>int a[10];</code>的情况下，我们可以使用<code>decltype(a) *fn(int b)</code>这种形式定义一个返回指向数组的指针的返回值类型。</p><h2 id="函数重载（P207，6-4）"><a href="#函数重载（P207，6-4）" class="headerlink" title="函数重载（P207，6.4）"></a>函数重载（P207，6.4）</h2><p>我们可以定义一组功能类似，函数名一致，但是接受的参数类型或数量不同的函数。定义多个这种函数就叫做<strong>函数重载</strong>。函数重载可以提供给我们用一个函数名处理多种参数形式的情况。</p><p>定义重载函数要能重传入的参数里区别出实质不同的重载函数，如函数A的定义为<code>int fa(const int a);</code>和函数<code>B int fa(int b);</code>这两个函数函数名一样，形参类型不同，但仍然无法作为重载函数。因为我们传入一个int值时，fa不知道应该执行第一种还是第二种。所以<strong>只有参数顶层const属性不同的几个函数不是重载函数。</strong></p><blockquote><p>形参相同，但返回类型不同的函数也不能构成重载。</p></blockquote><p>当然，对于底层const，比如参数列表为<code>const int *a</code>的函数和参数列表为int a的函数能被看出不同，因为对于一个传入的const常量指针，这个实参只能初始化<code>const int *a</code>，不能被初始化<code>int a</code>。当同时有这两种形式的重载函数时，当传入一个非常量，IDE会优先选择为它匹配形参为<code>int a</code>版本的普通变量形参函数。</p><blockquote><p>形参是某种类型的引用或指针，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载。（此时的const是底层的）</p></blockquote><h3 id="const-cast和函数（P209，6-4）"><a href="#const-cast和函数（P209，6-4）" class="headerlink" title="const_cast和函数（P209，6.4）"></a>const_cast和函数（P209，6.4）</h3><p>这里主要介绍<code>const_cast</code>类型强制转换是如何在函数中被使用的。在第四章(4.11.3, P145)第一次接触<code>const_cast</code>的时候我们提到过这个常被用于函数里。这里我们就看看怎么使用。</p><p>之前说过，向函数传递参数时最好传递<code>const</code>型参数使其能够接受多种参数，这里我们可以在函数体内使用<code>const</code>再把参数变回普通的变量，这样就可以返回一个<code>非const</code>值了。</p><h3 id="重载和作用域（P210，6-4）"><a href="#重载和作用域（P210，6-4）" class="headerlink" title="重载和作用域（P210，6.4）"></a>重载和作用域（P210，6.4）</h3><p>声明变量时，变量的作用域就在块里，声明函数也一样，而且里层的作用域会隐藏外部的作用域。例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">int a=0; //这里是a的外层作用域</div><div class="line">    &#123;</div><div class="line">    double a=1.2; //外边已经有a了，这里又声明了一个a，因此这个a的作用域覆盖了前面的int a；</div><div class="line">    cout&lt;&lt;a&lt;&lt;endl; //输出的会是1.2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>函数声明也一样，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    int fa(int b); //这里是函数fa的外层作用域</div><div class="line">    double fa(double b); //重载了函数fa使它能够接受double</div><div class="line">    &#123;</div><div class="line">        double fa(string &amp; c); //外边已经有fa了，这里又声明了一个fa，因此这个fa的作用域覆盖了前面的;</div><div class="line">        fa(2.3); //错误，原型为double fa(double b)的函数声明作用域被double fa(string &amp; c);覆盖，匹配不到函数</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>C++中，名字查找发生在类型检查之前。</p></blockquote><h2 id="特殊用途语言特性（6-5）"><a href="#特殊用途语言特性（6-5）" class="headerlink" title="特殊用途语言特性（6.5）"></a>特殊用途语言特性（6.5）</h2><h3 id="默认实参（P211，6-5-1）"><a href="#默认实参（P211，6-5-1）" class="headerlink" title="默认实参（P211，6.5.1）"></a>默认实参（P211，6.5.1）</h3><p>有时候一些函数我们每次调用它总会向它传递一些特殊的值。我们可以声明带有默认实参的函数。默认实参如果没有明确说明，默认实参会被自动当做函数的初始值传递进去。<br>形如<code>int fn(int a,int b=2,double c=3.3)</code>这样定义函数头的方式就给了b和c默认的实参，注意，<strong>当一个形参被给了默认实参，它后面的所有参数都要有默认实参才行。</strong></p><p>当我们想使用默认实参的时候，只要调用函数的时候使用这种对应的实参就行了，默认实参会用来填补缺少的尾部实参，上面的定义的函数如果这么调用：<code>fn(1,2);</code>，<code>double c</code>的值会被自动设为3.3。书写这种函数时要尽量保证要经常用到的默认实参放在参数列表的更后面一点，这样才合理。</p><p>可以只在函数声明里标注默认实参不在函数定义里这样写，结果仍然将是正确的。<code>void fn(int = 1, int = 2, int =3);</code>这种函数声明语句省略了形参的名字，不过也是可以的。</p><blockquote><p>通常应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p></blockquote><p>局部变量不能做默认实参，默认实参的定义在函数体之外。另外，<strong>默认实参是可以在名字的作用域内通过名字更改的</strong>。</p><h3 id="内联函数（P213，6-5-2）"><a href="#内联函数（P213，6-5-2）" class="headerlink" title="内联函数（P213，6.5.2）"></a>内联函数（P213，6.5.2）</h3><p>有时我们要频繁调用一个优化规模小，流程直接，频繁被调用的函数，定义函数时我们可以在返回值类型前面加上关键字<code>inline</code>使它成为内联函数，减少运行时的开销。</p><blockquote><p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p></blockquote><h3 id="constexpr函数（P214，6-5-2）"><a href="#constexpr函数（P214，6-5-2）" class="headerlink" title="constexpr函数（P214，6.5.2）"></a>constexpr函数（P214，6.5.2）</h3><p>这是一种能够被用在常量表达式的函数，但是函数的返回值类型和形参类型必须都是字面值。<strong>函数体中必须有且只有一条<code>return</code>语句，<code>constexpr</code>函数被隐式的指定为内联函数。</strong>const函数中也可以有类型别名，使用作用域声明等不执行操作的其他语句。这里没有赋值，没有构建对象。同时<code>constexpr</code>可以返回计算后的结果。如<code>constexpr int fn(int a){return a+22;}</code>，这条定义是正确的，前提是调用函数这个函数fn时，传入的实参是一个常量。比如<code>fn(3);</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">constexpr</span> size_t <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> </span>&#123; <span class="keyword">return</span> new_sz() * cnt; &#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)]; <span class="comment">//正确，scale(2)是常量表达式</span></div><div class="line"><span class="keyword">int</span> i=<span class="number">2</span>;</div><div class="line"><span class="keyword">int</span> a2[scale(i)]; <span class="comment">//错误，scale(i)不是常量表达式</span></div></pre></td></tr></table></figure></p><blockquote><p>内联函数和constexpr函数通常定义在头文件中。</p></blockquote><h3 id="调试帮助（P215，6-5-3）"><a href="#调试帮助（P215，6-5-3）" class="headerlink" title="调试帮助（P215，6.5.3）"></a>调试帮助（P215，6.5.3）</h3><p>程序员在写程序时可能涉及到一些调试中的代码，这些代码只在开发程序时使用，当即将发布程序的时候，要暂时屏蔽掉正在调试中的代码。C++提供了<code>assert</code>和<code>NDEBUG</code>两个预处理功能屏蔽测试代码。</p><h4 id="assert预处理宏"><a href="#assert预处理宏" class="headerlink" title="assert预处理宏"></a>assert预处理宏</h4><p>assert这个宏定义在<code>cassert</code>头文件中，assert使用一个表达式作为它的条件，形如<code>assert(expr);</code>首先对expr或者表达式求值，如果结果为真（非0），那么assert什么都不做。如果结果为假(表达式值为0)，那么assert输出信息并且终止程序的执行。</p><p>assert经常用于处理不能发生的条件，如果你写了一段代码，代码没测试越界，你就可以用assert，当它越界了我们就结束程序的执行。</p><h4 id="NDEBUG预处理变量"><a href="#NDEBUG预处理变量" class="headerlink" title="NDEBUG预处理变量"></a>NDEBUG预处理变量</h4><p><code>NDEBUG</code>宏定义可以影响assert的行为，这个默认是没被定义的。当我们宏定义了<code>NDEBUG</code>，就屏蔽掉了assert的功能。</p><p>可以使用<code>NDEBUG</code>编写自己的调试代码。</p><p>此外，IDE还提供了<code>__FILE__</code>(这里是两个英文下划线，这个存放文件名) 、<code>__func__</code>（这个存放所在的函数名) 、 <code>__LINE__</code>（这个存放所在的行数) 、<code>__TIME__</code>（这个存放调试的时间) 、 <code>__DATE__</code>（这个存放调试的日期) 这五种静态数组来提供错误信息。</p><h2 id="函数匹配（P217，6-6）"><a href="#函数匹配（P217，6-6）" class="headerlink" title="函数匹配（P217，6.6）"></a>函数匹配（P217，6.6）</h2><p>程序员定义重载函数之后就可以使用它们了，挑选到底使用哪个版本的函数是一个过程，这个过程叫做函数匹配。</p><ol><li>函数匹配的第一步是在调用时先找与与调用函数同名的函数名。且调用点在函数作用域内。这一步筛选出的函数叫做<strong>候选函数</strong>。</li><li>函数匹配的第二步是从候选函数中选择出能够被本次函数调用的实参传入的函数，函数名一致的前提下还要求函数的形参个数和实参一致，实参能够转化成（或者就是）形参规定的类型。这一步筛选出的函数叫做<strong>可行函数</strong>。</li><li><strong>寻找最佳匹配。</strong>当<code>有int fn(int a);</code>和<code>int fn(double a,double b=1.0)</code>时，我们调用函数fn形如<code>fn(3.4);</code>显然这两种函数都是可行函数，这是我们再寻找最佳的匹配，因为<code>fn(3.4);</code>对应<code>fn(double,double=1.0);</code>的话无需转化，因此是最佳匹配。当有多个最佳匹配的时候函数将停止调用。</li></ol><p>为了划分最佳匹配的各种情况，编译器将实参类型到形参类型的转换划分为几个等级，具体排序如下所示：</p><ol><li>精确匹配：<br>精确匹配可以包含以下情况：数组名转化成数组指针的匹配，函数类型转换成函数指针的匹配，实参类型与形参类型相同。另外，像实参添加顶层const或者忽略实参赋值给形参的顶层const也属于精确匹配。</li><li>通过指针的转换把非常量指针转换成常量指针。</li><li>通过类型提升实现的匹配。</li><li>通过算数类型转换或指针转换实现的匹配</li><li>通过类类型转换实现匹配（类类型转换还没有讲）</li></ol><p>要注意小整数字面值会被自动转换成int，而带小数点的字面值会被默认转换成doube。</p><h2 id="函数指针（P221，6-7）"><a href="#函数指针（P221，6-7）" class="headerlink" title="函数指针（P221，6.7）"></a>函数指针（P221，6.7）</h2><p>声明一条函数指针的语句如下: <code>int (*PtrOfFunc)(参数列表)</code>，其中<code>PtrOfFunc</code>就是<strong><font color="00A00A">指向函数的指针</font></strong>。我们可以把函数名赋值给定义的函数指针的名字。</p><blockquote><p><code>*PtrOfFunc</code>两端 的括号不能少。</p></blockquote><p>返回函数指针的形参定义为<code>double(*fn(int a)) (int d,char b);</code>这里声明的函数是fn，函数的形参是<code>int a</code>，返回值是函数指针类型的，返回的函数指针对应的函数的返回类型是double，参数是int d,char b。</p><p>和处理数组一样，我们也可以<strong>使用尾置</strong>返回来返回一个函数指针，尾置返回函数指针的声明是<code>auto fn(int a)-&gt;double (*)(int d,char b);</code>尾置返回适合用来返回复杂的类型比如数组，函数指针等等。</p><p>遇到<code>double(*fn(int a)) (int d,char b);</code>这种复杂的表达式，应该以定义的变量名为中心，从里往外一层层往外扩展。这个函数的定义语句里面，fn就是其中的变量名，看它右侧，有<code>（int a）</code>,这（<code>int a）</code>是一个形参列表。因此得出结论fn的本质是一个函数，再看左侧，<code>*</code>代表这个函数返回一个指针，这个指针的类型在更外层<code>（double (*) (int d,char b)）</code>型。</p><p>当然这种声明/定义容易让人心累，所以这种情况下使用<code>auto fn(int a)-&gt;double (*)(int d,char b)</code>是不错的选择。如果这样还是觉得太长了，可以使用typdef，USING等重命名语句加上decltype推导。比如<code>tpyedef double func (int d,char b);</code>这样的语句之后，func就是一个函数类型。</p><p>也可以使用<code>tpyedef decltype(fn) func2;</code>这条语句等价于上面的语句。<br>对于using语句，<code>using Func2 = double (int d,char b);</code>即可。<br>可见typedef和using的替换原则是不同的，在涉及到复杂类型的时候，类似数组，函数指针，tpyedef的替换名要和被替换的类型一起被声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>); <span class="comment">//F是函数类型，不是指针</span></div><div class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span> (*) (<span class="keyword">int</span> *, <span class="keyword">int</span>); <span class="comment">// PF是指针类型</span></div><div class="line"></div><div class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//正确，PF是指向函数的指针，f1返回指向函数的指针。</span></div><div class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//错误，F是函数类型，f1不能返回一个函数</span></div><div class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">//正确，显式地指定返回类型是指向函数的指针。</span></div><div class="line"></div><div class="line"><span class="comment">// 当然也可以使用下面的形式直接声明f1</span></div><div class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span> *, <span class="keyword">int</span>);</div></pre></td></tr></table></figure><h2 id="术语表-P225"><a href="#术语表-P225" class="headerlink" title="术语表(P225)"></a>术语表(P225)</h2><p>1.函数 function<br>2.形参 parameter<br>3.调用运算符（一个动作） call operator<br>4.实参 argument<br>5.主调函数 calling function<br>6.被调函数 called function<br>7.生命周期 lifetime<br>8.局部变量 local variable<br>9.自动对象 automatic object<br>10.局部静态对象 local static object<br>11.函数原型 function prototype<br>12.分离式编译 separate compilation<br>13.可执行文件 executable file<br>14.引用传递 passed by reference<br>15.传引用调用 called by reference<br>16.值传递 passed by value<br>17.传值调用 called by value<br>18.重载 overloaded<br>19.函数匹配 function matching<br>20.重载确定 overloaded resolution<br>21.最佳匹配 best match<br>22.二义性调用 ambiguous call<br>23.默认实参 default argument<br>24.预处理宏 preprocessor marco<br>25.候选函数 candidate function<br>26.可行函数 viable function<br>27.递归循环 recursion loop<br>28.递归函数 recursive function<br>29.尾置返回类型 trailing return type</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>C++ Primer 中文版 第5版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49760521" target="_blank" rel="external">C++primer第五版第六章学习笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/23536587" target="_blank" rel="external">C++Primer第5版学习笔记（六）</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/06/CPP_06/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(四/五)表达式和语句</title>
      <link>http://wangwlj.com/2018/01/05/CPP_04_05/</link>
      <guid>http://wangwlj.com/2018/01/05/CPP_04_05/</guid>
      <pubDate>Fri, 05 Jan 2018 07:51:49 GMT</pubDate>
      <description>
      
        &lt;p&gt;第四章是和表达式有关的知识，表达式是C++的基础设施，本章由三部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表达式概念基础，包括表达式的基本概念，左值和右值的概念，优先级结合律，求值顺序。&lt;/li&gt;
&lt;li&gt;各种运算符,主要包括算数\关系\逻辑\赋值\递增递减\成员访问\条件\位运算\sizeof\逗号运算符 这10种运算符。&lt;/li&gt;
&lt;li&gt;类型转换，包括隐式和显式两种转换的规则。&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>第四章是和表达式有关的知识，表达式是C++的基础设施，本章由三部分组成：</p><ol><li>表达式概念基础，包括表达式的基本概念，左值和右值的概念，优先级结合律，求值顺序。</li><li>各种运算符,主要包括算数\关系\逻辑\赋值\递增递减\成员访问\条件\位运算\sizeof\逗号运算符 这10种运算符。</li><li>类型转换，包括隐式和显式两种转换的规则。</li></ol><a id="more"></a><h2 id="表达式基础"><a href="#表达式基础" class="headerlink" title="表达式基础"></a>表达式基础</h2><h3 id="表达式的基本概念-P120，4-1-1"><a href="#表达式的基本概念-P120，4-1-1" class="headerlink" title="表达式的基本概念(P120，4.1.1)"></a>表达式的基本概念(P120，4.1.1)</h3><p>表达式由一个或者多个运算对象组成，多个对象组成表达式时，对象之间用运算符连接形成复杂表达式。</p><p>运算符中，需要两个对象和运算符连接形成表达式的这种运算符叫做二元（双目，二目）运算符。</p><p>分析一个表达式，必须先了解运算对象的含义、运算符的优先级(precedence)、结合律(associativity)和运算符的求值顺序(order of evaluation)。</p><ol><li>对于含有子表达式的复杂表达式，应该按照求值顺序，看看应该先求哪一个子表达式的值。</li><li>对于不那么复杂的子表达式，应该按照优先级，查看表达式中的每个操作数（对象）应该先跟那一个运算符在一起运算。</li><li>如果有优先级相同的运算符同时在同一个运算对象左右，应该按照结合律选定结合顺序是从右向左还是从左向右计算表达式的值。</li></ol><h3 id="左值和右值-P121，4-1-1"><a href="#左值和右值-P121，4-1-1" class="headerlink" title="左值和右值(P121，4.1.1)"></a>左值和右值(P121，4.1.1)</h3><p><strong>起源</strong>：左值和右值原来是C语言中的概念，特指赋值运算符左右两段的表达式。C语言中，能放在赋值运算符左侧被赋值的对象就是左值，反过来在赋值运算符右侧的对象就是右值。C++中的这两个概念的词义发生了改变。</p><p><strong>概述</strong>：可以暂时概述一下C++中左值和右值的概念。从性质上来看，当一个对象做右值时，我们使用的是这个对象的内容（值）；当一个对象做左值时，我们使用的是它对象的身份（在内存中的位置）。</p><p><strong>应用</strong>：表达式中有的位置需要的是左值，有的位置需要的是右值。表达式的值本身也有左右的分别。<br><strong>赋值运算符</strong>中左侧操作数和表达式结果都是左值。<br><strong>取地址符</strong>的操作对象是左值，得到的是右值。<br><strong>解引用、下标运算符</strong>的求值结果是左值。<br><strong>decltype</strong>作用于表达式时，如果表达式的结果是一个左值，decltype会返回一个引用类型。</p><h3 id="优先级和结合律（P122，4-1-2）"><a href="#优先级和结合律（P122，4-1-2）" class="headerlink" title="优先级和结合律（P122，4.1.2）"></a>优先级和结合律（P122，4.1.2）</h3><p>1.<font color="AA0AA0">优先级</font> 复杂表达式中一个运算对象连接多个不同运算符时，哪个运算符优先级高，就先计算哪个运算符和对象作用后的值。</p><p>2.<font color="AA0AA0">结合律</font> 复杂表达式中一个运算对象连接多个优先级相同的运算符时，根据这一优先级对应的结合律，按从右至左或者从左至右的顺序计算表达式的值。</p><p>如<code>3+2*4-7；</code>这个表达式是一个复杂表达式，因为表达式里<code>*</code>号优先级比较高，所以先计算<code>2*4</code>，得到<code>3+8-7</code>；得到的新表达式更简洁了，只剩下+-两个符号，这两个符号优先级相同，因此查看这个优先级对应的结合律可知这一级别的符号满足左结合性。因此从左向右计算，得到<code>11-7</code>；进一步得到结果<code>4</code>。</p><blockquote><p>括号无视优先级和结合律，可以考虑多使用括号。</p></blockquote><h3 id="求值顺序（P123，4-1-3）"><a href="#求值顺序（P123，4-1-3）" class="headerlink" title="求值顺序（P123，4.1.3）"></a>求值顺序（P123，4.1.3）</h3><p>一个表达式里如果运算对象都是函数返回的，都需要计算求值才知道对象的状态，函数调用符号优先级一致，中间隔着几个优先级低的其他符号连接操作对象，比如<code>int a=f()+g();</code>，这时候是函数f()先被调用还是g()先被调用呢？<font color="AA0AA0">答案是未定义。</font>C++语法没有规定这种情况应该谁先谁后。</p><p>就像下面的表达式<code>++i+i++</code>这个表达式中，优先级最高的表达式<code>++i</code>和<code>i++</code>中间隔着优先级低的运算符<code>+</code>，关于<code>++i</code>先计算还是<code>i++</code>先计算，这是<strong>未定义</strong>的，而因为这个表达式先计算<code>++i</code>或先计算<code>i++</code>的结果不同，<strong>所以这条表达式是错误的</strong>。<font color="AA0AA0">一个变量如果在同一个表达式里被多次改变，这个表达式的求值顺序又不一定，就会出现二义性。应该避免这样的写法。</font></p><p>目前只有四种运算符明确规定了求值顺序。</p><ol><li>逻辑运算符<code>&amp;&amp;</code>和<code>||</code>(P126)：这两个运算符先计算左边操作数的值。</li><li>条件运算符<code>?:</code>(P137)：条件运算符先计算？前的表达式，并求值，之后对视情况对：左右侧的表达式求值。</li><li>逗号运算符<code>，</code>(P140) ：这个运算符的求值顺序是从左至右。</li></ol><blockquote><p>处理复合表达式的两点建议：<br>①拿不准的时候最好用括号来强制让表达式的组合关系复合程序逻辑的要求；<br>②如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。例外：当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。</p></blockquote><h3 id="关于运算符，左值和右值的归纳"><a href="#关于运算符，左值和右值的归纳" class="headerlink" title="关于运算符，左值和右值的归纳"></a>关于运算符，左值和右值的归纳</h3><p>本章各种运算符形成的表达式所返回的值的属性和运算符需要的操作数的属性如下：</p><ul><li>算数/逻辑/位运算符： 操作对象和结果都是右值 </li><li>赋值运算符：左侧的操作对象必须是可以修改的左值，右侧的操作对象是右值，返回一个左值。 </li><li>递增/递减运算符： 前置版本的++/–返回左值，后置版本的++/–返回右值。操作对象都必须是左值。</li><li>箭头成员访问运算符： 作用于指针，表达式结果是一个左值。</li><li>点成员访问运算符: 这个成员所属的对象是左值，结果就是左值；这个成员所属的对象是右值，结果就是右值。 </li><li>条件运算符： 条件运算符的三个表达式都是左值或者都能转化成左值类型时，结果为左值；否则是右值。</li></ul><h2 id="算术运算符-P124-4-2"><a href="#算术运算符-P124-4-2" class="headerlink" title="算术运算符(P124, 4.2)"></a>算术运算符(P124, 4.2)</h2><h3 id="除法和取模的结果-（P125，4-2）"><a href="#除法和取模的结果-（P125，4-2）" class="headerlink" title="除法和取模的结果 （P125，4.2）"></a>除法和取模的结果 （P125，4.2）</h3><p>两个非浮点型变量/字面值相除，结果还是原来的类型，不会有原来操作数是整数，运算之后结果是小数的情况。<br>C++11中， 对于<strong>除运算符，结果向零取整（直接切掉小数部分，得到的数就是结果）</strong>。对于<strong>取模运算符，结果的符号和被除数的符号一致</strong>。（之前的语法标准里除法的结果可以选择是否向零取整，求模（模就是余数）运算可选符号）</p><blockquote><p>(-m)/n = -(m/n); m/(-n) = -(m/n);<br>m%(-n) = m%n; (-m)%n = -(m%n);</p></blockquote><h2 id="成员访问运算符-P133-4-6"><a href="#成员访问运算符-P133-4-6" class="headerlink" title="成员访问运算符(P133, 4.6)"></a>成员访问运算符(P133, 4.6)</h2><p>点运算符和箭头运算符都可以获取类对象的一个成员，<code>ptr-&gt;mem</code> 等价于 <code>(*ptr).mem</code>。</p><p>解引用运算符的优先级低于点运算符，所以<code>(*ptr).mem</code>中的括号不能省略，否则出错。</p><h2 id="条件运算符-P134-4-7"><a href="#条件运算符-P134-4-7" class="headerlink" title="条件运算符(P134, 4.7)"></a>条件运算符(P134, 4.7)</h2><p>条件运算符的格式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cond?expr1:expr2</div></pre></td></tr></table></figure></p><p>条件运算符允许嵌套。</p><h2 id="位运算符（P136，4-8）"><a href="#位运算符（P136，4-8）" class="headerlink" title="位运算符（P136，4.8）"></a>位运算符（P136，4.8）</h2><p><code>bitset</code>的标准库类型可以表示任意大小的二进制位集合。</p><blockquote><p>关于符号位没有明确的规定，因此强烈建议仅将位运算符用于处理无符号类型。</p></blockquote><p>左移运算符移动二进制数后会在右侧插入零，右移运算符在处理有符号类型的操作数（尤其是带负号的）时具体行为由环境决定。</p><table><thead><tr><th style="text-align:center">运算符</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">～</td><td>位求反</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td>左移</td></tr><tr><td style="text-align:center">&gt;&gt;</td><td>右移</td></tr><tr><td style="text-align:center">&amp;</td><td>位与</td></tr><tr><td style="text-align:center">^</td><td>位异或</td></tr><tr><td style="text-align:center">&#124;</td><td>位或</td></tr></tbody></table><blockquote><p>【写博客相关】表格中竖号的打法：<code>&amp;#124;</code>，或者中文格式的<code>丨</code>（输入法输入“shu”查找）</p></blockquote><p>移位运算符（也叫IO运算符）满足左结合律。</p><h2 id="sizeof运算符（P139，4-9）"><a href="#sizeof运算符（P139，4-9）" class="headerlink" title="sizeof运算符（P139，4.9）"></a>sizeof运算符（P139，4.9）</h2><p>sizeof运算符有两种用法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">sizeof</span>(type)</div><div class="line"><span class="keyword">sizeof</span> expr</div></pre></td></tr></table></figure></p><p>第一种是sizeof后面直接加一条表达式语句；第二种形如<code>sizeof (类型名)；</code>第二种形式后会得到该类对象所占空间的大小。<br>第一种形式中，如果表达式是指针类型，sizeof运算符会返回指针本身的大小。当有一个类名叫data，类中有一个成员叫做student时，可以使用作用域标识符和sizeof联动，使用<code>sizeof(data::student);</code>就可以计算出student占字节数。</p><h3 id="隐式类型转换（P141，4-11）"><a href="#隐式类型转换（P141，4-11）" class="headerlink" title="隐式类型转换（P141，4.11）"></a>隐式类型转换（P141，4.11）</h3><p>概述：在C++中，一些类型可以按照一定规则互相转换，很多时候语境中需要使用两个或多个相同的类型才能继续运算。因此这时一种类型的值会被自动转换成另一个类型的值。这个过程就是隐式转换，其中算术隐式转换较为常见。</p><p>主要的隐式转换发生的情况：</p><ol><li>大多数表达式中，比int小的类型会被提升为int型。</li><li>在条件中，非布尔值要转化成布尔值。</li><li>在初始化和赋值语句中，赋值符号的右侧对象的类型转换成左侧对象的类型进行运算。</li><li>算术/关系运算中对象有有多种类型的，转化成同一类型。</li><li>形参转化为实参的类型（第六章）。</li><li>数组名会被转换为指针。</li><li>0，nullptr会转为任何类型的指针。任何类型的指针都可以转化为（const）void *类型。</li></ol><p>算数转换时发生隐式转换的补充：<br>在算术运算符的作用下，不同的操作数要转换成同一个类型才能够进行计算。以<code>i+a；</code>这个表达式举例，了解算术转换的方式。</p><ol><li>首先，当i和a的类型占字节比int小，如<code>char、short</code>，把他们转换为int型。如果他们原来类型的最大值在当前系统里大于int型最大值，则转化成<code>unsigned int</code>型。</li><li>之后，如果i和a的类型相同，结束算数隐式转换，若i和a的类型不同，把占字节少的类型的对象转成占字节多的类型的对象。</li><li>如果占字节多的带符号类型的最大值小于占字节少的带转换对象的最大值，带符号类型将被转换为无符号类型。</li></ol><h3 id="显式转换（P144，4-11-3）"><a href="#显式转换（P144，4-11-3）" class="headerlink" title="显式转换（P144，4.11.3）"></a>显式转换（P144，4.11.3）</h3><p>显式转换就是强制类型转换(cast)。</p><p>一个命名的强制类型转换具有以下形式：<code>cast-name&lt;要转换成的类型&gt; （被转换的值）；</code>其中，cast-name是四种强制类型转换：<code>static_cast、dynamic_cast、const_cast</code>和<code>reinterpret_cast</code>之中的一种。</p><ul><li><code>static_cast</code>用于常见的强制类型转换。只要两个类型有关联，比如浮点数类型和整数类型，整数类型和布尔值类型，布尔值类型和指针类型，就可以使用static_cast。只是不能转换常量const到变量。</li><li><code>const_cast</code>用于去掉（或者加上）对象的底层const，要转换的类型和转换的类型都必须是指针或者引用类型。常用于将在第六章介绍的函数重载。当然，这个重载只能针对指针或者引用类型。</li><li><code>reinterpret_cast</code>依赖机器，是强行改变一个类型到另外一个不相干的类型。</li><li><code>dynamic_cast</code>支持运行时类型识别，在19章(P730)将会提到。</li></ul><blockquote><p>建议：避免强制类型转换。</p></blockquote><h2 id="运算符优先级列表的规律（P147-4-12）"><a href="#运算符优先级列表的规律（P147-4-12）" class="headerlink" title="运算符优先级列表的规律（P147,4.12）"></a>运算符优先级列表的规律（P147,4.12）</h2><p>优先级和结合性是第四章的重要内容，因此第四章之后给出了完整的优先级和结合性的参考表。这里是有一定的规律的。</p><ol><li>首先优先级最高的运算符都有这样的属性：单独拿出这个运算符左面的操作数和右面的操作数都没有意义。即运算符本身是连接两个名字组合一个概念的连接器。比如优先级最高的运算符::（作用域运算符），优先级比较高的点运算符（成员选择）下标运算符[]。</li><li>比连接不同名字形成概念的这种运算符稍微低一级别的就是计算对象本身的运算符，比如++，–，类型转换，位求反，逻辑非，解引用，取地址，求类型占的字节数这些运算符大多都是单目元素符，他们的运算目的一般是根据操作数本身的属性进行计算或者改变操作数本身。</li><li>算术运算符。</li><li>逻辑运算符。</li><li>条件运算符。</li><li>赋值运算符 。</li><li>复合赋值，抛出异常，逗号运算符等。</li></ol><h2 id="术语表-P149"><a href="#术语表-P149" class="headerlink" title="术语表(P149)"></a>术语表(P149)</h2><p>1.运算对象 operand<br>2.结果 result<br>3.一元运算符 unary operator<br>4.二元运算符 binary operator<br>5.优先级 precedence<br>6.结合律 associativity<br>7.求值顺序 order of evaluation<br>8.提升 promoted<br>9.重载运算符 overloaded operator<br>10.右值 rvalue<br>11.左值 lvalue<br>12.复合表达式 compound expression<br>13.短路求值 short-circuit evaluation<br>14.高位 high order position<br>15.逗号运算符 comma operator<br>16.相互转换 conversion<br>17.隐式转换 implicit conversion<br>18.算术转换 arithmetic conversion<br>19.整型提升 intergral promotion<br>20.运算对象 operand</p><h2 id="语句简介"><a href="#语句简介" class="headerlink" title="语句简介"></a>语句简介</h2><p>第五章是和语句有关的知识，语句也是C++的重要组分，本章由三部分组成：</p><ol><li>语句的概念，包括简单语句和语句作用域的概念。</li><li>条件/循环/跳转语句,条件语句主要包括if/else语句、switc语句和？：表达式条件语句；循环语句则是for语句和while语句；跳转语句包括continue、break和goto语句。</li><li>try/throw和异常处理，包括异常处理的使用方法。</li></ol><h2 id="语句作用域（P155，5-2）"><a href="#语句作用域（P155，5-2）" class="headerlink" title="语句作用域（P155，5.2）"></a>语句作用域（P155，5.2）</h2><p>用花括号括起来的块就是作用域的标志。在作用域中定义的对象只在作用域中起作用。块之外是没法访问和控制块内部的变量的。</p><p>尤其是在switch语句中，switch的执行过程可能跨过一些标签，当标签里声明并定义了一个对象，这个对象的作用域就延伸到了所有case标签里，如果case 1定义了int a；switch执行了case2，这时这个我们不想执行的语句却产生了自己的作用域，这显然是不行的。因此可以在case标签后使用大括号形成块，这样就不会出现作用域的问题。</p><p>goto也一样不能向前（代码的后几行）跳过对象的定义。不允许跨过变量的定义到达变量的作用域内。但是goto语句可以向后（代码的前几行）跳过定义。</p><blockquote><p>不要在程序中使用goto语句，它会使得程序既难理解又难修改。</p></blockquote><h2 id="try语句块和异常处理（P172，5-6）"><a href="#try语句块和异常处理（P172，5-6）" class="headerlink" title="try语句块和异常处理（P172，5.6）"></a>try语句块和异常处理（P172，5.6）</h2><p>可以用try\throw和catch联动进行异常处理，形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span></div><div class="line">&#123;待检测块&#125; <span class="comment">//待检测块里面包括throw语句来抛出异常</span></div><div class="line"><span class="keyword">catch</span> (异常类型 异常对象的对象名)</div><div class="line">&#123;异常处理语句 &#125;</div><div class="line"><span class="keyword">catch</span> （同上，可以写很多<span class="keyword">catch</span>）</div><div class="line">&#123;另一组异常处理语句&#125;</div></pre></td></tr></table></figure></p><p>throw抛出异常和catch处理异常的头文件都在<code>stdexcept</code>里定义。抛出异常的语句形如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> 异常类型（<span class="string">"异常文本"</span>）；</div></pre></td></tr></table></figure></p><p>异常类型一般只支持赋值，初始化，调用成员函数.what之类的几种操作。</p><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>1.控制流 flow-of-control<br>2.表达式语句 expression statement<br>3.空语句 null statement<br>4.复合语句 compound statement<br>5.悬垂else dangling else<br>6.case标签 case label<br>7.引发（异常） raise<br>8.catch子句 catch clause<br>9.异常处理代码 exception handler<br>10.异常安全（这不是特别安全的意思，而是在异常情况下也能保证程序执行预期的正确行为） exception safe</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>C++ Primer 中文版 第5版</li><li><a href="https://zhuanlan.zhihu.com/p/23535827" target="_blank" rel="external">C++Primer第5版学习笔记（四、五）</a></li><li><a href="https://www.zhihu.com/question/37542455" target="_blank" rel="external">用Markdown写Hexo博客时如何转义竖杠 | ？</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/05/CPP_04_05/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
