<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wangwlj&#39;s Blog</title>
    <link>http://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Tue, 16 Jan 2018 14:24:10 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>C++ Primer学习笔记：(七)类</title>
      <link>http://wangwlj.com/2018/01/16/CPP_07/</link>
      <guid>http://wangwlj.com/2018/01/16/CPP_07/</guid>
      <pubDate>Tue, 16 Jan 2018 14:21:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;类是数据的抽象(&lt;code&gt;data abstraction&lt;/code&gt;)和封装(&lt;code&gt;encapsulation&lt;/code&gt;)。数据抽象是一种将接口(&lt;code&gt;interface&lt;/code&gt;)和实现(&lt;code&gt;implemention&lt;/code&gt;)分离的设计技术。接口是指用户可以对类使用的操作集。实现包括类的数据成员和接口函数体。封装使得类的使用者不必关注类内部是如何实现的，因为这些是类的设计者需要关注的。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>类是数据的抽象(<code>data abstraction</code>)和封装(<code>encapsulation</code>)。数据抽象是一种将接口(<code>interface</code>)和实现(<code>implemention</code>)分离的设计技术。接口是指用户可以对类使用的操作集。实现包括类的数据成员和接口函数体。封装使得类的使用者不必关注类内部是如何实现的，因为这些是类的设计者需要关注的。<br><a id="more"></a></p><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="类的定义和声明"><a href="#类的定义和声明" class="headerlink" title="类的定义和声明"></a>类的定义和声明</h3><p>类由类成员组成。类成员包括属性，字段，成员函数，构造函数，析构函数等组成。</p><p>类设计应该遵从抽象封装性。</p><p>类抽象性指对于类的使用者来说只需知道类接口即可使用类功能。类的具体实现由设计者负责。即使某个功能发生了变更但由于使用者是以接口方式调用类所以用户代码无需做任何修改。</p><p>类封装性指类用户只需知道类的功能无需了解具体实现。实现代码对用户来说不可见。</p><p>C++类没有访问级别限制，定义类时不能用<code>public</code> 或 <code>private</code> 做修饰。类成员有访问级别，可以定义 <code>public protect private</code>。</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>每一个类的内部都有一个隐含的this指针，该参数是由系统负责维护。它的类型是<code>CLASSTYPE *const this;</code>，即指向某个类的const指针。所以this指针在初始化以后就不能改变。系统使用this指针来指明函数使用的是哪个实例的数据成员。</p><p>在调用成员函数时，系统会自动传递类实例的地址给this指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CLASSTYPE exm;  </div><div class="line">exm.func();</div></pre></td></tr></table></figure></p><p>可以将该函数调用理解为：<code>CLASSTYPE::func(&amp;exm);</code></p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>在调用成员函数时，会传递类实例的地址给<code>this</code>指针。如果该实例是const对象，那么非const指针是无法指向const对象的。可以在函数参数列表后加上<code>const</code>来表明是const成员函数。</p><p>因此，this也是指向常量的指针。</p><h3 id="类的作用域与成员函数"><a href="#类的作用域与成员函数" class="headerlink" title="类的作用域与成员函数"></a>类的作用域与成员函数</h3><p>编译器分两步处理类：</p><ul><li>首先编译成员的声明，</li><li>然后编译成员函数体。</li></ul><p>因此，成员函数体可以随意使用类中的其他成员。（不管定义先后）</p><h3 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> Sales_data::avg_price() <span class="keyword">const</span>&#123;</div><div class="line"><span class="keyword">if</span>(units_old)</div><div class="line">    <span class="keyword">return</span> revenue/units_old;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Sales_data &amp; Sales_data::combine(<span class="keyword">const</span> Sales_data &amp;rhs) <span class="keyword">const</span>&#123;</div><div class="line">units_old += rhs.units_old; <span class="comment">//把rhs的成员加到this对象上</span></div><div class="line">    revenue += rhs.revenue;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回调用该函数的对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因此，执行<code>total.combine(trans)</code>语句时，是更新了变量total的值。</p><blockquote><p>引用类型返回左值。<code>return *this;</code>解引用this指针获得执行该函数的对象，也就是返回total的引用。</p></blockquote><h3 id="定义类相关的非成员函数-7-1-3-P234"><a href="#定义类相关的非成员函数-7-1-3-P234" class="headerlink" title="定义类相关的非成员函数(7.1.3,P234)"></a>定义类相关的非成员函数(7.1.3,P234)</h3><p>类的辅助函数，比如add，read和print等。概念上属于类的接口的组成部分，但实际上不属于类本身。</p><p>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件中。</p><h3 id="构造函数-7-1-4，P235"><a href="#构造函数-7-1-4，P235" class="headerlink" title="构造函数(7.1.4，P235)"></a>构造函数(7.1.4，P235)</h3><p>构造函数(<code>constructor</code>)是特殊的成员函数。在类对象定义时被调用。不能通过定义的类对象调用构造函数，<strong>构造函数可以定义多个或者说构造函数允许重载。</strong></p><p>如果没有定义任何构造函数，系统就会给类分配一个无参的默认构造函数(<code>default constructor</code>)，类只要定义了一个构造函数，编译器也不会再生成默认构造函数。只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。</p><p>定义类对象时不能写成 <code>Sales_item myobj();</code>，编译器会理解成：一个返回 Sales_item 类型叫 myobj的函数声明。 正确写法是去掉后面的括号。</p><p>构造函数<strong>不允许定义成 const</strong>，这样定义会产生语法错误： <code>Sales_item() const {};</code></p><p>构造函数在执行时会做类数据成员的初始化工作。从概念上讲，可以认为构造函数分两个阶段执行：（1）初始化阶段；（2）普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。</p><p>不管成员是否在构造函数初始化列表中显式初始化，类类型的数据成员总是在初始化阶段初始化。初始化发生在计算阶段开始之前。</p><h4 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Sales_data&#123;</div><div class="line"><span class="comment">//新增的构造函数</span></div><div class="line">Sales_data() = <span class="keyword">default</span>;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s): bookNo(s) &#123;&#125;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, unsighed n, <span class="keyword">double</span> p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//之前已有的其他成员</span></div><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</div><div class="line"><span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line"><span class="keyword">unsigned</span> units_old = <span class="number">0</span>;</div><div class="line"><span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码中，<code>= default</code>要求编译器生成默认构造函数。<br><code>Sales_data(const std::string &amp;s, unsighed n, double p): bookNo(s), units_sold(n), revenue(p*n) {}</code>中的冒号和花括号之间的部分叫做<font color="0AAA00"><strong>构造函数初始值列表(<code>constractor initialize list</code>)</strong></font>。</p><blockquote><p>如果编译器不支持类内初始值，那么所有构造函数都应该显式地初始化每个内置类型的成员。</p></blockquote><p>当然也可以在类外定义构造函数。</p><h3 id="拷贝、赋值和析构-7-1-5，P239"><a href="#拷贝、赋值和析构-7-1-5，P239" class="headerlink" title="拷贝、赋值和析构(7.1.5，P239)"></a>拷贝、赋值和析构(7.1.5，P239)</h3><p>尽管编译器能为我们合成拷贝、赋值和析构的操作，但某些情况下可能无法正常工作。如分配和管理动态内存的类（13.1.4, P447）。</p><h2 id="访问控制与封装-7-2，P240"><a href="#访问控制与封装-7-2，P240" class="headerlink" title="访问控制与封装(7.2，P240)"></a>访问控制与封装(7.2，P240)</h2><p>访问说明符(<code>access specifiers</code>)：加强类的封装性：</p><ul><li>public：在整个程序内可被访问；</li><li>private：可以被类的成员函数访问。</li></ul><p><font color="0AAA00"><strong>使用class和struct唯一的区别就是默认的访问权限</strong></font>：<br><code>struct</code>默认是<code>public</code>，<code>class</code>默认是<code>private</code>。</p><h3 id="友元-7-2-1，P241"><a href="#友元-7-2-1，P241" class="headerlink" title="友元(7.2.1，P241)"></a>友元(7.2.1，P241)</h3><p>友元(friend)：<code>friend</code>关键字，允许其他类或者函数访问类的私有成员。</p><h2 id="类的其他特性-7-3，P243"><a href="#类的其他特性-7-3，P243" class="headerlink" title="类的其他特性(7.3，P243)"></a>类的其他特性(7.3，P243)</h2><p>可变数据成员(mutable data member)：永远不会是const，即使是const对象的成员。</p><p>类内初始值：必须以符号=或者花括号。</p><h3 id="返回-this的成员函数-7-3-2，P246"><a href="#返回-this的成员函数-7-3-2，P246" class="headerlink" title="返回*this的成员函数(7.3.2，P246)"></a>返回<code>*this</code>的成员函数(7.3.2，P246)</h3><p>返回值是调用对象的引用，返回引用的函数是左值的，意味着这些函数返回对象本身。</p><p>如果返回类型不是引用，则返回的是<code>*this</code>的副本。</p><h2 id="类的作用域-7-4，P253"><a href="#类的作用域-7-4，P253" class="headerlink" title="类的作用域(7.4，P253)"></a>类的作用域(7.4，P253)</h2><p>编译器处理完全部声明后，才会处理成员函数的定义。</p><h2 id="构造函数再探-7-5，P257"><a href="#构造函数再探-7-5，P257" class="headerlink" title="构造函数再探(7.5，P257)"></a>构造函数再探(7.5，P257)</h2><p>成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过<strong>构造函数初始值列表</strong>为这些成员提供初值。</p><h3 id="委托构造函数-7-5-2，P261"><a href="#委托构造函数-7-5-2，P261" class="headerlink" title="委托构造函数(7.5.2，P261)"></a>委托构造函数(7.5.2，P261)</h3><p>委托构造函数(delegating constructor)：使用使用所属类的其他构造函数执行自己的初始化过程。成员初始值列表唯一，是类名本身。</p><p>explicit：抑制构造函数定义的隐式转换，只对一个实参的构造函数有效。</p><p>字面值常量类：constexpr</p><h2 id="类的静态成员-7-6，P269"><a href="#类的静态成员-7-6，P269" class="headerlink" title="类的静态成员(7.6，P269)"></a>类的静态成员(7.6，P269)</h2><p>定义并且初始化一个静态成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> Account::interestRate = initRate();</div></pre></td></tr></table></figure></p><p>定义静态数据成员的方式和在类外定义成员函数差不多。<br>如果类内部声明提供了初始值，则外部定义时不能提供初始值。<br>静态数据成员可以是不完全类型，如类类型；非静态成员只能是类的指针或者引用。</p><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>class 关键字： class keyword<br>构造函数： constructor<br>构造函数初始值列表： constructor initializer list<br>类的作用域： class scope<br>委托构造函数： delegating constructor<br>显示构造函数： explicit constructor<br>接口：interface<br>数据抽象：data abstraction<br>可变数据成员： mutable data member<br>友元： friend</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49798749" target="_blank" rel="external">C++primer第五版第七章学习笔记</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/16/CPP_07/#disqus_thread</comments>
    </item>
    
    <item>
      <title>判断int是否为3的幂—— Leetcode(326)</title>
      <link>http://wangwlj.com/2018/01/13/leetcode_326_power_of_3/</link>
      <guid>http://wangwlj.com/2018/01/13/leetcode_326_power_of_3/</guid>
      <pubDate>Sat, 13 Jan 2018 14:15:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;leetcode链接：&lt;a href=&quot;https://leetcode.com/problems/power-of-three/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;326. Power of Three&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an integer, write a function to determine if it is a power of three.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Could you do it without using any loop / recursion?&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>leetcode链接：<a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></p><blockquote><p>Given an integer, write a function to determine if it is a power of three.</p><p>Follow up:<br>Could you do it without using any loop / recursion?</p></blockquote><a id="more"></a><p>一般的通用解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfThree(int n) &#123;</div><div class="line">        while (n &gt;= 3 )&#123;</div><div class="line">            if(n % 3 != 0)</div><div class="line">                return false;</div><div class="line">            n /= 3;   </div><div class="line">        &#125;</div><div class="line">        return n&gt;0 &amp;&amp; n != 2;     </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>上述可以通过，但是题目说最好尝试一下非循环或者递归的解法。</p><p>我感觉此类方法就是有点取巧了。如，找出<code>int</code>范围内最大的3的倍数，所以任何3的倍数<code>n</code>都可以被其整除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfThree(int n) &#123;</div><div class="line">        //方法2</div><div class="line">        const int maxint = 0x7fffffff;</div><div class="line">        //假设3^k 是int范围内最大的3的幂</div><div class="line">        int k = int(log(maxint) / log(3));</div><div class="line">        int max_power_3 = pow(3,k);</div><div class="line">        return n&gt;0 &amp;&amp; max_power_3 % n ==0;  </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>或者将上述代码压缩到一行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; <span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="number">3</span>,<span class="keyword">int</span>(<span class="built_in">log</span>(<span class="number">0x7fffffff</span>) / <span class="built_in">log</span>(<span class="number">3</span>)))) % n == <span class="number">0</span>;</div></pre></td></tr></table></figure></p><blockquote><p><code>pow</code>函数在头文件<code>math.h</code>中。</p></blockquote><p>同类题：</p><ol><li><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></li><li><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></li><li><a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/leetcode_326_power_of_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>判断int是否为4的幂—— Leetcode(342)</title>
      <link>http://wangwlj.com/2018/01/13/leetcode_342_power_of_4/</link>
      <guid>http://wangwlj.com/2018/01/13/leetcode_342_power_of_4/</guid>
      <pubDate>Sat, 13 Jan 2018 13:41:51 GMT</pubDate>
      <description>
      
        &lt;p&gt;leetcode链接：&lt;a href=&quot;https://leetcode.com/problems/power-of-four/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;342. Power of Four&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an integer (signed 32 bits), write a function to check whether it is a power of 4.&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>leetcode链接：<a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></p><blockquote><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p></blockquote><a id="more"></a><blockquote><p>Example:<br>Given num = 16, return true. Given num = 5, return false.</p><p>Follow up: Could you solve it without loops/recursion?</p></blockquote><p>判断一个数是不是4的幂。还是使用二进制。<br>在判断2的幂的基础上添加条件。<br>如：<code>16(10000)</code>是，<code>8(1000)</code>不是；可以与<code>0x55(01010101)</code>取并集即可。(即判断1的位数是不是在奇数位)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfFour(int n) &#123;</div><div class="line">        return n&gt;0 &amp;&amp; ((n &amp; (n-1)) == 0) &amp;&amp; (n &amp; 0x55555555);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>另一种思路的解法为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; ((n &amp; (n<span class="number">-1</span>)) == <span class="number">0</span>) &amp;&amp; (（(n<span class="number">-1</span>) %<span class="number">3</span> == <span class="number">0</span>);</div></pre></td></tr></table></figure></p><p>先直觉上检验一下，发现的确是这样：$4 -1 = 3,16 - 1 = 15, 64 -1 = 63$，都是3的倍数。因此$(4^n - 1) % 3 == 0$是成立的。</p><p>下面给出简短证明：<br>$$4^n -1 = 2^{2n}-1 = (2^n+1)(2^n-1)$$<br>我们知道：$2^n+1$、$2^n$与$2^n-1$是三个连续数，其中必有一个为3的倍数，而且$2^n$必然不是3的倍数，因此，$2^n+1$与$2^n-1$中必有一个为3的倍数。也就是$4^n -1$必为3的倍数。</p><p>同类题：</p><ol><li><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></li><li><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></li><li><a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/leetcode_342_power_of_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>判断int是否为2的幂—— Leetcode(231)</title>
      <link>http://wangwlj.com/2018/01/13/leetcode_231_power_of_2/</link>
      <guid>http://wangwlj.com/2018/01/13/leetcode_231_power_of_2/</guid>
      <pubDate>Sat, 13 Jan 2018 13:26:24 GMT</pubDate>
      <description>
      
        &lt;p&gt;leetcode链接：&lt;a href=&quot;https://leetcode.com/problems/power-of-two/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;231. Power of Two&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given an integer, write a function to determine if it is a power of two.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>leetcode链接：<a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></p><p>Given an integer, write a function to determine if it is a power of two.</p><a id="more"></a><p>出错样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Input: -16 Expected: false // 就是没有考虑负数。</div></pre></td></tr></table></figure></p><p>C++实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">while</span>(n != <span class="number">2</span> &amp;&amp; n &gt; <span class="number">2</span>)&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(n%<span class="number">2</span> != <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                n /= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上述一个常规的做法：连续除。</p><p>此外，我们考虑到2的幂的二进制只有最高位为1，其余都为0，此时利用这个特点可以写出如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfTwo(int n) &#123;</div><div class="line">        if(n &lt;= 0)</div><div class="line">             return false;</div><div class="line">        return (n &amp;(n-1) )== 0;</div><div class="line">        //或者一句话表示，如下：</div><div class="line">        //return n&gt;0 &amp;&amp; (n &amp;(n-1) )== 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><blockquote><p><code>n &amp; (n-1)==0</code> 会被当作：<code>n &amp; ((n-1)==0)</code>，故需要加上括号写为：<code>(n &amp;(n-1) )== 0</code>。</p></blockquote><p>例如：8的二进制<code>1000</code>,7的二进制<code>0111</code>，取并集为0。</p><p>同类题：</p><ol><li><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></li><li><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></li><li><a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/leetcode_231_power_of_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git入门使用指南</title>
      <link>http://wangwlj.com/2018/01/13/Git_usage/</link>
      <guid>http://wangwlj.com/2018/01/13/Git_usage/</guid>
      <pubDate>Sat, 13 Jan 2018 07:04:26 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h2&gt;&lt;p&gt;下面是摘自官网的一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，Git是一个优秀的分布式版本管理软件。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>下面是摘自官网的一段话：</p><blockquote><p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p></blockquote><p>简而言之，Git是一个优秀的分布式版本管理软件。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开Git官网：<a href="https://git-scm.com/" target="_blank" rel="external">git-scm.com</a>，下载并安装。<br>Debian或<code>Ubuntu Linux</code>，通过一条<code>sudo apt-get install git</code>就可以直接完成<code>Git</code>的安装。</p><p>安装完成后，windows打开<code>git-bash</code>，linux直接打开<code>terminal</code>。</p><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>配置用户信息（和Github上一致）：用户名和邮箱地址：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name "qwerty200696"</div><div class="line">git config --global user.email "wang@126.com"</div></pre></td></tr></table></figure></p><p>如果之前已经配置好了，可以使用如下命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config user.name</div><div class="line">git config user.email</div></pre></td></tr></table></figure><p>还可以配置颜色和行尾。不同平台的行尾是有显著区别的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git config --global core.autocrlf true</div><div class="line">git config --global core.autocrlf input</div><div class="line"></div><div class="line">git config --global color.ui auto</div></pre></td></tr></table></figure><p>其他配置：<br>配置的级别分为：<code>global</code> 、<code>local</code>与<code>system</code>三种级别，<code>local</code>会覆盖<code>global</code>。就像面向对象的继承那样，最近的是最有效的，也就是<code>local</code>。</p><h2 id="init-amp-add——开始与添加"><a href="#init-amp-add——开始与添加" class="headerlink" title="init&amp;add——开始与添加"></a>init&amp;add——开始与添加</h2><p>选择需要版本控制的文件夹，打开终端(linux)或者Git Bash(windows)。</p><p>初始化Git：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure></p><blockquote><p>最好的方法是在开始一个项目之前，通过<code>git init xxx</code>来新建一个项目目录<code>xxx</code>。git会自动创建该<code>xxx</code>目录。</p></blockquote><p>假设文件夹下存在需要版本管理的文件，使用如下命令查看是否已经被管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure><p>添加需要管理的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add 1.py # 某个具体的文件</div><div class="line">git add .  # 添加文件夹下所有的文件</div></pre></td></tr></table></figure></p><p>可以在目录下创建一个名为<code>.gitignore</code>的文件，在其中输入需要忽略的文件。</p><h2 id="commit——提交修改"><a href="#commit——提交修改" class="headerlink" title="commit——提交修改"></a>commit——提交修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;first commit&quot;</div></pre></td></tr></table></figure><p>修改内容之后，使用<code>commit</code>提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure><p><code>log</code>命令可以查看每次的更改。</p><p>目前都是在本地化的版本管理。</p><h2 id="diff——显示不同"><a href="#diff——显示不同" class="headerlink" title="diff——显示不同"></a>diff——显示不同</h2><p>现在假设你修改了一个文件，但是过去了一段时间后忘记修改在什么地方了，此时你需要“diff”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git diff  # 文件的最新改动</div><div class="line">git diff --staged  # 已经暂存的和最近历史的改动。</div><div class="line">git diff HEAD # HEAD提交历史中，最近一次的别名，最新的修改与最近历史的改动。跳过了暂存的修改，直接与最近一次提交的比较。</div><div class="line"></div><div class="line">git diff --color-words  # 只对修改的地方用不同颜色标记，而不是整行。</div><div class="line">git diff --word-diff # 对长行的小改动更加清晰明了。</div><div class="line">git diff --stat  # 极简输出，只输出改动的文件，阻止其他输出。</div></pre></td></tr></table></figure></p><h2 id="log——查看修改"><a href="#log——查看修改" class="headerlink" title="log——查看修改"></a>log——查看修改</h2><p>log是一个非常强大的明了，不仅可以查看提交的历史记录，而且是了解仓库的进展、提交的内容以及文件的好帮手。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git log</div><div class="line">git log --oneline  # 更常用！</div><div class="line">git log --stat #可以查看修改的文件。</div><div class="line">git log --patch # 可以查看文件中具体的修改内容。</div><div class="line"></div><div class="line">git log --graph --all --decorate --oneline  # z展示每次提交的一行概括。</div></pre></td></tr></table></figure></p><h2 id="remove——删除文件"><a href="#remove——删除文件" class="headerlink" title="remove——删除文件"></a>remove——删除文件</h2><p>删除文件。两种方式，一种是<code>git rm</code>，一种是<code>git add</code></p><p><code>git rm</code> 用来删除一个文件；并且会自动暂存修改。</p><p>此外，如果用<code>rm</code>删除了一个文件，可以使用<code>git rm</code>再次暂存修改。</p><p>现实情况中，往往会有很多文件被删除了，不可能通过命令行一个个修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Git add -u .  # 注意，最后的dot不能省略哦，表示当前目录</div></pre></td></tr></table></figure></p><p>改命令会遍历文件夹，并且查找出所有删除的文件，并且暂存。</p><p>有时候只是想要从git中删除，但是本地文件不删除，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rm --cached xxx_file</div></pre></td></tr></table></figure></p><p>你是真的想在所有历史记录中删除这个文件的记录吗？这是另一个主题中会讲。或者你是不想要某个文件被追踪，之后也是这样，那么可以使用<code>git ignore</code>文件，在之后也会介绍。</p><h2 id="move——移动文件"><a href="#move——移动文件" class="headerlink" title="move——移动文件"></a>move——移动文件</h2><p> 移动文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git mv xxx_file otherPath/xxx.file</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add -A .</div></pre></td></tr></table></figure><p>找出所有的移动过的文件。（包括修改之后移动的文件）</p><p>追踪移动过的文件的历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git log -- path/file # 只会追踪到该目录下的历史，历史会终止在移动的时候。</div><div class="line"></div><div class="line">git log --stat -M --follow -- path/file # 跨目录追踪历史，文件在移动过程中也追踪。</div></pre></td></tr></table></figure></p><p>在移动文件之后，commit给我们一个数字来告诉我们文件在移动前后的相似度。Git提供的默认阈值是50%的相似度，超过50%，在移动前后就会继续追踪该文件。</p><h2 id="ignore——忽略文件"><a href="#ignore——忽略文件" class="headerlink" title="ignore——忽略文件"></a>ignore——忽略文件</h2><p>可以在目录/子目录下创建一个名为<code>.gitignore</code>的文件，在其中输入需要忽略的文件/文件夹。</p><p>只能对当前目录的文件/文件夹进行忽略。 可以使用匹配符，在当前目录/子目录都有效。</p><p><del>子目录中，需要路径优先级？？</del><br>也可以使用“！”反忽略某一个特定的文件。<br>注释行用“#”号开头。</p><p>查看忽略了的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git ls-files --others --ignored --exclude-standard  ## 查看忽略的文件</div><div class="line"></div><div class="line">git ls-files  --ignored --exclude-standard</div></pre></td></tr></table></figure></p><p><del>为什么我感觉不需要加上 <code>--others</code>也可以。而且第二个命令更靠谱。</del></p><p>以上述的第一个命令为主。<br>如果你感觉第一个命令不行的话，那是因为在某些文件先前已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的push，这样就不会出现忽略的文件了。git清除本地缓存命令如下：【参考资料二】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git rm -r --cached .</div><div class="line">git add .</div><div class="line">git commit -m &apos;update .gitignore&apos;</div></pre></td></tr></table></figure></p><p>关于ignore规则的详细介绍，可参考<a href="https://www.cnblogs.com/kevingrace/p/5690241.html" target="_blank" rel="external">这篇博文</a>，写得很详细。</p><h2 id="branch——开始新分支"><a href="#branch——开始新分支" class="headerlink" title="branch——开始新分支"></a>branch——开始新分支</h2><h3 id="创建与删除"><a href="#创建与删除" class="headerlink" title="创建与删除"></a>创建与删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git branch newBranchName  ## 创键分支</div><div class="line">git branch -d existedBranchname  ## 删除分支，没有合并的话会出错</div><div class="line">git branch -D existedBranchname  ## 删除分支，强制删除</div></pre></td></tr></table></figure><h3 id="switch——切换分支"><a href="#switch——切换分支" class="headerlink" title="switch——切换分支"></a>switch——切换分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout existedBranchname</div></pre></td></tr></table></figure><h2 id="checkout的其他用法"><a href="#checkout的其他用法" class="headerlink" title="checkout的其他用法"></a>checkout的其他用法</h2><p>最主要的作用就是切换分支，上面已经讲过了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch</div><div class="line">git status</div></pre></td></tr></table></figure></p><p>都可以查看目前处于那个分支上面。</p><p>撤销内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- filename.txt</div></pre></td></tr></table></figure></p><p>会清理掉最后一次commit的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b newBranchName</div></pre></td></tr></table></figure><p>一步到位，既创建了一个新的branch，也转移到了新的branch。</p><p>如果在使用<code>checkout</code>命令的时候，不小心将头指针分离了，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wangwlj@myUbuntu:~/文档/py_prog/py3_prog$ git branch -a</div><div class="line">* （头指针分离于 ee74fc7）</div><div class="line">  master</div><div class="line">  program</div></pre></td></tr></table></figure></p><p>当我们发现头指针游离于分支之外的时候，不要惊慌，再次<code>git checkout program</code>切换到已经存在的分支即可。</p><h2 id="merge——分支合并"><a href="#merge——分支合并" class="headerlink" title="merge——分支合并"></a>merge——分支合并</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master  ## 切换到主分支</div><div class="line">git merge branchNeedToMerge ## 将分支branchNeedToMerge的修改合并到master</div></pre></td></tr></table></figure><h3 id="merge冲突的解决"><a href="#merge冲突的解决" class="headerlink" title="merge冲突的解决"></a>merge冲突的解决</h3><p>merge冲突：两个文件都有变化，Git无法确定该怎么合并。该如何解决呢？</p><p>先用<code>git status</code>查看是哪个文件冲突 ，然后用编辑器打开，进行修改。</p><p>先查找<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>标志，表明是当前branch上的内容，直到<code>=======</code>标志结束。<br>在<code>=======</code>标志的下方，直到<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; branchNeedToMerge</code>标志结束，是另一个分支的内容。</p><p>找到位置后，需要手动地解决冲突：编辑文件，删去冲突的标签，决定该删去或保留哪些内容，保存即可。最后重新add、commit提交。</p><h3 id="abort——放弃冲突"><a href="#abort——放弃冲突" class="headerlink" title="abort——放弃冲突"></a>abort——放弃冲突</h3><p>放弃这个冲突（不重要），从上次commit开始，并且清除暂存区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --abort</div></pre></td></tr></table></figure></p><h3 id="squash压缩"><a href="#squash压缩" class="headerlink" title="squash压缩"></a>squash压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git merge --squash branchNeedToMerge</div><div class="line">git commit -m &quot;some message&quot;</div></pre></td></tr></table></figure><p>意思是 你在分支<code>branchNeedToMerge</code>里面做了很多次commit修改，但是修改很零碎；在master分支里只想要一次commit就更新到<code>branchNeedToMerge</code>分支的进度。此时就可以使用<code>--squash</code>参数。</p><blockquote><p>判断是否使用<code>--squash</code>选项最根本的标准是，待合并分支上的历史是否有意义。</p></blockquote><p>关于<code>--squash</code> 参数的举例可参考<a href="http://blog.csdn.net/rockrockwu/article/details/33740711" target="_blank" rel="external">这篇文章</a>。</p><h3 id="d-删除分支"><a href="#d-删除分支" class="headerlink" title="-d 删除分支"></a>-d 删除分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d branchNeedToMerge</div></pre></td></tr></table></figure><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><h3 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin &lt;server&gt;</div></pre></td></tr></table></figure><p><code>&lt;server&gt;</code>是远程服务器的地址、目的地的url。<br>如果输错了或者忘记了也不要紧，可以输入如下命令重新设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote set-url origin &lt;new-server&gt;</div></pre></td></tr></table></figure></p><p>查看远程的地址有哪些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure></p><p>最后删除远端地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rm origin</div></pre></td></tr></table></figure></p><h3 id="fetch-pull-push"><a href="#fetch-pull-push" class="headerlink" title="fetch/pull/push"></a>fetch/pull/push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git fetch origin</div><div class="line">git pull origin</div><div class="line">git push origin</div></pre></td></tr></table></figure><p>fetch:去github.com上面下载信息，放在远程追踪分支。，<br>pull：与fetch非常像，下载下来放到远程，并且合并到本地。<br>push：电脑上完成了工作，发送到github上面。</p><h2 id="fork-pull-requests"><a href="#fork-pull-requests" class="headerlink" title="fork/pull requests"></a>fork/pull requests</h2><p>fork:拷贝到自己的仓库进行修改，最好新建分支。<br>pull requests:对他人的代码进行修改，提意见</p><h2 id="reset——重置"><a href="#reset——重置" class="headerlink" title="reset——重置"></a>reset——重置</h2><p>reset有三个等级，默认的是<code>mixed</code>，除此之外还有<code>soft</code>与<code>hard</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git reset --soft HEAD~5  # 选择需要重置commit的次数</div><div class="line">git status</div><div class="line">git commit -m&quot;new message&quot;  # 重新提交</div></pre></td></tr></table></figure><p>reset在对仓库历史提交的处理上比较有用，当然也是一个危险的命令啦。</p><p>checkout可以做类似的事情，<code>checkout</code>更加关注的是一个目录或者文件级别的精度。也就是说，可以把某个文件拉回到几次提交之前的状态。</p><h2 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h2><p>包括<code>reset</code>做的那些不可恢复的操作，<code>reflog</code>都有记录。<br>但默认提供的是30天的保存时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure><p>也可以图形化查看历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitk --all `git reflog | cut c1-7`&amp;</div></pre></td></tr></table></figure></p><p><code>reflog</code>让我们有动力地去多做commit，commit了就有保障了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000" target="_blank" rel="external">忽略特殊文件</a></li><li><a href="https://www.cnblogs.com/zzcc/p/5695883.html" target="_blank" rel="external">Git中.gitignore文件不起作用的解决</a></li><li><a href="https://www.nowcoder.com/courses/2" target="_blank" rel="external">GitHub&amp;Git入门基础</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/Git_usage/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ubuntu下必备软件及安装总结</title>
      <link>http://wangwlj.com/2018/01/13/ubuntu_software_summary/</link>
      <guid>http://wangwlj.com/2018/01/13/ubuntu_software_summary/</guid>
      <pubDate>Sat, 13 Jan 2018 05:51:37 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;安装ubuntu&quot;&gt;&lt;a href=&quot;#安装ubuntu&quot; class=&quot;headerlink&quot; title=&quot;安装ubuntu&quot;&gt;&lt;/a&gt;安装ubuntu&lt;/h2&gt;&lt;p&gt;本文以&lt;code&gt;Ubuntu 16.04&lt;/code&gt;为例。&lt;/p&gt;
&lt;p&gt;制作U盘启动盘、安装Ubuntu系统。是装双系统还是只装linux。&lt;/p&gt;
&lt;p&gt;安装时，需要注意的两点。一是手动/自动分区，若手动分区，最好将&lt;code&gt;/home&lt;/code&gt;分区独立出来；二是系统语言选择中文还是英文，推荐中文。其他的就随意即可。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="安装ubuntu"><a href="#安装ubuntu" class="headerlink" title="安装ubuntu"></a>安装ubuntu</h2><p>本文以<code>Ubuntu 16.04</code>为例。</p><p>制作U盘启动盘、安装Ubuntu系统。是装双系统还是只装linux。</p><p>安装时，需要注意的两点。一是手动/自动分区，若手动分区，最好将<code>/home</code>分区独立出来；二是系统语言选择中文还是英文，推荐中文。其他的就随意即可。</p><a id="more"></a><p>给出几个参考链接：</p><ul><li><a href="http://blog.csdn.net/yaoyut/article/details/78003061" target="_blank" rel="external">用UltraISO制作Ubuntu16.04 U盘启动盘</a></li><li><a href="https://www.zhihu.com/question/19867618" target="_blank" rel="external">怎样安装 Windows 7 与 Linux 的双系统？</a><br>双系统是比较特殊的，双系统可以，单系统也没问题。</li></ul><h2 id="软件安装前的设置"><a href="#软件安装前的设置" class="headerlink" title="软件安装前的设置"></a>软件安装前的设置</h2><p>假设现在已经有了一个全新的<code>Ubuntu</code>系统，此时你需要先换源。</p><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>系统自带的源速度不快，因此考虑换成国内源。笔者采用的是阿里云的源，还是不错的。</p><ul><li><p><a href="http://blog.csdn.net/happywho250/article/details/52506321" target="_blank" rel="external">ubuntu16.04换源</a></p></li><li><p><a href="http://blog.csdn.net/u011557212/article/details/53233944" target="_blank" rel="external">Ubuntu16.04常用源</a></p></li></ul><h3 id="主文件夹下的中文目录改为英文目录"><a href="#主文件夹下的中文目录改为英文目录" class="headerlink" title="主文件夹下的中文目录改为英文目录"></a>主文件夹下的中文目录改为英文目录</h3><blockquote><p>可选项。主文件夹下的中文目录名其实也不错。</p></blockquote><p>Linux下使用命令行是很正常的事情，<code>cd ~/桌面</code> 需要切换输入法，可能会显得不那么流畅，因此，可以考虑将主文件夹下的中文目录设置为英文。</p><p>参考这篇文章：<br><a href="http://blog.csdn.net/l0605020112/article/details/20285239" target="_blank" rel="external">将Ubuntu主文件夹里的中文文件夹名称改成英文</a></p><p>我采用的是第一种方法。换了之后建议重启一下。</p><p>笔者不是一开始就改的，所以导致换目录名后出现了一系列问题。一开始就换会比较好。</p><h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><h2 id="安装必备软件"><a href="#安装必备软件" class="headerlink" title="安装必备软件"></a>安装必备软件</h2><p>在对Ubuntu换源之后，就可以开始安装一些必备而的软件了。Ubuntu下软件的安装都不难，可以根据需求选择安装相应的软件。</p><h3 id="1-搜狗输入法"><a href="#1-搜狗输入法" class="headerlink" title="1. 搜狗输入法"></a>1. 搜狗输入法</h3><p>输入法必备，放在第一个吧。</p><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>官网下载linux版本的dev包：<a href="http://pinyin.sogou.com/linux/" target="_blank" rel="external">pinyin.sogou.com/linux</a><br>进入下载目录，在终端执行安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> sudo dpkg  -i   sogoupinyin_2.2.0.0102_amd64.deb</div></pre></td></tr></table></figure></p><p>安装过程会出现 依赖关系问题（未安装成功，依赖库不全），不要担心，接着执行下面的命令就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span>sudo apt-get install -f</div></pre></td></tr></table></figure><p>等待完成后，搜狗拼音输入法就安装好了。</p><blockquote><p>上述两条命令都是常用命令，需要记住。</p></blockquote><h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p> 下面对输入法进行系统配置，具体流程如下：</p><ul><li>桌面右上角面板的<code>开关机的按钮</code>，选择<code>系统设置</code>；</li><li>进入系统设置后，点击<code>语言支持</code>，键盘输入方式系统中选择 <code>fcitx</code>；</li><li>注销系统用户，重新登陆进入桌面后看看，熟悉的搜狗输入法出现了吧。</li></ul><p>参考自：<a href="https://jingyan.baidu.com/article/a3aad71aa1abe7b1fa009641.html" target="_blank" rel="external">ubuntu安装配置搜狗拼音输入法</a></p><h3 id="2-网易云音乐"><a href="#2-网易云音乐" class="headerlink" title="2. 网易云音乐"></a>2. 网易云音乐</h3><p>网易云音乐，大家都知道的，无需过多介绍，虽然现在由于版权问题好多歌曲都下架了，不过<code>Linux</code>下的网易云做得非常好。</p><p>只需要简单地下载、安装即可。具体请参考：<a href="http://blog.csdn.net/u011557212/article/details/53234134" target="_blank" rel="external">ubuntu16.04安装网易云音乐</a></p><blockquote><p>别人写得很详细的教程，我就只放链接了。</p></blockquote><h3 id="3-chrome浏览器"><a href="#3-chrome浏览器" class="headerlink" title="3. chrome浏览器"></a>3. chrome浏览器</h3><p>Linux下谷歌浏览器是必备的。</p><p>安装谷歌浏览器，只需要三行代码：<br>打开终端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /tmp</div></pre></td></tr></table></figure></p><p>对于谷歌Chrome32位版本，使用如下链接：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb</div></pre></td></tr></table></figure></p><p>对于64位版本可以使用如下链接下载：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</div></pre></td></tr></table></figure></p><p>下载完后，运行如下命令安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dpkg -i google-chrome*; sudo apt-get -f install</div></pre></td></tr></table></figure></p><p>然后，就可以去搜索使用了。<br>是不是很方便？</p><p>参考自：<a href="http://www.linuxidc.com/Linux/2013-10/91857.htm" target="_blank" rel="external">安装谷歌Chrome浏览器</a></p><h3 id="4-Guake-Terminal-optional"><a href="#4-Guake-Terminal-optional" class="headerlink" title="4. Guake Terminal (optional)"></a>4. Guake Terminal (optional)</h3><h4 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h4><p><code>Guake Terminal</code>顾名思义，是一个终端。功能只有一个, 按 <code>F12</code> 时从屏幕顶部 嗖! 地下来一个。</p><p>可到官网：<a href="http://guake-project.org/" target="_blank" rel="external">guake-project.org</a> 查看详细说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/Guake/guake.git</div><div class="line">$ cd guake</div><div class="line"></div><div class="line"># For Ubuntu user, we have a script that does all these steps for you. Use:</div><div class="line">$ ./dev.sh</div></pre></td></tr></table></figure><p>如果上述第三条命令出错的话，请尝试以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./dev.sh --install</div></pre></td></tr></table></figure></p><p>期间，会自动安装一些库，如<code>git</code>之类的。</p><h4 id="设置与自启动"><a href="#设置与自启动" class="headerlink" title="设置与自启动"></a>设置与自启动</h4><p>安装完成后，可以在终端输入<code>guake</code>查看效果，输入<code>guake --preferences</code>进行相关的配置。<br><code>guake</code>启动后，按下<code>F12</code>显示终端，再按<code>F12</code>消失。可以设置焦点失去时隐藏，这样就不用反复点<code>F12</code>了。</p><p>自启动设置：</p><p>点击最左上角的<code>Dash</code>图标(用于查找文件与程序的nage)，输入<code>启动</code>二字查看搜索结果，点击“启动应用程序”，按下图设置：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fneyjbeucgj20gn0daabi.jpg" alt=""></p><h3 id="5-思维导图xmind"><a href="#5-思维导图xmind" class="headerlink" title="5. 思维导图xmind"></a>5. 思维导图xmind</h3><p><code>xmind</code>和<code>MindManager</code>都是优秀的思维导图软件，linux下只有<code>xmind</code>。</p><p>具体的安装步骤：</p><p>1、去官网下载<a href="http://www.xmind.net/download/linux/" target="_blank" rel="external">http://www.xmind.net/download/linux/</a></p><p>2、下载完后解压，进入解压后目录，在命令行输入<code>sudo ./setup</code>，这个是用来安装软件相关的依赖；然后进入<code>xmind_amd64</code>（64位系统）或者<code>xmind_i386</code>(32位系统)</p><p>3、在目录中直接双击<code>XMind</code>文件，或者在命令行中输入 <code>sudo ./XMind</code>。这样XMind就可以直接运行。由于XMInd8的ubuntu版本是用JAVA来开发的，所以可以直接打开，无需安装。</p><p>参考自：<a href="http://blog.csdn.net/faryang/article/details/70238326" target="_blank" rel="external">ubuntu16.04安装xmind8</a></p><h3 id="6-pycharm"><a href="#6-pycharm" class="headerlink" title="6. pycharm"></a>6. pycharm</h3><p>需要使用Python的话可以考虑安装Pycharm。</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>打开<a href="https://www.jetbrains.com/pycharm/download/#section=linux" target="_blank" rel="external">pycharm官网</a></p><p>下载linux版本的pycharm。</p><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p>打开刚才下载的目录。右击文件，点击提取到此处（这与Windows的解压是一个意思）</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>解压完成后，打开刚才解压好的文件夹，然后再打开bin目录。</p><p>在文件夹空白处右击，在此处打开终端然后输入：<code>sh ./pycharm.sh</code> 回车</p><p>接着就打开了pycharm。</p><p>如果你需要导入之前安装版本的设置的话，可以选择第一个选项；如果没有的话，默认不导入设置就可以了。</p><p>点击同意，然后激活<code>pycharm</code>就可以使用了。</p><p>详情可参考：<br><a href="https://jingyan.baidu.com/article/60ccbceb4e3b0e64cab19733.html" target="_blank" rel="external">Ubuntu系统安装PyCharm教程（详细图文）</a></p><p>另附：学生可以免费注册pycharm，学生版也可以使用专业版的pycharm，没有什么区别。</p><h3 id="7-WPS"><a href="#7-WPS" class="headerlink" title="7. WPS"></a>7. WPS</h3><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><p>进入WPS官网下载deb包：<a href="http://linux.wps.cn/" target="_blank" rel="external">http://linux.wps.cn/</a></p><p>安装，打开终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd 下载</div><div class="line">sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb</div></pre></td></tr></table></figure><h4 id="解决打开WPS时出现的系统缺失字体问题"><a href="#解决打开WPS时出现的系统缺失字体问题" class="headerlink" title="解决打开WPS时出现的系统缺失字体问题"></a>解决打开WPS时出现的系统缺失字体问题</h4><p>下载wps_symbol_fonts.zip: <a href="https://pan.baidu.com/s/1eS6xIzo" target="_blank" rel="external">https://pan.baidu.com/s/1eS6xIzo</a></p><p>将<code>wps_symbol_fonts.zip</code>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd wps_symbol_fontsls</div></pre></td></tr></table></figure></p><p>将目录中所有文件复制到<code>/usr/share/fonts</code>下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cp mtextra.ttf  symbol.ttf  WEBDINGS.TTF  wingding.ttf  WINGDNG2.ttf  WINGDNG3.ttf  /usr/share/fonts</div></pre></td></tr></table></figure><p>重新打开WPS，问题解决。</p><h4 id="删除libreOffice-optional"><a href="#删除libreOffice-optional" class="headerlink" title="删除libreOffice (optional)"></a>删除libreOffice (optional)</h4><p>另外，安装完WPS后就没有必要保留<code>libreOffice</code></p><p>卸载<code>libreOffice</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get remove libreoffice-common</div></pre></td></tr></table></figure></p><p>顺便把Amazon链接删除了吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    sudo apt-get remove unity-webapps-common</div><div class="line">    sudo apt autoremove</div><div class="line">```       </div><div class="line">参考自：[Ubuntu16.04安装wps并解决系统缺失字体问题](https://www.cnblogs.com/liutongqing/p/6388160.html)</div><div class="line"></div><div class="line">### 8. 图片编辑工具GIMP</div><div class="line"></div><div class="line">`GIMP`虽然不能完全替代`PS`，但是也能弥补一下。系统默认源中已经包含了GIMP，不需要使用PPA这些。</div><div class="line"></div><div class="line">安装：</div></pre></td></tr></table></figure></p><pre><code>sudo apt-get install gimp</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">启动：</div><div class="line"></div><div class="line">通过Dash搜索`GIMP`即可。或者命令行输入GIMP也行。</div><div class="line"></div><div class="line">参考：</div><div class="line"></div><div class="line">- https://www.gimp.org/downloads/</div><div class="line">- https://www.cnblogs.com/EasonJim/p/7121885.html</div><div class="line"></div><div class="line"></div><div class="line">### 9. indicator-sysmonitor</div><div class="line"></div><div class="line">先看一下效果图：</div><div class="line">![1](http://ww1.sinaimg.cn/large/c38a0784ly1fndxu83315j20fr02zglt.jpg)</div><div class="line"></div><div class="line">图中的“CPU，温度，内存”部分就是该软件的作用了。</div><div class="line"></div><div class="line">想要安装可参考：[Ubuntu 16.04安装indicator-sysmonitor实现导航条显示上下行网速/CPU/内存使用率](http://www.cnblogs.com/EasonJim/p/7130171.html)</div><div class="line"></div><div class="line">### 10. 主题管理工具unity tweak tool</div><div class="line"></div><div class="line">主题管理工具`unity tweak tool`</div><div class="line"></div><div class="line">1,    添加源</div></pre></td></tr></table></figure><p>sudo add-apt-repository ppa:freyja-dev/unity-tweak-tool-daily<br>sudo apt-get update<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2,安装</div></pre></td></tr></table></figure></p><p>　　sudo apt-get install unity-tweak-tool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,卸载</div></pre></td></tr></table></figure></p><p>　　sudo apt-get remove unity-tweak-tool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">4,搜索`unity tweak tool`运行</div><div class="line"></div><div class="line">5,若出现以下问题，终端输入`sudo apt-get install unity-webapps-service `即可</div><div class="line"></div><div class="line">![](http://ww1.sinaimg.cn/large/c38a0784ly1fne74thxbkj20j006ojrk.jpg)</div><div class="line"></div><div class="line"></div><div class="line">### 11. docky</div><div class="line"></div><div class="line">经常使用Mac者的福音。实现效果如下图：</div><div class="line"></div><div class="line">![](http://ww1.sinaimg.cn/large/c38a0784ly1fne792nqnfj20jj032mzj.jpg)</div><div class="line"></div><div class="line">一句话安装：</div></pre></td></tr></table></figure></p><p>sudo apt install ducky<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用方法：</div><div class="line"></div><div class="line">- 删除图标：拖到回收站上面就可以。</div><div class="line">- 添加图标：打开程序的时候会自动加载到docky中，此时右键选择锁定。</div><div class="line"></div><div class="line">图标模糊：下载高清图标，替换掉。具体可查看知乎问题“Docky中程序的图标太模糊，如何替换Docky中程序的图标？”的[回答](https://www.zhihu.com/question/22892627/answer/64026877)。</div><div class="line"></div><div class="line">### 12. teamviewer</div><div class="line"></div><div class="line">`teamviewer`的作用：与其他主机互传文件或者控制远程主机。</div><div class="line"></div><div class="line">安装过程如下：</div><div class="line"></div><div class="line">1、下载安装程序(32位和64位Ubuntu通用)</div><div class="line">https://www.teamviewer.com/zhcn/download/linux/</div><div class="line"></div><div class="line">选择下载对应版本。</div><div class="line"></div><div class="line">2、在终端中执行如下命令进行安装</div></pre></td></tr></table></figure></p><pre><code>sudo dpkg -i teamviewer_i386.deb</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3、使用如下命令处理依赖问题</div></pre></td></tr></table></figure><pre><code>sudo apt-get install –f </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">参考链接：[Ubuntu 16中如何安装TeamViewer 12](http://blog.csdn.net/zuochao_2013/article/details/53671245)</div><div class="line"></div><div class="line">使用部分不难，简单易上手。可以注册一个`teamview`账号，还是很方便的。</div><div class="line"></div><div class="line"></div><div class="line">### 13. 截图工具shutter</div><div class="line"></div><div class="line">`shutter`安装可参考：[ubuntu 安装截图工具 Shutter，并设置快捷键 Ctrl+Alt+A](http://blog.csdn.net/hanshileiai/article/details/46843713)</div><div class="line"></div><div class="line">其实`ubuntu`有自带的截图工具，不支持修改文件而已。</div></pre></td></tr></table></figure><pre><code>printscreen -- 全屏alt + printscreen -- 当前活动截图shift + printscreen -- 自选矩形截图</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">自带的截图工具配合第八个软件GIMP一起使用，也还是不错的。</div><div class="line"></div><div class="line">### 14. Markdown编辑器 </div><div class="line"></div><div class="line">我选择的是[Moeditor](https://github.com/Moeditor/Moeditor)。</div><div class="line"></div><div class="line">类似的`markdown`编辑器还有：[Atom](https://atom.io/) (Github出品)，Vim+Markdown，[Remarkable - Linux](https://remarkableapp.github.io/linux.html) （据说有点小bug），[Haroopad - The Next Document processor based on Markdown](http://pad.haroopress.com/user.html) ，[typora.io](https://www.typora.io/#linux) ， SublimeText3+插件，[StackEdit](https://stackedit.io/)  (网页版)，[小书匠markdown编辑器](http://markdown.xiaoshujiang.com/) ，马克飞象，VS Code，reText等等。</div><div class="line"></div><div class="line"></div><div class="line">`Moeditor`下载地址：https://github.com/Moeditor/Moeditor/releases</div><div class="line"></div><div class="line">安装： `sudo dpkg -i xxxx.deb`</div><div class="line"></div><div class="line">使用： 简单易上手。简洁。右上角分别为：最小化和全屏。菜单在左下角（新建，保存，另存为之类的）和右下角（切换编辑模式）。</div><div class="line"></div><div class="line">### 15. shadowsocks</div><div class="line"></div><div class="line">算是必备的吧。科研(?)利器。</div><div class="line">#### 安装软件</div><div class="line"></div><div class="line">ubuntu16.04 直接一句话安装：</div></pre></td></tr></table></figure><p>sudo apt install shadowsocks<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">提示需要安装一些依赖库，选择`yes`即可。</div><div class="line"></div><div class="line">我们可以在`/home/wangwlj/` 下新建个文件`shadowsocks.json`  (`wangwlj`是我在我电脑上的用户名，这里路径你自己看你的)。内容是这样：</div></pre></td></tr></table></figure></p><p>{<br>    “server”:”11.22.33.44”,<br>    “server_port”:50003,<br>    “local_port”:1080,<br>    “password”:”123456”,<br>    “timeout”:600,<br>    “method”:”aes-256-cfb”<br>}</p><p>上面的各项参数含义如下：<br>server  你服务端的IP<br>servier_port  你服务端的端口<br>local_port  本地端口，一般默认1080<br>passwd  ss服务端设置的密码<br>timeout  超时设置 和服务端一样<br>method  加密方法 和服务端一样<br>```</p><p>确定上面的配置文件没有问题，然后我们就可以在终端输入<code>sslocal -c /home/wangwlj/shadowsocks.json</code> 回车运行。如果没有问题的话，下面会是这样…</p><h4 id="chrome插件SwithyOmega配置"><a href="#chrome插件SwithyOmega配置" class="headerlink" title="chrome插件SwithyOmega配置"></a>chrome插件SwithyOmega配置</h4><p>这里就不详写了，看这篇，写的很详细：<a href="http://www.sundabao.com/ubuntu%E4%BD%BF%E7%94%A8shadowsocks/" target="_blank" rel="external">ubuntu使用shadowsocks</a></p><p>还是简要附上几点吧。</p><p>新建一个模式，代理服务器，代理协议<code>SOCKS5</code>，代理服务器<code>127.0.0.1</code>，端口<code>1080</code></p><p><code>auto switch</code>中，上述模式对应的是：(按照规则列表匹配请求)使用shadowsocks访问的规则列表：<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="external">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a><br>，其余情况为直接访问。</p><blockquote><p>PS：windows下的chrome插件SwithyOmega的配置与Ubuntu一样。</p></blockquote><h3 id="Updating-1"><a href="#Updating-1" class="headerlink" title="Updating"></a>Updating</h3><p>将在个人博客中持续更新……</p><p>为了查找安装方便，所有参考链接均在对应位置处，就不放在最后了。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/ubuntu_software_summary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(6) 第七章快速排序</title>
      <link>http://wangwlj.com/2018/01/11/algorithm_tutorial_charpter_7/</link>
      <guid>http://wangwlj.com/2018/01/11/algorithm_tutorial_charpter_7/</guid>
      <pubDate>Thu, 11 Jan 2018 13:54:42 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;快速排序简介&quot;&gt;&lt;a href=&quot;#快速排序简介&quot; class=&quot;headerlink&quot; title=&quot;快速排序简介&quot;&gt;&lt;/a&gt;快速排序简介&lt;/h2&gt;&lt;p&gt;快排最坏情况$O( n^2 )$，但平均效率$O(n lg n)$，而且$O(n lg n)$隐含的常数因子
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="快速排序简介"><a href="#快速排序简介" class="headerlink" title="快速排序简介"></a>快速排序简介</h2><p>快排最坏情况$O( n^2 )$，但平均效率$O(n lg n)$，而且$O(n lg n)$隐含的常数因子很小，快排可以说是最快的排序算法，并非浪得虚名。另外它还是原址排序。</p><p>快速排序是基于分治模式的：</p><ul><li>分解：数组A【p..r】被划分成两个（可能空）子数组A【p..q-1】和A【q+1..r】，使得A【p..q-1】中的每个元素都小于等于A(q)，而且，小于等于A【q+1..r】中的元素。计算下标q也是划分过程中的一部分。</li><li>解决：通过递归调用快速排序，对子数组A【p..q-1】和A【q+1..r】排序。</li><li>合并：因为两个子数组是原址排序的，将它们的合并不需要操作：整个数组A【p..r】已排序。</li></ul><p>快排的伪码：<br><img src="https://images2.imgbox.com/e6/39/ffgJfqit_o.jpg" alt=""></p><p>其中对数组的划分：<code>Partition</code>是快排算法的关键，，它对子数组A【p..r】进行原址重排）。<br><img src="https://images2.imgbox.com/7e/a5/T2zKB1UV_o.jpg" alt=""></p><h2 id="快速排序Python实现"><a href="#快速排序Python实现" class="headerlink" title="快速排序Python实现"></a>快速排序Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    x = A[r]</div><div class="line">    i = p - <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):  <span class="comment"># not r-1, but r</span></div><div class="line">        <span class="keyword">if</span> A[j] &lt; x:</div><div class="line">            i = i + <span class="number">1</span></div><div class="line">            A[i], A[j] = A[j], A[i]</div><div class="line">    A[r], A[i + <span class="number">1</span>] = A[i + <span class="number">1</span>], A[r]</div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">QUICKSORT</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = PARTITION(A, p, r)</div><div class="line">        QUICKSORT(A, p, q - <span class="number">1</span>)</div><div class="line">        QUICKSORT(A, q + <span class="number">1</span>, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</div><div class="line">    QUICKSORT(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)  <span class="comment"># all start from 0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">"  "</span>)</div></pre></td></tr></table></figure><h2 id="快速排序性能分析"><a href="#快速排序性能分析" class="headerlink" title="快速排序性能分析"></a>快速排序性能分析</h2><p>当数据量很小的时候，大概就十来个元素的小型序列，快排的优势并不明显，甚至比插入排序慢。但是一旦数据多，它的优势就充分发挥出来了。</p><p>举一个例子，<code>C++ STL</code> 中的<code>sort</code>函数，就充分发挥了快排的优势，并且取长补短，在数据量大时采用<code>QuickSort</code>，分段递归排序。一旦分段后的数据量小于某个门槛，为避免<code>QuickSort</code>递归调用带来过大的额外负荷，就改用插入排序。如果递归层次过深，还会改用<code>HeapSort</code>(堆排序，第六章刚讲)。所以说，C++的“混合兵种”sort的性能肯定会比C的qsort好。</p><p>快排的运行时间与Partition的划分有关：</p><ul><li><strong>最坏情况</strong>是输入的数组已经完全排好序，那么每次划分的左、右两个区域分别为n-1和0，效率为$O( n^2 )$.</li><li>而对于其他<strong>常数比例划分</strong>，哪怕是左右按9:1的比例划分，效果都是和在正中间划分一样快的（算法导论上有详细分析）</li><li>即，<strong>任何一种按照常数比例进行划分，总运行时间都是$\text{O}(n \text{lg} n)$</strong>。</li></ul><h2 id="快速排序的随机化版本"><a href="#快速排序的随机化版本" class="headerlink" title="快速排序的随机化版本"></a>快速排序的随机化版本</h2><p>随机抽样(random sampling):从$A[p..r]$中随机选一个元素作为主元，而不是始终采用$A[r]$作为主元。</p><p>随机化的快排的伪码如下：</p><p><img src="https://images2.imgbox.com/53/ea/JY82TS9f_o.jpg" alt="快速排序的随机化版本"></p><p>Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    x = A[r]</div><div class="line">    i = p - <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):  <span class="comment"># not r-1, but r</span></div><div class="line">        <span class="keyword">if</span> A[j] &lt; x:</div><div class="line">            i = i + <span class="number">1</span></div><div class="line">            A[i], A[j] = A[j], A[i]</div><div class="line">    A[r], A[i + <span class="number">1</span>] = A[i + <span class="number">1</span>], A[r]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RANDOMIZED_PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    rand_i = random.random()</div><div class="line">    <span class="comment"># print(round(a *(r - p)) + p)</span></div><div class="line">    rand_i = round(rand_i * (r - p) + p)  <span class="comment"># 区间的计算需要注意，否则不对</span></div><div class="line">    A[rand_i], A[r] = A[r], A[rand_i]</div><div class="line">    <span class="keyword">return</span> PARTITION(A, p, r)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RANDOMIZED_QUICKSORT</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = RANDOMIZED_PARTITION(A, p, r)</div><div class="line">        RANDOMIZED_QUICKSORT(A, p, q - <span class="number">1</span>)</div><div class="line">        RANDOMIZED_QUICKSORT(A, q + <span class="number">1</span>, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</div><div class="line">    RANDOMIZED_QUICKSORT(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)  <span class="comment"># all start from 0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">"  "</span>)</div></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>算法导论 中文 第三版</li><li><a href="http://blog.csdn.net/shuangde800/article/details/7599509" target="_blank" rel="external">【算法导论】排序 （三）：快速排序 深入分析</a></li><li><a href="http://www.runoob.com/python/func-number-random.html" target="_blank" rel="external">Python random() 函数</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/11/algorithm_tutorial_charpter_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(5) 第六章堆排序</title>
      <link>http://wangwlj.com/2018/01/09/algorithm_tutorial_charpter_6/</link>
      <guid>http://wangwlj.com/2018/01/09/algorithm_tutorial_charpter_6/</guid>
      <pubDate>Tue, 09 Jan 2018 13:27:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;在第二章介绍了两种排序算法，第六章将介绍第三种排序算法：堆排序(heapsort)，以及基于堆排序的优先队列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fn9epgz0rbj20k006rjs1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在第二章介绍了两种排序算法，第六章将介绍第三种排序算法：堆排序(heapsort)，以及基于堆排序的优先队列。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn9epgz0rbj20k006rjs1.jpg" alt=""></p><a id="more"></a><p>空间原址性(in place)：仅有常数个元素需要在排序过程中存储在数组之外。</p><h2 id="堆-6-1-P84"><a href="#堆-6-1-P84" class="headerlink" title="堆(6.1, P84)"></a>堆(6.1, P84)</h2><p>堆，也叫 二叉堆，是一个数组，可以看作近似的完全二叉树，树的每个节点对应数组一个元素。</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fn9epgz0rbj20k006rjs1.jpg" alt=""></p><p>表示堆的数组<code>A</code>包括两个属性：<code>A.length</code>给出数组元素的个数；<code>A.heap-size</code>给出有多少个元素存储在该数组中。即heap-size是数组的有效元素。</p><p>给定下标<code>i</code>，很容易计算其父节点、左节点和右节点：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div></pre></td></tr></table></figure></p><blockquote><p>这三个函数通常以宏或者内联函数的方式实现。</p></blockquote><p>二叉堆分为两种形式：最大堆和最小堆。<br>最大堆满足：A[PARENT(i)] ≥ A[i] ，即：某个节点的值最多与其父节点一样大；最小堆满足：A[PARENT(i)] ≤ A[i]。</p><p>堆排序算法采用的是最大堆。最小堆通常用于构造优先队列。</p><p>堆的高度为：$Θ(lgn)$</p><h2 id="维持堆的性质（6-2，P86）"><a href="#维持堆的性质（6-2，P86）" class="headerlink" title="维持堆的性质（6.2，P86）"></a>维持堆的性质（6.2，P86）</h2><p><code>MAX-HEAPIFY</code>：输入为一个数组A和一个下标i，A[i]有可能小于其孩子，通过让A[i]在数组中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆的性质。</p><p>该函数伪码表示为：<br><img src="https://images2.imgbox.com/54/2c/3rWF8zSL_o.png" alt="MAX-HEAPIFY伪码"></p><p>算法图示：<br><img src="https://images2.imgbox.com/71/85/6tJrJVIS_o.png" alt=""></p><p>Python实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= len(A) <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= len(A) <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest)</div></pre></td></tr></table></figure></p><p>每个孩子的子树最多为2n/3（不太理解这句话？？）。<br>所以，在最差情况下（最底层恰好半满）运行时间为：<br>$$T(n) = T(2n/3)+ \Theta(1)$$<br>上述递归式的解为：$T(n) = \text{O} (\text{lg}n)$</p><h2 id="建堆-6-3-P87"><a href="#建堆-6-3-P87" class="headerlink" title="建堆(6.3, P87)"></a>建堆(6.3, P87)</h2><p>子数组元素$A[ (\lfloor n/2\rfloor +1),\cdots,n]$是树中的所有叶节点。<br><code>BUILD_MAX_HEAP</code>从非叶节点开始一直循环到根节点。</p><p><img src="https://images2.imgbox.com/02/43/BH6sysvA_o.png" alt=""></p><p>Python实现为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUILD_MAX_HEAP</span><span class="params">(A)</span>:</span></div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(floor(heap_size / <span class="number">2</span>)), <span class="number">0</span>, <span class="number">-1</span>):</div><div class="line">        MAX_HEAPIFY(A, i)</div></pre></td></tr></table></figure></p><p><code>BUILD_MAX_HEAP</code> 的时间复杂度为$T(n) = \text{O}(n)$</p><h2 id="堆排序算法-6-4，P89"><a href="#堆排序算法-6-4，P89" class="headerlink" title="堆排序算法(6.4，P89)"></a>堆排序算法(6.4，P89)</h2><p>伪代码：<br><img src="https://images2.imgbox.com/5d/94/xcT4QVgb_o.png" alt=""></p><p>Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAPSORT</span><span class="params">(A)</span>:</span></div><div class="line">    BUILD_MAX_HEAP(A)</div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A), <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">        A[<span class="number">1</span> - <span class="number">1</span>], A[i - <span class="number">1</span>] = A[i - <span class="number">1</span>], A[<span class="number">1</span> - <span class="number">1</span>]  <span class="comment"># exchage A[i] with A[1]</span></div><div class="line">        heap_size = heap_size - <span class="number">1</span></div><div class="line">        MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div></pre></td></tr></table></figure></p><p><code>HEAPSORT</code>过程的时间复杂度为：$\text{O}(n\text{lg}n)$，因为<code>BUILD_MAX_HEAP</code>的时间复杂度为$\text{O}(n)$，n-1次调用<code>MAX_HEAPIFY</code>，每次时间为$\text{O}(\text{lg}n)$。</p><h2 id="堆排序的Python完整实现"><a href="#堆排序的Python完整实现" class="headerlink" title="堆排序的Python完整实现"></a>堆排序的Python完整实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i, size)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= size <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= size <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest, size)</div><div class="line">        </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">BUILD_MAX_HEAP</span><span class="params">(A)</span>:</span></div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(floor(heap_size / <span class="number">2</span>)), <span class="number">0</span>, <span class="number">-1</span>):</div><div class="line">        MAX_HEAPIFY(A, i, heap_size)</div><div class="line">        </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAPSORT</span><span class="params">(A)</span>:</span></div><div class="line">    BUILD_MAX_HEAP(A)</div><div class="line">    heap_size = len(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A), <span class="number">1</span>, <span class="number">-1</span>):</div><div class="line">        A[<span class="number">1</span> - <span class="number">1</span>], A[i - <span class="number">1</span>] = A[i - <span class="number">1</span>], A[<span class="number">1</span> - <span class="number">1</span>]  <span class="comment"># exchage A[i] with A[1]</span></div><div class="line">        heap_size = heap_size - <span class="number">1</span></div><div class="line">        MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># A = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]</span></div><div class="line">    <span class="comment"># MAX_HEAPIFY(A, 2)</span></div><div class="line">    <span class="comment"># for i in range(0, len(A)):</span></div><div class="line">    <span class="comment">#     print(A[i], end=" ")</span></div><div class="line">    <span class="comment"># A = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7]</span></div><div class="line">    <span class="comment"># BUILD_MAX_HEAP(A)</span></div><div class="line">    <span class="comment"># for i in range(0, len(A)):</span></div><div class="line">    <span class="comment">#     print(A[i], end=" ")</span></div><div class="line">    A = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</div><div class="line">    HEAPSORT(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">" "</span>)</div></pre></td></tr></table></figure><h2 id="优先队列-6-5，P90"><a href="#优先队列-6-5，P90" class="headerlink" title="优先队列(6.5，P90)"></a>优先队列(6.5，P90)</h2><p>优先队列：是一种用来维护由一组元素构成的集合S的数据结果，其中的每个元素都有一个相关的值，称为关键字。优先队列也有两种形式：最大优先队列和最小优先队列。</p><p>最大优先队列的应用：共享计算机系统的作业调度。<br>最小优先队列被用于基于事件驱动的模拟器。队列中保存要模拟的事件，每个事件都有一个发生事件作为关键词。</p><p>优先队列可以用堆来实现。优先队列的元素对应应用程序的对象，堆中每个元素存储对象的句柄(handle)。</p><p>最大优先队列支持：</p><ul><li>对最大优先队列进行插入，<code>MaxHeapInsert</code>；</li><li>返回最大优先队列的最大值，<code>HeapMax</code>；</li><li>去掉最大值并且返回该值，<code>HeapExtractMax</code>；</li><li>将第x个元素的值改为k，其中k&gt;=x的原来的值，<code>HeapIncreaseKey</code>；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_MAXIMUM</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">return</span> A[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_EXTRACT_MAX</span><span class="params">(A, heap_size)</span>:</span></div><div class="line">    <span class="keyword">if</span> heap_size &lt; <span class="number">1</span>:</div><div class="line">        print(<span class="string">"ERROR!! Heap underflow!!"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    max_A = A[<span class="number">1</span> - <span class="number">1</span>]</div><div class="line">    A[<span class="number">1</span> - <span class="number">1</span>] = A[heap_size - <span class="number">1</span>]</div><div class="line">    heap_size = heap_size - <span class="number">1</span></div><div class="line">    MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line">    <span class="keyword">return</span> max_A</div></pre></td></tr></table></figure><p><code>HeapExtractMax</code>的操作复杂度为$\text{O}(\text{lg}n)$（也就是<code>MAX_HEAPIFY</code>的复杂度）。</p><h2 id="最大优先队列的Python完整实现："><a href="#最大优先队列的Python完整实现：" class="headerlink" title="最大优先队列的Python完整实现："></a>最大优先队列的Python完整实现：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARENT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> i / <span class="number">2</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAPIFY</span><span class="params">(A, i, heap_size)</span>:</span></div><div class="line">    l = LEFT(i)</div><div class="line">    r = RIGHT(i)</div><div class="line">    largest = <span class="number">-1</span></div><div class="line">    <span class="keyword">if</span> l &lt;= heap_size <span class="keyword">and</span> A[l - <span class="number">1</span>] &gt; A[i - <span class="number">1</span>]:</div><div class="line">        largest = l</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        largest = i</div><div class="line">    <span class="keyword">if</span> r &lt;= heap_size <span class="keyword">and</span> A[r - <span class="number">1</span>] &gt; A[largest - <span class="number">1</span>]:</div><div class="line">        largest = r</div><div class="line"></div><div class="line">    <span class="keyword">if</span> largest != i:</div><div class="line">        A[i - <span class="number">1</span>], A[largest - <span class="number">1</span>] = A[largest - <span class="number">1</span>], A[i - <span class="number">1</span>]</div><div class="line">        MAX_HEAPIFY(A, largest, heap_size)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_MAXIMUM</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">return</span> A[<span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_EXTRACT_MAX</span><span class="params">(A, heap_size)</span>:</span></div><div class="line">    <span class="keyword">if</span> heap_size &lt; <span class="number">1</span>:</div><div class="line">        print(<span class="string">"ERROR!! Heap underflow!!"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span></div><div class="line">    max_A = A[<span class="number">1</span> - <span class="number">1</span>]</div><div class="line">    A[<span class="number">1</span> - <span class="number">1</span>] = A[heap_size - <span class="number">1</span>]</div><div class="line">    heap_size = heap_size - <span class="number">1</span></div><div class="line">    MAX_HEAPIFY(A, <span class="number">1</span>, heap_size)</div><div class="line">    <span class="keyword">return</span> max_A</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAP_INCREASE_KEY</span><span class="params">(A, i, key)</span>:</span></div><div class="line">    <span class="keyword">if</span> key &lt; A[i - <span class="number">1</span>]:</div><div class="line">        print(<span class="string">"ERROR!! New key is smaller than current key!!!"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    A[i - <span class="number">1</span>] = key</div><div class="line">    <span class="keyword">while</span> i &gt; <span class="number">1</span> <span class="keyword">and</span> A[int(PARENT(i) - <span class="number">1</span>)] &lt; A[int(i - <span class="number">1</span>)]:</div><div class="line">        A[int(PARENT(i) - <span class="number">1</span>)], A[int(i - <span class="number">1</span>)] = A[int(i - <span class="number">1</span>)], A[int(PARENT(i) - <span class="number">1</span>)]</div><div class="line">        i = PARENT(i)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_HEAP_INSERT</span><span class="params">(A, key)</span>:</span></div><div class="line">    MAX_INT = <span class="number">0x7fffffff</span></div><div class="line">    heap_size = len(A) + <span class="number">1</span></div><div class="line">    A.append(- MAX_INT)  <span class="comment"># 尾部追加元素</span></div><div class="line">    HEAP_INCREASE_KEY(A, heap_size, key)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">16</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]</div><div class="line">    MAX_HEAP_INSERT(A, <span class="number">9</span>)  <span class="comment"># 调用的数值都是从1开始。</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">" "</span>)</div></pre></td></tr></table></figure><p>算法基本思想：在末尾新插入一个元素，按照最大堆的要求排列好就行。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>算法导论 中文 第三版</li><li><a href="http://blog.csdn.net/u010183397/article/details/46882099" target="_blank" rel="external">算法导论 第六章：堆排序</a></li><li><a href="http://blog.csdn.net/xjm199/article/details/18039023" target="_blank" rel="external">最大优先队列–【算法导论】</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/09/algorithm_tutorial_charpter_6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>动手实现atoi函数—— Leetcode(8)</title>
      <link>http://wangwlj.com/2018/01/09/leetcode_8/</link>
      <guid>http://wangwlj.com/2018/01/09/leetcode_8/</guid>
      <pubDate>Tue, 09 Jan 2018 07:32:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;题目链接：&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;8. String to Integer (atoi)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Implement atoi to convert a string to an integer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hint&lt;/strong&gt;: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>题目链接：<a href="https://leetcode.com/problems/string-to-integer-atoi/description/" target="_blank" rel="external">8. String to Integer (atoi)</a></p><p>Implement atoi to convert a string to an integer.</p><p><strong>Hint</strong>: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p><a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现将<code>string</code>转化为<code>int</code>的<code>atoi</code>函数。这题需要充分考虑各种不规范输入的情况，主要有以下几种情况：</p><ol><li>忽略前面的所有空格直到非空格出现。从该字符开始，有可能是正负号，然后紧跟着一系列数字。</li><li>在数字的尾部有可能有一些无关的附加字符，也需要忽略它们。</li><li>如果第一个非空格字符不是有效数（即不是+-或者数字），则返回0。</li><li>如果string为空，或者仅有空格，则返回0。</li><li>如果最终结果超过int的范围，则返回int的最大/最小值。</li></ol><p>提供几个测试样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Input:&quot;2147483648&quot;     Expected:2147483647  //溢出的情况</div><div class="line">//Input:&quot;+&quot;              Expected:0 //不合法的情况 </div><div class="line">//Input:&quot;+-2&quot;            Expected:0 //不合法的情况 </div><div class="line">// Input: &quot;  123&quot; //有空格的情况</div><div class="line">// Input:&quot;-123&quot;   //有负数的情况</div><div class="line">// Input:&quot;+123&quot;   //有+号的情况</div></pre></td></tr></table></figure></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>先给出我自己折腾的一个解法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_atoi</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INT_MAX = <span class="number">0x7fffffff</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INT_MIN = <span class="number">0x80000000</span>;</div><div class="line">    <span class="keyword">int</span> len = str.size();</div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(str[index] == <span class="string">' '</span> &amp;&amp; index &lt; len)&#123;</div><div class="line">        index ++; <span class="comment">// 跳过空格</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>; <span class="comment">//符号位</span></div><div class="line">    <span class="keyword">long</span> l = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index; i&lt; len; ++i)&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)</div><div class="line">            <span class="keyword">if</span>(<span class="string">'0'</span>&lt;= str[i+<span class="number">1</span>] &amp;&amp; str[i+<span class="number">1</span>] &lt;= <span class="string">'9'</span>)</div><div class="line">                sign = (str[i] == <span class="string">'-'</span>)? <span class="number">-1</span> : <span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">'0'</span>&lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) </div><div class="line">        &#123;</div><div class="line">            l = l * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>); <span class="comment">// 字符0对应的10进制为48，可以直接减去48</span></div><div class="line">            <span class="keyword">if</span>(l * sign &gt; INT_MAX)&#123;</div><div class="line">                <span class="keyword">return</span> INT_MAX;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l * sign &lt; INT_MIN)&#123;</div><div class="line">                <span class="keyword">return</span> INT_MIN;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> l  * sign;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>主要思路就是：从左向右，先忽略空格；然后空格之后第一位有三种可能：</p><ul><li>如果是“+-”号，则第二位必须是数字才记上正负号，否则返回0；</li><li>如果是数字，直到遇到非数字结束；</li><li>如果不是上述情况，则返回0。</li></ul><p>这边再给出一个<a href="https://leetcode.com/problems/string-to-integer-atoi/discuss/4642" target="_blank" rel="external">简洁的写法</a>，具体思路类似。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_atoi</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> indicator = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=str.size();)</div><div class="line">    &#123;</div><div class="line">        i = str.find_first_not_of(<span class="string">' '</span>);</div><div class="line">        <span class="keyword">if</span>(str[i] == <span class="string">'-'</span> || str[i] == <span class="string">'+'</span>)</div><div class="line">            indicator = (str[i++] == <span class="string">'-'</span>)? <span class="number">-1</span> : <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(<span class="string">'0'</span>&lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) </div><div class="line">        &#123;</div><div class="line">            result = result*<span class="number">10</span> + (str[i++]-<span class="string">'0'</span>);</div><div class="line">            <span class="keyword">if</span>(result*indicator &gt;= INT_MAX) <span class="keyword">return</span> INT_MAX;</div><div class="line">            <span class="keyword">if</span>(result*indicator &lt;= INT_MIN) <span class="keyword">return</span> INT_MIN;                </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result*indicator;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注：原先<code>for(int i = 0; i&lt;=str.size();)</code>中并不包含等号，会导致空串时无返回值的错误。因此加上等于号。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/09/leetcode_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo博客彻底解决置顶问题</title>
      <link>http://wangwlj.com/2018/01/09/blog_pin_post/</link>
      <guid>http://wangwlj.com/2018/01/09/blog_pin_post/</guid>
      <pubDate>Tue, 09 Jan 2018 02:53:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;https://images2.imgbox.com/e8/af/g8uPUalf_o.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="https://images2.imgbox.com/e8/af/g8uPUalf_o.png" alt=""><br><a id="more"></a></p><h2 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h2><p>一种方法是手动对相关文件进行修改，具体可参考<a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="external">这篇文章</a>。</p><p>另一种方法就是，目前已经有修改后支持置顶的<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="external">仓库</a>，可以直接用以下命令安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> npm uninstall hexo-generator-index --save</div><div class="line"><span class="meta">$</span> npm install hexo-generator-index-pin-top --save</div></pre></td></tr></table></figure><p>然后在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code>即可。比如下面这篇文章：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">---</span></div><div class="line"><span class="attr">title:</span> <span class="string">hexo+GitHub博客搭建实战</span></div><div class="line"><span class="attr">date:</span> <span class="number">2017</span><span class="bullet">-09</span><span class="bullet">-08</span> <span class="number">12</span><span class="string">:00:25</span></div><div class="line"><span class="attr">categories:</span> <span class="string">博客搭建系列</span></div><div class="line"><span class="attr">top:</span> <span class="literal">true</span></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></figure><p>到目前为止，置顶功能已经可以实现了。所有相关博文到这边就结束了。</p><p>不过置顶的文章显示在最上面之后，如果没有明确的置顶标志，是不是感觉有点怪怪的呢？</p><h2 id="设置置顶标志"><a href="#设置置顶标志" class="headerlink" title="设置置顶标志"></a>设置置顶标志</h2><p>打开：<code>/blog/themes/next/layout/_macro</code> 目录下的<code>post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入如下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;% if post.top %&#125;</div><div class="line">  <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-thumb-tack"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">7D26CD</span>&gt;</span>置顶<span class="tag">&lt;/<span class="name">font</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p><p>效果展示：<br><img src="https://images2.imgbox.com/e8/af/g8uPUalf_o.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="external">解决Hexo博客文章置顶问题</a></li><li><a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="external">解决Hexo置顶问题</a></li><li><a href="http://jinfang.life/posts/e0bb97e1/" target="_blank" rel="external">Hexo主题的数据封装，样式渲染和扩展实例</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/09/blog_pin_post/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
