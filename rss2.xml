<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wangwlj&#39;s Blog</title>
    <link>http://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Sun, 21 Jan 2018 11:30:26 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>C++ Primer学习笔记：(十)泛型算法</title>
      <link>http://wangwlj.com/2018/01/20/CPP_10/</link>
      <guid>http://wangwlj.com/2018/01/20/CPP_10/</guid>
      <pubDate>Sat, 20 Jan 2018 15:00:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或者尾元素之后位置的迭代器。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或者尾元素之后位置的迭代器。</p><a id="more"></a><h2 id="概述（10-1，P336）"><a href="#概述（10-1，P336）" class="headerlink" title="概述（10.1，P336）"></a>概述（10.1，P336）</h2><p>大多数算法都定义在头文件<code>algorithm</code>中。标准库还在文件<code>numeric</code>中定义了一组数值泛型算法。</p><h2 id="初识泛型算法（10-2，P338）"><a href="#初识泛型算法（10-2，P338）" class="headerlink" title="初识泛型算法（10.2，P338）"></a>初识泛型算法（10.2，P338）</h2><p><code>accumulate</code>：定义在头文件<code>numeric</code>中。作用是对范围求和。</p><p><code>euqal</code>：定义在头文件<code>algorithm</code>中。作用是判断给定两个区间是否相等。假定第二个序列至少与第一个序列一样长。</p><p><code>fill</code>：定义在头文件algorithm中。作用是对给定区间全部赋予某值。</p><p><code>fill_n</code>：定义在头文件algorithm中。作用是对给定迭代器后的n个元素赋予某值。</p><p><code>back_inserter</code>：定义在头文件<code>iterator</code>中。得到指向容器尾部的迭代器。</p><h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>&#125;;</div><div class="line">sort(words.begin(),words.end());</div><div class="line"><span class="keyword">auto</span> end_unique = unique(words.begin(),words.end());</div><div class="line">words.erase(end_unique,words.end());</div></pre></td></tr></table></figure><p>消除重复单词的程序：使用到了下面这三个算法：</p><ul><li><code>sort</code>：定义在头文件<code>algorithm</code>中。对指定区间排序；</li><li><code>unique</code>：定义在头文件<code>algorithm</code>中。“消除”重复项，返回指向不重复值范围末尾的迭代器；</li><li><code>erase</code>：容器操作，而不是算法。删除指定范围内的元素。</li></ul><h2 id="定制操作（10-3）"><a href="#定制操作（10-3）" class="headerlink" title="定制操作（10.3）"></a>定制操作（10.3）</h2><h3 id="向算法传递函数（10-3-1）"><a href="#向算法传递函数（10-3-1）" class="headerlink" title="向算法传递函数（10.3.1）"></a>向算法传递函数（10.3.1）</h3><p><strong>谓词(predicate)</strong>是一个可调用的表达式，其返回结果是一个能用作条件的值。谓词分为：一元谓词和二元谓词。几元谓词接受几元参数。</p><p>使用谓词的排序版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>&#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Before: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = words.begin();iter != words.end(); ++iter)&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">"  "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">sort(words.begin(),words.end(), isShorter); <span class="comment">//使用谓词进行排序</span></div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After sort: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s: words)&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"  "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before: the  quick  red  fox  red  the  slow  </div><div class="line">After sort: the  red  fox  red  the  slow  quick</div></pre></td></tr></table></figure></p><p>可以看到三个字母的都在最前面，接着是长度为4,然后是长度为5的。</p><p>有时候我们希望长度相同的元素按照字典进行排序，此时可用<code>stable_sort</code>算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> s1.size() &lt; s2.size();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</div><div class="line"><span class="comment">//按字典顺序排序</span></div><div class="line">sort(words.begin(),words.end());</div><div class="line"></div><div class="line"><span class="keyword">auto</span> end_unique = unique(words.begin(),words.end());</div><div class="line">words.erase(end_unique,words.end());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>, <span class="string">"seen"</span>&#125;;</div><div class="line"></div><div class="line">elimDups(words);</div><div class="line"></div><div class="line">stable_sort(words.begin(), words.end(), isShorter);</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After stable_sort: "</span>;</div><div class="line"> <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s: words)&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"  "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出为：</p><blockquote><p><code>After sort: fox  red  the  seen  slow  quick</code></p></blockquote><h3 id="lambda表达式-10-3-2，P345"><a href="#lambda表达式-10-3-2，P345" class="headerlink" title="lambda表达式(10.3.2，P345)"></a>lambda表达式(10.3.2，P345)</h3><p>可调用对象：对于一个对象或一个表达式，如果可以对其使用调用运算符，则称为可调用的；可调用的对象有：函数、函数指针、重载函数调用运算符的类和<code>lambda</code>表达式。</p><p><code>lambda</code>表达式形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[capture list](parameter list)-&gt;return type&#123;function body&#125;;</div></pre></td></tr></table></figure></p><p><code>capture list</code>是一个<code>lambda</code>所在函数中定义的局部变量的列表（通常为空）；<br><code>return type</code>、<code>parameter list</code>和<code>function body</code>分别表示返回类型、参数列表和函数体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> s1.size() &lt; s2.size();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</div><div class="line"><span class="comment">//按字典顺序排序</span></div><div class="line">sort(words.begin(),words.end());</div><div class="line"></div><div class="line"><span class="keyword">auto</span> end_unique = unique(words.begin(),words.end());</div><div class="line">words.erase(end_unique,words.end());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type sz)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="comment">// 将words按字典序排序，删除重复单词</span></div><div class="line">elimDups(words); </div><div class="line"></div><div class="line"><span class="comment">// 按长度排序，长度相同的单词维持字典序</span></div><div class="line">stable_sort(words.begin(), words.end(), isShorter); </div><div class="line"></div><div class="line"><span class="comment">// 获取一个迭代器，指向第一个满足size()&gt;=sz的元素</span></div><div class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), [sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)&#123; <span class="keyword">return</span> a.size() &gt;= sz; &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 计算满足size&gt;=sz元素的数目</span></div><div class="line"><span class="keyword">auto</span> count = words.end() - wc;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">" "</span> &lt;&lt; ( (count&gt;<span class="number">1</span>) ? <span class="string">"word"</span> : <span class="string">"words"</span> ) &lt;&lt; <span class="string">" of length "</span> &lt;&lt; sz &lt;&lt; <span class="string">" or longer"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="comment">//打印长度大于等于给定值的单词，每个单词后面接一个空格</span></div><div class="line">for_each(wc,words.end(),[](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)&#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span>; &#125;);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>, <span class="string">"seen"</span>&#125;;</div><div class="line">biggies(words,<span class="number">4</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="lambda捕获与返回（10-3-3，P349）"><a href="#lambda捕获与返回（10-3-3，P349）" class="headerlink" title="lambda捕获与返回（10.3.3，P349）"></a>lambda捕获与返回（10.3.3，P349）</h3><p>捕获方式分为显式捕获、隐式捕获与混合使用。</p><p>显式捕获分为值捕获与引用捕获。<br>值捕获：与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是在调用时拷贝。</p><p>隐式捕获：在捕获列表写一个<code>&amp;</code>（引用捕获）或者<code>=</code>（值捕获）。</p><p>混合使用隐式捕获和显式捕获：捕获列表第一个元素必须是一个<code>&amp;</code>或<code>=</code>，并且显式捕获的变量必须采用与隐式捕获不同的方式。</p><h3 id="参数绑定（10-3-4，P354）"><a href="#参数绑定（10-3-4，P354）" class="headerlink" title="参数绑定（10.3.4，P354）"></a>参数绑定（10.3.4，P354）</h3><p>标准库<code>bind</code>函数：定义在头文件：<code>functional</code>；它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。</p><p>调用<code>bind</code>的形式：</p><blockquote><p>auto newCallable=bind(callable, arg_list);</p></blockquote><p><code>newCallable</code>本身是一个可调用对象，<code>arg_list</code>是一个逗号分隔的参数列表，对应给定的callable的参数。<code>arg_list</code>中的参数可能包含形如<code>_n</code>的名字，<code>_1</code>是<code>newCallable</code>的第一个参数,<code>_2</code>为第二个参数，依次类推。</p><p><code>_n</code>参数在命名空间<code>placeholders</code>中，需要如下声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</div></pre></td></tr></table></figure></p><p><code>bind</code>拷贝参数而不能拷贝<code>ostream</code>。我们可以使用<code>ref</code>函数。</p><p>函数<code>ref</code>返回一个对象，包含给定引用，此对象是可以拷贝的。标准库中还有一个<code>cref</code>函数，生成一个保存<code>const</code>引用的类。与<code>bind</code>一样，函数<code>ref</code>和<code>cref</code>也定义在头文件<code>functional</code>中。</p><h2 id="再探迭代器（10-4）"><a href="#再探迭代器（10-4）" class="headerlink" title="再探迭代器（10.4）"></a>再探迭代器（10.4）</h2><p>标准库在头文件<code>iterator</code>中定义了几种迭代器：</p><ul><li>插入迭代器：这些迭代器被绑定到一个容器上，可用来向容器插入元素。</li><li>流迭代器：这些迭代器被绑定到输入或输出流上，可用来遍历所有关联的IO流。</li><li>反向迭代器：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。</li><li>移动迭代器：这些专用的迭代器不是拷贝其中的元素，而是移动它们。</li></ul><h3 id="插入迭代器（10-4-1，P358）"><a href="#插入迭代器（10-4-1，P358）" class="headerlink" title="插入迭代器（10.4.1，P358）"></a>插入迭代器（10.4.1，P358）</h3><table><thead><tr><th>插入器的三种类型</th><th></th></tr></thead><tbody><tr><td>back_inserter</td><td>创建一个使用<code>push_back</code>的迭代器</td></tr><tr><td>front_inserter</td><td>创建一个使用<code>push_front</code>的迭代器</td></tr><tr><td>inserter</td><td>创建一个使用<code>insert</code>的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将插入到给定迭代器所表示的元素之前。</td></tr></tbody></table><p>练习10.28：分别使用上述三种插入迭代器将vector的内容拷贝到容器中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">9</span>; ++i)</div><div class="line">&#123;</div><div class="line">v.push_back(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; di, dbi, dfi;</div><div class="line">copy(v.begin(), v.end(), inserter(di, di.begin())); <span class="comment">// 接收两个参数</span></div><div class="line">copy(v.begin(), v.end(), back_inserter(dbi));</div><div class="line">copy(v.begin(), v.end(), front_inserter(dfi));</div></pre></td></tr></table></figure></p><p>三个插入器的最终结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inserter:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </div><div class="line">back_inserter:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </div><div class="line">front_inserter:<span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></div></pre></td></tr></table></figure></p><h3 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h3><h4 id="istream-iterator操作"><a href="#istream-iterator操作" class="headerlink" title="istream_iterator操作"></a>istream_iterator操作</h4><table><thead><tr><th><code>istream_iterator</code>操作</th><th>含义</th></tr></thead><tbody><tr><td><code>istream_iterator&lt;T&gt; in(is)</code></td><td>in从输入流is读取类型为T的值</td></tr><tr><td><code>istream_iterator&lt;T&gt; end;</code></td><td>读取类型为T的值的<code>istream_iterator</code>迭代器，表示尾后位置 （默认初始化）</td></tr><tr><td><code>in1 == in2</code></td><td>in1和in2必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同</td></tr><tr><td><code>in1 != in2</code></td><td>的输入，则两者相等</td></tr><tr><td><code>*in</code></td><td>返回从流中读取的值</td></tr><tr><td><code>in-&gt;mem</code></td><td>与<code>(*in).mem</code>的含义相同</td></tr><tr><td>++in,in++</td><td>使用元素类型所定义的&gt;&gt;运算符从输入流中读取下一值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值</td></tr></tbody></table><p>计算从标准输入的值的和：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in_iter(<span class="built_in">cin</span>), eof;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sum is: "</span> &lt;&lt; accumulate(in_iter, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><h4 id="ostream-iterator操作"><a href="#ostream-iterator操作" class="headerlink" title="ostream_iterator操作"></a>ostream_iterator操作</h4><table><thead><tr><th><code>ostream_iterator</code>操作</th><th>含义</th></tr></thead><tbody><tr><td><code>ostream_iterator&lt;T&gt; out(os);</code></td><td>out将类型为T的值写到输出流os中</td></tr><tr><td><code>ostream_iterator&lt;T&gt; out(os,d);</code></td><td>out将类型为T的值写到输出流os中，每个值后面都输出一个d。d指向一个空字符结尾的字符数组</td></tr><tr><td>out = val;</td><td>用<code>&lt;&lt;</code>运算符将val写入到out所绑定的ostream中。val的类型必须与out可写的类型兼容。</td></tr><tr><td><code>*out,++out,out++;</code></td><td>这些运算符是存在的，但不对out做任何事情。每个运算符都返回out</td></tr></tbody></table><p>使用流迭代器输出vector的内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</div><div class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; out_iter(<span class="built_in">cout</span>, <span class="string">" "</span>);</div><div class="line">copy(v.begin(),v.end(),out_iter);</div></pre></td></tr></table></figure></p><h3 id="反向迭代器（10-4-3，P363）"><a href="#反向迭代器（10-4-3，P363）" class="headerlink" title="反向迭代器（10.4.3，P363）"></a>反向迭代器（10.4.3，P363）</h3><p>sort函数正向与逆序排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</div><div class="line"></div><div class="line">sort(v.begin(),v.end());</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After sort: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = v.begin(); i != v.end(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">sort(v.rbegin(),v.rend());</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After reverse sort: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = v.begin(); i != v.end(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">After sort: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </div><div class="line">After reverse sort: <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></div></pre></td></tr></table></figure></p><p>使用反向迭代器逆序打印一个vector(练习10.34)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"逆序打印："</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = v.crbegin(); i != v.crend(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>输出结果为：</p><blockquote><p>逆序打印：8 9 2 6 4 7 1 5 3 </p></blockquote><p>使用<code>find</code>在一个int的<code>list</code>中查找最后一个值为<code>0</code>的元素（练习10.36）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> it = find(v.cbegin(),v.cend(),<span class="number">0</span>);</div><div class="line"><span class="keyword">auto</span> itr = find(v.crbegin(),v.crend(),<span class="number">0</span>);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代器的指向位置： "</span> &lt;&lt; *it &lt;&lt; *itr &lt;&lt;*(itr.base()) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After find: "</span> ;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = it; i != v.cend(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After reverse find: "</span> ;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = itr.base(); i != v.cend(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>输出为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">迭代器的指向位置： <span class="number">006</span></div><div class="line">After find: <span class="number">0</span> <span class="number">7</span> <span class="number">4</span> <span class="number">0</span> <span class="number">6</span> <span class="number">2</span> <span class="number">9</span> <span class="number">8</span> </div><div class="line">After reverse find: <span class="number">6</span> <span class="number">2</span> <span class="number">9</span> <span class="number">8</span></div></pre></td></tr></table></figure></p><h2 id="泛型算法结构（10-5）"><a href="#泛型算法结构（10-5）" class="headerlink" title="泛型算法结构（10.5）"></a>泛型算法结构（10.5）</h2><h3 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h3><table><thead><tr><th>迭代器类别</th><th></th></tr></thead><tbody><tr><td>输入迭代器</td><td>只读，不写；单遍扫描，只能递增</td></tr><tr><td>输出迭代器</td><td>只写，不读；单遍扫描，只能递增</td></tr><tr><td>前向迭代器</td><td>可读写，多遍扫描，只能递增</td></tr><tr><td>双向迭代器</td><td>可读写，多遍扫描，可递增递减</td></tr><tr><td>随机访问迭代器</td><td>可读写，多遍扫描，支持全部迭代器运算</td></tr></tbody></table><h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>4种算法形参模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alg(beg,end,other args);</div><div class="line">alg(beg,end,dest,other args);</div><div class="line">alg(beg,end,beg2,other args);</div><div class="line">alg(beg,end,beg2,end2,other args);</div></pre></td></tr></table></figure></p><p>其中，<code>alg</code>是算法的名字，<code>beg</code>和<code>end</code>是算法所操作的输入范围。<code>dest</code>、<code>beg2</code>和<code>end2</code>，都是迭代器参数。<br><code>dest</code>参数表示算法可以写入的目的位置的迭代器，算法假定：不管写入多少个元素都是安全的。</p><h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>一些算法使用重载参数形式传递一个谓词。</p><p><code>_if</code>版本的算法：接受一个元素值的算法通常有一个接受谓词版本的算法，加上后缀<code>_if</code></p><p>区分拷贝元素的版本和不拷贝元素的版本：重排元素的算法通常直接写回给定的输入序列，也可以将元素写到一个指定的输出目的的位置，此类算法在名字后面加上<code>_copy</code></p><h2 id="特定容器算法（10-6）"><a href="#特定容器算法（10-6）" class="headerlink" title="特定容器算法（10.6）"></a>特定容器算法（10.6）</h2><h3 id="list和forward-list成员函数版本的算法"><a href="#list和forward-list成员函数版本的算法" class="headerlink" title="list和forward_list成员函数版本的算法"></a>list和forward_list成员函数版本的算法</h3><table><thead><tr><th>list和forward_list成员函数版本的算法</th><th>含义</th></tr></thead><tbody><tr><td>lst.merga(lst2)   </td></tr><tr><td>lst.megra(lst2,comp)</td><td>将来自lst2的元素合并入lst。lst和lst2都必须是有序的。元素将从lst2中删除。在合并之后，lst2变成空。第一个版本使用&lt;运算符；第二个版本使用给定的比较操作。</td></tr><tr><td>lst.remove(val)</td></tr><tr><td>lst.remove_if(pred)</td><td>调用erase删除掉与给定值相等(==)或令一元谓词为真的每个元素</td></tr><tr><td>lst.reverse()</td><td>反转lst中元素的顺序</td></tr><tr><td>lst.sort() </td></tr><tr><td>lst.sort(comp)</td><td>使用&lt;或给定比较操作排序元素</td></tr><tr><td>lst.unique()</td></tr><tr><td>lst.unique(pred)</td><td>调用erase删除同一个值的连续拷贝。第一个版本使用==；第二个版本使用给定的二元谓词</td></tr></tbody></table><h3 id="list和forward-list的splice成员函数的参数"><a href="#list和forward-list的splice成员函数的参数" class="headerlink" title="list和forward_list的splice成员函数的参数"></a>list和forward_list的splice成员函数的参数</h3><table><thead><tr><th>lst.splice(args)或flst.splice_after(args)</th><th>含义</th></tr></thead><tbody><tr><td>(p,lst2)</td><td>p是一个指向lst中元素的迭代器，或一个指向flst首前位置的迭代器。函数将lst2的所有元素移动到lst中p之前的位置或是flst中p之后的位置。将元素从lst2中删除。lst2的类型必须与lst或flst相同，且不能是同一个链表。</td></tr><tr><td>(p,lst2,p2)</td><td>p2是一个指向lst2中位置的有效迭代器。将p2指向的元素移动到lst中，或将p2之后的元素移动到flst中。lst2可以是与lst或flst相同的链表。</td></tr><tr><td>(p,lst2,b,e)</td><td>b和e必须表示lst2中的合法范围。将给定范围中的元素从lst2移动到lst或flst。lst2与lst(或flst)可以是相同的链表，但p不能指向给定范围中元素。</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49800101" target="_blank" rel="external">C++primer第五版第九章学习笔记</a></li><li><a href="http://blog.csdn.net/libin1105/article/details/48676235" target="_blank" rel="external">《C++primer(第五版)》学习之路-第九章：顺序容器</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/20/CPP_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(九)顺序容器</title>
      <link>http://wangwlj.com/2018/01/18/CPP_09/</link>
      <guid>http://wangwlj.com/2018/01/18/CPP_09/</guid>
      <pubDate>Thu, 18 Jan 2018 13:56:55 GMT</pubDate>
      <description>
      
        &lt;p&gt;本章是第三章内容的扩展，完成本章的学习后，对标准库顺序容器知识的掌握就完整了。&lt;/p&gt;
&lt;p&gt;元素在顺序容器中的位置与其加入容器时的位置相对应。 标准库还定义了几种关联容器（第11章），关联容器中元素的位置由元素相关联的关键字决定。&lt;/p&gt;
&lt;p&gt;顺序容器有：&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;deque&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;forward_list&lt;/code&gt;、&lt;code&gt;array&lt;/code&gt;与&lt;code&gt;string&lt;/code&gt;。&lt;br&gt;容器适配器有：&lt;code&gt;stack&lt;/code&gt;、&lt;code&gt;queue&lt;/code&gt;与&lt;code&gt;priority_queue&lt;/code&gt;。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本章是第三章内容的扩展，完成本章的学习后，对标准库顺序容器知识的掌握就完整了。</p><p>元素在顺序容器中的位置与其加入容器时的位置相对应。 标准库还定义了几种关联容器（第11章），关联容器中元素的位置由元素相关联的关键字决定。</p><p>顺序容器有：<code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>、<code>array</code>与<code>string</code>。<br>容器适配器有：<code>stack</code>、<code>queue</code>与<code>priority_queue</code>。</p><a id="more"></a><h2 id="顺序容器概述（9-1，P292）"><a href="#顺序容器概述（9-1，P292）" class="headerlink" title="顺序容器概述（9.1，P292）"></a>顺序容器概述（9.1，P292）</h2><table><thead><tr><th>顺序容器类型</th><th>含义</th></tr></thead><tbody><tr><td>vector</td><td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢</td></tr><tr><td>deque</td><td>双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td></tr><tr><td>list</td><td>双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快</td></tr><tr><td>forward_list</td><td>单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快</td></tr><tr><td>array</td><td>固定大小数组。支持快速随机访问。不能添加或删除元素。</td></tr><tr><td>string</td><td>与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。</td></tr></tbody></table><p>以下是一些选择容器的基本原则：</p><p>⑴.除非你有很好的理由选择其他容器，否则应使用<code>vector</code></p><p>⑵.如果你的程序有很多小的元素，且额外开销很重要，则不要使用<code>list</code>或<code>forward_list</code></p><p>⑶.如果程序要求随机访问元素，应使用<code>vector</code>或<code>deque</code></p><p>⑷.如果程序需要<strong>在中间位置插入或删除元素</strong>，应使用<code>list</code>或<code>forward_list</code></p><p>⑸.如果程序需要<strong>在头尾位置插入或删除元素</strong>，但不会在中间位置进行插入或删除操作，则使用<code>deque</code></p><p>⑹.如果程序只有在读取输入时才需要再容器中间位置插入元素，随后需要随机访问元素，则</p><p>–首先，确定是否真的需要再容器中间位置添加元素。当处理输入数据时，通常可以很容易地向<code>vector</code>追加数据，然后再调用标准库的<code>sort</code>函数来重排容器中的元素，从而避免在中间位置添加元素。</p><p>–如果必须在中间位置插入元素，考虑在输入阶段使用<code>list</code>，一旦输入完成，将<code>list</code>中的内容拷贝到一个<code>vector</code>中。</p><h2 id="容器库概览（9-2，P294）"><a href="#容器库概览（9-2，P294）" class="headerlink" title="容器库概览（9.2，P294）"></a>容器库概览（9.2，P294）</h2><p>本节介绍对所有容器都适用的操作。</p><h3 id="容器操作表"><a href="#容器操作表" class="headerlink" title="容器操作表"></a>容器操作表</h3><table><thead><tr><th>类型别名</th><th></th></tr></thead><tbody><tr><td>iterator</td><td>此容器类型的迭代器类型</td></tr><tr><td>const_iterator</td><td>可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td>size_type</td><td>无符号整数类型，足够保存此种容器类型最大可能容器的大小</td></tr><tr><td>different_type</td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>reference</td><td>元素的左值类型；与value_type含义相同</td></tr><tr><td>const_reference</td><td>元素的const左值类型</td></tr></tbody></table><table><thead><tr><th>构造函数</th><th></th></tr></thead><tbody><tr><td>C c;</td><td>默认构造函数，构造空容器</td></tr><tr><td>C c1(c2);</td><td>构造c2的拷贝c1</td></tr><tr><td>C c(b,e);</td><td>构造c，将迭代器b和e指定范围内的元素拷贝到c(array不支持)</td></tr><tr><td>C c{a,b,c…};</td><td>列表初始化c</td></tr></tbody></table><table><thead><tr><th>赋值与swap</th><th></th></tr></thead><tbody><tr><td>c1 = c2</td><td>将c1中的元素替换为c2中元素</td></tr><tr><td>c1 = {a,b,c..}</td><td>将c1中的元素替换为列表中的元素</td></tr><tr><td>a.swap(b)</td><td>交换a和b的元素</td></tr><tr><td>swap(a,b)</td><td>与a.swap(b)等价</td></tr></tbody></table><table><thead><tr><th>大小</th><th></th></tr></thead><tbody><tr><td>c.size()</td><td>c中元素的数目（不支持forward_list）</td></tr><tr><td>c.max_size()</td><td>c可保存的的最大元素数目</td></tr><tr><td>c.empty()</td><td>若c中存储了元素，返回false，否则返回true</td></tr></tbody></table><table><thead><tr><th>添加/删除元素（不适用于array）</th><th></th></tr></thead><tbody><tr><td>注：在不同容器中，这些操作的接口都不同</td></tr><tr><td>c.insert(args)</td><td>将args中的元素拷贝进c</td></tr><tr><td>c.emplace(inits)</td><td>使用inits构造c中的一个元素</td></tr><tr><td>c.erase(args)</td><td>删除args指定的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素，返回void</td></tr></tbody></table><table><thead><tr><th>关系运算符</th><th></th></tr></thead><tbody><tr><td>==,!=</td><td>所有容器都支持相等（不等）操作</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>关系运算符(无序关联容器不支持)</td></tr></tbody></table><table><thead><tr><th>获取迭代器</th><th></th></tr></thead><tbody><tr><td>c.begin(),c.end()</td><td>返回指向c的首元素和尾元素之后位置的迭代器</td></tr><tr><td>c.cbegin(),c.cend()</td><td>返回const_iterator</td></tr></tbody></table><table><thead><tr><th>反向容器的额外成员</th><th></th></tr></thead><tbody><tr><td>reverse_iterator</td><td>按逆序寻址元素的迭代器</td></tr><tr><td>const_reverse_iterator</td><td>不能修改元素的逆序迭代器</td></tr><tr><td>c.rbegin(),c.rend()</td><td>返回指向c的尾元素和首元素之前位置的迭代器</td></tr><tr><td>c.crbegin(),c.crend()</td><td>返回const_reverse_iterator</td></tr></tbody></table><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器范围(<code>iterator range</code>)：<code>[begin,end)</code>，左闭合区间(<code>left-inclusive interval</code>)</p><p>迭代器的运算符（表3.6，P96）</p><table><thead><tr><th>迭代器的运算符</th><th>含义</th></tr></thead><tbody><tr><td><code>*iter</code></td><td>返回迭代器所指元素的引用</td></tr><tr><td>iter-&gt;mem</td><td>解引用iter并获取该元素的名为mem的成员，等价于<code>(*iter).mem</code></td></tr><tr><td>++iter</td><td>令iter指示容器中的下一个元素</td></tr><tr><td>++iter</td><td>令iter指示容器中的上一个元素</td></tr><tr><td>iter1 == iter2</td><td>判断两个迭代器是否相等（指向同一个位置则相等，包括尾后）</td></tr><tr><td>iter1 != iter2</td><td>判断两个迭代器是否不相等（指向同一个位置则相等，包括尾后）</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(begin != end)&#123;</div><div class="line">*begin = val;</div><div class="line">    ++begin;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果<code>begin</code>与<code>end</code>相等，则范围为空；如果<code>begin</code>与<code>end</code>不等，则范围至少包含一个元素，且<code>begin</code>指向该范围中的第一个元素；我们可以对<code>begin</code>递增若干次，使得<code>begin==end</code>。</p><h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3><h3 id="容器定义和初始化-9-2-4，P299"><a href="#容器定义和初始化-9-2-4，P299" class="headerlink" title="容器定义和初始化(9.2.4，P299)"></a>容器定义和初始化(9.2.4，P299)</h3><table><thead><tr><th>容器定义和初始化</th><th></th></tr></thead><tbody><tr><td>C c</td><td>默认构造函数。如果C是一个array，则c中元素按默认方式初始化，否则c为空</td></tr><tr><td><code>C c1(c2)</code> 与 <code>C c1 = c2</code></td><td>c1初始化为c2的拷贝。c1和c2必须是相同类型。</td></tr><tr><td><code>C c{a,b,c...}</code>与<code>C c = {a,b,c..}</code></td><td>c初始化为初始化列表中元素的拷贝。列表中元素的类型必须与C的元素类型相容。对于array类型，列表中元素数目必须等于或少于array的大小，任何遗漏的元素都进行值初始化。</td></tr><tr><td>C c(b,e)</td><td>c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与C的元素类型相容（对array不适用）</td></tr><tr><td>C seq(n)</td><td>seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的</td></tr><tr><td>C seq(n,t)</td><td>seq包含n个初始化为值t的元素</td></tr></tbody></table><p>$\color{red}{\heartsuit}$ <font color="0D54BD">只有顺序容器（不包括array）的构造函数才能接受大小参数。</font>关联容器并不支持。【上表中的倒数两个】</p><p>$\color{red}{\heartsuit}$ <font color="0D54BD">当一个容器初始化为另一个容器的拷贝时，两个容器的容器类型必须相同。</font></p><p>标准库array的大小也是类型的一部分。定义一个array时，除了指定元素类型，还需要指定容器大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,42&gt;</div><div class="line"><span class="built_in">array</span>&lt;<span class="built_in">string</span>,10&gt;::size_type i;</div></pre></td></tr></table></figure></p><h3 id="赋值与swap-9-2-5，P302"><a href="#赋值与swap-9-2-5，P302" class="headerlink" title="赋值与swap(9.2.5，P302)"></a>赋值与swap(9.2.5，P302)</h3><p>赋值、交换以及assign：</p><table><thead><tr><th>容器赋值运算</th><th></th></tr></thead><tbody><tr><td><code>c1 = c2</code></td><td>将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的类型</td></tr><tr><td><code>c = {a,b,c..}</code></td><td>将c1中元素替换为初始化列表中元素的拷贝</td></tr><tr><td><code>swap(c1,c2)</code>与<code>c1.swap(c2)</code>等价</td><td>交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多。</td></tr><tr><td><strong>assign操作不适用于关联容器和array</strong></td></tr><tr><td>seq.assign(b,e)</td><td>将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素</td></tr><tr><td>seq.assign(il)</td><td>将seq中的元素替换为初始化列表il中的元素</td></tr><tr><td>seq.assign(n,t)</td><td>将seq中的元素替换为n个值为t的元素 </td></tr></tbody></table><p>$\color{red}{\heartsuit}$ <font color="0D54BD">使用assign：允许我们使用不同但相容的类型赋值。</font></p><p>除了array外，swap不对任何元素进行拷贝、删除或者插入操作，因此可以保证常数时间内完成。<br>与其它容器不同，swap两个array会真正交换它们的元素。指针和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应的元素的值进行了交换。</p><p>除了string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。<br>特殊的，对一个string 调用swap会导致迭代器和指针失效。</p><p>forward_list支持max_size和empty，但不支持size。其它每个容器都有三个有关大小的操作。</p><h2 id="顺序容器操作-9-3，P305"><a href="#顺序容器操作-9-3，P305" class="headerlink" title="顺序容器操作(9.3，P305)"></a>顺序容器操作(9.3，P305)</h2><h3 id="向顺序容器中添加元素"><a href="#向顺序容器中添加元素" class="headerlink" title="向顺序容器中添加元素"></a>向顺序容器中添加元素</h3><table><thead><tr><th>向顺序容器添加元素的操作</th><th>含义</th></tr></thead><tbody><tr><td>c.push_back(t)</td><td>在c的尾部创建一个值为t或由args创建的元素，返回void</td></tr><tr><td>c.emplace_back(args)</td></tr><tr><td>c.push_front(t)</td><td>在c的头部创建一个值为t或由args创建的元素。返回void</td></tr><tr><td>c.emplace_front(args)</td></tr><tr><td>c.insert(p,t)</td><td>在迭代器p指向的元素<strong>之前</strong>创建一个值为t或由args创建的元素。返回指向新添加元素的迭 </td></tr><tr><td>c.emplace(p,args)</td><td>代器。 </td></tr><tr><td>c.insert(p,n,t)</td><td>在迭代器p指向的元素<strong>之前</strong>插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回p</td></tr><tr><td>c.insert(p,b,e)</td><td>将迭代器b和e指定的范围内的元素插入迭代器p指向的元素<strong>之前</strong>。b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回p</td></tr><tr><td>c.insert(p,il)</td><td>il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素<strong>之前</strong>。返回指向新添加的第一个元素的迭代器；若列表为空，则返回p</td></tr></tbody></table><table><thead><tr><th>添加元素操作</th><th>描述</th><th>vector</th><th>list</th><th>forward_list</th><th>array</th><th>deque</th></tr></thead><tbody><tr><td>push_back/emplace_back</td><td>尾部添加元素</td><td>ok</td><td>ok</td><td>不支持</td><td>不支持</td><td>ok</td></tr><tr><td>push_front/emplace_front</td><td>首部添加元素</td><td>不支持</td><td>ok</td><td>OK</td><td>不支持</td><td>ok</td></tr><tr><td>insert(p, t)/insert(p, n, t)/insert(p, b, e)/insert(p, {…})</td><td><strong>在指定p位置<font color="0D54BD">之前</font>插入元素</strong></td><td>ok</td><td>ok</td><td>有自己专用版本</td><td>不支持</td><td>ok</td></tr><tr><td>emplace</td><td>插入元素</td><td>ok</td><td>ok</td><td>有自己专用版本</td><td>不支持</td><td>ok</td></tr></tbody></table><p>添加元素会改变容器的大小，array不支持这些操作。forward_list有自己专有版本的insert和emplace。forward_list不支持push_back和emplace_back。</p><p>vector和string不支持push_front和emplace_front。将元素insert插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时。</p><p>emplace函数直接在容器中构造函数，传递给emplace函数的参数必须与元素类型相匹配。</p><h3 id="访问元素-9-3-2，P309"><a href="#访问元素-9-3-2，P309" class="headerlink" title="访问元素(9.3.2，P309)"></a>访问元素(9.3.2，P309)</h3><table><thead><tr><th>访问元素的操作</th><th>含义</th></tr></thead><tbody><tr><td>c.back()</td><td>返回c中尾元素的引用。若c为空，函数行为未定义</td></tr><tr><td>c.front()</td><td>返回c中首元素的引用。若c为空，函数行为未定义</td></tr><tr><td>c[n]</td><td>返回c中下标为n的元素的引用，n是一个无符号的整数。若n&gt;=c.size()，则函数行为未定义。</td></tr><tr><td>c.at(n)</td><td>返回下标为n的元素的引用。如果下标越界，则抛出一out_of_range异常。</td></tr></tbody></table><p>at和下标操作只适用于string,vector,deque和array。<br>back不适用于forward_list。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!c.empty())</div><div class="line">&#123;</div><div class="line">    c.front() = <span class="number">42</span>;</div><div class="line">    <span class="keyword">auto</span> &amp;v = c.back(); <span class="comment">// 获得指向最后一个元素的引用</span></div><div class="line">    v = <span class="number">1024</span>;</div><div class="line">    <span class="keyword">auto</span> v2 = c.back(); <span class="comment">// v2不是引用，只是c.back()的一个拷贝</span></div><div class="line">    v2 = <span class="number">0</span>; <span class="comment">// 没有改变c中的元素</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"v: "</span>&lt;&lt; v &lt;&lt;<span class="string">"  v2: "</span> &lt;&lt; v2 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果希望下标是合法的，可以使用at函数；如果下标越界，则抛出一个out_of_range异常。</p><h3 id="删除元素（9-3-3，P311）"><a href="#删除元素（9-3-3，P311）" class="headerlink" title="删除元素（9.3.3，P311）"></a>删除元素（9.3.3，P311）</h3><p>这些操作会改变容器大小，所以不适用于array；forward_list有特殊版本的erase；forward_list不支持pop_back；vector和string不支持pop_front。</p><table><thead><tr><th>删除元素操作</th><th>含义</th></tr></thead><tbody><tr><td>c.pop_back()</td><td>删除c中尾元素。若c为空，则函数行为未定义。函数返回void</td></tr><tr><td>c.pop_front()</td><td>删除c中首元素。若c为空，则函数行为未定义。函数返回void</td></tr><tr><td>c.erase(p)</td><td>删除迭代器p所指定的元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后(off_the_end)迭代器。若p是尾后迭代器，则函数行为未定义。</td></tr><tr><td>c.erase(b,e)</td><td>删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器</td></tr><tr><td>c.clear()</td><td>删除c中所有元素。返回void</td></tr></tbody></table><p>删除一个<code>list</code>中的所有奇数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</div><div class="line"><span class="keyword">auto</span> it = lst.begin();</div><div class="line"><span class="keyword">while</span>(it != lst.end())</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(*it % <span class="number">2</span>)  <span class="comment">// 如果是奇数</span></div><div class="line">        it = lst.erase(it); <span class="comment">//删除此元素，返回下一个元素</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        ++it; <span class="comment">// 递增</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="特殊的forward-list操作"><a href="#特殊的forward-list操作" class="headerlink" title="特殊的forward_list操作"></a>特殊的forward_list操作</h3><table><thead><tr><th>在forward_list中插入或删除元素的操作</th><th>含义</th></tr></thead><tbody><tr><td>lst.before_begin()</td><td>返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。</td></tr><tr><td>lst.cbefore_begin()</td><td>cbefore_begin()返回一个const_iterator</td></tr><tr><td>lst.insert_after(p,t)</td><td>在迭代器p之后的位置插入元素，t是一个对象</td></tr><tr><td>lst.insert_after(p,n,t)</td><td>t是一个对象，n是数量</td></tr><tr><td>lst.insert_after(p,b,e)</td><td>b和e是表示范围的一对迭代器(b和e不能指向lst内)</td></tr><tr><td>lst.insert_after(p,il)</td><td>il是一个花括号列表。</td></tr><tr><td>insert_after小结</td><td>返回一个指向最后一个插入的元素的迭代器。如果范围为空，则返回p。若p为尾后迭代器，则函数行为未定义</td></tr><tr><td>emplace_after(p,args)</td><td>使用args在p指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若p为尾后迭代器，则函数行为未定义。</td></tr><tr><td>lst.earse_after(p)</td><td>删除p指向的位置之后的元素，或删除从b之后直到(但不包含)e之间的元素。返回一个</td></tr><tr><td>lst.earse_after(b,e)</td><td>指向被删元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。如果p指向lst的尾元素或者是一个尾后迭代器，则函数行为未定义。</td></tr></tbody></table><p>删除一个<code>forward_list</code>中的所有奇数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">forward_list&lt;<span class="keyword">int</span>&gt; flst = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</div><div class="line"><span class="keyword">auto</span> curr = flst.begin();</div><div class="line"><span class="keyword">auto</span> prev = flst.before_begin();</div><div class="line"><span class="keyword">while</span>(curr != flst.end())</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(*curr % <span class="number">2</span>)</div><div class="line">        curr = flst.erase_after(prev);</div><div class="line">    <span class="keyword">else</span> </div><div class="line">        prev = curr++; <span class="comment">//或者 prev=curr; curr++; //或者 prev++;curr++; </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="改变容器大小（9-3-5，P314）"><a href="#改变容器大小（9-3-5，P314）" class="headerlink" title="改变容器大小（9.3.5，P314）"></a>改变容器大小（9.3.5，P314）</h3><table><thead><tr><th>顺序容器大小操作</th><th>含义</th></tr></thead><tbody><tr><td>c.resize(n)</td><td>调整c的大小为n个元素。若<code>n&lt;c.size()</code>，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化</td></tr><tr><td>c.resize(n,t)</td><td>调整c的大小为n个元素。任何新添加的元素都初始化为值t。</td></tr></tbody></table><p><code>resize</code>不适用于<code>array</code>。<code>resize</code>用来增大或者缩小容器。</p><h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>向容器添加元素之后：</p><p>⑴.如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未被重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。</p><p>⑵.对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</p><p>⑶.对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍然有效。</p><p>当我们删除一个元素后：</p><p>⑴.对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍然有效。</p><p>⑵.对于<code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被删除元素之外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。</p><p>⑶.对于<code>vector</code>和<code>string</code>，指向被删元素之前元素的迭代器、引用和指针仍然有效。</p><p>注：当我们删除元素时，尾后迭代器总是会失效。</p><p>$\color{red}{\heartsuit}$ <font color="0D54BD">由于向迭代器添加元素和从迭代器删除元素的代码可能会使得迭代器失效，因此必须保证每次改变容器的操作之后都能正确地重新定位迭代器。</font></p><p>$\color{red}{\heartsuit}$ <font color="0D54BD">添加或删除元素的循环过程必须反复调用end，而不能在循环之前保存end返回的迭代器。</font></p><h2 id="vector是如何增长的（9-4，P317）"><a href="#vector是如何增长的（9-4，P317）" class="headerlink" title="vector是如何增长的（9.4，P317）"></a>vector是如何增长的（9.4，P317）</h2><p>1.容器大小管理操作</p><p><code>shrink_to_fit</code>只使用于<code>vector</code>、<code>string</code>和<code>deque</code>；<code>capacity</code>和<code>reserve</code>只适用于<code>vector</code>和<code>string</code></p><table><thead><tr><th>容器大小管理操作</th><th>含义</th></tr></thead><tbody><tr><td>c.shrink_to_fit()</td><td>请将capacity()减少为与size()相同大小</td></tr><tr><td>c.capacity()</td><td>不重新分配内存空间的话，c可以保存多少元素</td></tr><tr><td>c.reserve(n)</td><td>分配至少能容纳n个元素的内存空间</td></tr></tbody></table><p>2.当添加的数超出了<code>vector</code>原本分配的最大容量，<code>vector</code>的实现采用的策略是在每次需要分配新内存空间时将当前容量翻倍。</p><p>程序测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= <span class="number">33</span>; ++i)&#123;</div><div class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span>&lt;&lt; vec.size() &lt;&lt;<span class="string">"capacity: "</span>&lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">       vec.push_back(i);</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h2 id="额外的string操作（9-5，P320）"><a href="#额外的string操作（9-5，P320）" class="headerlink" title="额外的string操作（9.5，P320）"></a>额外的string操作（9.5，P320）</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><table><thead><tr><th>构造string的其他方法</th><th>含义</th></tr></thead><tbody><tr><td>string s(cp,n)</td><td>s是cp指向的数组中前n个字符的拷贝。此数组至少应该包含n个字符。</td></tr><tr><td>string s(s2,pos2)</td><td>s是string s2从下标pos2开始的字符的拷贝。若pos2&gt;s2.size()，构造函数的行为未定义</td></tr><tr><td>string s(s2,pos2,len2)</td><td>s是string s2从下标pos2开始len2个字符的拷贝。若pos2&gt;s2.size()，构造函数的行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符。</td></tr></tbody></table><h3 id="子字符串操作"><a href="#子字符串操作" class="headerlink" title="子字符串操作"></a>子字符串操作</h3><p><code>s.substr(pos,n)</code>：返回一个<code>string</code>，包含s中从pos开始的n个字符的拷贝。<code>pos</code>的默认值为<code>0</code>。<code>n</code>的默认值为<code>s.size()-pos</code>，即拷贝从pos开始的所有字符。</p><h3 id="改变string的其他方法"><a href="#改变string的其他方法" class="headerlink" title="改变string的其他方法"></a>改变string的其他方法</h3><table><thead><tr><th>修改string的操作</th><th>含义</th></tr></thead><tbody><tr><td>s.insert(pos,args)</td><td>在pos之前插入args指定的字符。pos可以是一个下标或一个迭代器。接受下标的版本返回一个指向s的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td></tr><tr><td>s.earse(pos,len)</td><td>删除从位置pos开始的len个字符。如果len被省略，则删除从pos开始直至s末尾的所有字符。返回一个指向s的引用。</td></tr><tr><td>s.assign(args)</td><td>将s中的字符替换为args指定的字符。返回一个指向s的引用</td></tr><tr><td>s.append(args)</td><td>将args追加到s。返回一个指向s的引用</td></tr><tr><td>s.replace(range,args)</td><td>删除s中范围range内的字符，替换为args指定的字符。range或者是一个下标和一个长度，或者是一对指向s的迭代器。返回一个指向s的引用</td></tr></tbody></table><h3 id="string搜索操作（9-5-3，P325）"><a href="#string搜索操作（9-5-3，P325）" class="headerlink" title="string搜索操作（9.5.3，P325）"></a>string搜索操作（9.5.3，P325）</h3><p><code>string</code>类提供了6个不同的搜索函数，每个函数都有4个重载版本。</p><p>每个搜索操作都会返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。</p><p>如果搜索失败，则返回一个名为<code>string::npos</code>的static成员。标准库将<code>npos</code>定义成一个<code>const string::size_type</code>类型，并初始化为<code>-1</code>。</p><p><code>string</code>搜索函数返回<code>string::size_type</code>值，该类型时一个<code>unsigned</code>类型，因此我们应该尽量不要使用带符号类型来保存这些返回值。</p><table><thead><tr><th>string搜索操作</th><th>含义</th></tr></thead><tbody><tr><td>s.find(args)</td><td>查找s中args第一次出现的位置</td></tr><tr><td>s.rfind(args)</td><td>查找s中args最后一次出现的位置</td></tr><tr><td>s.find_first_of(args)</td><td>在s中查找args中任何一个字符第一次出现的位置</td></tr><tr><td>s.find_last_of(args)</td><td>　在s中查找args中任何一个字符最后第一次出现的位置</td></tr><tr><td>s.find_first_not_of(args)</td><td>在s中查找第一个不在args中的字符</td></tr><tr><td>s.find_last_not_of(args)</td><td>在s中查找最后一个不在args中的字符  </td></tr></tbody></table><table><thead><tr><th>args的形式</th><th>含义</th></tr></thead><tbody><tr><td>c,pos</td><td>从s中位置pos开始查找字符c。pos默认为0</td></tr><tr><td>s2,pos</td><td>从s中位置pos开始查找字符串s2。pos默认为0</td></tr><tr><td>cp,pos</td><td>从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串。pos默认为0</td></tr><tr><td>cp,pos,n</td><td>从s中位置pos开始查找指针cp指向的数组的前n个字符。pos和n无默认值</td></tr></tbody></table><h3 id="字符串比较函数-9-5-4，P327"><a href="#字符串比较函数-9-5-4，P327" class="headerlink" title="字符串比较函数(9.5.4，P327)"></a>字符串比较函数(9.5.4，P327)</h3><table><thead><tr><th>s.compare(args)中args形式</th><th>含义</th></tr></thead><tbody><tr><td>s2</td><td>比较s和s2</td></tr><tr><td>pos1,n1,s2</td><td>将s中从pos1开始的n1个字符与s2比较</td></tr><tr><td>pos1,n1,s2,pos2,n2</td><td>将s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符进行比较</td></tr><tr><td>cp</td><td>比较s与cp指向的以空字符结尾的字符数组</td></tr><tr><td>pos1,n1,cp</td><td>将s中从pos1开始的n1个字符与cp指向的以空字符结尾的字符数组进行比较</td></tr><tr><td>pos1,n1,cp,n2</td><td>将s中从pos1开始的n1个字符与cp指向的地址开始的n2个字符进行比较</td></tr></tbody></table><h3 id="string和数值之间的转换-9-5-5，P327"><a href="#string和数值之间的转换-9-5-5，P327" class="headerlink" title="string和数值之间的转换(9.5.5，P327)"></a>string和数值之间的转换(9.5.5，P327)</h3><p>string参数中第一个非空白符必须是符号(+或-)或数字。它可以以0x或0X开头来表示十六进制数。对那些将字符串转换为浮点值的函数，string参数也可以以小数点开头，并可有包含e或E来表示指数部分。对于那些将字符串转换为整型值的函数，根据基数不同，string参数可以包含字母字符，对应大于数字9的数</p><p>如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常。如果转换得到的数值无法用任何类型表示，则抛出一个out_of_range异常</p><table><thead><tr><th>string和数值之间的转换</th><th>含义</th></tr></thead><tbody><tr><td>to_string(val)</td><td>一组重载函数，返回数值val的string表示。val可以是任何算术类型。对每个浮点类型和int或更大的整型，都有相应版本的to_string。与往常一样，小整型会被提升。</td></tr><tr><td>stoi(s,p,b)</td><td>返回s的起始子串(表示整数内容)的数值，返回值类型分别是int,long,unsigned long,long long,</td></tr><tr><td>stol(s,p,b)</td><td>unsigned long long。b表示转换所用的基数，默认值是10。p是size_t指针，用来保存s中第一个</td></tr><tr><td>stoul(s,p,b)</td><td>非数值字符下标，p默认为0，即函数不保存下标。</td></tr><tr><td>stoll(s,p,b) </td></tr><tr><td>stoull(s,p,b) </td></tr><tr><td>stof(s,p)</td><td>返回s的起始子串(表示浮点数内容)的数值，返回值类型分别是float,double或long double。参数</td></tr><tr><td>stod(s,p)</td><td>p的作用于整数转换函数中一样</td></tr><tr><td>stold(s,p)</td></tr></tbody></table><h2 id="容器适配器（9-6，P329）"><a href="#容器适配器（9-6，P329）" class="headerlink" title="容器适配器（9.6，P329）"></a>容器适配器（9.6，P329）</h2><p>标准库定义了三个顺序容器适配器：<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，stack适配器接受一个顺序容器（除array或forward_list）。</p><p>所有容器适配器都支持的操作和类型：</p><table><thead><tr><th>容器适配器都支持的操作和类型</th><th>含义</th></tr></thead><tbody><tr><td>size_type</td><td>一种类型，足以保存当前类型的最大对象的大小</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>container_type</td><td>实现适配器的底层容器类型</td></tr><tr><td>A a;</td><td>创建一个名为a的空适配器</td></tr><tr><td>A a(c);</td><td>创建一个名为a的适配器，带有容器c的一个拷贝</td></tr><tr><td>关系运算符</td><td>每个适配器都支持所有关系运算符:==,!=,&lt;,&lt;=,&gt;,&gt;=，这些运算符返回底层容器的比较结果</td></tr><tr><td>a.empty()</td><td>若a包含任何元素，返回false，否则返回true</td></tr><tr><td>a.size()</td><td>返回a中元素数目</td></tr><tr><td>swap(a,b)</td><td>交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必须相同</td></tr><tr><td>a.swap(b)</td></tr></tbody></table><h3 id="栈适配器的其他操作"><a href="#栈适配器的其他操作" class="headerlink" title="栈适配器的其他操作"></a>栈适配器的其他操作</h3><table><thead><tr><th>栈适配器的其他操作</th><th>含义</th></tr></thead><tbody><tr><td>s.pop()</td><td>删除栈顶元素，但不返回该元素值</td></tr><tr><td>s.push(item)</td><td>创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，或者由args构造</td></tr><tr><td>s.emplace(args)</td></tr><tr><td>s.top()</td><td>返回栈顶元素，但不将元素弹出栈</td></tr></tbody></table><h3 id="queue和priority-queue的其他操作"><a href="#queue和priority-queue的其他操作" class="headerlink" title="queue和priority_queue的其他操作"></a><code>queue</code>和<code>priority_queue</code>的其他操作</h3><table><thead><tr><th><code>queue</code>和<code>priority_queue</code>的其他操作</th><th>含义</th></tr></thead><tbody><tr><td>q.pop()</td><td>返回queue的首元素或priority_queue的最高优先级元素，但不删除此元素</td></tr><tr><td>q.front()</td><td>返回首元素，但不删除此元素</td></tr><tr><td>q.back()</td><td>返回尾元素，但不删除此元素，只适用于queue</td></tr><tr><td>q.top()</td><td>返回优先级最高的元素，但不删除此元素，只适用于priority_queue</td></tr><tr><td>q.push(item)</td><td>在queue末尾或priority_queue中恰当的位置创建一个元素，其值为item，或者有args构造</td></tr><tr><td>q.emplace(args)</td></tr></tbody></table><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>适配器：adaptor<br>容器：container<br>迭代器范围：iterator range<br>首前迭代器： off-the-beginning iterator<br>尾后迭代器： off-the-end iterator<br>顺序容器： sequential container<br>左闭合区间： left-inclusive interval</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49800101" target="_blank" rel="external">C++primer第五版第九章学习笔记</a></li><li><a href="http://blog.csdn.net/libin1105/article/details/48676235" target="_blank" rel="external">《C++primer(第五版)》学习之路-第九章：顺序容器</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/18/CPP_09/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(八)IO类</title>
      <link>http://wangwlj.com/2018/01/17/CPP_08/</link>
      <guid>http://wangwlj.com/2018/01/17/CPP_08/</guid>
      <pubDate>Wed, 17 Jan 2018 05:18:49 GMT</pubDate>
      <description>
      
        &lt;p&gt;C++使用标准库类来处理面向流的输入和输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iostream处理控制台IO&lt;/li&gt;
&lt;li&gt;fstream处理命名文件IO&lt;/li&gt;
&lt;li&gt;stringstream完成内存string的IO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类fstream和stringstream都继承自iostream。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>C++使用标准库类来处理面向流的输入和输出：</p><ul><li>iostream处理控制台IO</li><li>fstream处理命名文件IO</li><li>stringstream完成内存string的IO</li></ul><p>类fstream和stringstream都继承自iostream。<br><a id="more"></a></p><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>头文件<code>iostream</code>包含所有<code>i/o</code>流所需的基本信息，并定义有四个标准<code>i/o</code>流对象：</p><ul><li>cin：标准输入流对象（与标准输入设备连接）</li><li>cout ：标准输出流（与标准输出设备连接）</li><li>cerr ：非缓冲的标准错误流（默认设备为显示器）</li><li>clog ：经缓冲的标准错误流（默认设备为打印机）</li></ul><p>IO对象没有拷贝或者赋值。</p><h3 id="条件状态-P8-1-1，P279"><a href="#条件状态-P8-1-1，P279" class="headerlink" title="条件状态(P8.1.1，P279)"></a>条件状态(P8.1.1，P279)</h3><p>IO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态(<code>condition state</code>)。</p><table><thead><tr><th style="text-align:center">条件状态</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">strm::iostate</td><td>由各个iostream类定义，用于定义条件状态</td></tr><tr><td style="text-align:center">strm::badbit</td><td>strm::iostate类型的值，用于指出被破坏的流</td></tr><tr><td style="text-align:center">strm::failbit</td><td>strm::iostate类型的值，用于指出失败的IO操作</td></tr><tr><td style="text-align:center">strm::eofbit</td><td>strm::iostate类型的值，用于指出流已经到达文件的结束符</td></tr><tr><td style="text-align:center">s.eof()</td><td>如果设置了流s的eofbit值，该函数返回true</td></tr><tr><td style="text-align:center">s.bad()</td><td>如果设置了流s的badbit值，该函数返回true</td></tr><tr><td style="text-align:center">s.fail()</td><td>如果设置了流s的failbit值，该函数返回true</td></tr><tr><td style="text-align:center">s.good()</td><td>如果流s处于有效状态，该函数返回true</td></tr><tr><td style="text-align:center">s.clear()</td><td>清空流s的所有状态，并设为true</td></tr><tr><td style="text-align:center">s.clear(flag)</td><td>给流s的某个条件状态位设置为true。flag，类型是strm::iostate</td></tr><tr><td style="text-align:center">s.setstate(flag)</td><td>给流s的添加指定条件。flag，类型是strm::iostate</td></tr><tr><td style="text-align:center">s.rdstate()</td><td>返回流s的当前条件，返回值类型是strm::iostate</td></tr></tbody></table><h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3><p><code>endl</code> 操纵符，用于输出一个换行符并刷新缓冲区。<br><code>flush</code>操纵符，用于刷新流，但不在输出中添加任何字符。<br><code>ends</code>操作符，这个操纵符在缓冲区中插入空字符<code>null</code>，然后刷新它。</p><blockquote><p>如果程序崩溃（异常终止），输出缓冲区不会刷新。</p></blockquote><h2 id="文件输入输出-8-2，P283"><a href="#文件输入输出-8-2，P283" class="headerlink" title="文件输入输出(8.2，P283)"></a>文件输入输出(8.2，P283)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>; <span class="comment">//构建一个ifstream并打开给定文件</span></div><div class="line">ofstream out; <span class="comment">//输出文件流，没有与任何文件关联</span></div><div class="line">out.open(iflie +<span class="string">".copy"</span>); <span class="comment">//打开指定的文件</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>(out)  <span class="comment">//检查open是否成功</span></div></pre></td></tr></table></figure><h3 id="文件模式-8-2-2，P286"><a href="#文件模式-8-2-2，P286" class="headerlink" title="文件模式(8.2.2，P286)"></a>文件模式(8.2.2，P286)</h3><p>文件模式有：<code>in</code>,  <code>out</code>,  <code>app</code>（append的缩写，追加模式，写操作前定位到文件末尾）,  <code>ate</code>,  <code>trunk</code>（截断文件）,  <code>binary</code>。</p><blockquote><p>保留<code>ofstream</code>打开的文件中已有数据的唯一方法：显式地指定<code>app</code>或<code>in</code>模式。</p></blockquote><h2 id="string流-8-3，P287"><a href="#string流-8-3，P287" class="headerlink" title="string流(8.3，P287)"></a>string流(8.3，P287)</h2><p>标准库定义了三种类型的字符串流：<br><code>istringstream</code>，由<code>istream</code>派生而来，提供读<code>string</code>的功能。<br><code>ostringstream</code>，由<code>ostream</code>派生而来，提供写<code>string</code>的功能。<br><code>stringstream</code>，由<code>iostream</code>派生而来，提供读写<code>string</code>的功能。</p><p>stringstream 特定的操作：</p><table><thead><tr><th>stringstream 特有的操作</th><th>含义</th></tr></thead><tbody><tr><td>sstream strm;</td><td>strm是一个未绑定的stringstream对象。sstream是头文件sstream中定义的一个类型</td></tr><tr><td>sstream strm(s);</td><td>strm是一个sstream对象，保存string s的一个拷贝。此构造函数是explict的。</td></tr><tr><td>strm.str()</td><td>返回strm所保存的string的拷贝</td></tr><tr><td>strm.str(s)</td><td>将string s拷贝到strm中。返回void</td></tr></tbody></table><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>继承： inheritance<br>条件状态： condition state<br>文件模式： file mode<br>文件流： file stream<br>字符串流： string stream</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49799679" target="_blank" rel="external">C++primer第五版第八章学习笔记</a></li><li><a href="http://blog.csdn.net/libin1105/article/details/48675765" target="_blank" rel="external">《C++primer(第五版)》学习之路-第八章：IO库</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/17/CPP_08/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(七)类</title>
      <link>http://wangwlj.com/2018/01/16/CPP_07/</link>
      <guid>http://wangwlj.com/2018/01/16/CPP_07/</guid>
      <pubDate>Tue, 16 Jan 2018 14:21:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;类是数据的抽象(&lt;code&gt;data abstraction&lt;/code&gt;)和封装(&lt;code&gt;encapsulation&lt;/code&gt;)。数据抽象是一种将接口(&lt;code&gt;interface&lt;/code&gt;)和实现(&lt;code&gt;implemention&lt;/code&gt;)分离的设计技术。接口是指用户可以对类使用的操作集。实现包括类的数据成员和接口函数体。封装使得类的使用者不必关注类内部是如何实现的，因为这些是类的设计者需要关注的。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>类是数据的抽象(<code>data abstraction</code>)和封装(<code>encapsulation</code>)。数据抽象是一种将接口(<code>interface</code>)和实现(<code>implemention</code>)分离的设计技术。接口是指用户可以对类使用的操作集。实现包括类的数据成员和接口函数体。封装使得类的使用者不必关注类内部是如何实现的，因为这些是类的设计者需要关注的。<br><a id="more"></a></p><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="类的定义和声明"><a href="#类的定义和声明" class="headerlink" title="类的定义和声明"></a>类的定义和声明</h3><p>类由类成员组成。类成员包括属性，字段，成员函数，构造函数，析构函数等组成。</p><p>类设计应该遵从抽象封装性。</p><p>类抽象性指对于类的使用者来说只需知道类接口即可使用类功能。类的具体实现由设计者负责。即使某个功能发生了变更但由于使用者是以接口方式调用类所以用户代码无需做任何修改。</p><p>类封装性指类用户只需知道类的功能无需了解具体实现。实现代码对用户来说不可见。</p><p>C++类没有访问级别限制，定义类时不能用<code>public</code> 或 <code>private</code> 做修饰。类成员有访问级别，可以定义 <code>public protect private</code>。</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>每一个类的内部都有一个隐含的this指针，该参数是由系统负责维护。它的类型是<code>CLASSTYPE *const this;</code>，即指向某个类的const指针。所以this指针在初始化以后就不能改变。系统使用this指针来指明函数使用的是哪个实例的数据成员。</p><p>在调用成员函数时，系统会自动传递类实例的地址给this指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CLASSTYPE exm;  </div><div class="line">exm.func();</div></pre></td></tr></table></figure></p><p>可以将该函数调用理解为：<code>CLASSTYPE::func(&amp;exm);</code></p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>在调用成员函数时，会传递类实例的地址给<code>this</code>指针。如果该实例是const对象，那么非const指针是无法指向const对象的。可以在函数参数列表后加上<code>const</code>来表明是const成员函数。</p><p>因此，this也是指向常量的指针。</p><h3 id="类的作用域与成员函数"><a href="#类的作用域与成员函数" class="headerlink" title="类的作用域与成员函数"></a>类的作用域与成员函数</h3><p>编译器分两步处理类：</p><ul><li>首先编译成员的声明，</li><li>然后编译成员函数体。</li></ul><p>因此，成员函数体可以随意使用类中的其他成员。（不管定义先后）</p><h3 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> Sales_data::avg_price() <span class="keyword">const</span>&#123;</div><div class="line"><span class="keyword">if</span>(units_old)</div><div class="line">    <span class="keyword">return</span> revenue/units_old;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Sales_data &amp; Sales_data::combine(<span class="keyword">const</span> Sales_data &amp;rhs) <span class="keyword">const</span>&#123;</div><div class="line">units_old += rhs.units_old; <span class="comment">//把rhs的成员加到this对象上</span></div><div class="line">    revenue += rhs.revenue;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回调用该函数的对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因此，执行<code>total.combine(trans)</code>语句时，是更新了变量total的值。</p><blockquote><p>引用类型返回左值。<code>return *this;</code>解引用this指针获得执行该函数的对象，也就是返回total的引用。</p></blockquote><h3 id="定义类相关的非成员函数-7-1-3-P234"><a href="#定义类相关的非成员函数-7-1-3-P234" class="headerlink" title="定义类相关的非成员函数(7.1.3,P234)"></a>定义类相关的非成员函数(7.1.3,P234)</h3><p>类的辅助函数，比如add，read和print等。概念上属于类的接口的组成部分，但实际上不属于类本身。</p><p>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件中。</p><h3 id="构造函数-7-1-4，P235"><a href="#构造函数-7-1-4，P235" class="headerlink" title="构造函数(7.1.4，P235)"></a>构造函数(7.1.4，P235)</h3><p>构造函数(<code>constructor</code>)是特殊的成员函数。在类对象定义时被调用。不能通过定义的类对象调用构造函数，<strong>构造函数可以定义多个或者说构造函数允许重载。</strong></p><p>如果没有定义任何构造函数，系统就会给类分配一个无参的默认构造函数(<code>default constructor</code>)，类只要定义了一个构造函数，编译器也不会再生成默认构造函数。只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。</p><p>定义类对象时不能写成 <code>Sales_item myobj();</code>，编译器会理解成：一个返回 Sales_item 类型叫 myobj的函数声明。 正确写法是去掉后面的括号。</p><p>构造函数<strong>不允许定义成 const</strong>，这样定义会产生语法错误： <code>Sales_item() const {};</code></p><p>构造函数在执行时会做类数据成员的初始化工作。从概念上讲，可以认为构造函数分两个阶段执行：（1）初始化阶段；（2）普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。</p><p>不管成员是否在构造函数初始化列表中显式初始化，类类型的数据成员总是在初始化阶段初始化。初始化发生在计算阶段开始之前。</p><h4 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Sales_data&#123;</div><div class="line"><span class="comment">//新增的构造函数</span></div><div class="line">Sales_data() = <span class="keyword">default</span>;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s): bookNo(s) &#123;&#125;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, unsighed n, <span class="keyword">double</span> p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//之前已有的其他成员</span></div><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</div><div class="line"><span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line"><span class="keyword">unsigned</span> units_old = <span class="number">0</span>;</div><div class="line"><span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码中，<code>= default</code>要求编译器生成默认构造函数。<br><code>Sales_data(const std::string &amp;s, unsighed n, double p): bookNo(s), units_sold(n), revenue(p*n) {}</code>中的冒号和花括号之间的部分叫做<font color="0AAA00"><strong>构造函数初始值列表</strong>(<code>constractor initialize list</code>)</font>。</p><blockquote><p>如果编译器不支持类内初始值，那么所有构造函数都应该显式地初始化每个内置类型的成员。</p></blockquote><p>当然也可以在类外定义构造函数。</p><h3 id="拷贝、赋值和析构-7-1-5，P239"><a href="#拷贝、赋值和析构-7-1-5，P239" class="headerlink" title="拷贝、赋值和析构(7.1.5，P239)"></a>拷贝、赋值和析构(7.1.5，P239)</h3><p>尽管编译器能为我们合成拷贝、赋值和析构的操作，但某些情况下可能无法正常工作。如分配和管理动态内存的类<code>（13.1.4, P447）</code>。</p><h2 id="访问控制与封装-7-2，P240"><a href="#访问控制与封装-7-2，P240" class="headerlink" title="访问控制与封装(7.2，P240)"></a>访问控制与封装(7.2，P240)</h2><p>访问说明符(<code>access specifiers</code>)：加强类的封装性：</p><ul><li>public：在整个程序内可被访问；</li><li>private：可以被类的成员函数访问。</li></ul><p><font color="0AAA00"><strong>使用class和struct唯一的区别就是默认的访问权限</strong></font>：<br><code>struct</code>默认是<code>public</code>，<code>class</code>默认是<code>private</code>。</p><h3 id="友元-7-2-1，P241"><a href="#友元-7-2-1，P241" class="headerlink" title="友元(7.2.1，P241)"></a>友元(7.2.1，P241)</h3><p>友元(<code>friend</code>)：<code>friend</code>关键字，允许其他类或者函数访问类的私有成员。</p><h2 id="类的其他特性-7-3，P243"><a href="#类的其他特性-7-3，P243" class="headerlink" title="类的其他特性(7.3，P243)"></a>类的其他特性(7.3，P243)</h2><p>可变数据成员(<code>mutable data member</code>)：永远不会是const，即使是const对象的成员。</p><p>类内初始值：必须以符号=或者花括号。</p><h3 id="返回-this的成员函数-7-3-2，P246"><a href="#返回-this的成员函数-7-3-2，P246" class="headerlink" title="返回*this的成员函数(7.3.2，P246)"></a>返回<code>*this</code>的成员函数(7.3.2，P246)</h3><p>返回值是调用对象的引用，返回引用的函数是左值的，意味着这些函数返回对象本身。</p><p>如果返回类型不是引用，则返回的是<code>*this</code>的副本。</p><h2 id="类的作用域-7-4，P253"><a href="#类的作用域-7-4，P253" class="headerlink" title="类的作用域(7.4，P253)"></a>类的作用域(7.4，P253)</h2><p>编译器处理完全部声明后，才会处理成员函数的定义。</p><h2 id="构造函数再探-7-5，P257"><a href="#构造函数再探-7-5，P257" class="headerlink" title="构造函数再探(7.5，P257)"></a>构造函数再探(7.5，P257)</h2><p>成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过<strong>构造函数初始值列表</strong>为这些成员提供初值。</p><h3 id="委托构造函数-7-5-2，P261"><a href="#委托构造函数-7-5-2，P261" class="headerlink" title="委托构造函数(7.5.2，P261)"></a>委托构造函数(7.5.2，P261)</h3><p>委托构造函数(<code>delegating constructor</code>)：使用使用所属类的其他构造函数执行自己的初始化过程。成员初始值列表唯一，是类名本身。</p><p><code>explicit</code>：抑制构造函数定义的隐式转换，只对一个实参的构造函数有效。且只能在类内声明的时候采用<code>explicit</code>关键字。</p><p>字面值常量类：<code>constexpr</code></p><h2 id="类的静态成员-7-6，P269"><a href="#类的静态成员-7-6，P269" class="headerlink" title="类的静态成员(7.6，P269)"></a>类的静态成员(7.6，P269)</h2><p>一般来说，我们不能在类内初始化静态成员。相反，必须在类的外部定义和初始化每个静态成员。</p><p>定义并且初始化一个静态成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> Account::interestRate = initRate();</div></pre></td></tr></table></figure></p><p>定义静态数据成员的方式和在类外定义成员函数差不多。</p><p>只有字面值常量类型<code>constexpr</code>的静态成员可以在类内，且初始值必须是常量表达式。</p><p>如果类内部声明提供了初始值，则外部定义时不能提供初始值。</p><p>静态数据成员可以是不完全类型，如类类型；非静态成员只能是类的指针或者引用。</p><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>class 关键字： class keyword<br>构造函数： constructor<br>构造函数初始值列表： constructor initializer list<br>类的作用域： class scope<br>委托构造函数： delegating constructor<br>显示构造函数： explicit constructor<br>接口：interface<br>数据抽象：data abstraction<br>可变数据成员： mutable data member<br>友元： friend</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49798749" target="_blank" rel="external">C++primer第五版第七章学习笔记</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/16/CPP_07/#disqus_thread</comments>
    </item>
    
    <item>
      <title>判断int是否为3的幂—— Leetcode(326)</title>
      <link>http://wangwlj.com/2018/01/13/leetcode_326_power_of_3/</link>
      <guid>http://wangwlj.com/2018/01/13/leetcode_326_power_of_3/</guid>
      <pubDate>Sat, 13 Jan 2018 14:15:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;leetcode链接：&lt;a href=&quot;https://leetcode.com/problems/power-of-three/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;326. Power of Three&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an integer, write a function to determine if it is a power of three.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Could you do it without using any loop / recursion?&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>leetcode链接：<a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></p><blockquote><p>Given an integer, write a function to determine if it is a power of three.</p><p>Follow up:<br>Could you do it without using any loop / recursion?</p></blockquote><a id="more"></a><p>一般的通用解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfThree(int n) &#123;</div><div class="line">        while (n &gt;= 3 )&#123;</div><div class="line">            if(n % 3 != 0)</div><div class="line">                return false;</div><div class="line">            n /= 3;   </div><div class="line">        &#125;</div><div class="line">        return n&gt;0 &amp;&amp; n != 2;     </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>上述可以通过，但是题目说最好尝试一下非循环或者递归的解法。</p><p>我感觉此类方法就是有点取巧了。如，找出<code>int</code>范围内最大的3的倍数，所以任何3的倍数<code>n</code>都可以被其整除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfThree(int n) &#123;</div><div class="line">        //方法2</div><div class="line">        const int maxint = 0x7fffffff;</div><div class="line">        //假设3^k 是int范围内最大的3的幂</div><div class="line">        int k = int(log(maxint) / log(3));</div><div class="line">        int max_power_3 = pow(3,k);</div><div class="line">        return n&gt;0 &amp;&amp; max_power_3 % n ==0;  </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>或者将上述代码压缩到一行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; <span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="number">3</span>,<span class="keyword">int</span>(<span class="built_in">log</span>(<span class="number">0x7fffffff</span>) / <span class="built_in">log</span>(<span class="number">3</span>)))) % n == <span class="number">0</span>;</div></pre></td></tr></table></figure></p><blockquote><p><code>pow</code>函数在头文件<code>math.h</code>中。</p></blockquote><p>同类题：</p><ol><li><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></li><li><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></li><li><a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/leetcode_326_power_of_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>判断int是否为4的幂—— Leetcode(342)</title>
      <link>http://wangwlj.com/2018/01/13/leetcode_342_power_of_4/</link>
      <guid>http://wangwlj.com/2018/01/13/leetcode_342_power_of_4/</guid>
      <pubDate>Sat, 13 Jan 2018 13:41:51 GMT</pubDate>
      <description>
      
        &lt;p&gt;leetcode链接：&lt;a href=&quot;https://leetcode.com/problems/power-of-four/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;342. Power of Four&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an integer (signed 32 bits), write a function to check whether it is a power of 4.&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>leetcode链接：<a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></p><blockquote><p>Given an integer (signed 32 bits), write a function to check whether it is a power of 4.</p></blockquote><a id="more"></a><blockquote><p>Example:<br>Given num = 16, return true. Given num = 5, return false.</p><p>Follow up: Could you solve it without loops/recursion?</p></blockquote><p>判断一个数是不是4的幂。还是使用二进制。<br>在判断2的幂的基础上添加条件。<br>如：<code>16(10000)</code>是，<code>8(1000)</code>不是；可以与<code>0x55(01010101)</code>取并集即可。(即判断1的位数是不是在奇数位)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfFour(int n) &#123;</div><div class="line">        return n&gt;0 &amp;&amp; ((n &amp; (n-1)) == 0) &amp;&amp; (n &amp; 0x55555555);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>另一种思路的解法为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; ((n &amp; (n<span class="number">-1</span>)) == <span class="number">0</span>) &amp;&amp; (（(n<span class="number">-1</span>) %<span class="number">3</span> == <span class="number">0</span>);</div></pre></td></tr></table></figure></p><p>先直觉上检验一下，发现的确是这样：$4 -1 = 3,16 - 1 = 15, 64 -1 = 63$，都是3的倍数。因此$(4^n - 1) % 3 == 0$是成立的。</p><p>下面给出简短证明：<br>$$4^n -1 = 2^{2n}-1 = (2^n+1)(2^n-1)$$<br>我们知道：$2^n+1$、$2^n$与$2^n-1$是三个连续数，其中必有一个为3的倍数，而且$2^n$必然不是3的倍数，因此，$2^n+1$与$2^n-1$中必有一个为3的倍数。也就是$4^n -1$必为3的倍数。</p><p>同类题：</p><ol><li><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></li><li><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></li><li><a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/leetcode_342_power_of_4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>判断int是否为2的幂—— Leetcode(231)</title>
      <link>http://wangwlj.com/2018/01/13/leetcode_231_power_of_2/</link>
      <guid>http://wangwlj.com/2018/01/13/leetcode_231_power_of_2/</guid>
      <pubDate>Sat, 13 Jan 2018 13:26:24 GMT</pubDate>
      <description>
      
        &lt;p&gt;leetcode链接：&lt;a href=&quot;https://leetcode.com/problems/power-of-two/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;231. Power of Two&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an integer, write a function to determine if it is a power of two.&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>leetcode链接：<a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></p><blockquote><p>Given an integer, write a function to determine if it is a power of two.</p></blockquote><a id="more"></a><p>出错样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Input: -16 Expected: false // 就是没有考虑负数。</div></pre></td></tr></table></figure></p><p>C++实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="keyword">while</span>(n != <span class="number">2</span> &amp;&amp; n &gt; <span class="number">2</span>)&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(n%<span class="number">2</span> != <span class="number">0</span>)</div><div class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                n /= <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>上述一个常规的做法：连续除。</p><p>此外，我们考虑到2的幂的二进制只有最高位为1，其余都为0，此时利用这个特点可以写出如下的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfTwo(int n) &#123;</div><div class="line">        if(n &lt;= 0)</div><div class="line">             return false;</div><div class="line">        return (n &amp;(n-1) )== 0;</div><div class="line">        //或者一句话表示，如下：</div><div class="line">        //return n&gt;0 &amp;&amp; (n &amp;(n-1) )== 0;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><blockquote><p><code>n &amp; (n-1)==0</code> 会被当作：<code>n &amp; ((n-1)==0)</code>，故需要加上括号写为：<code>(n &amp;(n-1) )== 0</code>。</p></blockquote><p>例如：8的二进制<code>1000</code>,7的二进制<code>0111</code>，取并集为0。</p><p>同类题：</p><ol><li><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></li><li><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></li><li><a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/leetcode_231_power_of_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git入门使用指南</title>
      <link>http://wangwlj.com/2018/01/13/Git_usage/</link>
      <guid>http://wangwlj.com/2018/01/13/Git_usage/</guid>
      <pubDate>Sat, 13 Jan 2018 07:04:26 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h2&gt;&lt;p&gt;下面是摘自官网的一段话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，Git是一个优秀的分布式版本管理软件。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>下面是摘自官网的一段话：</p><blockquote><p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p></blockquote><p>简而言之，Git是一个优秀的分布式版本管理软件。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开Git官网：<a href="https://git-scm.com/" target="_blank" rel="external">git-scm.com</a>，下载并安装。<br>Debian或<code>Ubuntu Linux</code>，通过一条<code>sudo apt-get install git</code>就可以直接完成<code>Git</code>的安装。</p><p>安装完成后，windows打开<code>git-bash</code>，linux直接打开<code>terminal</code>。</p><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>配置用户信息（和Github上一致）：用户名和邮箱地址：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name "qwerty200696"</div><div class="line">git config --global user.email "wang@126.com"</div></pre></td></tr></table></figure></p><p>如果之前已经配置好了，可以使用如下命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config user.name</div><div class="line">git config user.email</div></pre></td></tr></table></figure><p>还可以配置颜色和行尾。不同平台的行尾是有显著区别的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git config --global core.autocrlf true</div><div class="line">git config --global core.autocrlf input</div><div class="line"></div><div class="line">git config --global color.ui auto</div></pre></td></tr></table></figure><p>其他配置：<br>配置的级别分为：<code>global</code> 、<code>local</code>与<code>system</code>三种级别，<code>local</code>会覆盖<code>global</code>。就像面向对象的继承那样，最近的是最有效的，也就是<code>local</code>。</p><h2 id="init-amp-add——开始与添加"><a href="#init-amp-add——开始与添加" class="headerlink" title="init&amp;add——开始与添加"></a>init&amp;add——开始与添加</h2><p>选择需要版本控制的文件夹，打开终端(linux)或者Git Bash(windows)。</p><p>初始化Git：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git init</div></pre></td></tr></table></figure></p><blockquote><p>最好的方法是在开始一个项目之前，通过<code>git init xxx</code>来新建一个项目目录<code>xxx</code>。git会自动创建该<code>xxx</code>目录。</p></blockquote><p>假设文件夹下存在需要版本管理的文件，使用如下命令查看是否已经被管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git status</div></pre></td></tr></table></figure><p>添加需要管理的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add 1.py # 某个具体的文件</div><div class="line">git add .  # 添加文件夹下所有的文件</div></pre></td></tr></table></figure></p><p>可以在目录下创建一个名为<code>.gitignore</code>的文件，在其中输入需要忽略的文件。</p><h2 id="commit——提交修改"><a href="#commit——提交修改" class="headerlink" title="commit——提交修改"></a>commit——提交修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;first commit&quot;</div></pre></td></tr></table></figure><p>修改内容之后，使用<code>commit</code>提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git log</div></pre></td></tr></table></figure><p><code>log</code>命令可以查看每次的更改。</p><p>目前都是在本地化的版本管理。</p><h2 id="diff——显示不同"><a href="#diff——显示不同" class="headerlink" title="diff——显示不同"></a>diff——显示不同</h2><p>现在假设你修改了一个文件，但是过去了一段时间后忘记修改在什么地方了，此时你需要“diff”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git diff  # 文件的最新改动</div><div class="line">git diff --staged  # 已经暂存的和最近历史的改动。</div><div class="line">git diff HEAD # HEAD提交历史中，最近一次的别名，最新的修改与最近历史的改动。跳过了暂存的修改，直接与最近一次提交的比较。</div><div class="line"></div><div class="line">git diff --color-words  # 只对修改的地方用不同颜色标记，而不是整行。</div><div class="line">git diff --word-diff # 对长行的小改动更加清晰明了。</div><div class="line">git diff --stat  # 极简输出，只输出改动的文件，阻止其他输出。</div></pre></td></tr></table></figure></p><h2 id="log——查看修改"><a href="#log——查看修改" class="headerlink" title="log——查看修改"></a>log——查看修改</h2><p>log是一个非常强大的明了，不仅可以查看提交的历史记录，而且是了解仓库的进展、提交的内容以及文件的好帮手。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git log</div><div class="line">git log --oneline  # 更常用！</div><div class="line">git log --stat #可以查看修改的文件。</div><div class="line">git log --patch # 可以查看文件中具体的修改内容。</div><div class="line"></div><div class="line">git log --graph --all --decorate --oneline  # z展示每次提交的一行概括。</div></pre></td></tr></table></figure></p><h2 id="remove——删除文件"><a href="#remove——删除文件" class="headerlink" title="remove——删除文件"></a>remove——删除文件</h2><p>删除文件。两种方式，一种是<code>git rm</code>，一种是<code>git add</code></p><p><code>git rm</code> 用来删除一个文件；并且会自动暂存修改。</p><p>此外，如果用<code>rm</code>删除了一个文件，可以使用<code>git rm</code>再次暂存修改。</p><p>现实情况中，往往会有很多文件被删除了，不可能通过命令行一个个修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Git add -u .  # 注意，最后的dot不能省略哦，表示当前目录</div></pre></td></tr></table></figure></p><p>改命令会遍历文件夹，并且查找出所有删除的文件，并且暂存。</p><p>有时候只是想要从git中删除，但是本地文件不删除，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git rm --cached xxx_file</div></pre></td></tr></table></figure></p><p>你是真的想在所有历史记录中删除这个文件的记录吗？这是另一个主题中会讲。或者你是不想要某个文件被追踪，之后也是这样，那么可以使用<code>git ignore</code>文件，在之后也会介绍。</p><h2 id="move——移动文件"><a href="#move——移动文件" class="headerlink" title="move——移动文件"></a>move——移动文件</h2><p> 移动文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git mv xxx_file otherPath/xxx.file</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add -A .</div></pre></td></tr></table></figure><p>找出所有的移动过的文件。（包括修改之后移动的文件）</p><p>追踪移动过的文件的历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git log -- path/file # 只会追踪到该目录下的历史，历史会终止在移动的时候。</div><div class="line"></div><div class="line">git log --stat -M --follow -- path/file # 跨目录追踪历史，文件在移动过程中也追踪。</div></pre></td></tr></table></figure></p><p>在移动文件之后，commit给我们一个数字来告诉我们文件在移动前后的相似度。Git提供的默认阈值是50%的相似度，超过50%，在移动前后就会继续追踪该文件。</p><h2 id="ignore——忽略文件"><a href="#ignore——忽略文件" class="headerlink" title="ignore——忽略文件"></a>ignore——忽略文件</h2><p>可以在目录/子目录下创建一个名为<code>.gitignore</code>的文件，在其中输入需要忽略的文件/文件夹。</p><p>只能对当前目录的文件/文件夹进行忽略。 可以使用匹配符，在当前目录/子目录都有效。</p><p><del>子目录中，需要路径优先级？？</del><br>也可以使用“！”反忽略某一个特定的文件。<br>注释行用“#”号开头。</p><p>查看忽略了的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git ls-files --others --ignored --exclude-standard  ## 查看忽略的文件</div><div class="line"></div><div class="line">git ls-files  --ignored --exclude-standard</div></pre></td></tr></table></figure></p><p><del>为什么我感觉不需要加上 <code>--others</code>也可以。而且第二个命令更靠谱。</del></p><p>以上述的第一个命令为主。<br>如果你感觉第一个命令不行的话，那是因为在某些文件先前已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的push，这样就不会出现忽略的文件了。git清除本地缓存命令如下：【参考资料二】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git rm -r --cached .</div><div class="line">git add .</div><div class="line">git commit -m &apos;update .gitignore&apos;</div></pre></td></tr></table></figure></p><p>关于ignore规则的详细介绍，可参考<a href="https://www.cnblogs.com/kevingrace/p/5690241.html" target="_blank" rel="external">这篇博文</a>，写得很详细。</p><h2 id="branch——开始新分支"><a href="#branch——开始新分支" class="headerlink" title="branch——开始新分支"></a>branch——开始新分支</h2><h3 id="创建与删除"><a href="#创建与删除" class="headerlink" title="创建与删除"></a>创建与删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git branch newBranchName  ## 创键分支</div><div class="line">git branch -d existedBranchname  ## 删除分支，没有合并的话会出错</div><div class="line">git branch -D existedBranchname  ## 删除分支，强制删除</div></pre></td></tr></table></figure><h3 id="switch——切换分支"><a href="#switch——切换分支" class="headerlink" title="switch——切换分支"></a>switch——切换分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout existedBranchname</div></pre></td></tr></table></figure><h2 id="checkout的其他用法"><a href="#checkout的其他用法" class="headerlink" title="checkout的其他用法"></a>checkout的其他用法</h2><p>最主要的作用就是切换分支，上面已经讲过了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch</div><div class="line">git status</div></pre></td></tr></table></figure></p><p>都可以查看目前处于那个分支上面。</p><p>撤销内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- filename.txt</div></pre></td></tr></table></figure></p><p>会清理掉最后一次commit的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b newBranchName</div></pre></td></tr></table></figure><p>一步到位，既创建了一个新的branch，也转移到了新的branch。</p><p>如果在使用<code>checkout</code>命令的时候，不小心将头指针分离了，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wangwlj@myUbuntu:~/文档/py_prog/py3_prog$ git branch -a</div><div class="line">* （头指针分离于 ee74fc7）</div><div class="line">  master</div><div class="line">  program</div></pre></td></tr></table></figure></p><p>当我们发现头指针游离于分支之外的时候，不要惊慌，再次<code>git checkout program</code>切换到已经存在的分支即可。</p><h2 id="merge——分支合并"><a href="#merge——分支合并" class="headerlink" title="merge——分支合并"></a>merge——分支合并</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master  ## 切换到主分支</div><div class="line">git merge branchNeedToMerge ## 将分支branchNeedToMerge的修改合并到master</div></pre></td></tr></table></figure><h3 id="merge冲突的解决"><a href="#merge冲突的解决" class="headerlink" title="merge冲突的解决"></a>merge冲突的解决</h3><p>merge冲突：两个文件都有变化，Git无法确定该怎么合并。该如何解决呢？</p><p>先用<code>git status</code>查看是哪个文件冲突 ，然后用编辑器打开，进行修改。</p><p>先查找<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>标志，表明是当前branch上的内容，直到<code>=======</code>标志结束。<br>在<code>=======</code>标志的下方，直到<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; branchNeedToMerge</code>标志结束，是另一个分支的内容。</p><p>找到位置后，需要手动地解决冲突：编辑文件，删去冲突的标签，决定该删去或保留哪些内容，保存即可。最后重新add、commit提交。</p><h3 id="abort——放弃冲突"><a href="#abort——放弃冲突" class="headerlink" title="abort——放弃冲突"></a>abort——放弃冲突</h3><p>放弃这个冲突（不重要），从上次commit开始，并且清除暂存区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --abort</div></pre></td></tr></table></figure></p><h3 id="squash压缩"><a href="#squash压缩" class="headerlink" title="squash压缩"></a>squash压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git merge --squash branchNeedToMerge</div><div class="line">git commit -m &quot;some message&quot;</div></pre></td></tr></table></figure><p>意思是 你在分支<code>branchNeedToMerge</code>里面做了很多次commit修改，但是修改很零碎；在master分支里只想要一次commit就更新到<code>branchNeedToMerge</code>分支的进度。此时就可以使用<code>--squash</code>参数。</p><blockquote><p>判断是否使用<code>--squash</code>选项最根本的标准是，待合并分支上的历史是否有意义。</p></blockquote><p>关于<code>--squash</code> 参数的举例可参考<a href="http://blog.csdn.net/rockrockwu/article/details/33740711" target="_blank" rel="external">这篇文章</a>。</p><h3 id="d-删除分支"><a href="#d-删除分支" class="headerlink" title="-d 删除分支"></a>-d 删除分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d branchNeedToMerge</div></pre></td></tr></table></figure><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><h3 id="Remotes"><a href="#Remotes" class="headerlink" title="Remotes"></a>Remotes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add origin &lt;server&gt;</div></pre></td></tr></table></figure><p><code>&lt;server&gt;</code>是远程服务器的地址、目的地的url。<br>如果输错了或者忘记了也不要紧，可以输入如下命令重新设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote set-url origin &lt;new-server&gt;</div></pre></td></tr></table></figure></p><p>查看远程的地址有哪些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote -v</div></pre></td></tr></table></figure></p><p>最后删除远端地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote rm origin</div></pre></td></tr></table></figure></p><h3 id="fetch-pull-push"><a href="#fetch-pull-push" class="headerlink" title="fetch/pull/push"></a>fetch/pull/push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git fetch origin</div><div class="line">git pull origin</div><div class="line">git push origin</div></pre></td></tr></table></figure><p>fetch:去github.com上面下载信息，放在远程追踪分支。，<br>pull：与fetch非常像，下载下来放到远程，并且合并到本地。<br>push：电脑上完成了工作，发送到github上面。</p><h2 id="fork-pull-requests"><a href="#fork-pull-requests" class="headerlink" title="fork/pull requests"></a>fork/pull requests</h2><p>fork:拷贝到自己的仓库进行修改，最好新建分支。<br>pull requests:对他人的代码进行修改，提意见</p><h2 id="reset——重置"><a href="#reset——重置" class="headerlink" title="reset——重置"></a>reset——重置</h2><p>reset有三个等级，默认的是<code>mixed</code>，除此之外还有<code>soft</code>与<code>hard</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git reset --soft HEAD~5  # 选择需要重置commit的次数</div><div class="line">git status</div><div class="line">git commit -m&quot;new message&quot;  # 重新提交</div></pre></td></tr></table></figure><p>reset在对仓库历史提交的处理上比较有用，当然也是一个危险的命令啦。</p><p>checkout可以做类似的事情，<code>checkout</code>更加关注的是一个目录或者文件级别的精度。也就是说，可以把某个文件拉回到几次提交之前的状态。</p><h2 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h2><p>包括<code>reset</code>做的那些不可恢复的操作，<code>reflog</code>都有记录。<br>但默认提供的是30天的保存时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reflog</div></pre></td></tr></table></figure><p>也可以图形化查看历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitk --all `git reflog | cut c1-7`&amp;</div></pre></td></tr></table></figure></p><p><code>reflog</code>让我们有动力地去多做commit，commit了就有保障了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000" target="_blank" rel="external">忽略特殊文件</a></li><li><a href="https://www.cnblogs.com/zzcc/p/5695883.html" target="_blank" rel="external">Git中.gitignore文件不起作用的解决</a></li><li><a href="https://www.nowcoder.com/courses/2" target="_blank" rel="external">GitHub&amp;Git入门基础</a></li><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">Git教程</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/Git_usage/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ubuntu下必备软件及安装总结</title>
      <link>http://wangwlj.com/2018/01/13/ubuntu_software_summary/</link>
      <guid>http://wangwlj.com/2018/01/13/ubuntu_software_summary/</guid>
      <pubDate>Sat, 13 Jan 2018 05:51:37 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;安装ubuntu&quot;&gt;&lt;a href=&quot;#安装ubuntu&quot; class=&quot;headerlink&quot; title=&quot;安装ubuntu&quot;&gt;&lt;/a&gt;安装ubuntu&lt;/h2&gt;&lt;p&gt;本文以&lt;code&gt;Ubuntu 16.04&lt;/code&gt;为例。&lt;/p&gt;
&lt;p&gt;制作U盘启动盘、安装Ubuntu系统。是装双系统还是只装linux。&lt;/p&gt;
&lt;p&gt;安装时，需要注意的两点。一是手动/自动分区，若手动分区，最好将&lt;code&gt;/home&lt;/code&gt;分区独立出来；二是系统语言选择中文还是英文，推荐中文。其他的就随意即可。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="安装ubuntu"><a href="#安装ubuntu" class="headerlink" title="安装ubuntu"></a>安装ubuntu</h2><p>本文以<code>Ubuntu 16.04</code>为例。</p><p>制作U盘启动盘、安装Ubuntu系统。是装双系统还是只装linux。</p><p>安装时，需要注意的两点。一是手动/自动分区，若手动分区，最好将<code>/home</code>分区独立出来；二是系统语言选择中文还是英文，推荐中文。其他的就随意即可。</p><a id="more"></a><p>给出几个参考链接：</p><ul><li><a href="http://blog.csdn.net/yaoyut/article/details/78003061" target="_blank" rel="external">用UltraISO制作Ubuntu16.04 U盘启动盘</a></li><li><a href="https://www.zhihu.com/question/19867618" target="_blank" rel="external">怎样安装 Windows 7 与 Linux 的双系统？</a><br>双系统是比较特殊的，双系统可以，单系统也没问题。</li></ul><h2 id="软件安装前的设置"><a href="#软件安装前的设置" class="headerlink" title="软件安装前的设置"></a>软件安装前的设置</h2><p>假设现在已经有了一个全新的<code>Ubuntu</code>系统，此时你需要先换源。</p><h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>系统自带的源速度不快，因此考虑换成国内源。笔者采用的是阿里云的源，还是不错的。</p><ul><li><p><a href="http://blog.csdn.net/happywho250/article/details/52506321" target="_blank" rel="external">ubuntu16.04换源</a></p></li><li><p><a href="http://blog.csdn.net/u011557212/article/details/53233944" target="_blank" rel="external">Ubuntu16.04常用源</a></p></li></ul><h3 id="主文件夹下的中文目录改为英文目录"><a href="#主文件夹下的中文目录改为英文目录" class="headerlink" title="主文件夹下的中文目录改为英文目录"></a>主文件夹下的中文目录改为英文目录</h3><blockquote><p>可选项。主文件夹下的中文目录名其实也不错。</p></blockquote><p>Linux下使用命令行是很正常的事情，<code>cd ~/桌面</code> 需要切换输入法，可能会显得不那么流畅，因此，可以考虑将主文件夹下的中文目录设置为英文。</p><p>参考这篇文章：<br><a href="http://blog.csdn.net/l0605020112/article/details/20285239" target="_blank" rel="external">将Ubuntu主文件夹里的中文文件夹名称改成英文</a></p><p>我采用的是第一种方法。换了之后建议重启一下。</p><p>笔者不是一开始就改的，所以导致换目录名后出现了一系列问题。一开始就换会比较好。</p><h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><h2 id="安装必备软件"><a href="#安装必备软件" class="headerlink" title="安装必备软件"></a>安装必备软件</h2><p>在对Ubuntu换源之后，就可以开始安装一些必备而的软件了。Ubuntu下软件的安装都不难，可以根据需求选择安装相应的软件。</p><h3 id="1-搜狗输入法"><a href="#1-搜狗输入法" class="headerlink" title="1. 搜狗输入法"></a>1. 搜狗输入法</h3><p>输入法必备，放在第一个吧。</p><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>官网下载linux版本的dev包：<a href="http://pinyin.sogou.com/linux/" target="_blank" rel="external">pinyin.sogou.com/linux</a><br>进入下载目录，在终端执行安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> sudo dpkg  -i   sogoupinyin_2.2.0.0102_amd64.deb</div></pre></td></tr></table></figure></p><p>安装过程会出现 依赖关系问题（未安装成功，依赖库不全），不要担心，接着执行下面的命令就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span>sudo apt-get install -f</div></pre></td></tr></table></figure><p>等待完成后，搜狗拼音输入法就安装好了。</p><blockquote><p>上述两条命令都是常用命令，需要记住。</p></blockquote><h4 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h4><p> 下面对输入法进行系统配置，具体流程如下：</p><ul><li>桌面右上角面板的<code>开关机的按钮</code>，选择<code>系统设置</code>；</li><li>进入系统设置后，点击<code>语言支持</code>，键盘输入方式系统中选择 <code>fcitx</code>；</li><li>注销系统用户，重新登陆进入桌面后看看，熟悉的搜狗输入法出现了吧。</li></ul><p>参考自：<a href="https://jingyan.baidu.com/article/a3aad71aa1abe7b1fa009641.html" target="_blank" rel="external">ubuntu安装配置搜狗拼音输入法</a></p><h3 id="2-网易云音乐"><a href="#2-网易云音乐" class="headerlink" title="2. 网易云音乐"></a>2. 网易云音乐</h3><p>网易云音乐，大家都知道的，无需过多介绍，虽然现在由于版权问题好多歌曲都下架了，不过<code>Linux</code>下的网易云做得非常好。</p><p>只需要简单地下载、安装即可。具体请参考：<a href="http://blog.csdn.net/u011557212/article/details/53234134" target="_blank" rel="external">ubuntu16.04安装网易云音乐</a></p><blockquote><p>别人写得很详细的教程，我就只放链接了。</p></blockquote><h3 id="3-chrome浏览器"><a href="#3-chrome浏览器" class="headerlink" title="3. chrome浏览器"></a>3. chrome浏览器</h3><p>Linux下谷歌浏览器是必备的。</p><p>安装谷歌浏览器，只需要三行代码：<br>打开终端，输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /tmp</div></pre></td></tr></table></figure></p><p>对于谷歌Chrome32位版本，使用如下链接：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb</div></pre></td></tr></table></figure></p><p>对于64位版本可以使用如下链接下载：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</div></pre></td></tr></table></figure></p><p>下载完后，运行如下命令安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dpkg -i google-chrome*; sudo apt-get -f install</div></pre></td></tr></table></figure></p><p>然后，就可以去搜索使用了。<br>是不是很方便？</p><p>参考自：<a href="http://www.linuxidc.com/Linux/2013-10/91857.htm" target="_blank" rel="external">安装谷歌Chrome浏览器</a></p><h3 id="4-Guake-Terminal-optional"><a href="#4-Guake-Terminal-optional" class="headerlink" title="4. Guake Terminal (optional)"></a>4. Guake Terminal (optional)</h3><h4 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h4><p><code>Guake Terminal</code>顾名思义，是一个终端。功能只有一个, 按 <code>F12</code> 时从屏幕顶部 嗖! 地下来一个。</p><p>可到官网：<a href="http://guake-project.org/" target="_blank" rel="external">guake-project.org</a> 查看详细说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git clone https://github.com/Guake/guake.git</div><div class="line">$ cd guake</div><div class="line"></div><div class="line"># For Ubuntu user, we have a script that does all these steps for you. Use:</div><div class="line">$ ./dev.sh</div></pre></td></tr></table></figure><p>如果上述第三条命令出错的话，请尝试以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./dev.sh --install</div></pre></td></tr></table></figure></p><p>期间，会自动安装一些库，如<code>git</code>之类的。</p><h4 id="设置与自启动"><a href="#设置与自启动" class="headerlink" title="设置与自启动"></a>设置与自启动</h4><p>安装完成后，可以在终端输入<code>guake</code>查看效果，输入<code>guake --preferences</code>进行相关的配置。<br><code>guake</code>启动后，按下<code>F12</code>显示终端，再按<code>F12</code>消失。可以设置焦点失去时隐藏，这样就不用反复点<code>F12</code>了。</p><p>自启动设置：</p><p>点击最左上角的<code>Dash</code>图标(用于查找文件与程序的nage)，输入<code>启动</code>二字查看搜索结果，点击“启动应用程序”，按下图设置：</p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fneyjbeucgj20gn0daabi.jpg" alt=""></p><h3 id="5-思维导图xmind"><a href="#5-思维导图xmind" class="headerlink" title="5. 思维导图xmind"></a>5. 思维导图xmind</h3><p><code>xmind</code>和<code>MindManager</code>都是优秀的思维导图软件，linux下只有<code>xmind</code>。</p><p>具体的安装步骤：</p><p>1、去官网下载<a href="http://www.xmind.net/download/linux/" target="_blank" rel="external">http://www.xmind.net/download/linux/</a></p><p>2、下载完后解压，进入解压后目录，在命令行输入<code>sudo ./setup</code>，这个是用来安装软件相关的依赖；然后进入<code>xmind_amd64</code>（64位系统）或者<code>xmind_i386</code>(32位系统)</p><p>3、在目录中直接双击<code>XMind</code>文件，或者在命令行中输入 <code>sudo ./XMind</code>。这样XMind就可以直接运行。由于XMInd8的ubuntu版本是用JAVA来开发的，所以可以直接打开，无需安装。</p><p>参考自：<a href="http://blog.csdn.net/faryang/article/details/70238326" target="_blank" rel="external">ubuntu16.04安装xmind8</a></p><h3 id="6-pycharm"><a href="#6-pycharm" class="headerlink" title="6. pycharm"></a>6. pycharm</h3><p>需要使用Python的话可以考虑安装Pycharm。</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>打开<a href="https://www.jetbrains.com/pycharm/download/#section=linux" target="_blank" rel="external">pycharm官网</a></p><p>下载linux版本的pycharm。</p><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><p>打开刚才下载的目录。右击文件，点击提取到此处（这与Windows的解压是一个意思）</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>解压完成后，打开刚才解压好的文件夹，然后再打开bin目录。</p><p>在文件夹空白处右击，在此处打开终端然后输入：<code>sh ./pycharm.sh</code> 回车</p><p>接着就打开了pycharm。</p><p>如果你需要导入之前安装版本的设置的话，可以选择第一个选项；如果没有的话，默认不导入设置就可以了。</p><p>点击同意，然后激活<code>pycharm</code>就可以使用了。</p><p>详情可参考：<br><a href="https://jingyan.baidu.com/article/60ccbceb4e3b0e64cab19733.html" target="_blank" rel="external">Ubuntu系统安装PyCharm教程（详细图文）</a></p><p>另附：学生可以免费注册pycharm，学生版也可以使用专业版的pycharm，没有什么区别。</p><h3 id="7-WPS"><a href="#7-WPS" class="headerlink" title="7. WPS"></a>7. WPS</h3><h4 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h4><p>进入WPS官网下载deb包：<a href="http://linux.wps.cn/" target="_blank" rel="external">http://linux.wps.cn/</a></p><p>安装，打开终端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd 下载</div><div class="line">sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb</div></pre></td></tr></table></figure><h4 id="解决打开WPS时出现的系统缺失字体问题"><a href="#解决打开WPS时出现的系统缺失字体问题" class="headerlink" title="解决打开WPS时出现的系统缺失字体问题"></a>解决打开WPS时出现的系统缺失字体问题</h4><p>下载wps_symbol_fonts.zip: <a href="https://pan.baidu.com/s/1eS6xIzo" target="_blank" rel="external">https://pan.baidu.com/s/1eS6xIzo</a></p><p>将<code>wps_symbol_fonts.zip</code>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd wps_symbol_fontsls</div></pre></td></tr></table></figure></p><p>将目录中所有文件复制到<code>/usr/share/fonts</code>下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cp mtextra.ttf  symbol.ttf  WEBDINGS.TTF  wingding.ttf  WINGDNG2.ttf  WINGDNG3.ttf  /usr/share/fonts</div></pre></td></tr></table></figure><p>重新打开WPS，问题解决。</p><h4 id="删除libreOffice-optional"><a href="#删除libreOffice-optional" class="headerlink" title="删除libreOffice (optional)"></a>删除libreOffice (optional)</h4><p>另外，安装完WPS后就没有必要保留<code>libreOffice</code></p><p>卸载<code>libreOffice</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get remove libreoffice-common</div></pre></td></tr></table></figure></p><p>顺便把Amazon链接删除了吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    sudo apt-get remove unity-webapps-common</div><div class="line">    sudo apt autoremove</div><div class="line">```       </div><div class="line">参考自：[Ubuntu16.04安装wps并解决系统缺失字体问题](https://www.cnblogs.com/liutongqing/p/6388160.html)</div><div class="line"></div><div class="line">### 8. 图片编辑工具GIMP</div><div class="line"></div><div class="line">`GIMP`虽然不能完全替代`PS`，但是也能弥补一下。系统默认源中已经包含了GIMP，不需要使用PPA这些。</div><div class="line"></div><div class="line">安装：</div></pre></td></tr></table></figure></p><pre><code>sudo apt-get install gimp</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">启动：</div><div class="line"></div><div class="line">通过Dash搜索`GIMP`即可。或者命令行输入GIMP也行。</div><div class="line"></div><div class="line">参考：</div><div class="line"></div><div class="line">- https://www.gimp.org/downloads/</div><div class="line">- https://www.cnblogs.com/EasonJim/p/7121885.html</div><div class="line"></div><div class="line"></div><div class="line">### 9. indicator-sysmonitor</div><div class="line"></div><div class="line">先看一下效果图：</div><div class="line">![1](http://ww1.sinaimg.cn/large/c38a0784ly1fndxu83315j20fr02zglt.jpg)</div><div class="line"></div><div class="line">图中的“CPU，温度，内存”部分就是该软件的作用了。</div><div class="line"></div><div class="line">想要安装可参考：[Ubuntu 16.04安装indicator-sysmonitor实现导航条显示上下行网速/CPU/内存使用率](http://www.cnblogs.com/EasonJim/p/7130171.html)</div><div class="line"></div><div class="line">### 10. 主题管理工具unity tweak tool</div><div class="line"></div><div class="line">主题管理工具`unity tweak tool`</div><div class="line"></div><div class="line">1,    添加源</div></pre></td></tr></table></figure><p>sudo add-apt-repository ppa:freyja-dev/unity-tweak-tool-daily<br>sudo apt-get update<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2,安装</div></pre></td></tr></table></figure></p><p>　　sudo apt-get install unity-tweak-tool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3,卸载</div></pre></td></tr></table></figure></p><p>　　sudo apt-get remove unity-tweak-tool<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">4,搜索`unity tweak tool`运行</div><div class="line"></div><div class="line">5,若出现以下问题，终端输入`sudo apt-get install unity-webapps-service `即可</div><div class="line"></div><div class="line">![](http://ww1.sinaimg.cn/large/c38a0784ly1fne74thxbkj20j006ojrk.jpg)</div><div class="line"></div><div class="line"></div><div class="line">### 11. docky</div><div class="line"></div><div class="line">经常使用Mac者的福音。实现效果如下图：</div><div class="line"></div><div class="line">![](http://ww1.sinaimg.cn/large/c38a0784ly1fne792nqnfj20jj032mzj.jpg)</div><div class="line"></div><div class="line">一句话安装：</div></pre></td></tr></table></figure></p><p>sudo apt install ducky<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">使用方法：</div><div class="line"></div><div class="line">- 删除图标：拖到回收站上面就可以。</div><div class="line">- 添加图标：打开程序的时候会自动加载到docky中，此时右键选择锁定。</div><div class="line"></div><div class="line">图标模糊：下载高清图标，替换掉。具体可查看知乎问题“Docky中程序的图标太模糊，如何替换Docky中程序的图标？”的[回答](https://www.zhihu.com/question/22892627/answer/64026877)。</div><div class="line"></div><div class="line">### 12. teamviewer</div><div class="line"></div><div class="line">`teamviewer`的作用：与其他主机互传文件或者控制远程主机。</div><div class="line"></div><div class="line">安装过程如下：</div><div class="line"></div><div class="line">1、下载安装程序(32位和64位Ubuntu通用)</div><div class="line">https://www.teamviewer.com/zhcn/download/linux/</div><div class="line"></div><div class="line">选择下载对应版本。</div><div class="line"></div><div class="line">2、在终端中执行如下命令进行安装</div></pre></td></tr></table></figure></p><pre><code>sudo dpkg -i teamviewer_i386.deb</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">3、使用如下命令处理依赖问题</div></pre></td></tr></table></figure><pre><code>sudo apt-get install –f </code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">参考链接：[Ubuntu 16中如何安装TeamViewer 12](http://blog.csdn.net/zuochao_2013/article/details/53671245)</div><div class="line"></div><div class="line">使用部分不难，简单易上手。可以注册一个`teamview`账号，还是很方便的。</div><div class="line"></div><div class="line"></div><div class="line">### 13. 截图工具shutter</div><div class="line"></div><div class="line">`shutter`安装可参考：[ubuntu 安装截图工具 Shutter，并设置快捷键 Ctrl+Alt+A](http://blog.csdn.net/hanshileiai/article/details/46843713)</div><div class="line"></div><div class="line">其实`ubuntu`有自带的截图工具，不支持修改文件而已。</div></pre></td></tr></table></figure><pre><code>printscreen -- 全屏alt + printscreen -- 当前活动截图shift + printscreen -- 自选矩形截图</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">自带的截图工具配合第八个软件GIMP一起使用，也还是不错的。</div><div class="line"></div><div class="line">### 14. Markdown编辑器 </div><div class="line"></div><div class="line">我选择的是[Moeditor](https://github.com/Moeditor/Moeditor)。</div><div class="line"></div><div class="line">类似的`markdown`编辑器还有：[Atom](https://atom.io/) (Github出品)，Vim+Markdown，[Remarkable - Linux](https://remarkableapp.github.io/linux.html) （据说有点小bug），[Haroopad - The Next Document processor based on Markdown](http://pad.haroopress.com/user.html) ，[typora.io](https://www.typora.io/#linux) ， SublimeText3+插件，[StackEdit](https://stackedit.io/)  (网页版)，[小书匠markdown编辑器](http://markdown.xiaoshujiang.com/) ，马克飞象，VS Code，reText等等。</div><div class="line"></div><div class="line"></div><div class="line">`Moeditor`下载地址：https://github.com/Moeditor/Moeditor/releases</div><div class="line"></div><div class="line">安装： `sudo dpkg -i xxxx.deb`</div><div class="line"></div><div class="line">使用： 简单易上手。简洁。右上角分别为：最小化和全屏。菜单在左下角（新建，保存，另存为之类的）和右下角（切换编辑模式）。</div><div class="line"></div><div class="line">### 15. shadowsocks</div><div class="line"></div><div class="line">算是必备的吧。科研(?)利器。</div><div class="line">#### 安装软件</div><div class="line"></div><div class="line">ubuntu16.04 直接一句话安装：</div></pre></td></tr></table></figure><p>sudo apt install shadowsocks<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">提示需要安装一些依赖库，选择`yes`即可。</div><div class="line"></div><div class="line">我们可以在`/home/wangwlj/` 下新建个文件`shadowsocks.json`  (`wangwlj`是我在我电脑上的用户名，这里路径你自己看你的)。内容是这样：</div></pre></td></tr></table></figure></p><p>{<br>    “server”:”11.22.33.44”,<br>    “server_port”:50003,<br>    “local_port”:1080,<br>    “password”:”123456”,<br>    “timeout”:600,<br>    “method”:”aes-256-cfb”<br>}</p><p>上面的各项参数含义如下：<br>server  你服务端的IP<br>servier_port  你服务端的端口<br>local_port  本地端口，一般默认1080<br>passwd  ss服务端设置的密码<br>timeout  超时设置 和服务端一样<br>method  加密方法 和服务端一样<br>```</p><p>确定上面的配置文件没有问题，然后我们就可以在终端输入<code>sslocal -c /home/wangwlj/shadowsocks.json</code> 回车运行。如果没有问题的话，下面会是这样…</p><h4 id="chrome插件SwithyOmega配置"><a href="#chrome插件SwithyOmega配置" class="headerlink" title="chrome插件SwithyOmega配置"></a>chrome插件SwithyOmega配置</h4><p>这里就不详写了，看这篇，写的很详细：<a href="http://www.sundabao.com/ubuntu%E4%BD%BF%E7%94%A8shadowsocks/" target="_blank" rel="external">ubuntu使用shadowsocks</a></p><p>还是简要附上几点吧。</p><p>新建一个模式，代理服务器，代理协议<code>SOCKS5</code>，代理服务器<code>127.0.0.1</code>，端口<code>1080</code></p><p><code>auto switch</code>中，上述模式对应的是：(按照规则列表匹配请求)使用shadowsocks访问的规则列表：<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="external">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a><br>，其余情况为直接访问。</p><blockquote><p>PS：windows下的chrome插件SwithyOmega的配置与Ubuntu一样。</p></blockquote><h3 id="Updating-1"><a href="#Updating-1" class="headerlink" title="Updating"></a>Updating</h3><p>将在个人博客中持续更新……</p><p>为了查找安装方便，所有参考链接均在对应位置处，就不放在最后了。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/ubuntu_software_summary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(6) 第七章快速排序</title>
      <link>http://wangwlj.com/2018/01/11/algorithm_tutorial_charpter_7/</link>
      <guid>http://wangwlj.com/2018/01/11/algorithm_tutorial_charpter_7/</guid>
      <pubDate>Thu, 11 Jan 2018 13:54:42 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;快速排序简介&quot;&gt;&lt;a href=&quot;#快速排序简介&quot; class=&quot;headerlink&quot; title=&quot;快速排序简介&quot;&gt;&lt;/a&gt;快速排序简介&lt;/h2&gt;&lt;p&gt;快排最坏情况$O( n^2 )$，但平均效率$O(n lg n)$，而且$O(n lg n)$隐含的常数因子很小，快排可以说是最快的排序算法，并非浪得虚名。另外它还是原址排序。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="快速排序简介"><a href="#快速排序简介" class="headerlink" title="快速排序简介"></a>快速排序简介</h2><p>快排最坏情况$O( n^2 )$，但平均效率$O(n lg n)$，而且$O(n lg n)$隐含的常数因子很小，快排可以说是最快的排序算法，并非浪得虚名。另外它还是原址排序。</p><a id="more"></a><p>快速排序是基于分治模式的：</p><ul><li>分解：数组A【p..r】被划分成两个（可能空）子数组A【p..q-1】和A【q+1..r】，使得A【p..q-1】中的每个元素都小于等于A(q)，而且，小于等于A【q+1..r】中的元素。计算下标q也是划分过程中的一部分。</li><li>解决：通过递归调用快速排序，对子数组A【p..q-1】和A【q+1..r】排序。</li><li>合并：因为两个子数组是原址排序的，将它们的合并不需要操作：整个数组A【p..r】已排序。</li></ul><p>快排的伪码：<br><img src="https://images2.imgbox.com/e6/39/ffgJfqit_o.jpg" alt=""></p><p>其中对数组的划分：<code>Partition</code>是快排算法的关键，，它对子数组A【p..r】进行原址重排）。<br><img src="https://images2.imgbox.com/7e/a5/T2zKB1UV_o.jpg" alt=""></p><h2 id="快速排序Python实现"><a href="#快速排序Python实现" class="headerlink" title="快速排序Python实现"></a>快速排序Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    x = A[r]</div><div class="line">    i = p - <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):  <span class="comment"># not r-1, but r</span></div><div class="line">        <span class="keyword">if</span> A[j] &lt; x:</div><div class="line">            i = i + <span class="number">1</span></div><div class="line">            A[i], A[j] = A[j], A[i]</div><div class="line">    A[r], A[i + <span class="number">1</span>] = A[i + <span class="number">1</span>], A[r]</div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">QUICKSORT</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = PARTITION(A, p, r)</div><div class="line">        QUICKSORT(A, p, q - <span class="number">1</span>)</div><div class="line">        QUICKSORT(A, q + <span class="number">1</span>, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</div><div class="line">    QUICKSORT(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)  <span class="comment"># all start from 0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">"  "</span>)</div></pre></td></tr></table></figure><h2 id="快速排序性能分析"><a href="#快速排序性能分析" class="headerlink" title="快速排序性能分析"></a>快速排序性能分析</h2><p>当数据量很小的时候，大概就十来个元素的小型序列，快排的优势并不明显，甚至比插入排序慢。但是一旦数据多，它的优势就充分发挥出来了。</p><p>举一个例子，<code>C++ STL</code> 中的<code>sort</code>函数，就充分发挥了快排的优势，并且取长补短，在数据量大时采用<code>QuickSort</code>，分段递归排序。一旦分段后的数据量小于某个门槛，为避免<code>QuickSort</code>递归调用带来过大的额外负荷，就改用插入排序。如果递归层次过深，还会改用<code>HeapSort</code>(堆排序，第六章刚讲)。所以说，C++的“混合兵种”sort的性能肯定会比C的qsort好。</p><p>快排的运行时间与Partition的划分有关：</p><ul><li><strong>最坏情况</strong>是输入的数组已经完全排好序，那么每次划分的左、右两个区域分别为n-1和0，效率为$O( n^2 )$.</li><li>而对于其他<strong>常数比例划分</strong>，哪怕是左右按9:1的比例划分，效果都是和在正中间划分一样快的（算法导论上有详细分析）</li><li>即，<strong>任何一种按照常数比例进行划分，总运行时间都是$\text{O}(n \text{lg} n)$</strong>。</li></ul><h2 id="快速排序的随机化版本"><a href="#快速排序的随机化版本" class="headerlink" title="快速排序的随机化版本"></a>快速排序的随机化版本</h2><p>随机抽样(random sampling):从$A[p..r]$中随机选一个元素作为主元，而不是始终采用$A[r]$作为主元。</p><p>随机化的快排的伪码如下：</p><p><img src="https://images2.imgbox.com/53/ea/JY82TS9f_o.jpg" alt="快速排序的随机化版本"></p><p>Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    x = A[r]</div><div class="line">    i = p - <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):  <span class="comment"># not r-1, but r</span></div><div class="line">        <span class="keyword">if</span> A[j] &lt; x:</div><div class="line">            i = i + <span class="number">1</span></div><div class="line">            A[i], A[j] = A[j], A[i]</div><div class="line">    A[r], A[i + <span class="number">1</span>] = A[i + <span class="number">1</span>], A[r]</div><div class="line"></div><div class="line">    <span class="keyword">return</span> i + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RANDOMIZED_PARTITION</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    rand_i = random.random()</div><div class="line">    <span class="comment"># print(round(a *(r - p)) + p)</span></div><div class="line">    rand_i = round(rand_i * (r - p) + p)  <span class="comment"># 区间的计算需要注意，否则不对</span></div><div class="line">    A[rand_i], A[r] = A[r], A[rand_i]</div><div class="line">    <span class="keyword">return</span> PARTITION(A, p, r)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">RANDOMIZED_QUICKSORT</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = RANDOMIZED_PARTITION(A, p, r)</div><div class="line">        RANDOMIZED_QUICKSORT(A, p, q - <span class="number">1</span>)</div><div class="line">        RANDOMIZED_QUICKSORT(A, q + <span class="number">1</span>, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    A = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</div><div class="line">    RANDOMIZED_QUICKSORT(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)  <span class="comment"># all start from 0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">"  "</span>)</div></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>算法导论 中文 第三版</li><li><a href="http://blog.csdn.net/shuangde800/article/details/7599509" target="_blank" rel="external">【算法导论】排序 （三）：快速排序 深入分析</a></li><li><a href="http://www.runoob.com/python/func-number-random.html" target="_blank" rel="external">Python random() 函数</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/11/algorithm_tutorial_charpter_7/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
