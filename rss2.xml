<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wangwlj&#39;s Blog</title>
    <link>http://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Sun, 04 Mar 2018 14:05:50 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>计算机网络学习笔记：(三)传输层</title>
      <link>http://wangwlj.com/2019/03/01/network_03_transmission_layer/</link>
      <guid>http://wangwlj.com/2019/03/01/network_03_transmission_layer/</guid>
      <pubDate>Fri, 01 Mar 2019 14:34:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fp14w75zxvj22tc1vk4i9.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fp14w75zxvj22tc1vk4i9.jpg" alt=""><br><a id="more"></a></p><p>本文是<a href="https://www.bilibili.com/video/av9876107/" target="_blank" rel="external">计算机网络课程</a>传输层部分的笔记。</p><h3 id="传输层两个协议简介"><a href="#传输层两个协议简介" class="headerlink" title="传输层两个协议简介"></a>传输层两个协议简介</h3><p>传输层有两个协议：TCP和UDP。</p><p>TCP：传输控制协议(Transmission Control Protocol)。文件分段传输，需要建立会话，可靠传输；流量控制功能</p><p>UDP：用户数据报协议(User Data Protocol) 一个数据包就能够完成数据通信，不分段；不需要建立会话，不需要流量控制；不可靠传输。</p><p>查看会话：<code>netstat -n</code><br>查看是哪个进程创建的会话：<code>netstat -nb</code></p><p>举例场景：<br>DNS域名解析：使用UDP协议；<br>QQ聊天：聊天记录 使用UDP协议；<br>QQ传文件：TCP协议；<br>发送邮件：可能很大需要分段，因此TCP协议；<br>FTP下载文件：TCP<br>屏幕广播 多播：UDP</p><h3 id="传输层协议和应用层协议之间的关系"><a href="#传输层协议和应用层协议之间的关系" class="headerlink" title="传输层协议和应用层协议之间的关系"></a>传输层协议和应用层协议之间的关系</h3><p>http = tcp + 80<br>https = tcp +443<br>rdp = tcp +3389<br>ftp = tcp + 21<br>访问共享文件夹=tcp + 445<br>SMTP【发送】 = TCP + 25<br>POP3【接收】 = TCP + 110<br>Telnet = TCP + 23<br>SQL  = TCP +1433<br>DNS = UDP +53</p><h3 id="服务和应用层协议之间的关系"><a href="#服务和应用层协议之间的关系" class="headerlink" title="服务和应用层协议之间的关系"></a>服务和应用层协议之间的关系</h3><p>服务是由端口决定的。<br>服务是启动状态才侦听端口。<br>网卡是大门，网卡设置安全，只允许80端口【Web服务】。只允许特定服务的端口。</p><p>服务使用TCP或者UDP的端口侦听客户端请求。</p><p>客户端使用IP地址定位服务器，使用目标端口定位服务。<br>可以在服务器网卡上设置只开放必要的端口，实现服务器的网络安全。</p><h4 id="如何在Windows上安装服务"><a href="#如何在Windows上安装服务" class="headerlink" title="如何在Windows上安装服务"></a>如何在Windows上安装服务</h4><p>自带Telnet远程登录。远程桌面服务。<br>DNS服务<br>Web服务<br>SMTP服务<br>POP3服务</p><h4 id="如何查看服务侦听的端口"><a href="#如何查看服务侦听的端口" class="headerlink" title="如何查看服务侦听的端口"></a>如何查看服务侦听的端口</h4><p><code>netstat -an</code>查看服务器上侦听的窗口。<br><code>netstat -n</code>查看建立的会话<br><code>netstat -nb</code>查看建立会话的进程<br><code>telnet 192.168.80.100 3389</code> 测试远程计算机某个端口是否打开。</p><h4 id="如何更改服务使用的默认端口"><a href="#如何更改服务使用的默认端口" class="headerlink" title="如何更改服务使用的默认端口"></a>如何更改服务使用的默认端口</h4><p>  迷惑入侵者，使系统更加安全。</p><h4 id="如何设置Windows网络安全"><a href="#如何设置Windows网络安全" class="headerlink" title="如何设置Windows网络安全"></a>如何设置Windows网络安全</h4><p>只开特定服务端口：本地连接属性——TCP/IP协议属性——高级——选项——属性</p><h3 id="传输层功能和端口范围"><a href="#传输层功能和端口范围" class="headerlink" title="传输层功能和端口范围"></a>传输层功能和端口范围</h3><p>传输层功能：<br>为相互通信的应用程序/应用进程提供了端到端的逻辑通信。（网络层是为主机之间提供了逻辑通信）。<br>传输层要对收到的报文进行差错校验。<br>传输层提供面向连接和无连接的服务。</p><p>传输层端口：16位端口号进行标志，标志本计算机应用层中的各进程。端口号只具有本地意义，本地不冲突即可。</p><p>熟知端口：数值一般为0-1023<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">FTP：21</div><div class="line">TELNET：23</div><div class="line">SMTP：25</div><div class="line">DNS：53</div><div class="line">HTTP：80</div><div class="line">Https：443</div><div class="line">RDP：3389</div></pre></td></tr></table></figure></p><p>登记端口号：数值为1024~49151<br>客户端口号：数值为49152-65535</p><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3><p>UDP的主要特点：<br>UDP是无连接的，即发送数据之前不需要建立连接。<br>UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。<br>UDP面向报文，没有拥塞控制，很适合多媒体通信的要求。<br>UDP支持一对一、一对多、多对一和多对多的交互通信。<br>UDP的首部开销小，只有8个字节。<br><img src="http://wx1.sinaimg.cn/large/c38a0784gy1fow7l7mao9j20mv0bkdk3.jpg" alt="image"></p><h3 id="传输控制协议TCP概述"><a href="#传输控制协议TCP概述" class="headerlink" title="传输控制协议TCP概述"></a>传输控制协议TCP概述</h3><p>TCP是面向连接的传输层协议。TCP把连接作为最基本的抽象。</p><p>TCP提供可靠交付的服务。</p><p>TCP提供全双工通信。</p><p>面向字节流。8bit = 1byte</p><p>每一条TCP连接只能有两个端点(endpoint)，每一条TCP连接只能是点对点的(一对一)。<strong>TCP连接的端点叫做<font color="FC0000">套接字(socket)</font></strong>。端口号拼接到IP地址即构成了套接字。<br>套接字 socket = (IP地址：端口号)</p><p>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：<br>TCP连接::={socket1, socket2}<br>      = {(IP1:port1),(IP2:port2)}</p><h4 id="TCP如何实现可靠传输"><a href="#TCP如何实现可靠传输" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h4><p>可靠传输的工作原理————停止等待协议</p><p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</p><p>这种可靠传输协议常称为自动重传请求(<code>Automatic Repeat reQuest</code>)。</p><p><code>ARQ</code>表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。</p><p>停止等待协议优点是简单，缺点是信道利用率太低。</p><p>流水线传输：发送方可以连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。由于信道上一直有数据不间断地传送，这种传输方式可获得很高的利用率。</p><p>连续ARQ协议：发送方维持发送窗口（发送窗口是5），<font color="FC0000">滑动窗口。</font></p><p>累积确认。</p><h4 id="TCP如何实现流量控制"><a href="#TCP如何实现流量控制" class="headerlink" title="TCP如何实现流量控制"></a>TCP如何实现流量控制</h4><p>接收端告诉发送端接收窗口有多大来实现流量控制。</p><h4 id="TCP协议如何避免网络拥塞"><a href="#TCP协议如何避免网络拥塞" class="headerlink" title="TCP协议如何避免网络拥塞"></a>TCP协议如何避免网络拥塞</h4><p>暂无</p><h3 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h3><p><img src="http://wx1.sinaimg.cn/large/c38a0784gy1fowfjl3fezj20n10e8jvp.jpg" alt="image"><br>首部字节一般是固定部分的20个字节，还有长度可变的选项。</p><table><thead><tr><th>TCP报文段首部</th><th>含义</th></tr></thead><tbody><tr><td>源端口</td><td></td></tr><tr><td>目标端口</td><td></td></tr><tr><td>序号</td><td>第一个字节是整个文章的第几个字节。</td></tr><tr><td>确认号</td><td>收到数据包后，让继续发的号</td></tr><tr><td>数据偏移</td><td>占4位；记录第多少个字节是数据。十进制最大为15，代表最大15x4=60个字节。</td></tr><tr><td>URG</td><td>设为1时代表紧急，发送端不排队，提前传走。</td></tr><tr><td>ACK</td><td>确认号</td></tr><tr><td>PSH</td><td>push，设为1代表接收端不排队，直接交给应用程序</td></tr><tr><td>RST</td><td>reset，表明TCP会话出现严重错误，需要重新连接。</td></tr><tr><td>SYN</td><td>同步，SYN攻击：伪造不存在的IP地址。land攻击：源地址和目的地址同一个。</td></tr><tr><td>FIN</td><td>数据传完了，最后释放连接。</td></tr><tr><td>窗口</td><td>假设客户端接收缓存为65535字节，服务器就设置发送缓存65535字节(不能超过)，反向同样也需要协商</td></tr><tr><td>检验和</td><td></td></tr><tr><td>紧急指针</td><td>URG=1时才起作用。指明紧急数据结束的位置。</td></tr><tr><td>选项(长度可变)</td><td>可以规定最大数据报的长度MSS，是否支持选择性确认SACK，时间戳</td></tr><tr><td>填充</td><td>凑够四个字节整数倍</td></tr></tbody></table><p>三个建立会话的数据包。MSS=1460数据包最大字节</p><h3 id="TCP如何实现可靠传输-1"><a href="#TCP如何实现可靠传输-1" class="headerlink" title="TCP如何实现可靠传输"></a>TCP如何实现可靠传输</h3><p>1.以字节为单位的滑动窗口技术</p><p>发送窗口由接收窗口大小来决定的。</p><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>$$新的RTTs = (1-\alpha)\times (旧的RTTs) + \alpha \times (新的RTT样本)$$</p><p>RFC2988推荐的$\alpha$值为1/8。</p><h3 id="TCP的传输连接管理"><a href="#TCP的传输连接管理" class="headerlink" title="TCP的传输连接管理"></a>TCP的传输连接管理</h3><p>传输连接有三个阶段，即：连接建立、数据传送和连接释放。</p><h4 id="三次握手建立TCP连接"><a href="#三次握手建立TCP连接" class="headerlink" title="三次握手建立TCP连接"></a>三次握手建立TCP连接</h4><p><code>SYN=1，ACK=0，seq=x</code><br><code>SYN=1，ACK=1，seq=y，ack=x+1</code><br><code>ACK=1，seq=x+1，ack=y+1</code></p><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fp143et6n4j20n20e343x.jpg" alt=""></p><h4 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h4><p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fp1471ygbuj20mo0fmtg2.jpg" alt=""></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2019/03/01/network_03_transmission_layer/#disqus_thread</comments>
    </item>
    
    <item>
      <title>计算机网络学习笔记：(二)网络层</title>
      <link>http://wangwlj.com/2019/02/28/network_02_network_layer/</link>
      <guid>http://wangwlj.com/2019/02/28/network_02_network_layer/</guid>
      <pubDate>Thu, 28 Feb 2019 07:34:52 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/c38a0784ly1fp15220grkj22pv3ecqv5.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/c38a0784ly1fp15220grkj22pv3ecqv5.jpg" alt=""><br><a id="more"></a></p><p>本文是<a href="https://www.bilibili.com/video/av9876107/" target="_blank" rel="external">计算机网络课程</a>网络层部分的笔记。</p><p>由于是备战面试，因此跳过了物理层和数据链路层，下面只对上述两层简单回顾一下，对上述两层感兴趣的同学可以去原视频观看。</p><h3 id="物理层和数据链路层简述"><a href="#物理层和数据链路层简述" class="headerlink" title="物理层和数据链路层简述"></a>物理层和数据链路层简述</h3><p>物理层：<br>1.网络设备的机械特性，电气特性，功能特性，过程特性<br>2数据通信的基础知识：数字知识，模拟知识<br>3频分多路复用<br>4时分多路复用</p><p>数据链路层：<br>1.封装成帧<br>2透明封装【转义字符】<br>3无差错接收【差错校验】<br>4点到点线路的数据链路层 PPP<br>5广播信道的数据链路层 CSMA/CD<br>6以太网 集线器，网桥，交换机<br>100M，1000M以太网</p><h3 id="网络层提供的服务"><a href="#网络层提供的服务" class="headerlink" title="网络层提供的服务"></a>网络层提供的服务</h3><p>网络层的功能：负责在不同网络之间尽力转发数据包，基于数据包的IP地址转发。</p><p>如果丢了，不负责数据重传，也不负责顺序。</p><p>实现网络层功能的设备就是路由器。路由器只关心IP地址，选择下一跳在哪。</p><h3 id="网络设备和OSI参考模型关系"><a href="#网络设备和OSI参考模型关系" class="headerlink" title="网络设备和OSI参考模型关系"></a>网络设备和OSI参考模型关系</h3><p>计算机通信的过程是什么？</p><p>1应用程序准备要传送的文件；<br>2传输层，将文件分段，并且编号；<br>3网络层给每一段加上IP地址【目的地址与源地址】【数据包】<br>4数据链路层：【数据帧】<br>使用自己的子网掩码判断自己地址在哪个网段；使用自己的子网掩码判断目标地址在哪个网段。加上物理层的地址<br>两种情况：<br>①同一个网段：ARP协议广播解析目标IP地址的MAC地址<br>②不是一个网段：<br>FCS帧检验序列<br>5物理层传输二进制。【比特流】</p><p><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fov2uym6jbj211l0f4wmm.jpg" alt="image"></p><p>集线器：增强信号<br>交换机：存储转发【链路层，两层设备】<br>路由器：接收比特流，根据数据包选择路径。【网络层设备，三层设备】</p><p>病毒是应用程序，路由器，交换机，集线器等都不会中病毒。</p><h3 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h3><p>在TCP/IP协议族中，属于网络层的协议有：IP/ARP/ICMP与IGMP协议。</p><p><strong>ARP协议</strong>：（Address Resolution Protocol）数据通信之前的操作。将IP地址通过广播，【广播不能跨网段】，目标MAC地址是FF-FF-FF-FF-FF-FF，解析目标IP地址的MAC地址。</p><p><strong>ARP的功能</strong>：利用网络层地址(IP地址)，来取得对应的链路层地址(MAC地址)。</p><p>Mac地址就是在媒体接入层上使用的地址，通俗点说就是网卡的物理地址。现在的Mac地址一般都采用6字节48bit。</p><p>扫描本网段的IP地址</p><p>cmd下的命令<code>gpedit.msc</code> 组策略编辑器——脚本（启动/关机）<br><code>arp -a</code><br>本地链接——修复 清除缓存</p><h3 id="使用ICMP协议的命令——Ping和pathping"><a href="#使用ICMP协议的命令——Ping和pathping" class="headerlink" title="使用ICMP协议的命令——Ping和pathping"></a>使用ICMP协议的命令——Ping和pathping</h3><p><strong>ICMP(Internet Control Message Protocol)</strong>：Internet控制消息协议。该协议是TCP/IP协议集中的一个子协议，属于<strong>网络层协议，主要用于在主机和路由器之间传递控制信息，包括报告错误，交换首先控制和状态信息等。</strong></p><p>当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。我们可以通过<strong>Ping</strong>命令发送ICMP回应请求消息并且记录收到ICMP回应回复消息，通过这些消息来对网络或主机的故障提供参考依据。</p><p><code>Ping</code>命令底层就是<code>ICMP</code>协议。</p><p><code>Ping time</code> 查看延迟。<br>其中的TTL是生存时间，可以判断系统。Linux是<code>64</code>，windows是<code>128</code>，Unix是<code>255</code>。<br><code>Ping 8.8.8.8 -t</code> 一直ping下去<br><code>Ping 8.8.8.8 -l 2000</code> 指定ping时数据包的大小。<br><code>Ping 8.8.8.8 -i 2</code>  更改数据包TTL时间，能够跟踪数据包途径的路由器信息。</p><p>ping 估算网络状况。</p><p><code>pathping</code> 跟踪数据包路径，计算丢包情况【功能更强】</p><p><code>tracert 10.7.1.53</code> 在Windows上跟踪数据包路径的命令，不计算丢包情况。<br><code>traceroute 10.7.1.53</code> 在路由器上跟踪数据包路径的命令</p><p>Ping命令能够产生流量，但不是应用程序。是网络层的程序。不需要应用程序支持。</p><h3 id="IGMP——网络组播管理协议"><a href="#IGMP——网络组播管理协议" class="headerlink" title="IGMP——网络组播管理协议"></a>IGMP——网络组播管理协议</h3><p>点到点通信：每个人都可以自由调节进度<br>广播：一个网段中实现。跨不了路由器。<br>组播 = 多播，相当于频道。</p><h3 id="IP数据报的结构"><a href="#IP数据报的结构" class="headerlink" title="IP数据报的结构"></a>IP数据报的结构</h3><p>一个IP数据报由首部和数据两部分组成。</p><p><img src="http://wx2.sinaimg.cn/large/c38a0784gy1fovzoc61htj20ng0e6aey.jpg" alt="image"></p><p>首部的前一部分是固定长度，共20个字节，是所有IP数据包必须具有的。</p><p>在首部的固定部分的后面是一些可选字段，其长度是可变的。</p><p><strong>数据包最大1500-20=1480字节，超过就要分片了。</strong></p><table><thead><tr><th>IP数据包首部格式</th><th>含义</th></tr></thead><tbody><tr><td>版本</td><td>占4位，用来标识TCP/IP协议的版本 v4 v6</td></tr><tr><td>首部长度</td><td>占4位，一般是20个字节，可变长度一般不用。</td></tr><tr><td>区分服务</td><td>占8位，用来获得更好的服务。区分服务DS(Differentiated Services)QoS</td></tr><tr><td>总长度</td><td>占16位，总长度指首部和数据之和的长度，单位为字节。数据报的最大长度为2^16-1=65535字节。最大传送单元MTU(Maximum Transfer Unit)，当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的MTU值。</td></tr><tr><td>标识(identification)</td><td>占16位，数据包分片后，便于重组</td></tr><tr><td>标志(flag)</td><td>表示是否完整。占3位，目前只有前两位有意义。标志字段的最低位是MF(More Fragment)。MF=1表示后面“还有分片”，MF=0表示最后一个分片。标志字段中间的以为是DF(Dont Fragment)。只有当DF=0时才允许分片。【没有分片的时候为010】</td></tr><tr><td>片偏移</td><td>占13位，片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。数据第一个字节是整个数据包的第多少个字节</td></tr><tr><td>生存时间</td><td>占8位，TTL(Time To Live)，防止路由环路时永不消失。Linux=64; Windows=128; Unix=255;据此可粗略估计系统</td></tr><tr><td>协议号</td><td>占8位，用来标识用哪个协议来处理。ICMP=1；IGMP=2；TCP=6；UDP=17；IPv6=41；OSPF=89</td></tr><tr><td>首部检验和</td><td>占16位，只校验数据报的首部，不检验数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化），不检验数据部分可减少计算的工作量。</td></tr><tr><td>源地址</td><td>占32位</td></tr><tr><td>目的地址</td><td>占32位</td></tr><tr><td>可选字段</td><td>长度可变，很少使用。IPv6没有可变部分。</td></tr></tbody></table><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>让路由器自动学习路由表的协议就是IP协议。</p><p>RIP、<br>OSPF<br>静态路由和动态路由（网络规模大时采用）。</p><p>网络畅通的条件————数据包有去有回。</p><p>路由器必须知道到目的地址网段的下一跳是谁。<br>目的地址无法到达【路由表】；请求超时【有可能是无网关设置】。</p><p><strong>静态路由</strong>：需要管理员gei告诉路由器所有没有直连的网络(如何转发)下一跳给谁。<br>静态路由的缺点：适合于小规模的网络，不能自动调整路由【以适应网络的变化】。</p><p><strong>动态路由</strong>：<br><strong>RIP协议</strong>：周期性地广播路由表，选择最佳路径的标准是跳数，30秒更新一下路由信息。最大跳数为15跳。</p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2019/02/28/network_02_network_layer/#disqus_thread</comments>
    </item>
    
    <item>
      <title>计算机网络学习笔记：(一)概述</title>
      <link>http://wangwlj.com/2018/02/27/network_01_overview/</link>
      <guid>http://wangwlj.com/2018/02/27/network_01_overview/</guid>
      <pubDate>Tue, 27 Feb 2018 07:04:12 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fp150dyosij21xg1g3wtm.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fp150dyosij21xg1g3wtm.jpg" alt=""><br><a id="more"></a><br>本文是<a href="https://www.bilibili.com/video/av9876107/" target="_blank" rel="external">计算机网络课程</a>概述部分的笔记。</p><h3 id="IP地址、域名地址与URL"><a href="#IP地址、域名地址与URL" class="headerlink" title="IP地址、域名地址与URL"></a>IP地址、域名地址与URL</h3><p>IP地址<br>域名地址<br>域名服务器(DNS,Domain Name Server)：提供IP地址和域名之间的转换服务的服务器。</p><p>统一资源定位器(URL，Uniform Resource Locator)由三部分组成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">传输协议：//主机IP地址或域名地址/资源所在路径和文件名</div></pre></td></tr></table></figure></p><p>标识Internet网上资源位置的三种方式：<br>1.IP地址<br>2.域名地址<br>3.URL</p><blockquote><p>路由器的IP地址一般为192.168.0.1，最后一位一般是1.</p></blockquote><h3 id="Internet的工作原理"><a href="#Internet的工作原理" class="headerlink" title="Internet的工作原理"></a>Internet的工作原理</h3><p>TCP/IP数据包。发送文件时，TCP先把该文件分成一个个小数据包，并加上一个特定的信息（可以看成是装箱单），以便接收方的机器确认传输是正确无误的，然后IP再在数据包上标上地址信息，形成可在Internet上传输的TCP/IP数据包。</p><p>使用TCP/IP传送数据：<br>当TCP/IP数据包到达目的地后，计算机首先去掉地址标志，利用TCP的装箱单检查数据在传输中是否有损失，如果接收方发现有损坏的数据包，就要求发送端重新发送被损坏的数据包，确认无误后再将各个数据包重新组合成原文件。</p><p>Internet通过TCP/IP协议这一网上的“世界语”和IP地址实现了它的全球通信的功能。</p><h3 id="TCP-IP协议家族"><a href="#TCP-IP协议家族" class="headerlink" title="TCP/IP协议家族"></a>TCP/IP协议家族</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">IP：Internet Protocol</div><div class="line"> UDP：</div><div class="line"> RTP，traceroute</div><div class="line"> TCP</div><div class="line">  HTTP，FTP，ssh</div></pre></td></tr></table></figure><h3 id="ISO-OSI网络模型"><a href="#ISO-OSI网络模型" class="headerlink" title="ISO/OSI网络模型"></a>ISO/OSI网络模型</h3><p><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fov0hzikdsj20h608owhq.jpg" alt="image"></p><p>7个网络层(Layer)：<br>    Layer 1: Physical - cables                (物理层)<br>    Layer 2: Data Link - ethernet            (数据链路层)<br>    Layer 3: Network - IP                    (网络层)<br>    Layer 4: Transport - TCP/UDP            (传输层)<br>    Layer 5: Session                        (会话层)<br>    Layer 6: Presentation                    (表示层)<br>    Layer 7: Application                     (应用层)</p><p>应用层：所有能产生网络流量的程序【最抽象的层次，最接近软件的层次】<br>表示层：在传输之前是否进行加密 或 压缩处理 二进制 ASCII。【传输前的处理，开发人员处理的事情，不是网络人员。】【出现乱码就是表示层】<br>会话层：建立会话 【查看木马 netstat -n/ netstat -nb】<br>传输层：可靠传输，流量控制【处理速度】，不可靠传输【解析DNS】。<br>网络层： 负责选择最佳路径，规划IP地址【IPv4 v6的改变只会影响网络层】<br>数据链路层：帧的开始和结束 实现透明传输 差错校验【形象的比喻：老式的电话交换机，美女接话员，接线。通讯链路的搭建。】<br>物理层：接口标准 电气标准 如何在物理链路上传输更快的速度。【最底层】</p><p>层次的关系。由底层构造出更高层。</p><h3 id="OSI模型对网络排错的指导"><a href="#OSI模型对网络排错的指导" class="headerlink" title="OSI模型对网络排错的指导"></a>OSI模型对网络排错的指导</h3><p>物理层故障：查看连接状态，查看发送和接收的数据包。<br>具体如：网线接口，水晶头故障【物理层，发送有包，接收没包】</p><p>数据链路层故障：<br>1.笔记本：一个教室可以上网，另一个不可以。原因：Mac地址冲突【改注册表】<br>2.ADSL欠费，网络不通属于数据链路层；<br>3.网速协商不一致【一般是自动协商】<br>4.vlan【虚拟局域网】接入错误的vlan</p><p>网络层故障：<br>配置错误、配置错误的IP地址、子网掩码、网关【选路径】；路由器上没有到达目标网络的路由</p><p>应用层故障：<br>应用程序配置错误； </p><h3 id="OSI参考模型和网络安全"><a href="#OSI参考模型和网络安全" class="headerlink" title="OSI参考模型和网络安全"></a>OSI参考模型和网络安全</h3><p>1.物理层安全【用不到的网线拔掉】<br>2.数据链路层安全： ADSL 账号密码；数据链路层安全 VLAN，交换机端口绑定MAC地址<br>3.网络层安全：在路由器上使用ACL控制数据包流量<br>4.应用层安全：开发的应用程序没有漏洞</p><h3 id="OSI参考模型和TCP-IP协议"><a href="#OSI参考模型和TCP-IP协议" class="headerlink" title="OSI参考模型和TCP/IP协议"></a>OSI参考模型和TCP/IP协议</h3><p>数据封装的过程：<br><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fouyocx8gaj20ji0dan0y.jpg" alt="image"></p><p>计算机在接收到数据帧后，需要去掉为了传输而添加的附加信息，这称为解封装。上述封装操作的逆过程。</p><p><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fouyrp19o7j20ci09ldi9.jpg" alt="image"></p><p>客户进程和服务器进程使用TCP/IP协议进行通信：<br><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fouytd6blbj20if09rq7g.jpg" alt="image"></p><h3 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h3><p><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fov0kk54mmj20dl0d8q79.jpg" alt="image"></p><ol><li>速率：主机在数字信道【一个发送端到一个接收端】上传送数据位数的速率，也称为<code>data rate</code>或<code>bit rate</code>，单位是b/s, kb/s, Mb/s, Gb/s</li><li>带宽：数字信道传送的最高数据率</li><li>吞吐量：单位时间内通过某个网络的数据量。【总的流量】</li><li>时延：【延迟】<br><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fouz5xocvsj20gl0a9q5w.jpg" alt="image"></li><li>时延带宽积【数据量】</li><li>往返时间：RTT(<code>Round-Trip Time</code>)，从发送方发送数据开始，到发送方收到接收方确认【可以使用Ping命令测试，Ping网关】</li><li>利用率：<br>信道利用率=有数据通过时间/(有+无)数据通过时间<br>网络利用率：信道利用率加权平均值。</li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/02/27/network_01_overview/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(十一)关联容器</title>
      <link>http://wangwlj.com/2018/02/26/CPP_11/</link>
      <guid>http://wangwlj.com/2018/02/26/CPP_11/</guid>
      <pubDate>Mon, 26 Feb 2018 13:41:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ws2.sinaimg.cn/mw690/c38a0784gy1fou6gje7a1j23vc2kw7oj.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ws2.sinaimg.cn/mw690/c38a0784gy1fou6gje7a1j23vc2kw7oj.jpg" alt="image"></p><a id="more"></a><h2 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h2><p>关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p><h3 id="关联容器类型"><a href="#关联容器类型" class="headerlink" title="关联容器类型"></a>关联容器类型</h3><table><thead><tr><th>关联容器类型</th><th>含义</th></tr></thead><tbody><tr><td>按关键字有序保存元素</td></tr><tr><td>map</td><td>关联数组，保存关键字-值对</td></tr><tr><td>set</td><td>关键字即值，即只保存关键字的容器</td></tr><tr><td>multimap</td><td>关键字可重复出现的map</td></tr><tr><td>multiset</td><td>关键字可重复出现的set</td></tr><tr><td>无序集合</td></tr><tr><td>unordered_map</td><td>用哈希函数组织的map</td></tr><tr><td>unordered_set</td><td>用哈希函数组织的set</td></tr><tr><td>unordered_multimap</td><td>哈希组织的map；关键字可以重复出现</td></tr><tr><td>unordered_multiset</td><td>哈希组织的set；关键字可以重复出现</td></tr></tbody></table><p>map是关键字-值对的集合，因此map类型被称为关联数组(<code>associative array</code>)。<br>set就是关键字的简单集合。当想知道一个值是否存在的时候，set是最有用的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//chap11_1_word_count_exclude_some_words.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> *统计每个单词在输入中出现的次数。</span></div><div class="line"><span class="comment"> *Linux g++ 5.4.0 编译通过。</span></div><div class="line"><span class="comment"> *命令：</span></div><div class="line"><span class="comment"> *      g++  -std=c++11 chap11_1_word_count_exclude_some_words.cpp</span></div><div class="line"><span class="comment"> *      ./a.out</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</div><div class="line">    <span class="comment">//对关联容器的元素进行列表初始化</span></div><div class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"The"</span>, <span class="string">"But"</span>, <span class="string">"And"</span>, <span class="string">"Or"</span>, <span class="string">"An"</span>, <span class="string">"A"</span>,</div><div class="line">                           <span class="string">"the"</span>, <span class="string">"but"</span>, <span class="string">"and"</span>, <span class="string">"or"</span>, <span class="string">"an"</span>, <span class="string">"a"</span>&#125;;</div><div class="line">    <span class="built_in">string</span> word;</div><div class="line">    <span class="comment">//在新的一行按CTRL+Z（或者LINUX类系统中按CTRL+D）即可终止循环。</span></div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word) &#123;</div><div class="line">        <span class="comment">//find调用返回一个迭代器，只统计不在exclude中的单词。</span></div><div class="line">        <span class="keyword">if</span>(exclude.find(word) == exclude.end())</div><div class="line">            ++word_count[word];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_count) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">" occur "</span> &lt;&lt; w.second </div><div class="line">             &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">" times"</span> : <span class="string">" time"</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="练习11-4"><a href="#练习11-4" class="headerlink" title="练习11.4"></a>练习11.4</h3><p>统计每个单词在输入中出现的次数。要求：忽略标点符号且大小写无关。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//chap11_exersize_4.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> *统计每个单词在输入中出现的次数。[忽略标点符号且大小写无关]</span></div><div class="line"><span class="comment"> *Linux g++ 5.4.0 编译通过。</span></div><div class="line"><span class="comment"> *命令：</span></div><div class="line"><span class="comment"> *      g++  -std=c++11 chap11_exersize_4.cpp</span></div><div class="line"><span class="comment"> *      ./a.out</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; word_count;</div><div class="line">    <span class="comment">//对关联容器的元素进行列表初始化</span></div><div class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exclude = &#123;<span class="string">"The"</span>, <span class="string">"But"</span>, <span class="string">"And"</span>, <span class="string">"Or"</span>, <span class="string">"An"</span>, <span class="string">"A"</span>,</div><div class="line">                           <span class="string">"the"</span>, <span class="string">"but"</span>, <span class="string">"and"</span>, <span class="string">"or"</span>, <span class="string">"an"</span>, <span class="string">"a"</span>&#125;;</div><div class="line">    <span class="built_in">string</span> word;</div><div class="line">    <span class="comment">//在新的一行按CTRL+Z（或者LINUX类系统中按CTRL+D）即可终止循环。</span></div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word) &#123;</div><div class="line">        <span class="comment">//将字母统一转化为小写形式</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : word) &#123;</div><div class="line">            ch = <span class="built_in">tolower</span>(ch); <span class="comment">//针对每一字母</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//删去标点</span></div><div class="line">        word.erase(remove_if(word.begin(), word.end(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>(*)(<span class="keyword">int</span>)&gt;(&amp;<span class="built_in">ispunct</span>)), word.end());</div><div class="line">    </div><div class="line">        <span class="comment">//find调用返回一个迭代器，只统计不在exclude中的单词。</span></div><div class="line">        <span class="keyword">if</span>(exclude.find(word) == exclude.end())</div><div class="line">            ++word_count[word];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;w : word_count) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; w.first &lt;&lt; <span class="string">" occur "</span> &lt;&lt; w.second </div><div class="line">             &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">" times"</span> : <span class="string">" time"</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h2><p>关联容器都支持普通容器操作。关联容器不支持顺序容器的位置相关的操作，原因是关联容器中元素都是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。</p><p>pair标准库类型，位于头文件utility中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">// error: in C++98 ‘p’ must be initialized by constructor, not by ‘&#123;...&#125;’</span></div><div class="line"><span class="comment">// command:</span></div><div class="line"><span class="comment">//      g++ chap11_2_pair.cpp -std=c++11</span></div><div class="line"><span class="comment">//      ./a.out</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> s = <span class="string">"hello"</span>;</div><div class="line">    <span class="comment">//初始化方式有很多，这是列表初始化</span></div><div class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">size_t</span>&gt; p = &#123;s, s.size()&#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of string \""</span>&lt;&lt; p.first &lt;&lt; <span class="string">"\" is "</span> &lt;&lt; p.second &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h2><h3 id="关联容器额外的类型别名"><a href="#关联容器额外的类型别名" class="headerlink" title="关联容器额外的类型别名"></a>关联容器额外的类型别名</h3><table><thead><tr><th>关联容器额外的类型别名</th><th>含义</th></tr></thead><tbody><tr><td>key_type</td><td>此容器类型的关键字类型</td></tr><tr><td>mapped_type</td><td>每个关键字关联的类型：只适用于map</td></tr><tr><td>value_type</td><td>对于set，与key_type相同，对于map，为<code>pair&lt;const key_type,mapped_type&gt;</code></td></tr></tbody></table><h3 id="关联容器insert操作"><a href="#关联容器insert操作" class="headerlink" title="关联容器insert操作"></a>关联容器insert操作</h3><table><thead><tr><th>关联容器额外的类型别名</th><th>含义</th></tr></thead><tbody><tr><td>c.insert(v)</td></tr><tr><td>c.elmpace(args)</td><td>v是value_type类型对象；args用来构造一个元素。对于map和set，只有当元素关键字不在c中才插入(或构造)元素。函数返回一个pair，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否是否成功的bool值。对于multimap和multiset，总会插入(或构造)给定元素，并返回一个指向新元素的迭代器。</td></tr><tr><td>c.insert(b,e)           </td></tr><tr><td>c.insert(il)</td><td>b和e是迭代器，表示一个c::value_type类型值的范围；il是这种值的花括号列表。函数返回void。对于map和set，只插入关键字不在c中的元素。对于multimap和multiset，则会插入范围中的每个元素。</td></tr><tr><td>c.insert(p,v)     </td></tr><tr><td>c.insert(p,args)</td><td>类似insert(v)(或emplace(args))，但迭代器p作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素。</td></tr></tbody></table><h3 id="map和unordered-map的下标操作"><a href="#map和unordered-map的下标操作" class="headerlink" title="map和unordered_map的下标操作"></a>map和unordered_map的下标操作</h3><table><thead><tr><th>map和unordered_map的下标操作</th><th>含义</th></tr></thead><tbody><tr><td>c[k]</td><td>返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化</td></tr><tr><td>c.at[k]</td><td>访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常</td></tr></tbody></table><h3 id="在一个关联容器中查找元素"><a href="#在一个关联容器中查找元素" class="headerlink" title="在一个关联容器中查找元素"></a>在一个关联容器中查找元素</h3><table><thead><tr><th>关联容器中查找元素</th><th>含义</th></tr></thead><tbody><tr><td>lower_bound和upper_bound</td><td>不适用于无序容器。</td></tr><tr><td>下标和at操作只适用于</td><td>非const的map和unordered_map</td></tr><tr><td>c.find(k)</td><td>返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器</td></tr><tr><td>c.count(k)</td><td>返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远是0和1</td></tr><tr><td>c.lower_bound(k)</td><td>返回一个迭代器，指向第一个关键字不小于k的元素</td></tr><tr><td>c.upper_bound(k)</td><td>返回一个迭代器，指向第一个关键字大于k的元素</td></tr><tr><td>c.equal_range(k)</td><td>返回一个迭代器pair，表示关键字等于k的元素的范围。若k不存在，pair的两个成员均等于c.end()</td></tr></tbody></table><h2 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h2><h3 id="无序容器管理操作"><a href="#无序容器管理操作" class="headerlink" title="无序容器管理操作"></a>无序容器管理操作</h3><table><thead><tr><th>关联容器中查找元素</th><th>含义</th></tr></thead><tbody><tr><td>桶接口</td></tr><tr><td>c.bucket_count()</td><td>正在使用的桶的数目</td></tr><tr><td>c.max_bucket_count()</td><td>容器能容纳的最多的桶的数量</td></tr><tr><td>c.bucket_size()</td><td>第n个桶中有多少个元素</td></tr><tr><td>c.bucket(k)</td><td>关键字为k的元素在哪个桶中</td></tr><tr><td>桶迭代</td></tr><tr><td>local_iterator</td><td>可以用来访问桶中元素的迭代器类型</td></tr><tr><td>const_local_iterator</td><td>桶迭代器的const版本</td></tr><tr><td>c.begin(n),c.end(n)</td><td>桶n的首元素迭代器和尾后迭代器</td></tr><tr><td>c.cbegin(n),c.cend(n)</td><td>与前两个函数类似，但返回<code>const_local_iterator</code></td></tr><tr><td>哈希策略</td></tr><tr><td>c.load_factor()</td><td>每个桶的平均元素数量，返回float值</td></tr><tr><td>c.max_load_factor()</td><td>c试图维护的平均桶大小，返回float值。c会在需要时添加新的桶，以使得<code>load_factor&lt;=max_load_factor</code></td></tr><tr><td>c.rehash(n)</td><td>重组存储，使得bucket_count&gt;=n且bucket_count&gt;size/max_load_factor</td></tr><tr><td>c.reserve(n)</td><td>重组存储，使得c可以保存n个元素且不必rehash</td></tr></tbody></table><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>关联容器：associative container<br>无序容器：unordered container<br>哈希函数：hash function</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/vernice/article/details/50816730" target="_blank" rel="external">c++ 去除字符串中的空格和标点符号 （remove_if 函数的用法）</a><br><a href="http://blog.csdn.net/libin1105/article/details/48749231" target="_blank" rel="external">《C++primer(第五版)》学习之路-第十一章：关联容器</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/02/26/CPP_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(10) 第十二章 二叉搜索树</title>
      <link>http://wangwlj.com/2018/02/02/algorithm_tutorial_chapter_12/</link>
      <guid>http://wangwlj.com/2018/02/02/algorithm_tutorial_chapter_12/</guid>
      <pubDate>Fri, 02 Feb 2018 14:39:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ws2.sinaimg.cn/mw690/c38a0784gy1fou65t0kztj22o01s0b29.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ws2.sinaimg.cn/mw690/c38a0784gy1fou65t0kztj22o01s0b29.jpg" alt="image"></p><a id="more"></a><h2 id="二叉搜索树概述"><a href="#二叉搜索树概述" class="headerlink" title="二叉搜索树概述"></a>二叉搜索树概述</h2><p>搜索树数据结构支持许多动态集合操作：<code>SEARCH</code>、<code>MINIMUM</code>、<code>MAXIMUM</code>、<code>PREDECESSOR</code>、<code>SUCCESSOR</code>、<code>INSERT</code>与<code>DELETE</code>。</p><p>上述基本操作花费的时间与这棵树的高度成正比。</p><h3 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h3><p>（1）设<code>x</code>为二叉查找树中的一个结点，若<code>y</code>是<code>x</code>左子树中的一个结点，则<code>key[y] &lt;= key[x</code>]；若<code>y</code>是<code>x</code>右子树中的一个结点，则<code>key[x]&lt;=key[y]</code><br>（2）二叉查找树上执行的基本操作的时间与树的高度成正比。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>每个节点就是一个对象，包含：关键字<code>key</code>，卫星数据<code>data</code>，以及三个属性：分别指向父、左右孩子的指针<code>p</code>,<code>left</code>, <code>right</code></p><h3 id="在二叉查找树上的操作"><a href="#在二叉查找树上的操作" class="headerlink" title="在二叉查找树上的操作"></a>在二叉查找树上的操作</h3><p>查找一个关键字：SEARCH(x, k)<br>求最小关键字：MINIMUM(x)<br>求最大关键字：MAXIMUM(x)<br>求前驱：PREDECESSOR(x)<br>求后继：SUCCESSOR(x)<br>插入一个结点：INSERT(T, z)<br>删除一个结点：DELETE(z)</p><h3 id="二叉查找树的应用"><a href="#二叉查找树的应用" class="headerlink" title="二叉查找树的应用"></a>二叉查找树的应用</h3><p>1.遍历：中序遍历、先序遍历、后序遍历【根关键字遍历的先后顺序】</p><p>2.查找：查找包含某个关键字的结点，查找关键字最大或最小的结点、查找某个结点的前驱或后继</p><h3 id="12-1-2"><a href="#12-1-2" class="headerlink" title="12.1-2"></a>12.1-2</h3><p>二叉搜索树的性质与最小堆的性质有什么不同？</p><p>二叉搜索树：左子树关键字&lt;=根结点关键字&lt;=右子树关键字</p><p>最小堆：左子树关键字&gt;=根结点关键字 &amp;&amp; 右子树关键字&gt;=根结点关键字</p><p>不能，因为一个结点的的左子树与右子树的关键字大小没有关系</p><h3 id="12-1-3-遍历的非递归实现"><a href="#12-1-3-遍历的非递归实现" class="headerlink" title="12.1-3 遍历的非递归实现"></a>12.1-3 遍历的非递归实现</h3><p>给出一个非递归的中序树遍历算法。(提示：有两种方法，在较容易的方法中，可以采用栈作为辅助数据结构；较复杂的方法中，不采用栈结构，但假设可以测试两个指针是否相等)。</p><p>中根遍历要求顺序是左根右，借助栈s实现。先将根root入栈，接着从根root开始查找最左的子孩子结点直到为空为止，然后将空节点出栈，再将左子树节点出栈遍历，然后判断该左子树的右子树节点入栈。循环此过程，直到栈为空为止。此时需要注意的是入栈过程中空结点也入栈了，用以判断左孩子是否结束和左孩子是否有右孩子结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//中序遍历非递归过程</span></div><div class="line"><span class="keyword">void</span> BST_Tree::Inorder_Iterative_Traverse(BST_Node *root)</div><div class="line">&#123;  <span class="comment">//用C++STL——栈stack实现</span></div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">//空树</span></div><div class="line">    <span class="built_in">stack</span>&lt;BST_Node *&gt;s;</div><div class="line">    s.push(root);</div><div class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</div><div class="line">        BST_Node *p = s.top();</div><div class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)        <span class="comment">//直到左节点为空，即最小元素</span></div><div class="line">        &#123;</div><div class="line">            s.push(p-&gt;left);</div><div class="line">            p = s.top();</div><div class="line">        &#125;                           </div><div class="line">        s.pop();                <span class="comment">//空结点出栈</span></div><div class="line">        <span class="keyword">if</span>(!s.empty())</div><div class="line">        &#123;</div><div class="line">            p = s.top();</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;key &lt;&lt; <span class="string">" "</span>;</div><div class="line">            s.pop();</div><div class="line">            s.push(p-&gt;right);   <span class="comment">//右子树结点入栈（不一定有右节点，可以压入NULL</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>一个更加简洁的写法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//中序遍历非递归过程——简洁版</span></div><div class="line"><span class="keyword">void</span> BST_Tree::Inorder_Iterative_Traverse_2(BST_Node *root)</div><div class="line">&#123;  <span class="comment">//用C++STL——栈stack实现</span></div><div class="line">    <span class="built_in">stack</span>&lt;BST_Node *&gt;s;</div><div class="line">    BST_Node *p = root;</div><div class="line">    <span class="keyword">while</span> (p || !s.empty()) &#123;</div><div class="line">        <span class="keyword">if</span>(p != <span class="literal">NULL</span>)           <span class="comment">//左节点入栈</span></div><div class="line">        &#123;</div><div class="line">            s.push(p);          <span class="comment">//压入值非空</span></div><div class="line">            p = p-&gt;left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;   <span class="comment">//出栈遍历</span></div><div class="line">            p = s.top();</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;key &lt;&lt; <span class="string">" "</span>;</div><div class="line">            s.pop();</div><div class="line">            p = p-&gt;right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="查询二叉搜索树"><a href="#查询二叉搜索树" class="headerlink" title="查询二叉搜索树"></a>查询二叉搜索树</h2><h3 id="查找任一节点"><a href="#查找任一节点" class="headerlink" title="查找任一节点"></a>查找任一节点</h3><p>伪码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">TREE-SEARCH(x, k)</div><div class="line">if x == NIL or k == x.key</div><div class="line">    return x</div><div class="line">    if k &lt; x.key</div><div class="line">    return TREE-SEARCH(x.left, k)</div><div class="line">   else return TREE-SEARCH(x.right, k)</div><div class="line"></div><div class="line">INTERATIVE-TREE-SEARCH(x, k)</div><div class="line">while x != NIL and k != x.key</div><div class="line">        if k &lt; x.key</div><div class="line">            x = x.left</div><div class="line">        else x = x.right</div><div class="line">    return x</div></pre></td></tr></table></figure></p><p>运行时间为$O(h)$，h为树的高度。</p><h3 id="最大关键字元素和最小关键字元素"><a href="#最大关键字元素和最小关键字元素" class="headerlink" title="最大关键字元素和最小关键字元素"></a>最大关键字元素和最小关键字元素</h3><p>根据二叉查找树的特征，很容易查找出最大和最小关键字。<br>查找二叉树中的最小关键字：从根结点开始，沿着各个节点的left指针查找下去，直到遇到NULL时结束。如果一个结点x无左子树，则以x为根的子树中，最小关键字就是key[x]。<br>查找二叉树中的最大关键字：从根结点开始，沿着各个结点的right指针查找下去，直到遇到NULL时结束。</p><p>书中给出了查找最大最小关键字的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">TREE-MINIMUM(x)</div><div class="line">while x.left != NIL</div><div class="line">    x = x.left</div><div class="line">    return x</div><div class="line">    </div><div class="line">TREE-MAXIMUM(x)</div><div class="line">while x.right != NIL</div><div class="line">    x = x.right</div><div class="line">    return x</div></pre></td></tr></table></figure><p>均能在$O(h)$时间内执行完。</p><h3 id="后继与前驱"><a href="#后继与前驱" class="headerlink" title="后继与前驱"></a>后继与前驱</h3><p>伪码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">TREE-SUCCESSOR(x)</div><div class="line">if x.right != NIL</div><div class="line">    return TREE-MINIMUM(x.right)</div><div class="line">    y = x.p</div><div class="line">    while y != NIL and x == y.right</div><div class="line">    x = y</div><div class="line">        y = y.p</div><div class="line">    return y</div></pre></td></tr></table></figure></p><p>x.p 指向双亲。 右侧为空，则向上搜索。</p><blockquote><p>在一颗高度为<code>h</code>的二叉搜索树上，动态集合上的操作<code>SEARCH</code>、<code>MINIMUM</code>、<code>MAXIMUM</code>、<code>SUCCESSOR</code> 和<code>PREDECEDOR</code>可以在$O(h)$时间内完成。</p></blockquote><h2 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>伪码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">TREE-INSERT(T,z)</div><div class="line">y = NIL</div><div class="line">    x = T.root</div><div class="line">    while x != NIL</div><div class="line">    y = x</div><div class="line">        if z.key &lt; x.key</div><div class="line">        x = x.left</div><div class="line">        else x = x.right</div><div class="line">    z.p = y</div><div class="line">    if y == NIL</div><div class="line">    T.root = z   # tree T is empty</div><div class="line">    else if z.key &lt; y.key</div><div class="line">    y.left = z</div><div class="line">    else y.right = z</div></pre></td></tr></table></figure></p><p>从树根开始，指针x记录了一条向下的简单路径，直到查找到要替换为输入项z的NIL。NIL占据的位置就是z放置的位置。<br>上述过程保持遍历指针(<code>trailing pointer</code>)y作为x的双亲，找到NIL时需要直到z属于哪个节点。</p><p>该过程可以在$O(h)$时间内完成。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>从二叉查找树中删除给定的结点z，分以下情况讨论：</p><ul><li>如果z没有左孩子，那么用右孩子来替换z</li><li>如果z有且仅有一个左孩子，那么用其左孩子替换z</li><li>否则，z既有左孩子又有右孩子，此时我们查找z 的后继y，这个后继位于z的右子树中并且没有左孩子。则将y移出原来的位置进行拼接，并替换数中的z。</li><li>如果y是z的右孩子，那么用y替换z，并且仅留下y的右孩子。</li></ul><p>伪码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">TRANSPLANT(T,u,v)</div><div class="line">    if u.p == NIL</div><div class="line">        T.root = v</div><div class="line">    else if u == u.p.left</div><div class="line">        u.p.left = v</div><div class="line">    else u.p.right = v</div><div class="line">    if v != NIl</div><div class="line">        v.p = u.p</div><div class="line">        </div><div class="line">TREE-DELETE(T,z)</div><div class="line">if z.left == NIL</div><div class="line">    TRANSPLANT(T,z,z.right)</div><div class="line">else if z.right == NIL</div><div class="line">    TRANSPLANT(T,z,z.left)</div><div class="line">    else y = TREE-MINIMUM(z.right)</div><div class="line">    if y.p != z</div><div class="line">        TRANSPLANT(T,y,y.right)  # 删除y</div><div class="line">            y.right = z.right</div><div class="line">            y.right.p = y</div><div class="line">        TRANSPLANT(T,z,y)</div><div class="line">        y.left = z.left</div><div class="line">        y.left.p = y</div></pre></td></tr></table></figure></p><blockquote><p>定理12.3 在一颗高度为<code>h</code>的二叉搜索树上，实现动态集合操作<code>INSERT</code>和<code>DELETE</code>的运行时间均为$O(h)$。</p></blockquote><h2 id="随机构建二叉搜索树"><a href="#随机构建二叉搜索树" class="headerlink" title="随机构建二叉搜索树"></a>随机构建二叉搜索树</h2><p>二叉查找树各种操作时间均是$O(h)$，构建二叉查找树时，一般只用插入函数，这样便于分析，如果按严格增长顺序插入，那么构造出来的树就是一个高度为<code>n-1</code>的链。另一方面练习<code>B.5-4</code>说明了<code>h≥lgn</code>.这里我特别证明下。</p><p>证明：一个有n个结点的非空二叉树的高度至少为<code>lgn</code>。</p><p>对于一个高度为<code>h</code>的二叉树总结点数至多为<code>n≤2^h-1</code>(等于的情况就是完全二叉树)，所以给这个不等式适当变型得：<code>h≥lg(n+1)≥lgn</code>,所以对于<code>n</code>个结点的数高度至少为<code>lgn</code>。虽然没有用归纳法，但是这种方法感觉简单易懂。</p><blockquote><p>定理12.4 一棵有<code>n</code>个不同关键字的随机构建二叉搜索树(<code>random built binary search tree</code>)的期望高度为<code>O(lgn)</code>。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>算法导论 第三版 中文版</li><li><a href="http://blog.csdn.net/z84616995z/article/details/28880407" target="_blank" rel="external">算法导论第十二(12)章 二叉查找树</a></li><li><a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7718917" target="_blank" rel="external">算法导论 第12章 二叉查找树</a></li><li><a href="http://blog.csdn.net/luming_xml/article/details/51277023" target="_blank" rel="external">《算法导论》第12章 二叉查找树</a></li><li><a href="http://blog.csdn.net/z84616995z/article/details/20854381" target="_blank" rel="external">二叉树的递归与非递归实现</a></li><li><a href="http://blog.csdn.net/sdulibh/article/details/50573036" target="_blank" rel="external">对于二叉树三种非递归遍历方式的理解</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/02/02/algorithm_tutorial_chapter_12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>摄影 | 152年一遇的月全食</title>
      <link>http://wangwlj.com/2018/02/01/photo_total_lunar_eclipse/</link>
      <guid>http://wangwlj.com/2018/02/01/photo_total_lunar_eclipse/</guid>
      <pubDate>Thu, 01 Feb 2018 15:06:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/c38a0784gy1fo1cdvwz8dj22ch26j1kz.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ws1.sinaimg.cn/large/c38a0784gy1fo1cdvwz8dj22ch26j1kz.jpg" alt="image"></p><a id="more"></a><p>2018年01月31日晚上（也就是昨天）的月全食据说是152年一遇的月全食。</p><p>大概是今天看到了如下这张图片之后，想着自己也可以弄一张类似的照片。<br><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=efca4ecac9177f3e0439f45f11a650a2/0bd162d9f2d3572c2fdd40a08a13632762d0c38b.jpg" alt=""></p><p>于是便有了封面图的诞生。</p><p>这应该是第三次拍摄月亮了。</p><p>第一次是一个偶然的白天，晴空万里，一抬头居然发现了月亮。<br><img src="http://wx1.sinaimg.cn/large/c38a0784gy1fo1d5e3r4nj20ku0z3gmd.jpg" alt="image"></p><p>第二次，是2016年11月14日出现了超级大月亮，当时也拍摄了几张照片，顺便也附带上。<br><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fo1cuub8wgj20vq0lqjru.jpg" alt="image"><br><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fo1cv4h6eej20zk0mewex.jpg" alt="image"></p><p>第三次就是昨天晚上的月全食啦。<br>就以封面图结束吧。以后等照片多了，说不定就弄个照片墙～</p><p><img src="http://ws1.sinaimg.cn/large/c38a0784gy1fo1cdvwz8dj22ch26j1kz.jpg" alt="image"></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/02/01/photo_total_lunar_eclipse/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(9) 第十一章 散列表</title>
      <link>http://wangwlj.com/2018/01/30/algorithm_tutorial_chapter_11/</link>
      <guid>http://wangwlj.com/2018/01/30/algorithm_tutorial_chapter_11/</guid>
      <pubDate>Tue, 30 Jan 2018 14:39:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/mw690/c38a0784ly1fnxit86pfwj211y0lc7of.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ws1.sinaimg.cn/mw690/c38a0784ly1fnxit86pfwj211y0lc7of.jpg" alt=""></p><a id="more"></a><p>直接寻址表(<code>direct-address table</code>)缺点：如果全域U很大，分配直接寻址表T也不太现实；另一方面，实际存储的关键字集合<code>K</code>相对于<code>U</code>来说可能很小，导致浪费空间。</p><h2 id="散列表综述"><a href="#散列表综述" class="headerlink" title="散列表综述"></a>散列表综述</h2><p>散列表（<code>hash table</code>，也叫哈希表），支持<code>INSERT</code>、<code>SEARCH</code>、<code>DELETE</code>操作。</p><p>散列表可以使得在表小的情况下仍能够保存数据，并且能够在常数时间<code>O(1)</code>内完成查询。为什么是常数时间呢？因为我们不需要比较，不需要遍历查找，只要计算出地址，有待查询的值那么就找到了；没有，那么表中就不存在。</p><p>把关键字<code>k</code>映射到槽<code>h(k)</code>上的过程称为散列。<code>h</code>表示散列函数(<code>hash function</code>)，由关键字k计算出槽(<code>slot</code>)的位置。</p><p>多个关键字映射到同一个数组下标位置(槽)称为碰撞（或冲突，<code>collision</code>）。</p><p>好的散列函数应使每个关键字都等可能地散列到m个槽位中。</p><h3 id="链接法解决冲突"><a href="#链接法解决冲突" class="headerlink" title="链接法解决冲突"></a>链接法解决冲突</h3><p>链接法：把散列到同一个槽的所有元素都放在一个链表中。槽中存放指向该槽的所有元素的链表的表头；如果不存在这样的元素，则槽中为<code>NIL</code>。</p><h3 id="链接法散列的分析"><a href="#链接法散列的分析" class="headerlink" title="链接法散列的分析"></a>链接法散列的分析</h3><p>一个存放n个元素的、具有m个槽位的散列表T，其<strong>装载因子</strong>(<code>load factor</code>)为：$\alpha = \frac nm$，表示一个链的平均存储元素数。</p><p>简单均匀散列(<code>simple uniform hashing</code>)：一个给定元素，等可能地散列到m个槽位中的任意一个上，且与其他元素被散列到什么位置无关。</p><blockquote><p>在简单均匀散列的假设下，对于用链接法解决冲突的散列表，一次不成功查找的平均时间为$\Theta(1+\alpha)$，一次成功查找所需的平均时间也为$\Theta(1+\alpha)$</p></blockquote><p>当散列表的槽数与表中元素个数成正比，则有$n= \text{O}(m)$，查找需要常数时间$\text{O}(1)$。当链表为双向链表时，插入和删除的最坏情况也是$\text{O}(1)$。</p><h2 id="Hash函数（11-3，P147）"><a href="#Hash函数（11-3，P147）" class="headerlink" title="Hash函数（11.3，P147）"></a>Hash函数（11.3，P147）</h2><p>我们如何设计一个好的Hash函数（哈希函数，散列函数）？本节介绍了三种设计哈希函数的方法：除法散列、乘法散列和全域散列。</p><h3 id="好的哈希函数的特点"><a href="#好的哈希函数的特点" class="headerlink" title="好的哈希函数的特点"></a>好的哈希函数的特点</h3><p>这里有两个要点：</p><p>一个好的哈希函数应该能够将关键字均匀的分配到哈希表T中；</p><p>而关键字的分布率不应该影响这种均匀性。</p><h3 id="除法散列法"><a href="#除法散列法" class="headerlink" title="除法散列法"></a>除法散列法</h3><p>定义<code>hash</code>函数为 $h(k) = k \;\text{mod}\; m$</p><p><code>m</code>取值的原则就是<code>m</code>选为质数且不能太接近<code>2</code>或者<code>10</code>的幂次。</p><p>原因：键值的低位可能具有某种分布规律，如果选择<code>2</code>或者<code>10</code>的幂次容易出现冲突。比如$2^r$，关键字只会考虑二进制的低<code>r</code>位；十进制类似。</p><h3 id="乘法散列法"><a href="#乘法散列法" class="headerlink" title="乘法散列法"></a>乘法散列法</h3><p>乘法散列法的公式为：$h(k) = m(kA\; \text{mod}\; 1) $</p><p>其中，$0&lt;A&lt;1$。</p><p>一般的实现方法如下：假设计算机字长是<code>w</code>位，限制A是形如$A =\frac {s}{2^w}$的分数，整数<code>s</code>取值范围为$0&lt; s &lt;2^w $。用整数$s=A\cdot 2^w$乘上<code>k</code>，其结果是2w位的值$r_1 2^w + r_0 $</p><p>A的取值理想情况为$ A \approx \sqrt 5-1 = 0.6180339887\cdots $。（这不就是黄金分割率么……）根据A的取值计算s的值。</p><p>乘法散列法的优点是<code>m</code>的取值不是很关键，一般取为<code>m=2^r</code>。</p><h3 id="11-3-4"><a href="#11-3-4" class="headerlink" title="11.3-4"></a>11.3-4</h3><p>考虑一个大小为<code>m=1000</code>的散列表和一个对应的散列函数<code>h(k)=m(kAmod1)</code>,其中<code>A=(√5-1)/2</code>,试计算关键字61,62,63,64和65被映射到位置。</p><p>直接根据公式计算，实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;  </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> A=(<span class="built_in">sqrt</span>(<span class="number">5</span>)<span class="number">-1</span>)/<span class="number">2.0</span>;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> m)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">double</span> x=(A*k-(<span class="keyword">int</span>)(A*k))*m;  </div><div class="line">    <span class="keyword">return</span> x;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">   <span class="keyword">int</span> k;  </div><div class="line">   <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;k)  </div><div class="line">   &#123;  </div><div class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hash["</span>&lt;&lt;k&lt;&lt;<span class="string">"]="</span>&lt;&lt;hash(k,<span class="number">1000</span>)&lt;&lt;<span class="built_in">endl</span>;  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p>开放寻址法是另一种解决冲突的方法。</p><p>开放寻址法的特点：装载因子不会超过1；不用指针就可以计算出槽的序列。</p><p>插入元素的过程叫做探查(<code>probe</code>)：连续地检查散列表，直到找到一个空槽来放置待插入的关键字为止。检查顺序依赖于待插入的关键字</p><p>开放寻址法的散列函数有第二个参数：探查序号。</p><p>插入元素的伪码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">HASH-INSERT(T,k)</div><div class="line">i = 0</div><div class="line">    repeat</div><div class="line">    j = h(k, i)</div><div class="line">        if T[j] = NIL</div><div class="line">        T[j] = k </div><div class="line">            return j</div><div class="line">        else i = i + 1</div><div class="line">    util i == m</div><div class="line">    error &quot;hash table overflow&quot;</div></pre></td></tr></table></figure></p><p>查找元素的伪码：（由于是依次插入，因此可以依次查找；有个前提：关键字不会被删除）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HASH-SEARCH(T,k)</div><div class="line">i = 0</div><div class="line">    repeat</div><div class="line">    j = h(k, i)</div><div class="line">        if T[j] = K </div><div class="line">            return j</div><div class="line">        else i = i + 1</div><div class="line">    util T[j] == NIl or i == m</div><div class="line">    return NIL</div></pre></td></tr></table></figure></p><p>在开放寻址法中，删除操作比较困难，但也有解决办法，在必须删除关键字的应用中，往往采用链接法解决碰撞。</p><h3 id="三种探查技术"><a href="#三种探查技术" class="headerlink" title="三种探查技术"></a>三种探查技术</h3><p>三种探查技术来计算探查序列：</p><p>1)线性探查：<br>$$h(k,i)=(h’(k)+i)\text{mod}\; m,\; i=0,1,\cdots,m-1$$<br>线性探查存在问题：一次群集(primary clustering)。</p><p>2)二次探查：<br>$$h(k,i)=(h’(k)+c_1i+c_2i^2)\text{mod}\; m, \; i=0,1,\cdots,m-1$$<br>二次探查存在问题：二次群集(secondary clustering)。二次探查与线性探查都是初始位置决定了探查序列，且只有m个探查序列被使用到。</p><p>3)双重探查：<br>$$h(k,i)=(h_1(k)+ih_2(k))\text{mod}\; m, \; i=0,1,\cdots,m-1 $$<br>双重探查要求值$h_2(k)$与表的大小<code>m</code>互素。一种简便的方法是：<code>m</code>取<code>2</code>的幂，$h_2(k)$只产生奇数；或者m为素数，h2总是返回比m小的正整数。</p><p>由于每一对可能的$ (h_1(k), h_2(k))$都会产生一个不同的探查序列，因此双重散列法用到了$\Theta(m^2) $种探查序列。</p><p>双重散列的例子：<br>$$h_1(k) = k \;\text{mod}\; m ,\;h_2(k) = 1+(k\; \text{mod} \;m’) $$<br>取m为素数，$m’ $略小于m（比如，m-1）</p><h3 id="开放寻址散列的分析："><a href="#开放寻址散列的分析：" class="headerlink" title="开放寻址散列的分析："></a>开放寻址散列的分析：</h3><blockquote><p>定理11.6 给定一个装载因子<code>a=n/m&lt;1</code>的开放寻址散列表，假设散列是均匀的，在一次不成功的查找中，期望的探查数至多为<code>1/(1-a)</code>.。</p></blockquote><p>不成功的查找即：最后一次查找为<code>NIL</code>，且前面的<code>Hash table</code>查找都是被占用但是不包含所查的关键字。因此，可以推论插入的期望值，即：插入前需要做一次不成功的查找。</p><blockquote><p>推论11.7 均匀散列，平均情况下，向一个装载因子为a的开放寻址散列表中插入一个元素时，至多需要做<code>1/(1-a)</code>次探查。</p></blockquote><p>查找的过程和插入类似，假设待查找的关键字k的插入位置为i，则，根据推论11.7，有探查的期望次数至多为$1/(1-i/m) = m/(m - i)$。对散列表的所有n个关键字求平均，则得到一次成功查找的探查期望次数：<br>$$\begin{align}<br>\frac 1 n \sum_{i = 0}^{n-1} \frac {m}{m-i}<br>&amp; = \frac mn \sum_{i = 0}^{n-1}\frac {1}{m-i} =\frac 1\alpha \sum_{k = m-n+1}^{n} \frac 1k \leqslant\frac 1 \alpha \int_{m-n}^{m}\frac 1x dx\\<br>&amp; =\frac 1\alpha ln \frac m{m-n} = \frac 1a ln\frac1{1-a}<br>\end{align}$$</p><p>因此得到定理11.8：</p><blockquote><p>定理11.8 给定一个装载因子为<code>a&lt;1</code>的开放寻址散列表，假设散列是均匀的，一次成功查找中的期望探查数至多为<code>(1/a)ln(1/(1-a))</code>.</p></blockquote><h3 id="11-4-1"><a href="#11-4-1" class="headerlink" title="11.4-1"></a>11.4-1</h3><p>考虑将关键字10,22,31,4,15,28,17,88,59用<strong>开放寻址法</strong>插入到一个长度为<code>m=11</code>的散列表中，主散列函数为<code>h&#39;(k)=k mod m</code>.说明用线性探查，二次探查<code>(c1=1,c2=3)</code>以及双重散列<code>h2(k)=1+(k mod (m-1))</code>将这些关键字插入散列表的结果。</p><p>C++实现代码：<br><a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_11/hash_table.cpp" target="_blank" rel="external">Introduction_to_Algorithms/Part_3/Chap_11/hash_table.cpp</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt; // for memset</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Null -1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETED -2</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 算法导论习题11.4-1 开放寻址法实现散列表。</span></div><div class="line"><span class="comment"> * 顺便也实现了搜索与删除。</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * Linux下g++5.4.0编译通过。</span></div><div class="line"><span class="comment"> * 命令：</span></div><div class="line"><span class="comment"> *   $ g++ -o hash_table.out hash_table.cpp -std=c++11</span></div><div class="line"><span class="comment"> *   $ ./hash_table.out</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">11</span>;  <span class="comment">//槽位数量</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1 = <span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> c2 = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> *T)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; T[i] &lt;&lt; <span class="string">' '</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> k % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 线性探查</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">linear_probing</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (key + i) % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//二次探查</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">quadratic_probing</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (key + c1 * i + c2 * i * i) % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//双重散列</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">double_hashing</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (key + i * (<span class="number">1</span> + key % (m - <span class="number">1</span>))) % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span> (*) (<span class="keyword">int</span>, <span class="keyword">int</span>);   <span class="comment">//函数指针</span></div><div class="line">PF hash_functions[<span class="number">3</span>] = &#123;linear_probing, quadratic_probing, double_hashing&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 判断探查的状态：当槽为空或者已到末尾时，为True</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">probe_state</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> T[j] == Null || T[j] == DELETED || T[j] == <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_insert</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> key, PF hash_function)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> k = key;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> j = hash_function(k, i);  <span class="comment">//这里通过函数指针，可以在调用时选择线性、二次及双重探查。关于函数指针的简单介绍，可以查看http://wangwlj.com/2018/01/06/CPP_06/</span></div><div class="line">        <span class="keyword">if</span> (probe_state(T, j))</div><div class="line">        &#123;</div><div class="line">            T[j] = k;</div><div class="line">            <span class="keyword">return</span> j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> ++i;</div><div class="line">    &#125; <span class="keyword">while</span> (i != m);</div><div class="line"></div><div class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"hash table overflow"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_search</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> k, PF hash_function)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        j = hash_function(k, i);  <span class="comment">//这里可以替换成二次，双重探查。插入，查找，删除函数同时被替换  </span></div><div class="line">        <span class="keyword">if</span> (T[j] == k)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> ++i;</div><div class="line">    &#125; <span class="keyword">while</span> (!probe_state(T, j));</div><div class="line">    <span class="keyword">return</span> Null;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_delete</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> k, PF hash_function)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">int</span> j = hash_search(T, k, hash_function);  <span class="comment">//首先先找到该关键字k  </span></div><div class="line">    <span class="keyword">if</span> (j != Null)  </div><div class="line">    &#123;  </div><div class="line">       T[j] = DELETED;  <span class="comment">//如果找到了，那么设置其为空。  </span></div><div class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"关键字："</span> &lt;&lt; k &lt;&lt; <span class="string">" 删除成功！"</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"待删除的数据不在表中！"</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> key[<span class="number">9</span>] = &#123;<span class="number">10</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">88</span>, <span class="number">59</span>&#125;;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> T[<span class="number">11</span>];</div><div class="line">   </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123; </div><div class="line">        <span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T));  <span class="comment">// 初始化T为全零</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</div><div class="line">            hash_insert(T, key[j], hash_functions[i]); </div><div class="line">        &#125;</div><div class="line">    Print(T);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"搜索关键字：88，返回结果："</span> &lt;&lt; hash_search(T, <span class="number">88</span>, hash_functions[i]) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    hash_delete(T, <span class="number">88</span>, hash_functions[i]);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除 88 之后元素为："</span>;</div><div class="line">    Print(T);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>算法导论 第三版 中文版</li><li><a href="http://blog.csdn.net/z84616995z/article/details/21329071" target="_blank" rel="external">算法导论第十一(11)章散列(Hash)表</a></li><li><a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7713307" target="_blank" rel="external">算法导论-第11章-散列表</a></li><li><a href="http://wangwlj.com/2018/01/06/CPP_06/">C++ Primer学习笔记：(六)函数</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/30/algorithm_tutorial_chapter_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(8) 第十章 基本数据结构</title>
      <link>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_10/</link>
      <guid>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_10/</guid>
      <pubDate>Sat, 27 Jan 2018 09:11:56 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fnva4kd9a0j20k50j5wjm.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;本章介绍几种基本的结构：栈、队列、链表和有根树。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fnva4kd9a0j20k50j5wjm.jpg" alt=""><br>本章介绍几种基本的结构：栈、队列、链表和有根树。</p><a id="more"></a><h2 id="栈和队列（10-1，P129）"><a href="#栈和队列（10-1，P129）" class="headerlink" title="栈和队列（10.1，P129）"></a>栈和队列（10.1，P129）</h2><p>栈和队列都是动态集合。</p><h3 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h3><p><strong>概念定义</strong>：栈采用<strong><font color="FA1C1C">先进后出</font></strong>策略（LIFO）。基本操作是<strong>压入（PUSH）</strong>和<strong>弹出（POP）</strong>。如果<code>s.top=0</code>，表示栈空，如果试图对空栈进行<code>POP</code>操作会发生下溢（<code>underflow</code>）。如果<code>s.top&gt;n</code>,表示栈满，如果进行<code>PUSH</code>操作会发生上溢（<code>overflow</code>）。</p><p>栈的Python实现代码链接：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_10/stack.py" target="_blank" rel="external">Introduction_to_Algorihtms/stack_my.py</a></p><h3 id="队列queue"><a href="#队列queue" class="headerlink" title="队列queue"></a>队列queue</h3><p><strong>概念定义</strong>：队列采用<strong><font color="FA1C1C">先进先出</font></strong>策略（FIFO）。基本操作是<strong>入队（enqueue）</strong>和<strong>出队（dequeue）</strong>。如果<code>head=tail</code>，表示队列为空，如果试图对空队列进行<code>enqueue</code>操作会发生下溢（<code>underflow</code>）。如果<code>head=tail+1</code>,表示队列满，如果进行<code>dequeue</code>操作会发生上溢（<code>overflow</code>）。</p><p>队列的Python实现：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_10/queue.py" target="_blank" rel="external">Introduction_to_Algorihtms/queue_my.py</a></p><h2 id="链表（10-2，P131）"><a href="#链表（10-2，P131）" class="headerlink" title="链表（10.2，P131）"></a>链表（10.2，P131）</h2><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。</p><p>双向链表(<code>doubly linked list</code>)的每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个(前一个)结点地址的指针域。 </p><p>未排序双向链表的Python实现代码：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_10/list.py" target="_blank" rel="external">Introduction_to_Algorihtms/list_my.py</a></p><h2 id="指针和对象的实现（10-3，P134）"><a href="#指针和对象的实现（10-3，P134）" class="headerlink" title="指针和对象的实现（10.3，P134）"></a>指针和对象的实现（10.3，P134）</h2><p>当有些语言不支持指针和对象数据类型时，我们可以用数组和数组下标构造对象和指针。这种链表称为<a href="http://baike.baidu.com/link?url=GFeesiUYKbcXr0Q4vPTOK518GTn6z4DnzuBNxiplK80cT9bzyAVcqpX8G9Huw8yC" target="_blank" rel="external">静态链表</a>。</p><h3 id="对象的多数组表示"><a href="#对象的多数组表示" class="headerlink" title="对象的多数组表示"></a>对象的多数组表示</h3><p>用三个数组<code>next</code> <code>key</code> <code>prev</code> 分别表示链表的后继/数据/前驱。<br>多数组表示只能表示同构对象（所有对象有相同的属性）。而单数组表示可以表示异构对象（比如对象具有不同的长度）。</p><h3 id="对象的单数组表示"><a href="#对象的单数组表示" class="headerlink" title="对象的单数组表示"></a>对象的单数组表示</h3><p>用一个数组即可表示双链表，这种表示法比较灵活，因为它允许不同长度的对象存储于同一数组中。一般地我们考虑的数据结构多是由同构的元素构成，因此采用对象的多数组表示法足够满足我们的需求。</p><h3 id="对象的分配与释放"><a href="#对象的分配与释放" class="headerlink" title="对象的分配与释放"></a>对象的分配与释放</h3><p>把自由(<code>free</code>)对象保存在一个单链表中，称为自由表(<code>free list</code>)。</p><p>自由表只使用next数组，该数组只存储链表中的next指针。自由表的头存储在全局变量free中。</p><p>自由表的实现类似与栈：下一个被分配的对象就是最后被释放的对象（后进先出）。</p><h2 id="有根树的表示（10-4，P137）"><a href="#有根树的表示（10-4，P137）" class="headerlink" title="有根树的表示（10.4，P137）"></a>有根树的表示（10.4，P137）</h2><p>用链式结构表示有根树。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树<code>T</code>具有三个属性：<code>p</code>，<code>left</code>，<code>right</code>分别存放指向父节点、左孩子节点和右孩子节点的指针。<br>如果<code>x.p=NIL</code>，则<code>x</code>是根节点。属性<code>T.root</code>指向整棵树<code>T</code>的根节点。</p><p>更多关于二叉树的内容将在第12章中介绍。本次就暂不实现二叉树。</p><h3 id="分支无限制的有根树"><a href="#分支无限制的有根树" class="headerlink" title="分支无限制的有根树"></a>分支无限制的有根树</h3><p>两种表示方法。一种是将<code>left</code>，<code>right</code>扩展为$child_1,\cdots,child_k$，这种方法的缺点是若<code>k</code>很大，但是多数节点只有少量的孩子，则会浪费大量存储空间。</p><p>第二种方法是左孩子右兄弟表示法(<code>left-child,right-sibling representation</code>)。每个节点除了父节点指针<code>p</code>，还有两个指针:<br><code>x.left-child</code>表示节点<code>x</code>最左边的孩子节点；<code>x.right-sibling</code>表示右侧相邻的兄弟节点。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.算法导论 中文 第三版<br>2.<a href="http://blog.csdn.net/z84616995z/article/details/19202773" target="_blank" rel="external">算法导论第十章基本数据结构</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(7) 第八章 线性排序算法</title>
      <link>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_8/</link>
      <guid>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_8/</guid>
      <pubDate>Sat, 27 Jan 2018 08:26:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;任何比较排序在最坏情况下都要经过$\Theta(n\text{lg}n)$次比较。&lt;/p&gt;
&lt;p&gt;本文介绍三种线性时间排序的算法：计数排序，基数排序以及桶排序。因此，这些都不属于比较排序。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>任何比较排序在最坏情况下都要经过$\Theta(n\text{lg}n)$次比较。</p><p>本文介绍三种线性时间排序的算法：计数排序，基数排序以及桶排序。因此，这些都不属于比较排序。</p><a id="more"></a><p>本文所有实现代码均已放在<code>GitHub</code>上，欢迎查看：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms" target="_blank" rel="external">GitHub链接</a></p><h2 id="本章概述"><a href="#本章概述" class="headerlink" title="本章概述"></a>本章概述</h2><p>非比较排序指使用一些非比较的操作来确定排序顺序的排序算法，对于非比较排序，下界O(nlgn)不适用。</p><p>计数排序是稳定排序，若n个数据的取值范围是<code>[0..k]</code>，则运行时间为<code>O(n+k)</code>，运行空间是<code>O(n+k)</code></p><p>基数排序也是稳定排序，需要另一个稳定排序作为基础，若n个d位数，每一位有k种取值可能，所用的稳定排序运行时间为<code>O(n+k)</code>，则基数排序的时间是<code>O(d(n+k))</code></p><p>桶排序也是稳定排序，当输入数据符合均匀分布时，桶排序可以以线性时间运行。所设所有元素均匀分布在区间<code>[0,1)</code>上，把区间[0,1)划分成n个相同大小的子区间（桶），对各个桶中的数进行排序，把依次把各桶中的元素列出来。</p><h2 id="计数排序（8-2，P108）"><a href="#计数排序（8-2，P108）" class="headerlink" title="计数排序（8.2，P108）"></a>计数排序（8.2，P108）</h2><p>计数排序(<code>counting sort</code>)是使用输入元素的实际值来确定其在数组中的位置。</p><p>计数排序的一个重要特性就是它是稳定的：即对于相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同。也就是说，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。</p><p>计数排序的伪代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">COUNTING_SORT(A,B,k)</div><div class="line">      <span class="keyword">for</span> i=<span class="number">0</span> to k</div><div class="line">        <span class="keyword">do</span> C[i] = <span class="number">0</span></div><div class="line">      <span class="keyword">for</span> j=<span class="number">1</span> to length(A)</div><div class="line">          <span class="keyword">do</span> C[A[j]] = C[A[j]]+<span class="number">1</span>   <span class="comment">//C[i]中包含等于元素i的个数</span></div><div class="line">      <span class="keyword">for</span> i=<span class="number">1</span> to k</div><div class="line">          <span class="keyword">do</span> C[i] = C[i] + C[i<span class="number">-1</span>]  <span class="comment">//C[i]中包含小于等于元素i的个数</span></div><div class="line">      <span class="keyword">for</span> j=length[A] downto <span class="number">1</span></div><div class="line">          <span class="keyword">do</span> B[C[A[j]]] = A[j]</div><div class="line">             C[A[j]] = C[A[j]] <span class="number">-1</span></div></pre></td></tr></table></figure></p><p>计数排序的<code>Python</code>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Author：wangwlj</span></div><div class="line"><span class="comment"># 计数排序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(A)</span>:</span></div><div class="line">    k = max(A)  <span class="comment"># k is max of A</span></div><div class="line">    C = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, k + <span class="number">1</span>):</div><div class="line">        C.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        C[A[j]] = C[A[j]] + <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k + <span class="number">1</span>):</div><div class="line">        C[i] = C[i] + C[i - <span class="number">1</span>]</div><div class="line"></div><div class="line">    B = []  <span class="comment"># output</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        B.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        <span class="comment"># m = A[j],n  = C[m],k = B[n - 1]  # for test</span></div><div class="line">        B[C[A[j]] - <span class="number">1</span>] = A[j]  <span class="comment"># B[n] start from 0, so need -1</span></div><div class="line">        C[A[j]] = C[A[j]] - <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> B</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    A = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>]</div><div class="line">    B = counting_sort(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(B)):</div><div class="line">        print(B[i], end=<span class="string">" "</span>)</div></pre></td></tr></table></figure></p><h3 id="练习8-2-3"><a href="#练习8-2-3" class="headerlink" title="练习8.2-3"></a>练习8.2-3</h3><p>在<code>COUNTING_SORT</code>过程中，第四个for循环为什么是<code>for j=length[A] downto 1</code>，而不是<code>for j=1 to length[A]</code>？</p><p><strong>为了保证算法是稳定的</strong>。由于是从前往后计数排序，两个数相同的时候，计数值较大的数对应于数组中靠后的元素，所以在输出时需要逆序。</p><h2 id="基数排序（8-3，P110）"><a href="#基数排序（8-3，P110）" class="headerlink" title="基数排序（8.3，P110）"></a>基数排序（8.3，P110）</h2><p>基数排序(<code>radix sort</code>)按有效位从低到高依次排序。</p><p>伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RADIX_SORT(A,d）</div><div class="line">    for i=1 to d</div><div class="line">          use a stable sort to sort array A on digit i</div></pre></td></tr></table></figure></p><p>基数排序一般采用<strong>计数排序</strong>作为中间稳定排序。</p><p>基数排序的<code>python</code>实现请参阅下面的练习题<code>8.3-4</code>。</p><h3 id="练习8-3-1"><a href="#练习8-3-1" class="headerlink" title="练习8.3-1"></a>练习8.3-1</h3><p>说明<code>RADIX-SORT</code>在如下英文单词上的操作过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">    A = &#123;COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB, BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX&#125;  </div><div class="line">==&gt; A = &#123;SEA, TEA, MOB, TAB, DOG, RUG, DIG, BIG, BAR, EAR, TAR, COW, ROW, NOW, BOX, FOX&#125;  </div><div class="line">==&gt; A = &#123;TAB, BAR, EAR, TAR, SEA, TEA, DIG, BIG, MOB, DOG, COW, ROW, NOW, BOX, FOX, RUB&#125;  </div><div class="line">==&gt; A = &#123;BAR, BIG, BOX, COW, DIG, DOG, EAR, FOX, MOB, NOW, ROW, TAB, TAR, TEA, SEA, RUB&#125;</div></pre></td></tr></table></figure></p><h3 id="练习8-3-4"><a href="#练习8-3-4" class="headerlink" title="练习8.3-4"></a>练习8.3-4</h3><p>题目：在<code>O(n)</code>时间内对<code>[0..n^3-1]</code>之间的n个整数排序。</p><p>思路：把整数转换为n进制再排序，每个数有三位，每位的取值范围是[0..n-1]，再进行基数排序</p><p>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">n = <span class="number">5</span></div><div class="line">base_k = <span class="number">5</span>  <span class="comment"># bask could be any number. In test 8.3-4 is 5(equal to n)</span></div><div class="line">d = <span class="number">3</span>  <span class="comment"># 8.3-4</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stable_sort</span><span class="params">(A, index)</span>:</span>  <span class="comment"># similar with counting sort,</span></div><div class="line">    C = []  <span class="comment"># C：统计每位数上可能出现的k个数的次数</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, base_k + <span class="number">1</span>):  <span class="comment"># the number is in range of base_k（k）</span></div><div class="line">        C.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        <span class="comment"># 统计当前位上的数出现的次数</span></div><div class="line">        num = int(A[j] % pow(base_k, index) / pow(base_k, index - <span class="number">1</span>))  <span class="comment"># the base number</span></div><div class="line">        <span class="comment"># print(A[j], ' 当前位编号：', index, '当前值：', num, )  # for test</span></div><div class="line">        C[num] = C[num] + <span class="number">1</span>  <span class="comment"># the count of the base number (C - num)</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, base_k + <span class="number">1</span>):</div><div class="line">        C[i] = C[i] + C[i - <span class="number">1</span>]</div><div class="line"></div><div class="line">    B = []  <span class="comment"># output</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        B.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        num = int(A[j] % pow(base_k, index) / pow(base_k, index - <span class="number">1</span>))</div><div class="line">        B[C[num] - <span class="number">1</span>] = A[j]  <span class="comment"># B[n] start from 0, so need -1</span></div><div class="line">        C[num] = C[num] - <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> B</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, d + <span class="number">1</span>):</div><div class="line">        A = stable_sort(A, i)</div><div class="line">    <span class="comment"># for i in range(0, len(A)):</span></div><div class="line">    <span class="comment">#     print(A[i], end=' ')</span></div><div class="line">    <span class="keyword">return</span> A</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    <span class="comment"># A = [114, 18, 35, 74, 36]</span></div><div class="line">    A = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</div><div class="line">        A.append(random.randint(<span class="number">0</span>, pow(n, <span class="number">3</span>)))</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'\n'</span>)</div><div class="line"></div><div class="line">    A = radix_sort(A)</div><div class="line">    print(<span class="string">'After radix_sort：'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">' '</span>)</div></pre></td></tr></table></figure></p><h2 id="桶排序（8-4，P112）"><a href="#桶排序（8-4，P112）" class="headerlink" title="桶排序（8.4，P112）"></a>桶排序（8.4，P112）</h2><p>桶排序(<code>bucket sort</code>)假设输入数据服从均匀分布，平均情况下它的时间代价为$\text{O}_n$，与计数排序类似，因为对输入数据做了某种假设，桶排序的速度也很快。具体来说，计数排序假设输入数据都属于一个小区间的整数，而桶排序则假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.算法导论 中文 第三版<br>2.<a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7678859" target="_blank" rel="external">算法导论 第8章 线性时间排序</a>这个包含习题答案，很不错<br>3.<a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7685839" target="_blank" rel="external">算法导论8.3-4</a><br>4.<a href="http://blog.csdn.net/qing0706/article/details/50117873" target="_blank" rel="external">MIT算法导论-第五讲-线性时间排序</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python数据结构之链表</title>
      <link>http://wangwlj.com/2018/01/26/python_linkedlist/</link>
      <guid>http://wangwlj.com/2018/01/26/python_linkedlist/</guid>
      <pubDate>Fri, 26 Jan 2018 14:56:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fnvahij9xbj20jm0ejgr2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;主要实现了链表的三个功能：链表的查找、插入与删除。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fnvahij9xbj20jm0ejgr2.jpg" alt=""><br>主要实现了链表的三个功能：链表的查找、插入与删除。<br><a id="more"></a></p><p>最近在看《算法导论》，看到第十章——基本数据结构中，提到了链表，于是用<code>Python</code>进行了实现。算法导论中只给出了三个操作：链表的查找、插入与删除。于是，暂时也只实现了这三个。</p><p>下面进行简要的介绍：</p><p>我们首先定义一个节点的类，用来存储链表中的每个节点。每个节点都有三个属性：节点存储的元素值，指向上一个节点的指针以及指向下一个节点的指针。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span>  <span class="comment"># 链表的每个节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, _prev=None, _next=None)</span>:</span></div><div class="line">        self.value = value</div><div class="line">        self.prev = _prev</div><div class="line">        self.next = _next</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>  <span class="comment"># 在print时默认返回value</span></div><div class="line">        <span class="keyword">return</span> str(self.value)</div></pre></td></tr></table></figure></p><p>其中，<code>__str__</code>函数使得在print一个Node对象的时候打印其value值。</p><p>接着我们定义链表类List。Python中<code>list</code>是一个关键字，表示序列，故避免重复，也可以把链表叫做<code>LinkedList</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.head = <span class="keyword">None</span>  <span class="comment"># init as a empty list</span></div></pre></td></tr></table></figure></p><p>上述初始化函数中的<code>self.head = None</code>将链表初始化为空链表。</p><p>接着分别实现搜索、插入和删除三个功能。可以对照着书中的伪码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, key)</span>:</span></div><div class="line">    x = self.head</div><div class="line">    <span class="keyword">while</span> x.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> x.value != key:</div><div class="line">        x = x.next</div><div class="line">    <span class="keyword">return</span> x</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></div><div class="line">    <span class="comment"># 插入节点x作为新的头节点</span></div><div class="line">    x.next = self.head</div><div class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        self.head.prev = x</div><div class="line">    self.head = x</div><div class="line">    x.prev = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></div><div class="line">    <span class="comment"># x is in list and known (can use search to find)</span></div><div class="line">    <span class="keyword">if</span> x.prev <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        x.prev.next = x.next</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        self.head = x.next</div><div class="line"></div><div class="line">    <span class="keyword">if</span> x.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        x.next.prev = x.prev</div></pre></td></tr></table></figure></p><p>下面的这个<code>show_value</code>函数是为了依次打印链表的元素，不是必须的，可以跳过。<code>__str__</code>与Node中的类似，实现了可以直接打印一个List的对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_value</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment"># 依次打印链表的值</span></div><div class="line">    x = self.head</div><div class="line">    print(<span class="string">"The List Value is:"</span>, end=<span class="string">' '</span>)</div><div class="line">    <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        print(x.value, end=<span class="string">' '</span>)</div><div class="line">        x = x.next</div><div class="line">    print()</div><div class="line">    <span class="keyword">return</span> <span class="string">'show_value'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment"># 支持直接print一个List的对象</span></div><div class="line">    <span class="keyword">return</span> self.show_value() + <span class="string">" in List"</span></div></pre></td></tr></table></figure></p><p>最后是主函数，对上述实现进行简单的测试。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    l = List()</div><div class="line">    l.insert(Node(<span class="number">5</span>))</div><div class="line">    l.insert(Node(<span class="number">4</span>))</div><div class="line">    l.insert(Node(<span class="number">3</span>))</div><div class="line">    n = l.search(<span class="number">5</span>)</div><div class="line">    print(<span class="string">"search value: "</span>, n.value, n.prev, n.next,</div><div class="line">          <span class="string">"\nhead: "</span>, l.head.value, l.head.prev, l.head.next)</div><div class="line">    l.delete(n)</div><div class="line">    print(<span class="string">"head: "</span>, l.head.value, l.head.prev, l.head.next)</div><div class="line">    l.insert(Node(<span class="number">6</span>))  <span class="comment"># always insert as head.</span></div><div class="line">    l.insert(Node(<span class="number">7</span>))</div><div class="line">    l.insert(Node(<span class="number">8</span>))</div><div class="line">    l.show_value()</div><div class="line"></div><div class="line">    n = l.search(<span class="number">7</span>)</div><div class="line">    print(<span class="string">"search value:"</span>, n, n.prev, n.next,</div><div class="line">          <span class="string">"\nhead:"</span>, l.head, l.head.prev, l.head.next)</div><div class="line"></div><div class="line">    l.delete(l.search(<span class="number">6</span>))</div><div class="line">    print(l)</div></pre></td></tr></table></figure></p><p>完整的代码放在Github上了，仅供参考。链接为：<a href="https://github.com/qwerty200696/Introduction_to_Algorihtms/blob/master/list_my.py" target="_blank" rel="external">Introduction_to_Algorihtms/list_my.py</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/26/python_linkedlist/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
