<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>王立杰的博客</title>
    <link>https://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Thu, 28 Dec 2017 14:24:19 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>基于TensorFlow的简单语音识别</title>
      <link>https://wangwlj.com/2017/12/28/TensorFlow_speech_commands/</link>
      <guid>https://wangwlj.com/2017/12/28/TensorFlow_speech_commands/</guid>
      <pubDate>Thu, 28 Dec 2017 14:24:03 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;简单语音识别教程&quot;&gt;&lt;a href=&quot;#简单语音识别教程&quot; class=&quot;headerlink&quot; title=&quot;简单语音识别教程&quot;&gt;&lt;/a&gt;简单语音识别教程&lt;/h2&gt;&lt;p&gt;重要的是要知道，真正的语音和音频识别系统要复杂得多，但是像MNIST（入门级的CV数据集）一
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="简单语音识别教程"><a href="#简单语音识别教程" class="headerlink" title="简单语音识别教程"></a>简单语音识别教程</h2><p>重要的是要知道，真正的语音和音频识别系统要复杂得多，但是像MNIST（入门级的CV数据集）一样，它应该会让你对所涉技术有一个基本的了解。</p><p>完成本教程后，你将可以尝试创建一个模型，将一秒钟的音频剪辑去噪，识别单词有“yes”，“no”，“up”，“down”，”left”，”right”，”on”，”off”，”stop”，or “go”。</p><p>你也可以在Android应用程序中运行该模型。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>你要确保已经安装了TensorFlow，由于该版本下载了超过1GB的训练数据，因此你需要电脑有足够的内存，另外网速要快，训练过程可能需要几个小时。</p><h2 id="出错与解决"><a href="#出错与解决" class="headerlink" title="出错与解决"></a>出错与解决</h2><h3 id="找不到audio-ops"><a href="#找不到audio-ops" class="headerlink" title="找不到audio_ops"></a>找不到audio_ops</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"train.py"</span>, line <span class="number">79</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    <span class="keyword">import</span> input_data</div><div class="line">  File <span class="string">"/home/philglau/speech_commands/input_data.py"</span>, line <span class="number">35</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    <span class="keyword">from</span> tensorflow.contrib.framework.python.ops <span class="keyword">import</span> audio_ops <span class="keyword">as</span> contrib_audio</div><div class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">'audio_ops'</span></div></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>这个’audio_ops’只在TensorFlow1.4版本中有，所以，如果不是1.4的版本，一般都会有这个错误。</p><p>此时的解决方案，一是更细TensorFlow版本，二是使用如下命令安装tf-nightly即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tf-nightly</div></pre></td></tr></table></figure><p>详见参考连接三。</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>要开始训练过程，请访问<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">TensorFlow源代码树</a>下载并运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python tensorflow/examples/speech_commands/train.py</div></pre></td></tr></table></figure><p>训练过程将从下载“ 语音命令”数据集开始，该数据集由65000个WAVE音频文件组成，其中有30个不同的单词。</p><p>这些数据是由Google收集的，并根据CCBY许可证发布。存档超过1GB，所以下载可能需要一段时间，但你应该能看到进度日志，一旦下载完成，你就不用再次执行此步骤了。</p><p>下载完成后，你将看到如下所示的日志记录信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">I0730 16:53:44.766740 55030 train.py:176] Training from step: 1</div><div class="line"></div><div class="line">I0730 16:53:47.289078 55030 train.py:217] Step #1: rate 0.001000, accuracy 7.0%, cross entropy 2.611571</div></pre></td></tr></table></figure><p>这表明初始化过程已经完成，循环训练已经开始。你会看到它输出每个训练步骤的信息。</p><p>步骤分解：</p><p>Step #1表明我们正在循环训练的第一步。在这种情况下，总共将有18000个步骤，所以你可以查看步骤号码，了解其完成程度有多接近。</p><p>rate 0.001000是控制网络权重更新速度的学习率。早期的这个数字是相对较高的（0.001），但是对于后来的训练周期，它会减少10倍到0.0001。</p><p><code>accuracy 7.0%</code>在这个训练步骤中正确地预测了有多少classes。value函数往往波动很大，但随着训练的进行，平均值会增加。该模型输出一个数字数组，每个标签一个，每个数字是该类输入的预测可能性。</p><p>通过选择具有最高分数的条目来选择预测的标签，分数总是在零和一之间。</p><p><code>cross entropy 2.611571</code>是我们用来指导培训过程的损失功能的结果。这是通过比较当前训练运动与正确标签的分数向量获得的分数，这在训练期间应该向下倾斜。</p><p>经过一百步，你应该看到这样的一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I0730 16:54:41.813438 55030 train.py:252] Saving to &quot;/tmp/speech_commands_train/conv.ckpt-100&quot;</div></pre></td></tr></table></figure></p><p>这是将当前训练的权重保存到checkpoint文件中。如果你的训练脚本中断，可以查找最后保存的checkpoint，然后：<br><code>--start_checkpoint=/tmp/speech_commands_train/conv.ckpt-100</code>使用命令行参数重新启动脚本， 从那里开始。</p><h2 id="混淆矩阵"><a href="#混淆矩阵" class="headerlink" title="混淆矩阵"></a>混淆矩阵</h2><p>四百步后，将记录以下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">I0730 16:57:38.073667 55030 train.py:243] Confusion Matrix:</div><div class="line"></div><div class="line">[[258 0  0  0  0 0  0 0  0  0 0 0]</div><div class="line"></div><div class="line">[  7  6  26 94  7 49 1 15 40 2 0 11]</div><div class="line"></div><div class="line">[ 10  1 107 80 13 22 0 13 10 1 0  4]</div><div class="line"></div><div class="line">[ 1  3  16 163  6 48 0  5 10 1 0  17]</div><div class="line"></div><div class="line">[ 15 1  17 114 55 13 0  9 22 5 0  9]</div><div class="line"></div><div class="line">[ 1  1  6  97  3  87 1 12 46 0 0  10]</div><div class="line"></div><div class="line">[ 8  6 86  84 13  24 1  9  9 1 0  6]</div><div class="line"></div><div class="line">[ 9  3 32 112  9  26 1 36 19 0 0  9]</div><div class="line"></div><div class="line">[ 8  2 12  94  9  52 0  6 72 0 0  2]</div><div class="line"></div><div class="line">[ 16 1 39  74 29  42 0  6 37 9 0  3]</div><div class="line"></div><div class="line">[ 15 6 17  71 50  37 0  6 32 2 1  9]</div><div class="line"></div><div class="line">[ 11 1  6 151 5   42 0  8 16 0 0 20]]</div></pre></td></tr></table></figure></p><p>第一部分是<strong>混淆矩阵</strong>。要了解这是什么意思，你首先需要知道正在使用的标签，在这种情况下，它们分别表示为<code>静音、未知yes、no、up、down、left、right、on、off、stop、go</code>。</p><p>第一行是所有的静音剪辑，第二个剪辑是未知的单词，第三个“yes”等。</p><p>该矩阵可以比单个准确率得分更有用，因为它可以很好地总结出网络发生的错误。在此示例中，你可以看到除了初始条目之外，第一行中的所有条目都为零。</p><p>因为第一行实际上都是静音的片段，所以这意味着它们都没有被错误的标注为文字，所以我们没有任何静音的否定。这表明网络已经越来越好地区分了静音与谈话。</p><p><strong>一个完美的模型将产生一个混淆矩阵，其中所有的条目都是从对角线穿过中心的零点</strong>。一旦你确定了可以通过添加更多数据来解决问题，该模型的方差可以帮助你了解模型怎样最容易混淆。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>混淆矩阵之后，你会看到如下一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I0730 16:57:38.073777 55030 train.py:245] Step 400: Validation accuracy = 26.3% (N=3093)</div></pre></td></tr></table></figure></p><p>将数据集分为三类是很好的做法。最大的（大约是数据的80％）用于训练网络，一个较小的集（10％ “validation”）被保留用于评估训练中的准确性，另一组10％，“testing”）用于在训练完成后评估准确度。</p><p>通过将数据集分类为训练集、验证集、测试集，你可以确保该模型适用于之前从未见过的数据。测试集是一个额外的保障措施，以确保不仅仅是以适用于训练和验证集拟合调整模型。</p><p>训练脚本将数据集自动分成这三个类别，上面的记录行显示了在验证集上运行时的模型准确率。理想情况下，这应该与训练准确性相当接近。如果训练准确性增加但验证不是这样，这表明过度拟合正在发生，你的模型只是学习关于训练剪辑的东西，而不是真正的训练模式。</p><h2 id="Tensorboard"><a href="#Tensorboard" class="headerlink" title="Tensorboard"></a>Tensorboard</h2><p>使用Tensorboard可以看出训练进展。默认情况下，脚本将事件保存到/ tmp / retrain_logs，可以通过运行以下命令来加载它们：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tensorboard --logdir /tmp/retrain_logs</div></pre></td></tr></table></figure></p><p>然后在浏览器中导航到<code>http：// localhost：6006</code>，将看到显示模型进度的图表。</p><h2 id="完成训练"><a href="#完成训练" class="headerlink" title="完成训练"></a>完成训练</h2><p>经过几个小时的训练（取决于你的电脑快慢），脚本应该已经完成了所有18000个步骤。它将识别出最终的混淆矩阵，以及准确率分数，全部运行在测试集上。使用默认设置，准确率在85％到90％之间。</p><p>因为音频识别在移动设备上特别有用，接下来我们将其导出为，在移动平台上易于使用的格式。要执行此操作，请运行以下命令行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">python tensorflow/examples/speech_commands/freeze.py</div><div class="line"></div><div class="line">--start_checkpoint=/tmp/speech_commands_train/conv.ckpt-18000</div><div class="line"></div><div class="line">--output_file=/tmp/my_frozen_graph.pb</div></pre></td></tr></table></figure></p><p>创建固定模型后，可以使用<code>label_wav.py</code>脚本进行测试，如下所示：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">python tensorflow/examples/speech_commands/label_wav.py</div><div class="line"></div><div class="line">--graph=/tmp/my_frozen_graph.pb</div><div class="line"></div><div class="line">--labels=/tmp/speech_commands_train/conv_labels.txt</div><div class="line"></div><div class="line">--wav=/tmp/speech_dataset/left/a5d485dc_nohash_0.wav</div></pre></td></tr></table></figure></p><p>可以识别出三个标签：</p><p>left (score = 0.81477)</p><p>right (score = 0.14139)</p><p>_unknown_ (score = 0.03808)</p><p>跟多内容请查看论文：<a href="http://suo.im/3PW89b" target="_blank" rel="external">http://suo.im/3PW89b</a></p><h2 id="在Android应用程序中运行模型"><a href="#在Android应用程序中运行模型" class="headerlink" title="在Android应用程序中运行模型"></a>在Android应用程序中运行模型</h2><p>查看此模型在真实应用程序中如何工作的最简单的方法是，下载预构建的Android演示应用程序并将其安装在手机上（<a href="http://suo.im/4n1pym）。" target="_blank" rel="external">http://suo.im/4n1pym）。</a></p><p>你会看到“TF Speech”出现在应用程序列表中，打开它将显示我们刚刚训练过单词列表，从“yes”和“no”开始。</p><p>你还可以自己构建此应用程序，因为它是开源的， 并可作为github上TensorFlow存储库的一部分使用（<a href="http://suo.im/mfUa8）。默认情况下，它从tensorflow.org下载一个预先训练的模型，但你可以轻松地用自己训练的模型替换它。" target="_blank" rel="external">http://suo.im/mfUa8）。默认情况下，它从tensorflow.org下载一个预先训练的模型，但你可以轻松地用自己训练的模型替换它。</a></p><p>如果你自己创建的话，你需要确保SpeechActivity Java源文件（<a href="http://suo.im/2fWbai）中的" target="_blank" rel="external">http://suo.im/2fWbai）中的</a> SAMPLE_RATE，SAMPLE_DURATION符合你训练时的默认设置所做的任何更改。</p><p>你还会看到一个Java版本的Rec<br>ognizeCommands模块（<a href="http://suo.im/31vKvx）。" target="_blank" rel="external">http://suo.im/31vKvx）。</a></p><p>这与本教程中的C ++版本非常相似。如果你调整了参数，还可以在SpeechActivity中进行更新，以获得与服务器测试相同的结果。</p><p>演示应用程序，根据你在固定模型复制到模型中的标签文本文件，自动更新其用户界面列表，可以轻松地尝试不同的模型，而无需进行任何代码更改。如果你更改路径，需要updaye LABEL_FILENAME，MODEL_FILENAME添加到文件。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.tensorflow.org/versions/master/tutorials/audio_recognition" target="_blank" rel="external">TensorFlow官网教程：Simple Audio Recognition</a></li><li><a href="http://www.sohu.com/a/167209693_798050" target="_blank" rel="external">中文翻译参考</a></li><li><a href="https://stackoverflow.com/questions/45952387/anaconda-install-of-tensorflow-missing-audio-ops-from-contrib-framework" target="_blank" rel="external">Tensorflow missing ‘audio_ops’ from contrib framework</a></li></ul>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/28/TensorFlow_speech_commands/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS2015 设置调试时不加载符号</title>
      <link>https://wangwlj.com/2017/12/27/CPP_VS2015_noPDB/</link>
      <guid>https://wangwlj.com/2017/12/27/CPP_VS2015_noPDB/</guid>
      <pubDate>Wed, 27 Dec 2017 13:53:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;用VS2015打开代码文件，按下F5进行调试，当电脑接入网络后系统会&lt;strong&gt;自动从Microsoft符号服务器加载P
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>用VS2015打开代码文件，按下F5进行调试，当电脑接入网络后系统会<strong>自动从Microsoft符号服务器加载PDB符号文件</strong>，而且是每次都会加载。如下图所示：<br><img src="https://images2.imgbox.com/1c/a2/uWHMn9oN_o.png" alt="调试加载界面"></p><p>此加载符号过程使得调试变得非常慢。</p><p>通过查阅得知，此类的pdb调试器在编写代码时对于新手来说，根本用不到。也就是说完全可以不需要加载。</p><p>那么如何避免VS2013调试时自动加载符号呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li><p>打开VS的【工具】-【选项】：<br><img src="https://images2.imgbox.com/bc/8e/PXMTNcYk_o.png" alt="工具选项"></p></li><li><p>选择其中的【调试】-【符号】，并 取消勾选“Microsoft符号服务器” ：<br><img src="https://images2.imgbox.com/eb/35/XrMdw2M8_o.png" alt="取消勾选"></p></li><li><p>确定并退出即可，此后再次按F5进行调试。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://jingyan.baidu.com/article/fea4511a1a1040f7bb91251a.html" target="_blank" rel="external">VS2013代码调试：如何避免调试时加载符号</a></p></li><li><p><a href="http://blog.csdn.net/u010186001/article/details/52759945" target="_blank" rel="external">vs2015加载符号慢，请问怎么解决</a></p></li></ol>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/27/CPP_VS2015_noPDB/#disqus_thread</comments>
    </item>
    
    <item>
      <title>机器学习技法笔记01：最佳分类超平面</title>
      <link>https://wangwlj.com/2017/12/26/ML_taiwan_01/</link>
      <guid>https://wangwlj.com/2017/12/26/ML_taiwan_01/</guid>
      <pubDate>Tue, 26 Dec 2017 02:24:06 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Large-Margin-Separating-Hyperplane&quot;&gt;&lt;a href=&quot;#Large-Margin-Separating-Hyperplane&quot; class=&quot;headerlink&quot; title=&quot;Large-Margin Separating 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Large-Margin-Separating-Hyperplane"><a href="#Large-Margin-Separating-Hyperplane" class="headerlink" title="Large-Margin Separating Hyperplane"></a>Large-Margin Separating Hyperplane</h2><p>题目翻译为中文的意思大体上是 最大余量分类超平面。本节主要讲解如何确定该最佳分类超平面。</p><p>首先，我们回顾一下之前讲过的Linear Classfication ：有$\circ$和$\times$，我们用一条直线将$\circ$和$\times$分开，或者在高维空间中使用超平面将其分开。数学上，将资料拿来计算一个加权和，根据和的正负预测$\circ$和$\times$。</p><p>现在，给定一个线性可分的资料，则会有很多条线将和分开，但是下图中的那条线会更好呢？</p><p><img src="/2017/12/26/ML_taiwan_01/ML01.png" alt=""></p><p>PLA(Perceptron learning algorithm,For binary classification解决是非问题)会选哪一条线与PLA看到的错误有关，因此PLA得到哪一条线不定。从之前的理论来看，三条线似乎也没什么区别，例如从VC Bound来看：<br>$$E_{out}(w)\leqslant E_{in}(w) + \Omega(H) $$</p><p>其中$E_{in}(w)$为训练样本上的错误率，三条线都满足；$\Omega(H)$为复杂度，都是线，因此复杂度都为<code>d+1</code>。但是我们的直觉告诉我们最右边是最好的线。</p><p>一种原始的解释：<br>假设我们已经拿到原始资料，即图上的点，但是在测试的时候我们拿到跟原始资料相近的资料(测量误差、资料收集等造成)，下图中灰色的x。所以，测试资料可能会和训练资料有点出入。</p><p>假设我们绝对相信我们的训练资料，若果有误差，则我们人为最好的预测为将测试资料预测的与训练资料很接近(不完全一样)。</p><p><img src="/2017/12/26/ML_taiwan_01/ML02.png" alt=""></p><p>上图中左边与右边最大的差别就在于<strong>对测量误差的容忍度</strong>，点距离线越远则容忍度越好(<code>tolerate more noise</code>)，进而可以避免过拟合(<code>more robust to overfitting</code>)。</p><p>或者换个角度，看这条线有多胖（能涨出去多少），倾向于选择胖的线。</p><p><img src="/2017/12/26/ML_taiwan_01/ML03.png" alt=""></p><blockquote><p>robustness = fatness: distance to closest xn<br>比较胖的线是比较好的。</p><p>goal: find fattest separating hyperplane<br>在分类正确的基础上，找出最胖、最强壮(鲁棒)的线。</p></blockquote><p><strong>目标</strong>是：<br>我们要找出一条线，首先这条线可以将$\circ$和$\times$分开(线性可分)，然后取最胖的一条线，即计算所有点到线的距离，取其中最小的距离。也就是下面的公式所描述的：<br><img src="/2017/12/26/ML_taiwan_01/ML04.png" alt=""></p><p><code>fatness: formally called margin</code>：<br>最胖的线，术语上叫“margin”，余量，留白的多少。</p><p><code>correctness: yn = sign(w^T x_n)</code><br>算出来的分数是正的还是负的，相乘是同号(分类正确)就可以。</p><p><code>goal: find largest-margin separating hyperplane</code>：寻找边界最宽，能够完全分开的线（超平面）。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://blog.csdn.net/nysyxxg/article/details/52843827" target="_blank" rel="external">台大林轩田《机器学习基石》学习笔记5：线性模型一（PLA/pocket、Linearregression ）</a></li><li><a href="http://blog.csdn.net/xiong452980729/article/details/52234270" target="_blank" rel="external">机器学习技法(林軒田)笔记之一</a></li><li>机器学习技法(林軒田)视频与讲稿。</li></ol>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/26/ML_taiwan_01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(一/二)从基本类型开始</title>
      <link>https://wangwlj.com/2017/12/25/CPP_01_02/</link>
      <guid>https://wangwlj.com/2017/12/25/CPP_01_02/</guid>
      <pubDate>Mon, 25 Dec 2017 02:31:35 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;第一章-开始&quot;&gt;&lt;a href=&quot;#第一章-开始&quot; class=&quot;headerlink&quot; title=&quot;第一章 开始&quot;&gt;&lt;/a&gt;第一章 开始&lt;/h1&gt;&lt;h2 id=&quot;include指令-P6-1-2&quot;&gt;&lt;a href=&quot;#include指令-P6-1-2&quot; cla
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h1><h2 id="include指令-P6-1-2"><a href="#include指令-P6-1-2" class="headerlink" title="include指令(P6,1.2)"></a>include指令(P6,1.2)</h2><p>通常情况下<code>#include</code>指令必须在所有函数之外。include和它想包含的头文件名字必须在同一行里，不然会报错。</p><p>一般情况下我们把include指令放在源文件代码内容的最前面，当你在源文件中使用<code>#include</code>声明了一个头文件，效果相当于你把整个头文件黏贴到对应的那一行上。</p><h2 id="编译器-P14-1-4"><a href="#编译器-P14-1-4" class="headerlink" title="编译器(P14,1.4)"></a>编译器(P14,1.4)</h2><p>编译器的一部分工作是寻找程序文本中的错误。<br>常见错误类型：</p><ul><li>语法错误(syntax error)</li><li>类型错误(type error)</li><li>声明错误(declaration error)</li></ul><p><strong>“编辑-编译-调试”（edit-compile-debug）</strong>周期。</p><h2 id="文件重定向-P19-1-5"><a href="#文件重定向-P19-1-5" class="headerlink" title="文件重定向(P19,1.5)"></a>文件重定向(P19,1.5)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> addItems &lt;infile &gt;outfile</div></pre></td></tr></table></figure><h2 id="专业术语-P23"><a href="#专业术语-P23" class="headerlink" title="专业术语(P23)"></a>专业术语(P23)</h2><ol><li>花括号 curly brace</li><li>内置类型 built-in type</li><li>形参列表 parameter list</li><li>字符串字面值常量 string literal</li><li>操作符 manipulator</li><li>变量 variable</li><li>初始化 initialize</li><li>注释 comments</li><li>集成开发环境 Integrated Developed Environment,IDE</li><li>条件 condition</li><li>赋值 assignment</li><li>表达式 expression</li><li>语法错误 syntax error</li><li>方法（类方法） method</li></ol><h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="C-语言关于类型的规定-P30-2-1-1"><a href="#C-语言关于类型的规定-P30-2-1-1" class="headerlink" title="C++语言关于类型的规定(P30,2.1.1)"></a>C++语言关于类型的规定(P30,2.1.1)</h2><p>C++语言的基本类型的设定与硬件紧密相关，因此很多类型的内存尺寸也都只是给了一个范围，其实各家IDE（LLVM，GCC，Visaul C++）的实现都是在范围内，具体的实现细节都是不确定的。</p><p>其中bool最小尺寸未定义，char最小尺寸是8位，wchar_t和char16_t的最小尺寸都是16位，char32_t的最小尺寸是32位，int的最小尺寸是16位，long和long long的最小尺寸分别是32位和64位，对于浮点型数据的表现尺寸是按照精度计算的，其中float的最小尺寸精度是小数点后6位(通常占内存32bytes)，double（通常占内存 64bytes）和long double(通常占内存 96~128bytes)的最小尺寸精度则是小数点后10位(实际可能比这个精度要大一些，比如float小数点后有效位为7，double为16)。</p><p>int不得小于short,long不得小于int,long long不得小于long。float,double,long double也应该是精度递增（或者相同）的关系。</p><p>要特别注意的是，<strong>扩展的字符类型</strong>(char16_t，char32_t，wchar_t)<strong>和布尔类型都没有带符号和无符号之分</strong>（尽管它们也确实属于算数类型）。</p><h2 id="类型转换-P32-2-1-2"><a href="#类型转换-P32-2-1-2" class="headerlink" title="类型转换(P32,2.1.2)"></a>类型转换(P32,2.1.2)</h2><p>程序自动执行的类型转换操作发生在程序里IDE预期我们使用A类型但是实际上我们使用B类型的时候，B类型的对象会自动转换为A类型的，如果没法转换，程序就会报错。赋值操作中就可能发生这样的情况。</p><p>我们先看赋值操作里表达式里面发生的自动转换，赋值操作A=B中，等号左边的A被叫做<strong>左值</strong>，B被叫做<strong>右值</strong>，程序期待事情是你给定的右值和左值类型完全相同。如果不相同，这里就会发生<strong>强制的类型转换</strong>，即把B的类型转化为A的类型。如果把一个超出左值类型表达范围的数赋值给左值，左值又是一个无符号类型，比如<code>unsigned char c=-1;</code>这时-1（整型，负的），右值会转化为无符号字符型，初始值对无符号类型表示数值总数取模，然后求余数，这个余数就是转化后的数。</p><p>因为C++没有明确规定有符号类型的数应该如何表示，因此如果把一个超出左值类型表达范围的数赋值给左值，左值又是一个有符号类型，这种行为的结果是不一定的，因为C++标准委员会没有规定这样做之后到底会发生什么，因此各个IDE可能会有不同的实现。我们把这种不确定造成结果的行为叫做<strong>未定义行为</strong>。</p><p><strong>建议：避免无法预知和依赖于环境的行为</strong>。</p><p><strong>提示：切勿混用带符号类型和无符号类型</strong>。</p><h2 id="转义序列-P36，2-1-3"><a href="#转义序列-P36，2-1-3" class="headerlink" title="转义序列(P36，2.1.3)"></a>转义序列(P36，2.1.3)</h2><p>字符的转义序列可以为<code>\</code>后面加上最多3个8进制数字（如果多于3个不会引发报错，多出的部分会被当成字符），或者<code>\x</code>后面加上最多两个16进制数字（多出会报错）。数字转换成10进制后的大小不得超过字符集的限定范围。一般的字面值转义无此限制，不过，一般的字面值的类型是不确定的。10进制数字类型字面值会被转换为能够容纳这个数的带符号整数类型，其他进制中它们则会被转换为能容纳它们的占内存最小的类型的值。</p><p>在最新的C++14标准中，数字字面值里还允许以0b或者0B开头，后面加上二进制数成为二进制字面值。如0B101，代表数字5；0b11，代表数字3。</p><p>指定字面值的常量：当使用一个长整型字面值时，请使用大写字母<code>L</code>来标记，因为小写字母<code>l</code>和数字<code>1</code>太容易混淆了。</p><h2 id="变量-P38"><a href="#变量-P38" class="headerlink" title="变量(P38)"></a>变量(P38)</h2><h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>C++11标准：列表初始化(list initialization)，用一组花括号来初始化变量。下面的第三种：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</div></pre></td></tr></table></figure></p><h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p><strong>变量能且只能被定义一次，但是可以被多次声明。</strong>声明变量：在变量名前添加关键字<code>extern</code>，而且不要显示地初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;        <span class="comment">// 仅仅是声明</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">0</span>;     <span class="comment">// 声明且定义</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> v;             <span class="comment">// 声明且定义</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;        <span class="comment">// 声明且定义</span></div></pre></td></tr></table></figure></p><p>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。</p><p>补：</p><blockquote><p>extern外部变量声明其实是在IDE进行编译的时候告诉IDE，这有一个外部变量你要去别的地方找。因此我们应该掌握编译链接这套流程才能够更加方便的会用extern。假设有一个头文件a.h，这个头文件里面定义了int aaa=0;还有一个源文件b.cpp。这个b.cpp里面使用了extern int aaa;这样的语句，那么这个b.cpp是编译不了的。因为头文件如果不被别的源文件引用，是不参与被编译为obj的过程的，一旦它不参与这个过程，它里面声明的aaa这个全局变量其实就不存在，因此在b.cpp里面外部生命一个不存在的变量自然就是非法的。另外，使用extern也要和static做区分并考量它在别的文件中会不会造成内存污染等问题。这里应该掌握分离式编译的编译和链接特性再使用extern比较好。</p></blockquote><p><strong>静态类型</strong>(P42)</p><h3 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h3><p><strong>初始化所有指针</strong>： 初始化为nullptr或0。</p><p><strong>void *指针</strong>(P50)：特殊的指针类型，可以存放任意对象的地址。我们对该指针中到底是个什么类型的对象并不了解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p1,p2;</div></pre></td></tr></table></figure><p>其中，p1是指向int的指针，p2是int。(强调变量具有的复合类型。)</p><p><strong>指向指针的指针</strong>：通过<code>*</code>的个数可以区分指针的级别，即：<code>**</code>表示指向指针的指针，<code>***</code>表示指向指针的指针的指针。</p><p><strong>指向指针的引用</strong>(P52)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p;</div><div class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">//r是对指针p的引用</span></div><div class="line"></div><div class="line">r = &amp;i; <span class="comment">//r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span></div><div class="line">*r = <span class="number">0</span>; <span class="comment">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></div></pre></td></tr></table></figure></p><p><font color="00cc00"><strong>面对一条比较复杂的指针或者引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义</strong></font>。<br>离变量名最近的符号（此例中是<code>&amp;r</code>的符号<code>&amp;</code>）对<strong>变量的类型有最直接的影响</strong>，因此<code>r</code>是一个引用。声明符的其余部分用以确定<code>r</code>引用的类型是是什么，此例中的符号<code>*</code>说明<code>r</code>引用的是一个指针。最后，声明的基本数据类型部分指出<code>r</code>引用的是一个<code>int</code>指针。</p><h2 id="顶层const-P57-2-4-3"><a href="#顶层const-P57-2-4-3" class="headerlink" title="顶层const(P57,2.4.3)"></a>顶层const(P57,2.4.3)</h2><p>顶层const是对const而言的，“顶层”可以用来修饰<code>const</code>状态的形容词。一个<code>const</code>使对象本身的值固定，这个<code>const</code>就被称为顶层const;一个<code>const</code>是对象指向或引用的对象成为固定值，这个const就被称为底层const。</p><p>顶层和底层const对拷贝来说密切相关，有相同底层const资格的两个对象才能够互相拷贝，而且顶层const声明变量之后不允许再次改变const的值。<br><code>int p,const int *a＝&amp;p;</code>这种语句中的const就是底层const。<br>像<code>int v1=9;const int *p=&amp;v1;int *p2=p;</code>这种语句如果能够通过编译，那么我们就可以使用p2的性质改变p1指向的常量的值，但是常量的值是不能够被改变的，因此这种变相改变常量的值的表达式都是错误的。可以通过分析const级别得到表达式中常量是否被更改，从而判断语句的正确性。</p><p>说到底，顶层底层说的是对拷贝控制的约束。总的规则就是“不能改变常量的值”。因此“拷入和拷出的对象都要有相同的底层const资格，或者两个对象数据类型必须能转换”，例如，有<code>int *p1,const int *p2;</code>。p1没有底层const,p2有底层const。p1=p2;这时<code>const int*</code>不能转换成<code>int *</code>(如果转换，就违反了“不能改变常量的值这一约束条件”)，因此<code>p1=p2;</code>不合法。<code>p2=p1;``int *</code>能够转换成<code>const int *</code>,因此<code>p2=p1</code>合法。</p><h2 id="constexpr-P58-2-4-4"><a href="#constexpr-P58-2-4-4" class="headerlink" title="constexpr(P58,2.4.4)"></a>constexpr(P58,2.4.4)</h2><p>我们在了解<code>constexpr</code>之前，应该先了解<strong>常量表达式</strong>。所谓常量就是固定的量，那么常量表达式就是值固定不变的表达式，这里“值固定不变”，指的是程序编译阶段，常量表达式的值就能被确定下来之后也不能对其进行任何种方式的修改。因此这个固定，是编译之后固定的。像<code>cout&lt;&lt;1234&lt;&lt;endl;</code>中的1234，就是常量表达式，显然，字面值是常量表达式。</p><p><code>constexpr</code>的作用之一就是帮助程序员在IDE的提示下查看一个赋值语句是不是常量表达式。使用的方式包含在声明语句里面，形如<code>constexpr 变量类型 变量名=右值;</code>如果右值是一个常量，这条语句就是正确的。在所有函数体外声明的全局变量的地址就符合“在编译期间能确定，编译后值不被改变”这两个条件，因此也属于常量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>; <span class="comment">// 20是常量表达式</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>; <span class="comment">// mf+1是常量表达式</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = size(); <span class="comment">//只有当size是一个constexpr函数时，才是一条正确的语句。</span></div></pre></td></tr></table></figure></p><p>另外，用constexpr声明的指针(比如，<code>constexpr int *p=&amp;v1;</code>中的<code>*p</code>，相当于<code>int *const p=&amp;v1;</code>)都是顶层const，即指针本身值固定。但是指针指向的内容是可以变的。引用也一样。</p><p><strong>定义于函数体之外的变量的地址是固定的，可以用来初始化constexpr指针</strong>。</p><p>当你使用constexpr定义引用变量的时候，这个变量引用的对象只能是全局基本数据类型（引用类型除外的）变量（因为要求的内存地址必须是固定不变的）。constexpr引用的结果和正常的引用的结果是一致的，因为引用本身就是固定不变的，因此相当于顶层const修饰的constexpr对引用类型类说没有特殊的意义。 </p><h2 id="类型别名-P61-2-4-4"><a href="#类型别名-P61-2-4-4" class="headerlink" title="类型别名(P61,2.4.4)"></a>类型别名(P61,2.4.4)</h2><p>使用<code>typedef int zhengxing;</code>这种对简单的类型名进行替换的方式无疑是非常直观并且好理解的，但是在涉及到复杂的类型名的时候往往会出现各种各样的问题。</p><p>比如<code>typedef char *Pstring;</code>这条语句是不是就意味着我们看到<code>Pstring</code>就可以用<code>char *</code>替换呢。其实并不是，实际上类型别名不只是替换的规则，而是要复杂很多。</p><p>比如我们遇到<code>const Pstring a;</code>的时候，按照替换的规则，这条语句就相当于<code>const char * a;</code>这里的const这种情况下是底层const，但是结果并不是这样的，这条语句正确的等同语句应该是<code>char *const a;</code>是一个顶层const，即指针本身是一个常量。让我们来分析一下为什么是这个样子，而不是简单的替换就行了。<code>typedef char *Pstring；</code>这条语句就是说<code>Pstring</code>是一个类型别名，它是什么类型的类型别名呢？Pstring是 指向char的指针的类型别名，也就是说，这个类型修饰的对象必须是一个指针，这个指针也必须指向char而不能指向别的什么东西，比如，不能指向<code>const char</code>。我们再看看<code>const Pstring a;</code>这个语句，首先a一定是指向char的指针。所以这个前面的const应该是用来修饰这个指针本身。也就是说，这个指针是<strong>常量指针</strong>而非指向常量的指针。这一点非常重要。</p><p><code>const char * a</code>这个语句里面，实际上类型是<code>const char</code>，<code>*</code>是声明符的一部分。我们说过，定义一个变量由两部分组成，类型名和声明符，声明符可以是<code>*</code>或者<code>&amp;</code>加上变量名的形式。而类型别名只是给类型一个别名，至于声明符是怎样的，不在它修饰的范围内。因此在有const的情况下，就可以看出来这两者之间的区别还是很明显的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</div><div class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//cstr是指向char的常量指针</span></div><div class="line"><span class="keyword">const</span> pstring *ps; <span class="comment">//ps是一个指针，它的对象是指向char的常量指针。</span></div></pre></td></tr></table></figure><p>pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const char *cstr = 0; //是对const pstring的错误理解</div></pre></td></tr></table></figure></p><p>数据类型就变成了<code>char</code>，<code>*</code>成为了声明符的一部分。这样改写的结果是，<code>const char</code>成了基本数据类型。cstr是一个指针，指向了常量字符。</p><h2 id="auto类型声明符-P61-2-5-2"><a href="#auto类型声明符-P61-2-5-2" class="headerlink" title="auto类型声明符(P61,2.5.2)"></a>auto类型声明符(P61,2.5.2)</h2><p>C++11中引入的auto主要有两种用途：自动类型推断和返回值占位。auto在C++98中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两个标准的auto，完全是两个概念。</p><p><code>auto</code>变量通过初始化语句，计算出右值的类型，并推导出左值的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">0</span>, &amp;r = i;</div><div class="line"><span class="keyword">auto</span> a = r; <span class="comment">// a是一个整数（r是i的别名，而i是一个整数）</span></div></pre></td></tr></table></figure></p><p>这个过程中auto将会忽视顶层const和引用类型，可用<code>const auto &amp;a=i;</code>这种方式显式地指出了：指出要推导的结果是带顶层指针属性的或者是引用属性的。</p><p>auto推导多个值时，这些值的类型必须是一样的。因为auto是利用初始化赋值，因此它的行为基本上也和初始化有关。</p><p>关于auto的更多用法：<a href="http://blog.csdn.net/zxh2075/article/details/9235591" target="_blank" rel="external">【C++11】新特性——auto的使用</a></p><h2 id="decltype类型指示符-P62-2-5-3"><a href="#decltype类型指示符-P62-2-5-3" class="headerlink" title="decltype类型指示符(P62,2.5.3)"></a>decltype类型指示符(P62,2.5.3)</h2><p>有时候会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为此，C++11新标准引入第二种类型说明符<code>decltype</code>。</p><p><code>decltype</code>不通过计算，只通过推算出变量应有的值，表达式本身应有的值和函数的返回值来<strong>推导类型</strong>。</p><p>对于变量类型，<code>decltype</code>保留顶层const和引用的属性。对于表达式，<strong>解引用表达式(如:<code>int i=1; int *p=&amp;i; decltype (*p) a=i;</code>中的<code>*p</code>,对p解引用是<code>int &amp;</code>类型的)和带括号的表达式，（如：<code>decltype ((a+1)) c=i;</code>）的结果都将是引用类型</strong>。因为decltype通过处理表达式得到结果，因此更详细的内容在<em>第四章</em>将会被提到。有的表达式返回左值，有的表达式返回右值，返回左值的表达式在decltype类型推导下得到的将是引用的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>,*p = &amp;i, &amp;r = i;</div><div class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">//正确，加法结果为int，因此b是一个（未初始化的）int</span></div><div class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">//错误，c是int&amp;，必须初始化</span></div><div class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">//错误，c是int&amp;，必须初始化</span></div><div class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">//正确，e是一个（未初始化的）int</span></div></pre></td></tr></table></figure></p><blockquote><p><strong>decltype((variable)) (注意是双层括号)的结果永远是引用</strong>，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</p></blockquote><p>补：</p><ol><li><p>一般情况下，出现数组名的表达式时会把数组名转换为<strong>指针</strong>，而用decltype一个数组名时，其返回类型是<strong>该数组的类型</strong>，如有int ia[10]，则<code>decltype(ia) da</code>，此时da也为包含10个int元素的数组。用于函数时也一样，不会自动把函数名转换为指针，而是返回该函数类型。</p></li><li><p>如果作用于一个取地址运算符，则为指向指针的指针，如有int p，则<code>decltype(&amp;p)</code>的结果是<code>int **</code>类型。</p></li></ol><h2 id="用关键字struct自定义数据结构"><a href="#用关键字struct自定义数据结构" class="headerlink" title="用关键字struct自定义数据结构"></a>用关键字struct自定义数据结构</h2><p>使用struct关键字定义类的形式如<code>struct 类名｛数据成员类型1 数据成员名1；数据成员类型2 数据成员名2;｝;</code>，C++11规定可以给类内成员提供类内初始值用于初始化用我们自定义类创建的对象实例中的成员的值。形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> student=<span class="number">0</span>;</div><div class="line">    <span class="keyword">float</span> numbers=<span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><blockquote><p> 很多新手程序员忘记在类定义的最后加上分号。</p></blockquote><h2 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure><p>头文件保护符依赖于预处理变量。如<code>#define DEBUG</code>，此时<code>DEBUG</code>就是预处理器变量。预处理变量无视C++语言中关于作用域的规则。</p><blockquote><p>头文件保护符很简单， 程序员只要<strong>习惯性加上</strong>就可以了，没必要太在乎你的程序到底需不需要。</p></blockquote><h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><p>1.算数类型 arithmetic type<br>2.整型 integral type<br>3.转换 convert<br>4.不可打印 nonprintable<br>5.转义序列 escape sequence<br>6.类型说明符 type specifier<br>7.分离式编译 separate compilation<br>8.声明 declaration<br>9.声明符 declarator<br>10.静态类型 statically typed<br>11.类型检查 type checking<br>12.标识符 identifier<br>13.内层作用域 inner scope<br>14.复合类型 compound type<br>15.左值引用 lvalue reference<br>16.预处理 preprocessor<br>17.临时量 temporary<br>18.指向常量的指针 pointer to const<br>19.常量指针 const pointer<br>20.字面值类型 literal type<br>21.类型别名 type alias<br>22.类内初始值 in-class initializer<br>23.预处理器 preprocessor<br>24.头文件保护符 header guard</p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/25/CPP_01_02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>photoshop白色背景图片转换为透明背景</title>
      <link>https://wangwlj.com/2017/12/21/ps_white2transparent/</link>
      <guid>https://wangwlj.com/2017/12/21/ps_white2transparent/</guid>
      <pubDate>Thu, 21 Dec 2017 13:45:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;1.打开Adobe Photoshop以及待处理的图片，如果图层上有“锁”的标志，就双击进行解锁；&lt;br&gt;&lt;img src=&quot;https://images2.imgbox.com/4e/6d/W7BRQIVn_o.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.在图层上右击，
        
      
      </description>
      
      <content:encoded><![CDATA[<p>1.打开Adobe Photoshop以及待处理的图片，如果图层上有“锁”的标志，就双击进行解锁；<br><img src="https://images2.imgbox.com/4e/6d/W7BRQIVn_o.png" alt="1"></p><p>2.在图层上右击，选择最上方的“混合选项”；<br><img src="https://images2.imgbox.com/40/79/k93NwYyF_o.png" alt=""></p><p>3.在混合选项中的本图层中，拖动右侧的白色小三角，向左滑动至适当位置。<br><img src="https://images2.imgbox.com/e4/a0/9gpxW33B_o.png" alt=""></p><p>4.效果展示。滑动之前的效果：<br><img src="https://images2.imgbox.com/93/b7/CRkJk51e_o.jpg" alt=""><br>滑动之后的效果：<br><img src="https://images2.imgbox.com/64/5c/lcI8vPjg_o.jpg" alt=""></p><p>5.存储。选择“文件”中的“存储为”；<br><img src="https://images2.imgbox.com/90/bf/osDfROqU_o.png" alt=""></p><p>在弹出窗口中选择保存类型为“PNG”格式，保存即可。也可以根据需要，选择合适的格式。<br><img src="https://images2.imgbox.com/18/da/M04vdmM2_o.png" alt=""></p><p>最后附上全文的<a href="https://wx3.sinaimg.cn/mw1024/c38a0784ly1fmop679zh6j215z2sn7wh.jpg" target="_blank" rel="external">图片链接</a>。</p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/21/ps_white2transparent/#disqus_thread</comments>
    </item>
    
    <item>
      <title>个人博客的域名注册与备案流程</title>
      <link>https://wangwlj.com/2017/12/19/blog_domain_register/</link>
      <guid>https://wangwlj.com/2017/12/19/blog_domain_register/</guid>
      <pubDate>Tue, 19 Dec 2017 04:17:15 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;域名注册&quot;&gt;&lt;a href=&quot;#域名注册&quot; class=&quot;headerlink&quot; title=&quot;域名注册&quot;&gt;&lt;/a&gt;域名注册&lt;/h2&gt;&lt;p&gt;简要说一下为什么选择&lt;strong&gt;万网&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看到网上的教程一般都是推荐到国外网站注册，如go
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h2><p>简要说一下为什么选择<strong>万网</strong>。</p><p>看到网上的教程一般都是推荐到国外网站注册，如godaddy，Gandi，Namesilo等等。<br>但一般都是比较早期的回答(2011-13)了，目前(2017/12)来说，仅从<strong>价格</strong>因素考虑，阿里云万网域名是普遍低于国外网站的。</p><p><strong>万网域名注册地址</strong>：<a href="https://wanwang.aliyun.com/domain/" target="_blank" rel="external">https://wanwang.aliyun.com/domain/</a></p><p>另外，关于<strong>域名后缀</strong>选择问题，一般来说，<strong>首选com域名</strong>，不推荐cn域名（国内监管严格的原因？）。其次，个人博客站点可以考虑其他后缀，如net，top，me(貌似万网不支持了)，xyz等等。</p><p>选择了心仪的域名之后，购买。以阿里云为例，购买完成后，点击右上角的<strong>控制台</strong>；进入控制台后，选择左下角的<strong>域名与网站（万网）</strong>下的<strong>域名</strong>，进入域名列表界面。</p><p>可以看到，右方出现了三个选项【续费】、【解析】【管理】<br><img src="https://images2.imgbox.com/cc/51/JLumBDiL_o.png" alt="域名列表界面"></p><p>点击<strong>解析</strong>，按照操作，添加解析即可。主要填写三个参数：记录类型、主机记录和记录值。</p><p><strong>记录类型</strong>：CNAME是跳转到其他网址，我的是github博客，就直接让他跳转到github博客即可。A是指向IPV4地址。</p><p><strong>主机记录</strong>是网址的前缀，比如说注册的网址是xxx.com，那么blog.xxx.com的主机记录就是blog，xxx.com的主机记录可以不填，也可以填上一个@</p><p>给出我目前的解析值作为参考。<br><img src="https://images2.imgbox.com/8f/d8/befX67KY_o.png" alt="解析值"><br>第一个是为了让百度搜索引擎抓取的，每个网址的主机记录都不同，可以忽略。</p><h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p>我使用的是<a href="http://wangwlj.com/2017/09/08/blog_setup/">hexo+Github搭建个人博客</a>，因此，只买了域名（也可以不买，直接使用github.io地址），没有买云服务器、虚拟主机之类的，因此无法备案。</p><p>简而言之，备案需要有<strong>服务器</strong>，然后到服务器提供商处备案即可。</p><p>阿里云官方的备案完整流程，可供备案参考：<a href="https://help.aliyun.com/knowledge_detail/36895.html" target="_blank" rel="external">https://help.aliyun.com/knowledge_detail/36895.html</a></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/19/blog_domain_register/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo博客优化之实现来必力评论功能</title>
      <link>https://wangwlj.com/2017/12/18/blog_comment/</link>
      <guid>https://wangwlj.com/2017/12/18/blog_comment/</guid>
      <pubDate>Mon, 18 Dec 2017 12:11:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;评论功能概述&quot;&gt;&lt;a href=&quot;#评论功能概述&quot; class=&quot;headerlink&quot; title=&quot;评论功能概述&quot;&gt;&lt;/a&gt;评论功能概述&lt;/h2&gt;&lt;p&gt;目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="评论功能概述"><a href="#评论功能概述" class="headerlink" title="评论功能概述"></a>评论功能概述</h2><p>目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。</p><p>可用的评论系统大概有：</p><ul><li><p>HyperComments：<a href="https://www.hypercomments.com" target="_blank" rel="external">https://www.hypercomments.com</a> （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气，，）</p></li><li><p>来必力：<a href="https://livere.com" target="_blank" rel="external">https://livere.com</a> （来自韩国，使用邮箱注册。）</p></li><li><p>畅言： <a href="http://changyan.kuaizhan.com" target="_blank" rel="external">http://changyan.kuaizhan.com</a> （安装需要备案号。不太好用。）</p></li><li><p>Gitment： <a href="https://github.com/imsun/gitment" target="_blank" rel="external">https://github.com/imsun/gitment</a> （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。）</p></li><li><p>Valine:  <a href="https://github.com/xCss/Valine" target="_blank" rel="external">https://github.com/xCss/Valine</a> (基于Leancloud的极简风评论系统，用了下，没效果，是我Next主题的原因还是？）</p></li></ul><p>综上，最终采用了来必力。</p><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>打开来必力官网：<br><a href="https://livere.com" target="_blank" rel="external">https://livere.com</a></p><p>按套路注册（有可能注册上面要花费点功夫）。（貌似需要科学上网？之前没科学上网好像登录界面显示不了）。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>点击上方的安装，选择免费的city版本。</p><p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fml5edyp4bj20wt0lymyx.jpg" alt=""></p><p>并点击现在安装，出现如下界面。<br><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fml5ekh4erj20yh0me0uf.jpg" alt=""></p><p>复制其中的uid字段。</p><p>打开主题目录下的<code>blog/themes/next/_config.yml</code>配置文件，定位到<code>livere_uid</code>字段，粘贴上刚刚复制的UID。</p><p>至此，大功告成。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>测试评论如图所示：<br><img src="https://images2.imgbox.com/b3/f1/9s6btT5a_o.png" alt=""></p><h2 id="设置提醒"><a href="#设置提醒" class="headerlink" title="设置提醒"></a>设置提醒</h2><p>当有新评论出现时，通过邮箱提醒。</p><p>点击<code>右上角-&gt;管理页面</code>。选择<code>评论提醒</code>，按照下图设置，输入邮箱、选择间隔时间。</p><p><img src="https://images2.imgbox.com/36/9a/23YhEmlz_o.png" alt=""></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/18/blog_comment/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(2) 第三章函数的增长</title>
      <link>https://wangwlj.com/2017/12/13/algorithm_tutorial_chapter_3/</link>
      <guid>https://wangwlj.com/2017/12/13/algorithm_tutorial_chapter_3/</guid>
      <pubDate>Wed, 13 Dec 2017 14:51:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;3-1-渐近记号&quot;&gt;&lt;a href=&quot;#3-1-渐近记号&quot; class=&quot;headerlink&quot; title=&quot;3.1 渐近记号&quot;&gt;&lt;/a&gt;3.1 渐近记号&lt;/h2&gt;&lt;p&gt;$\Theta、 \text{O}和\Omega $三种记号的图示：&lt;br&gt;&lt;img src
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="3-1-渐近记号"><a href="#3-1-渐近记号" class="headerlink" title="3.1 渐近记号"></a>3.1 渐近记号</h2><p>$\Theta、 \text{O}和\Omega $三种记号的图示：<br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_1.png" alt="1"></p><h3 id="先看第一幅图-a-——-Theta-记号"><a href="#先看第一幅图-a-——-Theta-记号" class="headerlink" title="先看第一幅图(a)——$\Theta$记号"></a>先看第一幅图(a)——$\Theta$记号</h3><p>若存在正常量$c_1,c_2,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant c_1g(n)\leqslant f(n) \leqslant c_2g(n)$，则$f(n)$属于集合$\Theta(g(n))$，<br>可以记为$f(n)\in \Theta(g(n))$，我们通常用$f(n)=\Theta(g(n))$表达相同的概念。</p><p>上述公式的含义：函数f(n)能“夹入”$c_1g(n)$和$c_2g(n)$之间。换句话说，对所有的$n\geqslant n_0$，函数$f(n)$在一个常量因子内等于$g(n)$，我们称$g(n)$是$f(n)$的一个渐近紧确界(asymptotically tight bound)。</p><p>实例：可以用上述的形式化定义来证明：$\frac{1}{2}n^2-3n =\Theta(n^2)$，以及$6n^3 \neq \Theta(n^2)$。</p><p>渐近正函数就是对足够大的n均为正的函数。</p><p>直觉上，一个渐近正函数的低阶项 在确定渐近确界时可以被忽略，因为对于大的n，它们是无足轻重的。</p><p>一般来说，对任意多项式$p(n)=\sum_{i=0}^d a_i n^i$，其中$a_i$为常量且$a_d&gt;0$（最高阶的系数大于零），则有$p(n)=\Theta(n_d)$。</p><h3 id="接着看图-b-——-text-O-记号"><a href="#接着看图-b-——-text-O-记号" class="headerlink" title="接着看图(b)——$\text{O}$记号"></a>接着看图(b)——$\text{O}$记号</h3><p>$\Theta$记号渐近地给出了一个函数的上界和下届。当只有一个<em>渐近上界</em>时，使用$\text{O}$记号。</p><p>$\text{O}(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant  f(n) \leqslant cg(n)}$</p><p>我们记$f(n)=\text{O}(g(n))$表示$f(n)$是集合$\text{O}(g(n))$的成员。注意$f(n)=\Theta(g(n))$蕴含了$f(n)=\text{O}(g(n))$，因为$\Theta$记号是一个比$\text{O}$记号更强的概念。</p><p>使用$\text{O}$记号，我们常常可以仅仅通过检查算法的总体结构来描述算法的运行时间。$\text{O}$记号描述上界，对插入排序算法的最坏情况运行时间的界$\text{O}(n^2)$也适合于该算法对每个输入的运行时间。该算法对每个输入的运行时间都有一个界，这就是综合性描述。</p><h3 id="最后看图-c-——-Omega-记号"><a href="#最后看图-c-——-Omega-记号" class="headerlink" title="最后看图(c)——$\Omega$记号"></a>最后看图(c)——$\Omega$记号</h3><p>正如$\text{O}$记号提供了渐近上界，$\Omega$记号提供了渐进下界。</p><p>$\Omega(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant  cg(n) \leqslant f(n)}$</p><p>于是，由此引出了定理3.1。</p><h4 id="定理-3-1"><a href="#定理-3-1" class="headerlink" title="定理 3.1"></a>定理 3.1</h4><p>对任意两个函数$f(n)$和$g(n)$，我们有$f(n)=\Theta(g(n))$，当且仅当$f(n)=\text{O}(g(n))$且$f(n)=\Omega(g(n))$。</p><p>当一个算法的运行时间为$\Omega(g(n))$时，我们意指不管n是什么规模，只要n足够大，对那个输入的运行时间至少是$g(n)$的常数倍。</p><h3 id="等式和不等式中的渐近记号"><a href="#等式和不等式中的渐近记号" class="headerlink" title="等式和不等式中的渐近记号"></a>等式和不等式中的渐近记号</h3><p>当渐近记号出现在某个公式中时，我们将其解释为代表某个我们不关注名称的匿名函数。</p><p>例如：$2n^2+3n+1 = 2n^2 +\Theta(n)$。</p><p>按这种方式使用渐记号可以帮助消除一个等式中无关紧要的细节与混乱。</p><p>例如：归并排序的最坏情况运行时间：<br>$$T(n) = 2T(n/2)+\Theta(n)$$<br>如果只对T(n)的渐近行为感兴趣，就没必要准确说明所以低阶项，它们都被理解为包含在由项$\Theta(n)$表示的匿名函数中。</p><p>在某些例子中，渐近记号出现在等式的左边，如：<br>$$2n^2+\Theta(n) = \Theta(n^2) $$</p><p>无论怎么选择等号左边的匿名函数，总有一种办法来选择等号右边的匿名函数使等式成立。</p><h3 id="text-o-记号"><a href="#text-o-记号" class="headerlink" title="$\text{o}$记号"></a>$\text{o}$记号</h3><p>$\text{o}$记号，非渐近紧确的上界。</p><p>$\text{o}(g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant  f(n) &lt; cg(n)}$。</p><p>$\text{O}$记号与$\text{o}$记号类似，主要的区别 是在$f(n)=\text{O}(g(n))$中，界$0\leqslant  f(n) \leqslant cg(n)$对某个常量$c&gt;0$成立，但在$f(n)=\text{o}(g(n))$中，界$0\leqslant  f(n) &lt; cg(n)$对所有常量$c&gt;0$成立。</p><p>直观上，在$\text{o}$记号中，当n趋向于无穷时，函数$f(n)$相对于$g(n)$来说变得微不足道了，即：<br>$$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = 0$$</p><h3 id="omega-记号"><a href="#omega-记号" class="headerlink" title="$\omega$记号"></a>$\omega$记号</h3><p>非渐近紧确下界。</p><p>$\omega (g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant cg(n) &lt;  f(n) }$。</p><p>$$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = \infty $$</p><h3 id="渐近运算的运算性质"><a href="#渐近运算的运算性质" class="headerlink" title="渐近运算的运算性质"></a>渐近运算的运算性质</h3><p>传递性、自反性、对称性与转置对称性：<br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_2.png" alt="2"><br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_3.png" alt="3"><br>而且：两个函数f和g的渐近比较关系可与实数a与b之间的比较做类比： </p><ul><li>f(n)=O(g(n)) 类似于a&lt;= b </li><li>f(n)=Ω(g(n)) 类似于a&gt;= b </li><li>f(n)=Θ(g(n)) 类似于a= b </li><li>f(n)=o(g(n)) 类似于a&lt; b </li><li>f(n)=w(g(n)) 类似于a&gt; b</li></ul><p>三分性：虽然实数具有三分性，即对于任意两个实数a、b，下列三种情况必须有一种成立：$a<b$，$a=b$或$a>b$。但是不是所有函数都可以渐近比较。</b$，$a=b$或$a></p><h2 id="3-2-标准记号与常用函数"><a href="#3-2-标准记号与常用函数" class="headerlink" title="3.2 标准记号与常用函数"></a>3.2 标准记号与常用函数</h2><h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><p>单调递增/单调递减：包含等号；严格递增/严格递减：不包含等号。</p><h3 id="向下取整与向上取整"><a href="#向下取整与向上取整" class="headerlink" title="向下取整与向上取整"></a>向下取整与向上取整</h3><p>x的向下取整：$\lfloor x \rfloor$；x的向上取整：$\lceil x \rceil$。</p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>对任意整数a和正整数n，$a\ \text{mod}\ n$ 的值就是商a/n的余数。<br>$$a\ \text{mod}\ n = a-n\lfloor a/n\rfloor $$</p><p>若$(a\ \text{mod}\ n)=(b\ \text{mod}\ n)$，则记$a\equiv b(\text{mod}n)$</p><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>给定一个非负整数d，n的d次多项式$p(n)$：<br>$$p(n)=\sum_{i=0}^d a_i n^i$$<br>其中，$a_d \neq 0 $。</p><p>多项式为渐近正的当且仅当$a_d &gt; 0 $。对于一个d次渐近正的多项式$p(n)$，有$p(n)=\Theta(n^d)$</p><p>若对于某个常量k，有$f(n)=\text{O}(n^k)$，则称函数$f(n)$是多项式有界的。</p><h3 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h3><p>对所有使得$a&gt;1$的实常量a和b，有<br>$$\lim_{n\rightarrow \infty} \frac{n^b}{a^n} = 0$$<br>据此可得：<br>$$n^b = \text{o}(a^n)$$</p><h3 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h3><p>以2为底的自然数：<br>$$\text{lg}n = \text{log}_2n$$<br>自然对数：<br>$$\text{ln}n = \text{log}_en$$<br>取幂：<br>$$\text{lg}^kn = (\text{lg}n)^k$$<br>复合：<br>$$\text{lg}\text{lg}n =\text{lg} (\text{lg}n)$$</p><p>一个重要的记号约定：对数函数只适用于公式中的下一项，所以$\text{lg}n+k$意思是指$(\text{lg}n)+k$</p><p>对于$a&gt;0,b&gt;0,c&gt;0$和n，有<br>$$a = b^{\text{log}_ba}$$<br>$$\text{log}_c(ab) = \text{log}_ca +\text{log}_cb$$<br>$$\text{log}_b(a^n) = n\text{log}_ba$$<br>$$\text{log}_ba =\frac{\text{log}_ca}{\text{log}_cb} $$<br>$$\text{log}_b(1/a) =- \text{log}_ba $$<br>$$\text{log}_ba =\frac{1}{\text{log}_ab} $$<br>$$a^{\text{log}_bc} = c^{\text{log}_ba}$$<br>其中，上述等式的对数底不为1。</p><p>对任意常量a，有<br>$$\text{log}^bn = \text{o}(n^a)$$<br>表示任意正的多项式函数都比任意多对数函数增长得快。</p><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>$n!$，读作“n的阶乘”。其定义为对整数$n \geqslant 0$：<br>$$n! = \begin{cases}<br>1 &amp; 若n=0\\<br>n\cdot (n-1)! &amp; 若n&gt;0<br>\end{cases}$$</p><p>阶乘函数的一个弱上界是$n! \leqslant n^n$，因为在阶乘中，n项的每项最多为n。</p><h4 id="斯特林-Stirling-近似公式"><a href="#斯特林-Stirling-近似公式" class="headerlink" title="斯特林(Stirling)近似公式"></a>斯特林(Stirling)近似公式</h4><p>$$n!=\sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n})) $$</p><p>由上述公式可以证明：<br>$$n! = o(n^n)$$<br>$$n! = \omega(2^n)$$<br>$$\text{lg}n! = \Theta(n\text{lg}n)$$</p><h3 id="多重函数"><a href="#多重函数" class="headerlink" title="多重函数"></a>多重函数</h3><p>记号$f^{(i)}(n)$表示f(n)重复i次作用于一个初值n上。对非负整数i，我们递归地定义：<br>$$f^{(i)}(n)=\begin{cases}<br>n &amp; 若i=0 \\<br>f(f^{(i-1)}(n)) &amp; 若i&gt;0<br>\end{cases}$$</p><h3 id="多重对数函数"><a href="#多重对数函数" class="headerlink" title="多重对数函数"></a>多重对数函数</h3><p>$\text{lg}^*n$表示多重对数，多重对数增长非常慢。</p><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>斐波那契数的递归定义：<br>$$F_0 = 0$$<br>$$F_1 = 1$$<br>$$F_i = F_{i-1}+F_{i-2}, i \geqslant 2$$</p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/13/algorithm_tutorial_chapter_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(1) 第二章算法基础</title>
      <link>https://wangwlj.com/2017/12/12/algorithm_tutolrial_chapter_2/</link>
      <guid>https://wangwlj.com/2017/12/12/algorithm_tutolrial_chapter_2/</guid>
      <pubDate>Tue, 12 Dec 2017 13:43:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;第二章-算法基础&quot;&gt;&lt;a href=&quot;#第二章-算法基础&quot; class=&quot;headerlink&quot; title=&quot;第二章 算法基础&quot;&gt;&lt;/a&gt;第二章 算法基础&lt;/h1&gt;&lt;h2 id=&quot;伪码说明&quot;&gt;&lt;a href=&quot;#伪码说明&quot; class=&quot;headerlink&quot; 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="第二章-算法基础"><a href="#第二章-算法基础" class="headerlink" title="第二章 算法基础"></a>第二章 算法基础</h1><h2 id="伪码说明"><a href="#伪码说明" class="headerlink" title="伪码说明"></a>伪码说明</h2><ol><li><p>数组A[1,…,n]长度为n的待排序序列。<br>注意，书中的下标都是从1开始的。python中是从0开始的。</p></li><li><p>伪码中，A的长度用A.length表示。python中使用len(A)表示。</p></li><li>缩进表示块结构。提高代码清晰度。</li><li>while, for, repeat-until 在循环结束后，循环计数器仍然保持其值。</li><li>符号“//”后面是注释。</li><li>数组元素通过“数组名[下标]”这样的形式来访问。</li><li>复合数据通常被组织成<em>对象</em>，对象又由<em>属性</em>组成。</li><li>return允许返回多个值</li><li>按值把参数传递给过程，被调用过程接收其参数自身的副本。</li><li>布尔运算符“and”和“or”都是短路的。</li></ol><h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><p>插入排序的Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(A)</span>:</span></div><div class="line">    length = len(A)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, length):</div><div class="line">        key = A[j]</div><div class="line">        i = j - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key:</div><div class="line">            A[i + <span class="number">1</span>] = A[i]</div><div class="line">            i = i - <span class="number">1</span></div><div class="line">        A[i + <span class="number">1</span>] = key</div><div class="line">    <span class="keyword">return</span> A</div><div class="line">A = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">8</span>, ]</div><div class="line">print(insertion_sort(A))</div></pre></td></tr></table></figure></p><p>对插入排序的简单理解：<br>从第二个数开始，依次比较前面的数和key的大小，若大于key，则后移。<br>最后将key插入到最前方停下的位置。<br>j是遍历数组每个元素；<br>i是每个元素前面、需要移动的最前方。</p><p>形象的解释：插入纸牌：key是当前带插入的牌，找到插入的位置，先把每个大的都往后挪一个位置出来，再把key插入到空出来的位置。</p><h2 id="2-2-分析算法"><a href="#2-2-分析算法" class="headerlink" title="2.2 分析算法"></a>2.2 分析算法</h2><p>RAM（Random-access machine,RAM）模型:单处理器计算模型，指令一条接一条地执行，没有并发操作。</p><p>真实计算机如何设计，RAM模型就是如何设计的，RAM模型包含真实计算机的常见指令：算术指令（加减乘除，取余，向下取整，向上取整），数据移动指令（装入、存储和复制）和控制指令（条件与无条件转移、子程序调用与返回）。</p><p>灰色区域：真实计算机中未列出的指令。如指数运算算是常量时间的指令吗？</p><p>答案：①一般情况下不是，如$x^y$，当x和y都是实数的时候。②在受限情况下，可以当做一个常量时间的操作。如$2^k$是一个常量的操作。</p><p>一个整数的各位左移k位等价于将该整数乘以$2^k$。</p><h3 id="插入排序算法的分析"><a href="#插入排序算法的分析" class="headerlink" title="插入排序算法的分析"></a>插入排序算法的分析</h3><p>算法需要的时间与输入规模同步增长，通常把一个程序的运行时间描述成其输入规模的函数。</p><p>输入规模的最佳概念依赖于研究的问题。</p><p>一个算法在特定输入上的运行时间是指执行的基本操作数或步数。<br>算法的运行时间是执行每条语句的运行时间之和。</p><p>若数组已排好序，则出现最佳情况：$T(n)=an+b$<br>若数组已反向排序（即按递减序排好序），则导致最坏情况：$T(n)=an^2+b$，是n的二次函数。</p><h3 id="最坏情况与平均情况分析"><a href="#最坏情况与平均情况分析" class="headerlink" title="最坏情况与平均情况分析"></a>最坏情况与平均情况分析</h3><p>本书往往集中于只求<em>最坏情况运行时间</em>，即对于规模为n的任何输入，算法的最长时间。</p><p>书中给出了三个理由，在此不详述。其中一点是平均情况往往与最坏情况一样差。</p><h3 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h3><p>最坏情况运行时间表示为：$T(n)=an^2+b$。</p><p>现在我们做出一种更简化的抽象：我们真正感兴趣的运行时间的$增长率$或$增长量级$。</p><h2 id="2-3-设计算法"><a href="#2-3-设计算法" class="headerlink" title="2.3 设计算法"></a>2.3 设计算法</h2><h3 id="2-3-1-分治法"><a href="#2-3-1-分治法" class="headerlink" title="2.3.1 分治法"></a>2.3.1 分治法</h3><p>许多算法在结构上是递归的，算法依次或多次递归地调用其自身以解决紧密相关的若干子问题。</p><p>分治模式在每层递归时都有三个步骤：</p><ul><li>分解原问题为若干子问题；</li><li>解决这些子问题，递归地求解各子问题。</li><li>合并这些子问题的解成原问题的解。</li></ul><p><em>归并排序</em>算法完全遵循分治模式。归并算法的关键在于合并。<br>归并排序的的基本步骤如下：</p><ol><li>把待排序的数组分为左数组和右数组</li><li>对左数组和右数组进行迭代排序</li><li>将左数组和右数组进行合并</li></ol><p>显然这些基本步骤符合分治模式在每一层递归上的三个步骤：分解、解决、合并。</p><h2 id="2-3-2-归并排序算法（分治算法）"><a href="#2-3-2-归并排序算法（分治算法）" class="headerlink" title="2.3.2 归并排序算法（分治算法）"></a>2.3.2 归并排序算法（分治算法）</h2><p>MERGE(A,p,q,r)：完成合并。A是一个数组，p,q,r是数组的下标，满足$p\leqslant q&lt;r$。假设A[p..q]与A[q+1..r]都已排好序，MERGE函数的目的就是合并这两个子数组形成单一的已排好序的数组A[p..r]。</p><p>形象地描述：同样以插入排序时的扑克牌为例，现在的情况是有两堆牌（两个输入堆），牌面朝上（可见，已排序），每次选取两堆中较小的放入到输出堆，牌面朝下。重复这个步骤，直到一个输入堆为空，则把另一个输入堆直接牌面朝下的放置到输出堆。</p><p>MERGE-SORT(A,p,r)排序子数组A[p,r]中的元素。若$p\geqslant r$，则该子数组最多只有一个元素，所以已经排好序，直接返回。否则，分解步骤。计算下表q，将A[p..r]分为A[p..q]和A[q+1..r]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># author: wangwlj</span></div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"></div><div class="line">MAX = <span class="number">1</span> &lt;&lt; <span class="number">31</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(A, p, q, r)</span>:</span></div><div class="line">    n1 = q - p + <span class="number">1</span></div><div class="line">    n2 = r - q</div><div class="line">    L = []</div><div class="line">    R = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n1):</div><div class="line">        L.append(A[p + i])  <span class="comment"># 因为我初始化为空列表，所以直接赋值的话会报错，只能以append的形式追加值。</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n2):</div><div class="line">        R.append(A[q + i + <span class="number">1</span>])</div><div class="line">    L.append(MAX)  <span class="comment"># 使用无穷大作为哨兵</span></div><div class="line">    R.append(MAX)</div><div class="line">    <span class="keyword">assert</span> len(L) == n1 + <span class="number">1</span> <span class="keyword">and</span> len(R) == n2 + <span class="number">1</span></div><div class="line"></div><div class="line">    i = <span class="number">0</span>  <span class="comment"># python是从0开始</span></div><div class="line">    j = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(p, r + <span class="number">1</span>):  <span class="comment"># 需要加1，因为首尾每个都算</span></div><div class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]:</div><div class="line">            A[k] = L[i]</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            A[k] = R[j]</div><div class="line">            j += <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = floor((p + r) / <span class="number">2</span>)</div><div class="line">        merge_sort(A, p, q)</div><div class="line">        merge_sort(A, q + <span class="number">1</span>, r)  <span class="comment"># 首尾都包含了，所以要加1</span></div><div class="line">        merge(A, p, q, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># test function</span></div><div class="line">    A = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>]</div><div class="line">    merge_sort(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)</div><div class="line">    print(A)</div></pre></td></tr></table></figure><p>上述代码测试成功。</p><h3 id="2-3-2-分析分治算法"><a href="#2-3-2-分析分治算法" class="headerlink" title="2.3.2 分析分治算法"></a>2.3.2 分析分治算法</h3><p>假设把原问题分解为a个子问题，每个子问题的规模都是原问题的1/b。（对于归并排序，a和b都是2，然而在许多分治算法中，$a\neq b $。）</p><p>求解规模为n/b的子问题，需要$T(n/b)$的时间，所以需要花费$aT(n/b)$的时间来求解a个子问题。</p><p>下面分析归并排序n个数的最坏情况运行时间$T(n)$的递归式。</p><ul><li>分解：分解步骤只计算子数组的中间位置，需要常量时间，因此，$D(n)=\Theta(n)$</li><li>解决：递归地求解两个规模为n/2的子问题，将贡献$2T(n/2)$的运行时间。</li><li>合并：n个子元素的数组上的merge需要$\Theta(n)$的时间（线性复杂度），所以$C(n)=\Theta(n)$。</li></ul><p>$D(n)$和$C(n)$相加的和，仍然是n的线性复杂度，即$\Theta(n)$。再与“解决”步骤相加，为：<br>$$T(n) =<br> \begin{cases}<br>  \Theta(1) &amp; 若n=1 \\<br> 2T(n/2)+\Theta(n) &amp;  若n&gt;1\\<br>  \end{cases}<br>  $$</p><p>在第四章，我们将看到“主定理”，可以用该定理来证明$T(n)$ 为$\Theta(n\text{lg}n)$。（即时间复杂度为nlgn）</p><p>运行时间为$\Theta(n\text{lg}n)$的归并排序优于运行时间为$\Theta(n^2)$的插入排序。</p><p>$T(n) =\Theta(n\text{lg}n)$的直观理解：<br><img src="/2017/12/12/algorithm_tutolrial_chapter_2/merge_sort_complexity.png" alt="归并排序复杂度的直观理解"><br>由(d)图，每层对n等分，可以展开为lgn层(再加上原来的一层，一共lgn+1层)。每层的复杂度都是cn，所以总的复杂度为$cn\text{lg}n+cn = cn(\text{lg}n+1)$。</p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/12/algorithm_tutolrial_chapter_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一起开始机器学习吧——知乎live笔记</title>
      <link>https://wangwlj.com/2017/12/12/Start_Machine_Learning_review/</link>
      <guid>https://wangwlj.com/2017/12/12/Start_Machine_Learning_review/</guid>
      <pubDate>Tue, 12 Dec 2017 09:02:37 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;问答干货&quot;&gt;&lt;a href=&quot;#问答干货&quot; class=&quot;headerlink&quot; title=&quot;问答干货&quot;&gt;&lt;/a&gt;问答干货&lt;/h2&gt;&lt;p&gt;①练手项目推荐：《机器学习实战》,从零开始写机器学习算法代码，有实际的项目。有一定了解之后，去Kaggle上找竞赛做。&lt;/p
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="问答干货"><a href="#问答干货" class="headerlink" title="问答干货"></a>问答干货</h2><p>①练手项目推荐：《机器学习实战》,从零开始写机器学习算法代码，有实际的项目。有一定了解之后，去Kaggle上找竞赛做。</p><p>②教程推荐：公开课（吴恩达、coursera等），coursera上吴恩达的公开课</p><p>③语言推荐：python，MATLAB。很多开源工具（MXNet，Tensorflow，Keras）都有Python接口。</p><p>④python方面，网上有很多博客，比如廖雪峰的博客，感觉只需要了解即可，会用就行；传统算法入门的话，推荐李航的《统计学习方法》,入门最合适。最近出了Bengio的《Deep learning》书，有中文翻译，前面章节全是传统算法。不推荐一上来就看大家都说的《pattern recognition and machine learning》以及《模式分类》,这两本书不适合入门。</p><p>⑤完全零基础的入门性质的资料：视频：<a href="https://www.youtube.com/watch?v=IpGxLWOIZy4&amp;t=9s" target="_blank" rel="external">https://www.youtube.com/watch?v=IpGxLWOIZy4&amp;t=9s</a><br>机器学习入门： <a href="http://www.cnblogs.com/subconscious/p/4107357.html" target="_blank" rel="external">http://www.cnblogs.com/subconscious/p/4107357.html</a></p><p>⑥数学基础课：数学（概率、线代、高数、随机过程，排名分先后）</p><p>⑦发论文经验：目前我只是有paper在投，还没有成功发过，哈哈。经验嘛，主要就是一定要敢于否定自己，我在写的paper一共两篇，每一篇都几乎改了七八次，每次都很严格地要求自己。同时，最好要把paper发给同组的人一起看看，不同的角度给你提问题，会帮助你认识到自己容易忽视的问题。视觉方面发paper其实很容易的。通常来说你需要在同一个数据集上跟最好的方法做对比。</p><p>⑧我数学基础不太牢固 想一边看机器学习一边补数学 但有很多数学符号甚至都不认识 百度也没法搜索 你有什么建议吗？<br>答：专业书籍都有符号索引表；学习简单的数学工具，如latex；matrix cookbook 矩阵常用的手册。</p><h2 id="PPT干货"><a href="#PPT干货" class="headerlink" title="PPT干货"></a>PPT干货</h2><ul><li>机器学习常用分类：监督学习、半监督学习、无监督学习、增强学习</li><li><p>②无监督才是世界的本质，标注数据往往要花费大量的人力物力。<br>没有标注这么做呢？迁移学习是可以类比无监督学习来做的事情。<br>人是有类比能力的，计算机可以吗？我们想让它有这个能力。（就是迁移学习）<br>通过迁移学习的方式可以部分地接近无监督学习的目标。<br>迁移学习的好处是什么？利用已有的知识，节约新学习的成本。<br>但需要找到两者的相似性。骑自行车-&gt;开汽车？ 不行！ 需要有相似性。<br>深度学习算是对迁移学习的改进（我的总结）？，因为深度学习不像迁移学习需要手动提取特征。</p></li><li><p>准备工作<br>  理论知识（高数、概率、线性代数、随机过程）<br>  编码能力（Python, Matlab, Java）</p></li><li>基本入门<br>  李航《统计学习方法》<br>  周志华《机器学习》<br>  吴恩达公开课<br>  Kaggle竞赛</li><li><p>进阶提高<br>  《模式分类》、《PRML》<br>  ICML、NIPS等国际会议<br>  做自己的研究工作</p></li><li><p>书籍资料整理：<a href="https://github.com/ty4z2008/Qix/blob/master/dl.md" target="_blank" rel="external">https://github.com/ty4z2008/Qix/blob/master/dl.md</a><br>  入门资料：<a href="http://www.cnblogs.com/subconscious/p/4107357.html" target="_blank" rel="external">http://www.cnblogs.com/subconscious/p/4107357.html</a><br>  公开课：<a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">http://open.163.com/special/opencourse/machinelearning.html</a><br>  Kaggle竞赛：<a href="https://www.kaggle.com/" target="_blank" rel="external">https://www.kaggle.com/</a></p></li></ul>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/12/Start_Machine_Learning_review/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
