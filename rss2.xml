<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>王立杰的博客</title>
    <link>https://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Tue, 19 Dec 2017 04:30:31 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>个人博客的域名注册与备案流程</title>
      <link>https://wangwlj.com/2017/12/19/blog_domain_register/</link>
      <guid>https://wangwlj.com/2017/12/19/blog_domain_register/</guid>
      <pubDate>Tue, 19 Dec 2017 04:17:15 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;域名注册&quot;&gt;&lt;a href=&quot;#域名注册&quot; class=&quot;headerlink&quot; title=&quot;域名注册&quot;&gt;&lt;/a&gt;域名注册&lt;/h2&gt;&lt;p&gt;简要说一下为什么选择&lt;strong&gt;万网&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看到网上的教程一般都是推荐到国外网站注册，如go
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h2><p>简要说一下为什么选择<strong>万网</strong>。</p><p>看到网上的教程一般都是推荐到国外网站注册，如godaddy，Gandi，Namesilo等等。<br>但一般都是比较早期的回答(2011-13)了，目前(2017/12)来说，仅从<strong>价格</strong>因素考虑，阿里云万网域名是普遍低于国外网站的。</p><p><strong>万网域名注册地址</strong>：<a href="https://wanwang.aliyun.com/domain/" target="_blank" rel="external">https://wanwang.aliyun.com/domain/</a></p><p>另外，关于<strong>域名后缀</strong>选择问题，一般来说，<strong>首选com域名</strong>，不推荐cn域名（国内监管严格的原因？）。其次，个人博客站点可以考虑其他后缀，如net，top，me(貌似万网不支持了)，xyz等等。</p><p>选择了心仪的域名之后，购买。以阿里云为例，购买完成后，点击右上角的<strong>控制台</strong>；进入控制台后，选择左下角的<strong>域名与网站（万网）</strong>下的<strong>域名</strong>，进入域名列表界面。</p><p>可以看到，右方出现了三个选项【续费】、【解析】【管理】<br><img src="https://images2.imgbox.com/cc/51/JLumBDiL_o.png" alt="域名列表界面"></p><p>点击<strong>解析</strong>，按照操作，添加解析即可。主要填写三个参数：记录类型、主机记录和记录值。</p><p><strong>记录类型</strong>：CNAME是跳转到其他网址，我的是github博客，就直接让他跳转到github博客即可。A是指向IPV4地址。</p><p><strong>主机记录</strong>是网址的前缀，比如说注册的网址是xxx.com，那么blog.xxx.com的主机记录就是blog，xxx.com的主机记录可以不填，也可以填上一个@</p><p>给出我目前的解析值作为参考。<br><img src="https://images2.imgbox.com/8f/d8/befX67KY_o.png" alt="解析值"><br>第一个是为了让百度搜索引擎抓取的，每个网址的主机记录都不同，可以忽略。</p><h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p>我使用的是<a href="http://wangwlj.com/2017/09/08/blog_setup/">hexo+Github搭建个人博客</a>，因此，只买了域名（也可以不买，直接使用github.io地址），没有买云服务器、虚拟主机之类的，因此无法备案。</p><p>简而言之，备案需要有<strong>服务器</strong>，然后到服务器提供商处备案即可。</p><p>阿里云官方的备案完整流程，可供备案参考：<a href="https://help.aliyun.com/knowledge_detail/36895.html" target="_blank" rel="external">https://help.aliyun.com/knowledge_detail/36895.html</a></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/19/blog_domain_register/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo博客优化之实现来必力评论功能</title>
      <link>https://wangwlj.com/2017/12/18/blog_comment/</link>
      <guid>https://wangwlj.com/2017/12/18/blog_comment/</guid>
      <pubDate>Mon, 18 Dec 2017 12:11:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;评论功能概述&quot;&gt;&lt;a href=&quot;#评论功能概述&quot; class=&quot;headerlink&quot; title=&quot;评论功能概述&quot;&gt;&lt;/a&gt;评论功能概述&lt;/h2&gt;&lt;p&gt;目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="评论功能概述"><a href="#评论功能概述" class="headerlink" title="评论功能概述"></a>评论功能概述</h2><p>目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。</p><p>可用的评论系统大概有：</p><ul><li><p>HyperComments：<a href="https://www.hypercomments.com" target="_blank" rel="external">https://www.hypercomments.com</a> （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气，，）</p></li><li><p>来必力：<a href="https://livere.com" target="_blank" rel="external">https://livere.com</a> （来自韩国，使用邮箱注册。）</p></li><li><p>畅言： <a href="http://changyan.kuaizhan.com" target="_blank" rel="external">http://changyan.kuaizhan.com</a> （安装需要备案号。不太好用。）</p></li><li><p>Gitment： <a href="https://github.com/imsun/gitment" target="_blank" rel="external">https://github.com/imsun/gitment</a> （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。）</p></li><li><p>Valine:  <a href="https://github.com/xCss/Valine" target="_blank" rel="external">https://github.com/xCss/Valine</a> (基于Leancloud的极简风评论系统，用了下，没效果，是我Next主题的原因还是？）</p></li></ul><p>综上，最终采用了来必力。</p><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>打开来必力官网：<br><a href="https://livere.com" target="_blank" rel="external">https://livere.com</a></p><p>按套路注册（有可能注册上面要花费点功夫）。（貌似需要科学上网？之前没科学上网好像登录界面显示不了）。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>点击上方的安装，选择免费的city版本。</p><p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fml5edyp4bj20wt0lymyx.jpg" alt=""></p><p>并点击现在安装，出现如下界面。<br><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fml5ekh4erj20yh0me0uf.jpg" alt=""></p><p>复制其中的uid字段。</p><p>打开主题目录下的<code>blog/themes/next/_config.yml</code>配置文件，定位到<code>livere_uid</code>字段，粘贴上刚刚复制的UID。</p><p>至此，大功告成。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>测试评论如图所示：<br><img src="https://images2.imgbox.com/b3/f1/9s6btT5a_o.png" alt=""></p><h2 id="设置提醒"><a href="#设置提醒" class="headerlink" title="设置提醒"></a>设置提醒</h2><p>当有新评论出现时，通过邮箱提醒。</p><p>点击<code>右上角-&gt;管理页面</code>。选择<code>评论提醒</code>，按照下图设置，输入邮箱、选择间隔时间。</p><p><img src="https://images2.imgbox.com/36/9a/23YhEmlz_o.png" alt=""></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/18/blog_comment/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(2) 第三章函数的增长</title>
      <link>https://wangwlj.com/2017/12/13/algorithm_tutorial_chapter_3/</link>
      <guid>https://wangwlj.com/2017/12/13/algorithm_tutorial_chapter_3/</guid>
      <pubDate>Wed, 13 Dec 2017 14:51:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;3-1-渐近记号&quot;&gt;&lt;a href=&quot;#3-1-渐近记号&quot; class=&quot;headerlink&quot; title=&quot;3.1 渐近记号&quot;&gt;&lt;/a&gt;3.1 渐近记号&lt;/h2&gt;&lt;p&gt;$\Theta、 \text{O}和\Omega $三种记号的图示：&lt;br&gt;&lt;img src
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="3-1-渐近记号"><a href="#3-1-渐近记号" class="headerlink" title="3.1 渐近记号"></a>3.1 渐近记号</h2><p>$\Theta、 \text{O}和\Omega $三种记号的图示：<br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_1.png" alt="1"></p><h3 id="先看第一幅图-a-——-Theta-记号"><a href="#先看第一幅图-a-——-Theta-记号" class="headerlink" title="先看第一幅图(a)——$\Theta$记号"></a>先看第一幅图(a)——$\Theta$记号</h3><p>若存在正常量$c_1,c_2,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant c_1g(n)\leqslant f(n) \leqslant c_2g(n)$，则$f(n)$属于集合$\Theta(g(n))$，<br>可以记为$f(n)\in \Theta(g(n))$，我们通常用$f(n)=\Theta(g(n))$表达相同的概念。</p><p>上述公式的含义：函数f(n)能“夹入”$c_1g(n)$和$c_2g(n)$之间。换句话说，对所有的$n\geqslant n_0$，函数$f(n)$在一个常量因子内等于$g(n)$，我们称$g(n)$是$f(n)$的一个渐近紧确界(asymptotically tight bound)。</p><p>实例：可以用上述的形式化定义来证明：$\frac{1}{2}n^2-3n =\Theta(n^2)$，以及$6n^3 \neq \Theta(n^2)$。</p><p>渐近正函数就是对足够大的n均为正的函数。</p><p>直觉上，一个渐近正函数的低阶项 在确定渐近确界时可以被忽略，因为对于大的n，它们是无足轻重的。</p><p>一般来说，对任意多项式$p(n)=\sum_{i=0}^d a_i n^i$，其中$a_i$为常量且$a_d&gt;0$（最高阶的系数大于零），则有$p(n)=\Theta(n_d)$。</p><h3 id="接着看图-b-——-text-O-记号"><a href="#接着看图-b-——-text-O-记号" class="headerlink" title="接着看图(b)——$\text{O}$记号"></a>接着看图(b)——$\text{O}$记号</h3><p>$\Theta$记号渐近地给出了一个函数的上界和下届。当只有一个<em>渐近上界</em>时，使用$\text{O}$记号。</p><p>$\text{O}(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant  f(n) \leqslant cg(n)}$</p><p>我们记$f(n)=\text{O}(g(n))$表示$f(n)$是集合$\text{O}(g(n))$的成员。注意$f(n)=\Theta(g(n))$蕴含了$f(n)=\text{O}(g(n))$，因为$\Theta$记号是一个比$\text{O}$记号更强的概念。</p><p>使用$\text{O}$记号，我们常常可以仅仅通过检查算法的总体结构来描述算法的运行时间。$\text{O}$记号描述上界，对插入排序算法的最坏情况运行时间的界$\text{O}(n^2)$也适合于该算法对每个输入的运行时间。该算法对每个输入的运行时间都有一个界，这就是综合性描述。</p><h3 id="最后看图-c-——-Omega-记号"><a href="#最后看图-c-——-Omega-记号" class="headerlink" title="最后看图(c)——$\Omega$记号"></a>最后看图(c)——$\Omega$记号</h3><p>正如$\text{O}$记号提供了渐近上界，$\Omega$记号提供了渐进下界。</p><p>$\Omega(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant  cg(n) \leqslant f(n)}$</p><p>于是，由此引出了定理3.1。</p><h4 id="定理-3-1"><a href="#定理-3-1" class="headerlink" title="定理 3.1"></a>定理 3.1</h4><p>对任意两个函数$f(n)$和$g(n)$，我们有$f(n)=\Theta(g(n))$，当且仅当$f(n)=\text{O}(g(n))$且$f(n)=\Omega(g(n))$。</p><p>当一个算法的运行时间为$\Omega(g(n))$时，我们意指不管n是什么规模，只要n足够大，对那个输入的运行时间至少是$g(n)$的常数倍。</p><h3 id="等式和不等式中的渐近记号"><a href="#等式和不等式中的渐近记号" class="headerlink" title="等式和不等式中的渐近记号"></a>等式和不等式中的渐近记号</h3><p>当渐近记号出现在某个公式中时，我们将其解释为代表某个我们不关注名称的匿名函数。</p><p>例如：$2n^2+3n+1 = 2n^2 +\Theta(n)$。</p><p>按这种方式使用渐记号可以帮助消除一个等式中无关紧要的细节与混乱。</p><p>例如：归并排序的最坏情况运行时间：<br>$$T(n) = 2T(n/2)+\Theta(n)$$<br>如果只对T(n)的渐近行为感兴趣，就没必要准确说明所以低阶项，它们都被理解为包含在由项$\Theta(n)$表示的匿名函数中。</p><p>在某些例子中，渐近记号出现在等式的左边，如：<br>$$2n^2+\Theta(n) = \Theta(n^2) $$</p><p>无论怎么选择等号左边的匿名函数，总有一种办法来选择等号右边的匿名函数使等式成立。</p><h3 id="text-o-记号"><a href="#text-o-记号" class="headerlink" title="$\text{o}$记号"></a>$\text{o}$记号</h3><p>$\text{o}$记号，非渐近紧确的上界。</p><p>$\text{o}(g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant  f(n) &lt; cg(n)}$。</p><p>$\text{O}$记号与$\text{o}$记号类似，主要的区别 是在$f(n)=\text{O}(g(n))$中，界$0\leqslant  f(n) \leqslant cg(n)$对某个常量$c&gt;0$成立，但在$f(n)=\text{o}(g(n))$中，界$0\leqslant  f(n) &lt; cg(n)$对所有常量$c&gt;0$成立。</p><p>直观上，在$\text{o}$记号中，当n趋向于无穷时，函数$f(n)$相对于$g(n)$来说变得微不足道了，即：<br>$$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = 0$$</p><h3 id="omega-记号"><a href="#omega-记号" class="headerlink" title="$\omega$记号"></a>$\omega$记号</h3><p>非渐近紧确下界。</p><p>$\omega (g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant cg(n) &lt;  f(n) }$。</p><p>$$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = \infty $$</p><h3 id="渐近运算的运算性质"><a href="#渐近运算的运算性质" class="headerlink" title="渐近运算的运算性质"></a>渐近运算的运算性质</h3><p>传递性、自反性、对称性与转置对称性：<br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_2.png" alt="2"><br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_3.png" alt="3"><br>而且：两个函数f和g的渐近比较关系可与实数a与b之间的比较做类比： </p><ul><li>f(n)=O(g(n)) 类似于a&lt;= b </li><li>f(n)=Ω(g(n)) 类似于a&gt;= b </li><li>f(n)=Θ(g(n)) 类似于a= b </li><li>f(n)=o(g(n)) 类似于a&lt; b </li><li>f(n)=w(g(n)) 类似于a&gt; b</li></ul><p>三分性：虽然实数具有三分性，即对于任意两个实数a、b，下列三种情况必须有一种成立：$a<b$，$a=b$或$a>b$。但是不是所有函数都可以渐近比较。</b$，$a=b$或$a></p><h2 id="3-2-标准记号与常用函数"><a href="#3-2-标准记号与常用函数" class="headerlink" title="3.2 标准记号与常用函数"></a>3.2 标准记号与常用函数</h2><h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><p>单调递增/单调递减：包含等号；严格递增/严格递减：不包含等号。</p><h3 id="向下取整与向上取整"><a href="#向下取整与向上取整" class="headerlink" title="向下取整与向上取整"></a>向下取整与向上取整</h3><p>x的向下取整：$\lfloor x \rfloor$；x的向上取整：$\lceil x \rceil$。</p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>对任意整数a和正整数n，$a\ \text{mod}\ n$ 的值就是商a/n的余数。<br>$$a\ \text{mod}\ n = a-n\lfloor a/n\rfloor $$</p><p>若$(a\ \text{mod}\ n)=(b\ \text{mod}\ n)$，则记$a\equiv b(\text{mod}n)$</p><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>给定一个非负整数d，n的d次多项式$p(n)$：<br>$$p(n)=\sum_{i=0}^d a_i n^i$$<br>其中，$a_d \neq 0 $。</p><p>多项式为渐近正的当且仅当$a_d &gt; 0 $。对于一个d次渐近正的多项式$p(n)$，有$p(n)=\Theta(n^d)$</p><p>若对于某个常量k，有$f(n)=\text{O}(n^k)$，则称函数$f(n)$是多项式有界的。</p><h3 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h3><p>对所有使得$a&gt;1$的实常量a和b，有<br>$$\lim_{n\rightarrow \infty} \frac{n^b}{a^n} = 0$$<br>据此可得：<br>$$n^b = \text{o}(a^n)$$</p><h3 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h3><p>以2为底的自然数：<br>$$\text{lg}n = \text{log}_2n$$<br>自然对数：<br>$$\text{ln}n = \text{log}_en$$<br>取幂：<br>$$\text{lg}^kn = (\text{lg}n)^k$$<br>复合：<br>$$\text{lg}\text{lg}n =\text{lg} (\text{lg}n)$$</p><p>一个重要的记号约定：对数函数只适用于公式中的下一项，所以$\text{lg}n+k$意思是指$(\text{lg}n)+k$</p><p>对于$a&gt;0,b&gt;0,c&gt;0$和n，有<br>$$a = b^{\text{log}_ba}$$<br>$$\text{log}_c(ab) = \text{log}_ca +\text{log}_cb$$<br>$$\text{log}_b(a^n) = n\text{log}_ba$$<br>$$\text{log}_ba =\frac{\text{log}_ca}{\text{log}_cb} $$<br>$$\text{log}_b(1/a) =- \text{log}_ba $$<br>$$\text{log}_ba =\frac{1}{\text{log}_ab} $$<br>$$a^{\text{log}_bc} = c^{\text{log}_ba}$$<br>其中，上述等式的对数底不为1。</p><p>对任意常量a，有<br>$$\text{log}^bn = \text{o}(n^a)$$<br>表示任意正的多项式函数都比任意多对数函数增长得快。</p><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>$n!$，读作“n的阶乘”。其定义为对整数$n \geqslant 0$：<br>$$n! = \begin{cases}<br>1 &amp; 若n=0\\<br>n\cdot (n-1)! &amp; 若n&gt;0<br>\end{cases}$$</p><p>阶乘函数的一个弱上界是$n! \leqslant n^n$，因为在阶乘中，n项的每项最多为n。</p><h4 id="斯特林-Stirling-近似公式"><a href="#斯特林-Stirling-近似公式" class="headerlink" title="斯特林(Stirling)近似公式"></a>斯特林(Stirling)近似公式</h4><p>$$n!=\sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n})) $$</p><p>由上述公式可以证明：<br>$$n! = o(n^n)$$<br>$$n! = \omega(2^n)$$<br>$$\text{lg}n! = \Theta(n\text{lg}n)$$</p><h3 id="多重函数"><a href="#多重函数" class="headerlink" title="多重函数"></a>多重函数</h3><p>记号$f^{(i)}(n)$表示f(n)重复i次作用于一个初值n上。对非负整数i，我们递归地定义：<br>$$f^{(i)}(n)=\begin{cases}<br>n &amp; 若i=0 \\<br>f(f^{(i-1)}(n)) &amp; 若i&gt;0<br>\end{cases}$$</p><h3 id="多重对数函数"><a href="#多重对数函数" class="headerlink" title="多重对数函数"></a>多重对数函数</h3><p>$\text{lg}^*n$表示多重对数，多重对数增长非常慢。</p><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>斐波那契数的递归定义：<br>$$F_0 = 0$$<br>$$F_1 = 1$$<br>$$F_i = F_{i-1}+F_{i-2}, i \geqslant 2$$</p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/13/algorithm_tutorial_chapter_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(1) 第二章算法基础</title>
      <link>https://wangwlj.com/2017/12/12/algorithm_tutolrial_chapter_2/</link>
      <guid>https://wangwlj.com/2017/12/12/algorithm_tutolrial_chapter_2/</guid>
      <pubDate>Tue, 12 Dec 2017 13:43:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;第二章-算法基础&quot;&gt;&lt;a href=&quot;#第二章-算法基础&quot; class=&quot;headerlink&quot; title=&quot;第二章 算法基础&quot;&gt;&lt;/a&gt;第二章 算法基础&lt;/h1&gt;&lt;h2 id=&quot;伪码说明&quot;&gt;&lt;a href=&quot;#伪码说明&quot; class=&quot;headerlink&quot; 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="第二章-算法基础"><a href="#第二章-算法基础" class="headerlink" title="第二章 算法基础"></a>第二章 算法基础</h1><h2 id="伪码说明"><a href="#伪码说明" class="headerlink" title="伪码说明"></a>伪码说明</h2><ol><li><p>数组A[1,…,n]长度为n的待排序序列。<br>注意，书中的下标都是从1开始的。python中是从0开始的。</p></li><li><p>伪码中，A的长度用A.length表示。python中使用len(A)表示。</p></li><li>缩进表示块结构。提高代码清晰度。</li><li>while, for, repeat-until 在循环结束后，循环计数器仍然保持其值。</li><li>符号“//”后面是注释。</li><li>数组元素通过“数组名[下标]”这样的形式来访问。</li><li>复合数据通常被组织成<em>对象</em>，对象又由<em>属性</em>组成。</li><li>return允许返回多个值</li><li>按值把参数传递给过程，被调用过程接收其参数自身的副本。</li><li>布尔运算符“and”和“or”都是短路的。</li></ol><h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><p>插入排序的Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(A)</span>:</span></div><div class="line">    length = len(A)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, length):</div><div class="line">        key = A[j]</div><div class="line">        i = j - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key:</div><div class="line">            A[i + <span class="number">1</span>] = A[i]</div><div class="line">            i = i - <span class="number">1</span></div><div class="line">        A[i + <span class="number">1</span>] = key</div><div class="line">    <span class="keyword">return</span> A</div><div class="line">A = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">8</span>, ]</div><div class="line">print(insertion_sort(A))</div></pre></td></tr></table></figure></p><p>对插入排序的简单理解：<br>从第二个数开始，依次比较前面的数和key的大小，若大于key，则后移。<br>最后将key插入到最前方停下的位置。<br>j是遍历数组每个元素；<br>i是每个元素前面、需要移动的最前方。</p><p>形象的解释：插入纸牌：key是当前带插入的牌，找到插入的位置，先把每个大的都往后挪一个位置出来，再把key插入到空出来的位置。</p><h2 id="2-2-分析算法"><a href="#2-2-分析算法" class="headerlink" title="2.2 分析算法"></a>2.2 分析算法</h2><p>RAM（Random-access machine,RAM）模型:单处理器计算模型，指令一条接一条地执行，没有并发操作。</p><p>真实计算机如何设计，RAM模型就是如何设计的，RAM模型包含真实计算机的常见指令：算术指令（加减乘除，取余，向下取整，向上取整），数据移动指令（装入、存储和复制）和控制指令（条件与无条件转移、子程序调用与返回）。</p><p>灰色区域：真实计算机中未列出的指令。如指数运算算是常量时间的指令吗？</p><p>答案：①一般情况下不是，如$x^y$，当x和y都是实数的时候。②在受限情况下，可以当做一个常量时间的操作。如$2^k$是一个常量的操作。</p><p>一个整数的各位左移k位等价于将该整数乘以$2^k$。</p><h3 id="插入排序算法的分析"><a href="#插入排序算法的分析" class="headerlink" title="插入排序算法的分析"></a>插入排序算法的分析</h3><p>算法需要的时间与输入规模同步增长，通常把一个程序的运行时间描述成其输入规模的函数。</p><p>输入规模的最佳概念依赖于研究的问题。</p><p>一个算法在特定输入上的运行时间是指执行的基本操作数或步数。<br>算法的运行时间是执行每条语句的运行时间之和。</p><p>若数组已排好序，则出现最佳情况：$T(n)=an+b$<br>若数组已反向排序（即按递减序排好序），则导致最坏情况：$T(n)=an^2+b$，是n的二次函数。</p><h3 id="最坏情况与平均情况分析"><a href="#最坏情况与平均情况分析" class="headerlink" title="最坏情况与平均情况分析"></a>最坏情况与平均情况分析</h3><p>本书往往集中于只求<em>最坏情况运行时间</em>，即对于规模为n的任何输入，算法的最长时间。</p><p>书中给出了三个理由，在此不详述。其中一点是平均情况往往与最坏情况一样差。</p><h3 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h3><p>最坏情况运行时间表示为：$T(n)=an^2+b$。</p><p>现在我们做出一种更简化的抽象：我们真正感兴趣的运行时间的$增长率$或$增长量级$。</p><h2 id="2-3-设计算法"><a href="#2-3-设计算法" class="headerlink" title="2.3 设计算法"></a>2.3 设计算法</h2><h3 id="2-3-1-分治法"><a href="#2-3-1-分治法" class="headerlink" title="2.3.1 分治法"></a>2.3.1 分治法</h3><p>许多算法在结构上是递归的，算法依次或多次递归地调用其自身以解决紧密相关的若干子问题。</p><p>分治模式在每层递归时都有三个步骤：</p><ul><li>分解原问题为若干子问题；</li><li>解决这些子问题，递归地求解各子问题。</li><li>合并这些子问题的解成原问题的解。</li></ul><p><em>归并排序</em>算法完全遵循分治模式。归并算法的关键在于合并。<br>归并排序的的基本步骤如下：</p><ol><li>把待排序的数组分为左数组和右数组</li><li>对左数组和右数组进行迭代排序</li><li>将左数组和右数组进行合并</li></ol><p>显然这些基本步骤符合分治模式在每一层递归上的三个步骤：分解、解决、合并。</p><h2 id="2-3-2-归并排序算法（分治算法）"><a href="#2-3-2-归并排序算法（分治算法）" class="headerlink" title="2.3.2 归并排序算法（分治算法）"></a>2.3.2 归并排序算法（分治算法）</h2><p>MERGE(A,p,q,r)：完成合并。A是一个数组，p,q,r是数组的下标，满足$p\leqslant q&lt;r$。假设A[p..q]与A[q+1..r]都已排好序，MERGE函数的目的就是合并这两个子数组形成单一的已排好序的数组A[p..r]。</p><p>形象地描述：同样以插入排序时的扑克牌为例，现在的情况是有两堆牌（两个输入堆），牌面朝上（可见，已排序），每次选取两堆中较小的放入到输出堆，牌面朝下。重复这个步骤，直到一个输入堆为空，则把另一个输入堆直接牌面朝下的放置到输出堆。</p><p>MERGE-SORT(A,p,r)排序子数组A[p,r]中的元素。若$p\geqslant r$，则该子数组最多只有一个元素，所以已经排好序，直接返回。否则，分解步骤。计算下表q，将A[p..r]分为A[p..q]和A[q+1..r]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># author: wangwlj</span></div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"></div><div class="line">MAX = <span class="number">1</span> &lt;&lt; <span class="number">31</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(A, p, q, r)</span>:</span></div><div class="line">    n1 = q - p + <span class="number">1</span></div><div class="line">    n2 = r - q</div><div class="line">    L = []</div><div class="line">    R = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n1):</div><div class="line">        L.append(A[p + i])  <span class="comment"># 因为我初始化为空列表，所以直接赋值的话会报错，只能以append的形式追加值。</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n2):</div><div class="line">        R.append(A[q + i + <span class="number">1</span>])</div><div class="line">    L.append(MAX)  <span class="comment"># 使用无穷大作为哨兵</span></div><div class="line">    R.append(MAX)</div><div class="line">    <span class="keyword">assert</span> len(L) == n1 + <span class="number">1</span> <span class="keyword">and</span> len(R) == n2 + <span class="number">1</span></div><div class="line"></div><div class="line">    i = <span class="number">0</span>  <span class="comment"># python是从0开始</span></div><div class="line">    j = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(p, r + <span class="number">1</span>):  <span class="comment"># 需要加1，因为首尾每个都算</span></div><div class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]:</div><div class="line">            A[k] = L[i]</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            A[k] = R[j]</div><div class="line">            j += <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = floor((p + r) / <span class="number">2</span>)</div><div class="line">        merge_sort(A, p, q)</div><div class="line">        merge_sort(A, q + <span class="number">1</span>, r)  <span class="comment"># 首尾都包含了，所以要加1</span></div><div class="line">        merge(A, p, q, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># test function</span></div><div class="line">    A = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>]</div><div class="line">    merge_sort(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)</div><div class="line">    print(A)</div></pre></td></tr></table></figure><p>上述代码测试成功。</p><h3 id="2-3-2-分析分治算法"><a href="#2-3-2-分析分治算法" class="headerlink" title="2.3.2 分析分治算法"></a>2.3.2 分析分治算法</h3><p>假设把原问题分解为a个子问题，每个子问题的规模都是原问题的1/b。（对于归并排序，a和b都是2，然而在许多分治算法中，$a\neq b $。）</p><p>求解规模为n/b的子问题，需要$T(n/b)$的时间，所以需要花费$aT(n/b)$的时间来求解a个子问题。</p><p>下面分析归并排序n个数的最坏情况运行时间$T(n)$的递归式。</p><ul><li>分解：分解步骤只计算子数组的中间位置，需要常量时间，因此，$D(n)=\Theta(n)$</li><li>解决：递归地求解两个规模为n/2的子问题，将贡献$2T(n/2)$的运行时间。</li><li>合并：n个子元素的数组上的merge需要$\Theta(n)$的时间（线性复杂度），所以$C(n)=\Theta(n)$。</li></ul><p>$D(n)$和$C(n)$相加的和，仍然是n的线性复杂度，即$\Theta(n)$。再与“解决”步骤相加，为：<br>$$T(n) =<br> \begin{cases}<br>  \Theta(1) &amp; 若n=1 \\<br> 2T(n/2)+\Theta(n) &amp;  若n&gt;1\\<br>  \end{cases}<br>  $$</p><p>在第四章，我们将看到“主定理”，可以用该定理来证明$T(n)$ 为$\Theta(n\text{lg}n)$。（即时间复杂度为nlgn）</p><p>运行时间为$\Theta(n\text{lg}n)$的归并排序优于运行时间为$\Theta(n^2)$的插入排序。</p><p>$T(n) =\Theta(n\text{lg}n)$的直观理解：<br><img src="/2017/12/12/algorithm_tutolrial_chapter_2/merge_sort_complexity.png" alt="归并排序复杂度的直观理解"><br>由(d)图，每层对n等分，可以展开为lgn层(再加上原来的一层，一共lgn+1层)。每层的复杂度都是cn，所以总的复杂度为$cn\text{lg}n+cn = cn(\text{lg}n+1)$。</p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/12/algorithm_tutolrial_chapter_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一起开始机器学习吧——知乎live笔记</title>
      <link>https://wangwlj.com/2017/12/12/Start_Machine_Learning_review/</link>
      <guid>https://wangwlj.com/2017/12/12/Start_Machine_Learning_review/</guid>
      <pubDate>Tue, 12 Dec 2017 09:02:37 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;问答干货&quot;&gt;&lt;a href=&quot;#问答干货&quot; class=&quot;headerlink&quot; title=&quot;问答干货&quot;&gt;&lt;/a&gt;问答干货&lt;/h2&gt;&lt;p&gt;①练手项目推荐：《机器学习实战》,从零开始写机器学习算法代码，有实际的项目。有一定了解之后，去Kaggle上找竞赛做。&lt;/p
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="问答干货"><a href="#问答干货" class="headerlink" title="问答干货"></a>问答干货</h2><p>①练手项目推荐：《机器学习实战》,从零开始写机器学习算法代码，有实际的项目。有一定了解之后，去Kaggle上找竞赛做。</p><p>②教程推荐：公开课（吴恩达、coursera等），coursera上吴恩达的公开课</p><p>③语言推荐：python，MATLAB。很多开源工具（MXNet，Tensorflow，Keras）都有Python接口。</p><p>④python方面，网上有很多博客，比如廖雪峰的博客，感觉只需要了解即可，会用就行；传统算法入门的话，推荐李航的《统计学习方法》,入门最合适。最近出了Bengio的《Deep learning》书，有中文翻译，前面章节全是传统算法。不推荐一上来就看大家都说的《pattern recognition and machine learning》以及《模式分类》,这两本书不适合入门。</p><p>⑤完全零基础的入门性质的资料：视频：<a href="https://www.youtube.com/watch?v=IpGxLWOIZy4&amp;t=9s" target="_blank" rel="external">https://www.youtube.com/watch?v=IpGxLWOIZy4&amp;t=9s</a><br>机器学习入门： <a href="http://www.cnblogs.com/subconscious/p/4107357.html" target="_blank" rel="external">http://www.cnblogs.com/subconscious/p/4107357.html</a></p><p>⑥数学基础课：数学（概率、线代、高数、随机过程，排名分先后）</p><p>⑦发论文经验：目前我只是有paper在投，还没有成功发过，哈哈。经验嘛，主要就是一定要敢于否定自己，我在写的paper一共两篇，每一篇都几乎改了七八次，每次都很严格地要求自己。同时，最好要把paper发给同组的人一起看看，不同的角度给你提问题，会帮助你认识到自己容易忽视的问题。视觉方面发paper其实很容易的。通常来说你需要在同一个数据集上跟最好的方法做对比。</p><p>⑧我数学基础不太牢固 想一边看机器学习一边补数学 但有很多数学符号甚至都不认识 百度也没法搜索 你有什么建议吗？<br>答：专业书籍都有符号索引表；学习简单的数学工具，如latex；matrix cookbook 矩阵常用的手册。</p><h2 id="PPT干货"><a href="#PPT干货" class="headerlink" title="PPT干货"></a>PPT干货</h2><ul><li>机器学习常用分类：监督学习、半监督学习、无监督学习、增强学习</li><li><p>②无监督才是世界的本质，标注数据往往要花费大量的人力物力。<br>没有标注这么做呢？迁移学习是可以类比无监督学习来做的事情。<br>人是有类比能力的，计算机可以吗？我们想让它有这个能力。（就是迁移学习）<br>通过迁移学习的方式可以部分地接近无监督学习的目标。<br>迁移学习的好处是什么？利用已有的知识，节约新学习的成本。<br>但需要找到两者的相似性。骑自行车-&gt;开汽车？ 不行！ 需要有相似性。<br>深度学习算是对迁移学习的改进（我的总结）？，因为深度学习不像迁移学习需要手动提取特征。</p></li><li><p>准备工作<br>  理论知识（高数、概率、线性代数、随机过程）<br>  编码能力（Python, Matlab, Java）</p></li><li>基本入门<br>  李航《统计学习方法》<br>  周志华《机器学习》<br>  吴恩达公开课<br>  Kaggle竞赛</li><li><p>进阶提高<br>  《模式分类》、《PRML》<br>  ICML、NIPS等国际会议<br>  做自己的研究工作</p></li><li><p>书籍资料整理：<a href="https://github.com/ty4z2008/Qix/blob/master/dl.md" target="_blank" rel="external">https://github.com/ty4z2008/Qix/blob/master/dl.md</a><br>  入门资料：<a href="http://www.cnblogs.com/subconscious/p/4107357.html" target="_blank" rel="external">http://www.cnblogs.com/subconscious/p/4107357.html</a><br>  公开课：<a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">http://open.163.com/special/opencourse/machinelearning.html</a><br>  Kaggle竞赛：<a href="https://www.kaggle.com/" target="_blank" rel="external">https://www.kaggle.com/</a></p></li></ul>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/12/Start_Machine_Learning_review/#disqus_thread</comments>
    </item>
    
    <item>
      <title>python爬虫实战--selenium模拟登录并自动点击</title>
      <link>https://wangwlj.com/2017/12/09/HDHome_clawler_tutorial/</link>
      <guid>https://wangwlj.com/2017/12/09/HDHome_clawler_tutorial/</guid>
      <pubDate>Sat, 09 Dec 2017 14:57:45 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;python爬虫实战–selenium模拟登录网站HDH并刷魔力值&quot;&gt;&lt;a href=&quot;#python爬虫实战–selenium模拟登录网站HDH并刷魔力值&quot; class=&quot;headerlink&quot; title=&quot;python爬虫实战–selenium模拟登录网站H
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="python爬虫实战–selenium模拟登录网站HDH并刷魔力值"><a href="#python爬虫实战–selenium模拟登录网站HDH并刷魔力值" class="headerlink" title="python爬虫实战–selenium模拟登录网站HDH并刷魔力值"></a>python爬虫实战–selenium模拟登录网站HDH并刷魔力值</h1><h2 id="任务介绍"><a href="#任务介绍" class="headerlink" title="任务介绍"></a>任务介绍</h2><p>最近刚刚注册了某个网站：<a href="http://hdhome.org/" target="_blank" rel="external">HDHome</a>，该站有新手考核任务，其中有一项是需要达到魔力值5000。在魔力值获取方式中，我们看到这一项：“说谢谢 = 0.5个魔力值”，而网站存活种子数量达到16000+，也就意味着对每个种子说一下谢谢，轻松达到8000+的魔力值，于是，这个项目应运而生。</p><p>实现思路：<br>获取种子的页面，在每个页面中找到说谢谢的按钮，并点击后，关闭。依次进行下去即可。</p><p>相似任务：</p><p>实现对某论坛的自动回复，实现自动获取所有帖子的信息等等相关操作，无论是否需要模拟登录、模拟鼠标操作还是直接解析网站元素。</p><h2 id="selenium-牛刀小试"><a href="#selenium-牛刀小试" class="headerlink" title="selenium 牛刀小试"></a>selenium 牛刀小试</h2><p>首先导入相关的库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> selenium.webdriver <span class="keyword">as</span> webdriver</div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</div><div class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</div><div class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</div><div class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</div></pre></td></tr></table></figure><p>这是整个程序里面用到的所有内容。<br>其中，<code>webdriver</code>是主浏览器，<code>selenium</code>都是基于整个浏览器的对象；<code>WebDriverWait、EC、By</code>是等待网页元素加载相关的操作；<code>Keys</code>是键值，如<code>Keys.CONTROL</code>，<code>Keys.ENTER</code>等等，<code>ActionChains</code>是用鼠标进行一系列的操作。</p><p><code>webdriver</code>可用的浏览器有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">webdriver.Firefox</div><div class="line">webdriver.FirefoxProfile</div><div class="line">webdriver.Chrome</div><div class="line">webdriver.ChromeOptions</div><div class="line">webdriver.Ie</div><div class="line">webdriver.Opera</div><div class="line">webdriver.PhantomJS</div><div class="line">webdriver.Remote</div><div class="line">webdriver.DesiredCapabilities</div><div class="line">webdriver.ActionChains</div><div class="line">webdriver.TouchActions</div><div class="line">webdriver.Proxy</div></pre></td></tr></table></figure></p><p>一开始我选择的是Chrome浏览器，后来改为了Firefox火狐。Chrome浏览器在执行单个元素（如验证码）截图时有坑（下文有详细说），所以后来才用的Firefox。此外，PhantomJS是匿名浏览器，没有显式的窗口。</p><p>那么，开始写程序吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">driver = webdriver.Firefox()</div><div class="line">login_url = <span class="string">"http://hdhome.org/login.php"</span></div><div class="line">login_failed_url = <span class="string">"http://hdhome.org/takelogin.php"</span></div><div class="line">driver.get(login_url)</div><div class="line"><span class="keyword">while</span> self.driver.current_url == login_url <span class="keyword">or</span> self.driver.current_url == login_failed_url:</div><div class="line">    time.sleep(<span class="number">10</span>)</div><div class="line"><span class="comment"># do something</span></div></pre></td></tr></table></figure></p><p>首先，实体化浏览器driver，执行<code>driver = webdriver.Firefox()</code>这句的时候，就会有firefox浏览器弹出来了。当执行到<code>driver.get(login_url)</code>时，浏览器转到相应的网址，后面的while语句是用来等待我们手动登录的，当我们手动登录成功后，会进入到<code>&quot;http://hdhome.org/index.php&quot;</code>，与login_url及login_failed_url都不同。接着便可以做自己想做的事情了。</p><p>我们发现单个种子的网址是类似这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">single_link = <span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i)</div></pre></td></tr></table></figure></p><p>i可以从1到30000多。于是，我们可以这样写程序，依次对每个种子执行“说谢谢”操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">saythanks</span><span class="params">(link)</span>:</span></div><div class="line">    driver.get(link)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        driver.find_element_by_xpath(<span class="string">"//input[@id='saythanks']"</span>).click()</div><div class="line">        print(link, <span class="string">" succeed\n"</span>)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        print(link, <span class="string">" not succeed\n"</span>)</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">        <span class="keyword">pass</span></div><div class="line">        </div><div class="line">START = <span class="number">1</span></div><div class="line">END = <span class="number">30000</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(START, END):</div><div class="line">    link = <span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i)</div><div class="line">    saythanks(link)</div><div class="line">driver.close()</div></pre></td></tr></table></figure></p><p>其中，我们使用<code>try</code>、<code>except</code>、<code>finally</code>语句来尝试定位到’saythanks’说谢谢的按钮元素。由于有时候加载较慢就会找不到，或者是这个种子已经被删除了，所以也导致找不到该元素。</p><p>其中定位网页元素的方法有一下几种：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># locate single element in a page:</span></div><div class="line">find_element_by_id</div><div class="line">find_element_by_name</div><div class="line">find_element_by_xpath</div><div class="line">find_element_by_link_text</div><div class="line">find_element_by_partial_link_text</div><div class="line">find_element_by_tag_name</div><div class="line">find_element_by_class_name</div><div class="line">find_element_by_css_selector</div><div class="line"></div><div class="line"><span class="comment"># To find multiple elements (these methods will return a list):</span></div><div class="line">find_elements_by_name</div><div class="line">find_elements_by_xpath</div><div class="line">find_elements_by_link_text</div><div class="line">find_elements_by_partial_link_text</div><div class="line">find_elements_by_tag_name</div><div class="line">find_elements_by_class_name</div><div class="line">find_elements_by_css_selector</div></pre></td></tr></table></figure></p><p>从上面可以看出，我们也可以用<code>find_element_by_id(&quot;saythanks&quot;)</code>同样可以找到说谢谢的按钮。</p><p>附上到目前为止的所有程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master/hdh_try_2.py" target="_blank" rel="external">GitHub地址1</a><br>完整程序中加上了logging模块，将输出日志也导入到了文件，方面以后查阅。</p><h2 id="改进一：使用多线程多标签"><a href="#改进一：使用多线程多标签" class="headerlink" title="改进一：使用多线程多标签"></a>改进一：使用多线程多标签</h2><p>在上述模块中，可以看到，我们按照种子的顺序依次进行相应的操作。在种子数量很多的时候，会显得很慢，于是，有了这个改进：使用多线程。</p><p>我们使用multiprocessing库。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div></pre></td></tr></table></figure></p><p>先来看一个使用该多线程库的示例程序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(fn)</span>:</span></div><div class="line">    <span class="comment"># fn: 函数参数是数据列表的一个元素</span></div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> fn * fn</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    testFL = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">    print(<span class="string">'shunxu:'</span>)  <span class="comment"># 顺序执行(也就是串行执行，单进程)</span></div><div class="line">    s = time.time()</div><div class="line">    <span class="keyword">for</span> fn <span class="keyword">in</span> testFL:</div><div class="line">        run(fn)</div><div class="line"></div><div class="line">    e1 = time.time()</div><div class="line">    print(<span class="string">"顺序执行时间："</span>, int(e1 - s))</div><div class="line"></div><div class="line">    print(<span class="string">'concurrent:'</span>)  <span class="comment"># 创建多个进程，并行执行</span></div><div class="line">    pool = Pool(<span class="number">5</span>)  <span class="comment"># 创建拥有5个进程数量的进程池</span></div><div class="line">    <span class="comment"># testFL:要处理的数据列表，run：处理testFL列表中数据的函数</span></div><div class="line">    rl = pool.map(run, testFL)</div><div class="line">    pool.close()  <span class="comment"># 关闭进程池，不再接受新的进程</span></div><div class="line">    pool.join()  <span class="comment"># 主进程阻塞等待子进程的退出</span></div><div class="line">    e2 = time.time()</div><div class="line">    print(<span class="string">"并行执行时间："</span>, int(e2 - e1))</div><div class="line">    print(rl)</div></pre></td></tr></table></figure></p><p>于是，模仿上述程序，我们也使用多线程来执行说谢谢。说谢谢的过程其实有两步：一是打开网页，二是对每个网页定位到每个元素并点击。</p><p>如果对一、二两个步骤都执行多线程会出错，可能是由于多窗口的原因。因此我目前只对打开网页的步骤执行了多线程的操作。</p><p>上述也提到了，要同时打开多个窗口，则需要使用浏览器的多标签功能。打开一个新的标签的程序需要执行js脚本，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_url</span><span class="params">(url)</span>:</span></div><div class="line">    newwindow = <span class="string">'window.open("&#123;&#125;")'</span>.format(url)</div><div class="line">    driver.execute_script(newwindow)</div></pre></td></tr></table></figure></p><p>于是多线程部分的改进如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">START = <span class="number">25980</span></div><div class="line">    END = <span class="number">30000</span></div><div class="line">    Thread_Num = <span class="number">3</span></div><div class="line">    t = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(START, END, Thread_Num):</div><div class="line"></div><div class="line">        pool = Pool(Thread_Num)</div><div class="line">        all_links = [<span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(i, i + Thread_Num)]</div><div class="line">        print(all_links)</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            rl = pool.map(open_url, all_links)</div><div class="line">            pool.close()</div><div class="line">            pool.join()</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            print(<span class="string">"multi thread start failed, next!!"</span>)</div><div class="line">            logging.info(<span class="string">"multi thread start failed, next!!"</span>)</div><div class="line">            time.sleep(<span class="number">5</span>)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="comment"># 通过移动句柄来说谢谢</span></div><div class="line">        saythanks()</div><div class="line">        <span class="comment"># sleep more</span></div><div class="line">        time.sleep(<span class="number">0.5</span>)</div><div class="line">        <span class="keyword">if</span> t % <span class="number">3</span> == <span class="number">0</span>:</div><div class="line">            time.sleep(<span class="number">0.5</span>)</div><div class="line">        <span class="keyword">if</span> t % <span class="number">5</span> == <span class="number">0</span>:</div><div class="line">            driver.switch_to.window(driver.window_handles[<span class="number">0</span>])</div><div class="line">            driver.refresh()</div><div class="line">            mystr = driver.find_elements_by_xpath(<span class="string">'//span[@class="medium"]'</span>)[<span class="number">0</span>].text</div><div class="line">            bonus = re.search(<span class="string">"\s[0-9,.]*\s"</span>, mystr).group()</div><div class="line">            usrName = re.search(<span class="string">"\s[a-zA-Z0-9]*\s"</span>, mystr).group()</div><div class="line">            print(driver.current_url, <span class="string">"normal refresh,&#123;&#125;bonus is&#123;&#125;now..."</span>.format(usrName, bonus))</div><div class="line">            logging.info(driver.current_url + <span class="string">"normal refresh,&#123;&#125;bonus is&#123;&#125;now..."</span>.format(usrName, bonus))</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">        t = t + <span class="number">1</span></div><div class="line">    driver.quit()</div><div class="line">    logging.info(<span class="string">"&#123;&#125;: driver quit, program stop."</span>.format(</div><div class="line">        time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime(time.time()))))</div></pre></td></tr></table></figure></p><p>为了不让浏览器检测到，我只是用了三个线程，可以适当的增加。saythanks()下面的部分程序是为了增加更多的延迟并且显示相应的信息。其中<code>if t % 5 == 0:</code>中，我们移动到主页上，进行刷新操作，然后定位到用户信息那一栏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bonus = re.search(&quot;\s[0-9,.]*\s&quot;, mystr).group()</div><div class="line">usrName = re.search(&quot;\s[a-zA-Z0-9]*\s&quot;, mystr).group()</div></pre></td></tr></table></figure></p><p>这个部分使用了re正则项来找出当前的魔力值以及用户名，并显示出来。</p><p>其中，说谢谢的程序也需要对多标签进行相应的改进，程序如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">saythanks</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> len(driver.window_handles) &gt; <span class="number">1</span>:</div><div class="line">        driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            WebDriverWait(driver, <span class="number">20</span>).until(EC.presence_of_element_located((By.ID, <span class="string">"outer"</span>)))</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            driver.refresh()</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">            print(driver.current_url, <span class="string">" refresh ---"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            driver.find_element_by_xpath(<span class="string">"//input[@id='saythanks']"</span>).click()</div><div class="line">            print(driver.current_url, <span class="string">" succeed"</span>)</div><div class="line">            logging.info(driver.current_url + <span class="string">" succeed~"</span>)</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            print(driver.current_url, <span class="string">" not succeed"</span>)</div><div class="line">            logging.info(driver.current_url + <span class="string">" not succeed!"</span>)</div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">            driver.close()</div><div class="line">            driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure></p><p>通过在不同窗口的句柄之间移动，来依次进行说谢谢的步骤。<br>在每个网页加载的时候，我们执行了等待的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebDriverWait(driver, <span class="number">20</span>).until(EC.presence_of_element_located((By.ID, <span class="string">"outer"</span>)))</div></pre></td></tr></table></figure></p><p>一直等到最外层的元素出现。我选择的”outer”这个元素，是在无论这个种子是否存在的时候都会出现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure><p>将窗口转移到最后打开的那个窗口。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">driver.close()</div><div class="line">driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure></p><p>关闭当前的个窗口，并转到当前的最后一个窗口。需要注意的是：窗口虽然关闭了，但是，driver依旧会停在那个已经失效的窗口，并不会自动的转到新的窗口（虽然在浏览器中看上去到了新的窗口），所以，需要我们自己手动的移动窗口的句柄。</p><p>这边还存在一个问题，就是多标签的时候，自动切换标签的时候，浏览器会自动弹出来。这样子便有点烦人，毕竟我们只是想让他在后台自己跑， 所以，我加上了一个虚拟窗口，使用的是<code>pyvirtualdisplay</code>库。</p><p>以下是<code>pyvirtualdisplay</code>库在ubuntu中的安装步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pip install pyvirtualdisplay</div><div class="line">sudo apt install xvfb</div><div class="line">sudo apt install xserver-xephyr</div></pre></td></tr></table></figure></p><p>下面是<code>pyvirtualdisplay</code>具体的使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from pyvirtualdisplay import Display</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    display = Display(visible=1, size=(800, 600))</div><div class="line">    display.start()</div></pre></td></tr></table></figure></p><p>把虚拟窗口放在一开始处的位置即可。<br>也可以将visible改为0，浏览器就完全不可见了。</p><p>最后附上这个阶段的完整程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master/hdh_try_4.py" target="_blank" rel="external">github地址2</a></p><h2 id="改进二：验证码保存-面向对象编程"><a href="#改进二：验证码保存-面向对象编程" class="headerlink" title="改进二：验证码保存+面向对象编程"></a>改进二：验证码保存+面向对象编程</h2><p>验证码保存：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">code = self.driver.find_element_by_xpath(<span class="string">"//img[@alt='CAPTCHA']"</span>)</div><div class="line">        img = code.screenshot_as_png</div><div class="line">        img_name = <span class="string">"./code/code&#123;&#125;.png"</span>.format(time.strftime(<span class="string">'%Y-%m-%d_%H%M%S'</span>, time.localtime(time.time())))</div><div class="line">        <span class="keyword">with</span> open(img_name, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(img)</div><div class="line">        rec_code = self.code_recog(img_name)</div></pre></td></tr></table></figure></p><p>其中，验证码保存步骤使用了selenium自带的<em>元素截图</em>功能，而不是全屏截图。这边正是我从chrome浏览器改为firefox浏览器的真实原因。chrome浏览器中的元素截图不可用！会报错！故此选用firefox浏览器。</p><p>面向对象编程就是对函数使用了类，把多个函数合并到了同一个类中去。</p><p>完整程序在最后给出。</p><h2 id="改进三：使用pyqt获得验证码图片"><a href="#改进三：使用pyqt获得验证码图片" class="headerlink" title="改进三：使用pyqt获得验证码图片"></a>改进三：使用pyqt获得验证码图片</h2><p>思路是：从网页中解析到验证码的图片，然后下载到本地；接着使用pyqt弹出一个窗口，窗口中显示获取到的验证码，手动输入验证码后点击关闭。</p><p>简化了每次登录的流程，账号、密码记录在程序中自动输入，只需要手动输入验证码。</p><p>其中，基于pyqt5图形界面的窗口部分的程序如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># CodeRecognition.py</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets, QtGui</div><div class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeRecognition</span><span class="params">(QtWidgets.QWidget)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span></div><div class="line">        QtWidgets.QWidget.__init__(self, parent)</div><div class="line">        self.setWindowTitle(<span class="string">"请手动输入验证码"</span>)</div><div class="line">        self.resize(<span class="number">250</span>, <span class="number">150</span>)</div><div class="line">        self.center()</div><div class="line">        <span class="comment"># 界面初始化</span></div><div class="line">        self.code_edit = QLineEdit()</div><div class="line">        self.label_code = QtWidgets.QLabel()</div><div class="line">        self.init_interface()</div><div class="line">        self.img_path = <span class="string">'./image_3.png'</span></div><div class="line">        self.show_code_img()</div><div class="line">        <span class="comment"># 输出的识别码</span></div><div class="line">        self.out_code = <span class="string">'To_be_recognize'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_interface</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        label1 = QtWidgets.QLabel(<span class="string">'请输入验证码：'</span>, self)</div><div class="line">        label2 = QtWidgets.QLabel(<span class="string">'输入完成后点击关闭按钮即可。'</span>, self)</div><div class="line">        self.code_edit.setToolTip(<span class="string">'请输入验证码'</span>)</div><div class="line">        button2 = QtWidgets.QPushButton(<span class="string">'关闭'</span>, self)</div><div class="line"></div><div class="line">        grid = QGridLayout()</div><div class="line">        grid.setSpacing(<span class="number">0</span>)</div><div class="line"></div><div class="line">        grid.addWidget(self.label_code, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">        grid.addWidget(label1, <span class="number">1</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(self.code_edit, <span class="number">2</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(label2, <span class="number">3</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(button2, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 关闭窗口</span></div><div class="line">        button2.clicked.connect(self.close)</div><div class="line">        self.setLayout(grid)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 该语句用来计算出显示器的分辨率（screen.width, screen.height）</span></div><div class="line">        screen = QtWidgets.QDesktopWidget().screenGeometry()</div><div class="line">        size = self.geometry()</div><div class="line">        self.move((screen.width() - size.width()) / <span class="number">2</span>, (screen.height() - size.height()) / <span class="number">2</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_text</span><span class="params">(self)</span>:</span></div><div class="line">        self.out_code = self.code_edit.text()</div><div class="line">        <span class="comment"># print(self.out_code)</span></div><div class="line">        <span class="keyword">return</span> self.out_code</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_code_img</span><span class="params">(self)</span>:</span></div><div class="line">        img = QtGui.QPixmap(self.img_path)</div><div class="line">        self.label_code.setPixmap(img)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span></div><div class="line">        code = self.get_text()</div><div class="line">        <span class="keyword">if</span> len(code) &lt; <span class="number">4</span> <span class="keyword">or</span> len(code) &gt;= <span class="number">8</span>:</div><div class="line">            QtWidgets.QMessageBox.about(self, <span class="string">"验证码输入错误"</span>, <span class="string">"请注意：\n验证码一般为4-6位，请重新输入!"</span>)</div><div class="line">            event.ignore()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            event.accept()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    app = QtWidgets.QApplication(sys.argv)</div><div class="line">    center = CodeRecognition()</div><div class="line"></div><div class="line">    <span class="comment"># 改变输入的图片。</span></div><div class="line">    path = <span class="string">"image_2.png"</span></div><div class="line">    center.img_path = path</div><div class="line">    center.show_code_img()</div><div class="line"></div><div class="line">    center.show()</div><div class="line">    app.exec_()</div><div class="line">    rec_code = center.get_text()</div><div class="line">    print(<span class="string">"识别的验证码为："</span>, rec_code)</div></pre></td></tr></table></figure></p><p>之前学过qt的同学看起来应该不困难，没有学过qt<br>的同学想要入门的话建议查看官方文档或者小甲鱼论坛的<a href="http://bbs.fishc.com/forum.php?mod=collection&amp;action=view&amp;ctid=153" target="_blank" rel="external">pyqt连接</a>。</p><p>最后附上完整的程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master" target="_blank" rel="external">github地址3</a></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/09/HDHome_clawler_tutorial/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python-基础篇</title>
      <link>https://wangwlj.com/2017/11/27/python_base_NJU_1/</link>
      <guid>https://wangwlj.com/2017/11/27/python_base_NJU_1/</guid>
      <pubDate>Mon, 27 Nov 2017 09:14:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;python基础&quot;&gt;&lt;a href=&quot;#python基础&quot; class=&quot;headerlink&quot; title=&quot;python基础&quot;&gt;&lt;/a&gt;python基础&lt;/h1&gt;&lt;p&gt;本文是学习南京大学Python玩转数据基础篇的笔记整理。&lt;/p&gt;
&lt;h2 id=&quot;pytho
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><p>本文是学习南京大学Python玩转数据基础篇的笔记整理。</p><h2 id="python类型"><a href="#python类型" class="headerlink" title="python类型"></a>python类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ol><li>整型/长整型： 长度与机器有关。长整型：整型值后面加上L。</li><li>布尔型：True、False。</li><li>浮点型：数学中的实数。可以用科学计数法表示。 float</li><li>复数型：虚数部分用j。</li></ol><pre><code>x = 2.4+ 5jOut[9]: (2.4+5j)type(x)Out[10]: complex</code></pre><p>复数可以对实数和复数部分分离。imag、real。</p><p>复数的共轭：conjugate()</p><pre><code>x.realOut[11]: 2.4x.imagOut[12]: 5.0x.conjugate()Out[13]: (2.4-5j)</code></pre><h3 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h3><p>字符串，列表[]，元组()</p><p>字符串：<br>        三种表示方式：单引号，双引号，三引号。<br>        可以使用索引操作符。</p><h3 id="映设类型"><a href="#映设类型" class="headerlink" title="映设类型"></a>映设类型</h3><p>字典：<br>        大括号{}鉴别；<br>        类似于哈希表的键值对。</p><h2 id="python运算"><a href="#python运算" class="headerlink" title="python运算"></a>python运算</h2><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><pre><code>+ - × /取余 %乘方 **整除 //  ----地板除</code></pre><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><pre><code>数值的比较：按值的大小字符串的比较：按ASCII码值的大小</code></pre><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><pre><code>not and or</code></pre><h3 id="字符运算"><a href="#字符运算" class="headerlink" title="字符运算"></a>字符运算</h3><pre><code>r / R,  ---原始字符串u / U</code></pre><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><pre><code>&lt;左移 &gt;右移</code></pre><h2 id="函数、模块与包"><a href="#函数、模块与包" class="headerlink" title="函数、模块与包"></a>函数、模块与包</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数可以看成类似于数学中的函数。完成一个特定功能的一段代码。如绝对值函数<code>abs()</code>，类型函数<code>type()</code>，四舍五入函数<code>round()</code>。</p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>如何查看python中自带的内建函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dir(__builtins__)</div></pre></td></tr></table></figure></p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>非内建函数如何使用呢？</p><p>如floor()函数，不是内建函数，但包含在math的头文件中，因此只需要导入该模块即可，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div></pre></td></tr></table></figure></p><p>什么是模块？<br>模块就是一个完整的python文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">文件：物理上的组织方式：math.py</div><div class="line">模块：逻辑上的组织方式：math</div></pre></td></tr></table></figure></p><p>Python中通常用<code>import 模块</code>的方式将现成模块中的函数、类重用到其他代码块中。</p><p>可以导入多个模快。可以从模块中导入指定的模块属性（把指定的名称导入）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleName</div><div class="line"><span class="keyword">import</span> ModuleName1,ModuleName2,...</div><div class="line"><span class="keyword">from</span> Module1 <span class="keyword">import</span> ModuleElement</div></pre></td></tr></table></figure></p><h3 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h3><p>包是有层次的文件目录结构。</p><p>比如说如下的目录结构定义了一个由模块和子包组成的Python应用程序执行环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">AAA/</div><div class="line">    __init__.py</div><div class="line">    bbb.py</div><div class="line">    CCC/</div><div class="line">    __init__.py</div><div class="line">        c1.py</div><div class="line">        c2.py</div><div class="line">    DDD/</div><div class="line">    __init__.py</div><div class="line">        d1.py</div><div class="line">    EEE/</div><div class="line">    ...</div></pre></td></tr></table></figure></p><p>因此，我们可以这样使用该包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> AAA.CCC.c1</div><div class="line">AAA.CCC.c1.func1(<span class="number">123</span>)</div></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> AAA.CCC.c1 <span class="keyword">import</span> func1</div><div class="line">func1(<span class="number">123</span>)</div></pre></td></tr></table></figure></p><h3 id="库（library）"><a href="#库（library）" class="headerlink" title="库（library）"></a>库（library）</h3><p>库是一组具有相关功能的模块的集合。<br>Python的一大特色就是具有强大的标准库、以及第三方库、以及自定义的模块。</p><h2 id="条件、循环与中断语句"><a href="#条件、循环与中断语句" class="headerlink" title="条件、循环与中断语句"></a>条件、循环与中断语句</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>if语句<br>else语句<br>elif语句：多分支情况下使用</p><p>其中，条件语句可以嵌套使用。</p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for iter_var in interable_object:</div><div class="line">    suite_to_repeat</div></pre></td></tr></table></figure><p>可以明确循环的次数，一般用在：</p><ul><li>遍历一个数据集的成员</li><li><p>在列表解析中使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">in</span>[<span class="number">4</span>]: [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</div><div class="line">Out[<span class="number">4</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div><div class="line"><span class="keyword">in</span>[<span class="number">5</span>]: [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)<span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</div><div class="line">Out[<span class="number">5</span>]: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure></li><li><p>在生成器表达式中使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">in</span>[<span class="number">6</span>]: (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)<span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>)</div><div class="line">Out[<span class="number">6</span>]: &lt;generator object &lt;genexpr&gt; at <span class="number">0x7f44af56f570</span>&gt;</div></pre></td></tr></table></figure></li></ul><p>可用于迭代的对象（iterable object）有：String、 List、Tuple、Dictionary、File。</p><h3 id="range语句"><a href="#range语句" class="headerlink" title="range语句"></a>range语句</h3><p>一般与for语句配合使用。</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while expression:</div><div class="line">suitr_to_repeat</div></pre></td></tr></table></figure></p><p>其中，expression是条件表达式，当expression的值为    True的时候，执行suitr_to_repeat的代码块。</p><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>while循环中的break与for循环中的break。</p><h3 id="循环中的else语句"><a href="#循环中的else语句" class="headerlink" title="循环中的else语句"></a>循环中的else语句</h3><p>循环中的else：<br>如果是正常结束，就执行else中的代码；break处中止，就不执行else。</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h3 id="自定义函数的创建："><a href="#自定义函数的创建：" class="headerlink" title="自定义函数的创建："></a>自定义函数的创建：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def function_name([arguments]):</div><div class="line">    &quot;optional documentation string&quot;</div><div class="line">    function_suite</div></pre></td></tr></table></figure><p>其中，def下一行可以是函数文档。～～～～～要学会使用函数文档！！</p><h3 id="自定义函数的调用"><a href="#自定义函数的调用" class="headerlink" title="自定义函数的调用"></a>自定义函数的调用</h3><p>函数名加上函数运算符，一对小括号。</p><p>括号之间是所有可选的参数，即使没有参数，小括号也不能省略。</p><p>参数问题，有参数就必须加上去。除非有默认值的可以不需要。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>函数的参数可以有一个默认值，如果提供有默认值，在函数定义中，默认参数以赋值语句的形式提供。</p><p>默认参数的值可以改变。</p><p>默认参数一般需要放置在参数列表的最后。默认参数后面不能有非默认参数。</p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数是让调用者通过使用参数名区分参数。允许你改变参数列表中的参数顺序。</p><h3 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h3><p>函数可以像参数一样传递给另外一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def addMe2Me(x):</div><div class="line">    return (x+x)</div><div class="line">def self(f,y):</div><div class="line">    print f(y)</div><div class="line"></div><div class="line">&gt;&gt;&gt; self(addMe2Me,2.2)</div><div class="line">4.4</div></pre></td></tr></table></figure></p><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>匿名函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 普通的函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_add</span><span class="params">(x,y)</span>:</span> <span class="keyword">return</span> x+y</div><div class="line"><span class="comment"># 匿名函数</span></div><div class="line"><span class="keyword">lambda</span> x, y : x + y</div><div class="line">my_add = <span class="keyword">lambda</span> x, y : x + y</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_add(<span class="number">3</span>,<span class="number">5</span>)</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>函数内部就是局部变量。</p><p>函数内部可以调用全局变量，使用<code>global</code>语句。</p><p>当全局变量和局部变量使用的是同一个名字时，内层会屏蔽外层。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归介绍"><a href="#递归介绍" class="headerlink" title="递归介绍"></a>递归介绍</h3><p>递归必须有边界条件，即停止递归的条件。 如n==0 或者n==1的情况。</p><p>递归的代码更简洁，更符合自然逻辑，更容易理解。</p><p>递归的执行方式：逐层递归调用，遇到边界条件停止递归，逐层返回调用至最初层，系统资源的消耗比循环大。</p><h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Filename: Hanoi.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span><span class="params">(a, b, c, n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">        print(a, <span class="string">'-&gt;'</span>, c)</div><div class="line"></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        hanoi(a, c, b, n - <span class="number">1</span>)</div><div class="line">        print(a, <span class="string">'-&gt;'</span>, c)</div><div class="line">        hanoi(b, a, c, n - <span class="number">1</span>)</div><div class="line"></div><div class="line"></div><div class="line">hanoi(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a -&gt; c</div><div class="line">a -&gt; b</div><div class="line">c -&gt; b</div><div class="line">a -&gt; c</div><div class="line">b -&gt; a</div><div class="line">b -&gt; c</div><div class="line">a -&gt; c</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/11/27/python_base_NJU_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>DeepLab简介及其pytorch实现</title>
      <link>https://wangwlj.com/2017/11/23/Torch_DeepLab/</link>
      <guid>https://wangwlj.com/2017/11/23/Torch_DeepLab/</guid>
      <pubDate>Thu, 23 Nov 2017 14:48:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;pytorch实现DeepLab&quot;&gt;&lt;a href=&quot;#pytorch实现DeepLab&quot; class=&quot;headerlink&quot; title=&quot;pytorch实现DeepLab&quot;&gt;&lt;/a&gt;pytorch实现DeepLab&lt;/h1&gt;&lt;p&gt;使用pytorch搭建Dee
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="pytorch实现DeepLab"><a href="#pytorch实现DeepLab" class="headerlink" title="pytorch实现DeepLab"></a>pytorch实现DeepLab</h1><p>使用pytorch搭建DeepLab。</p><h2 id="DeepLab简介"><a href="#DeepLab简介" class="headerlink" title="DeepLab简介"></a>DeepLab简介</h2><p>DeepLab文章的下载地址：<a href="https://arxiv.org/abs/1606.00915" target="_blank" rel="external">https://arxiv.org/abs/1606.00915</a></p><p>该文章的主要思想之一：<br>提出了Atrous convolution（带孔卷积）。<br>扩大视野但不增加计算量。</p><p>所谓的带孔卷积，就是在卷积核之间加上0。rate参数为2（torch中对应的参数为dilation）的示意图如下<br><img src="/2017/11/23/Torch_DeepLab/2.png" alt="Atrous convolution(rate=2)" title="Atrous convolution(rate=2)"></p><p>rate = 2就是在原卷积核相邻两个元素之间补上一个0，假设原卷积核为3x3，rate = 2的带孔卷积核的大小就为<code>3+(3-1) × (rate-1)=5</code>。</p><p>下图是不同rate的带孔卷积。</p><p><img src="/2017/11/23/Torch_DeepLab/different_rate.png" alt="different_rate"></p><p>以<code>rate = 12</code> 为例，带孔卷积的核的大小为：<code>3+(3-1)x(12-1)=25</code>，即新卷积核的大小为：<code>25*25</code>。</p><p>总的来说，对于<code>rate=r</code>的带孔卷积，在连接着的卷积核元素间插入<code>r-1</code>个元素。因此，扩展后的卷积核大小为$k_{new}=k+(k-1)(r-1)$。</p><h2 id="pytorch实现deeplab"><a href="#pytorch实现deeplab" class="headerlink" title="pytorch实现deeplab"></a>pytorch实现deeplab</h2><p>笔者主要目的是实现一下不同视野的concat过程。</p><p>在torch中，卷积函数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</div><div class="line">nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, groups=<span class="number">1</span>, bias=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p><p>其中的dilation参数就是带孔卷积的参数（也就是tensorFlow下的rate），默认情况下为1，就是普通的卷积，所以带孔卷积只需要修改这个参数就可以了。</p><p>比如说，我们已经写好了不同的视野下的卷积，然后需要将他们的feature map叠加起来，torch中使用<code>torch.cat(inputs, dimension=0)</code>函数来进行叠加。torch的参数一般是四个维度的：<code>[n_batch_size, n_feature_map, height, weight]</code>，所以参数中的<code>dimension = 1</code>就是对<code>feature map</code>叠加。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = torch.cat([x2, x3, x4, x5], dim=<span class="number">1</span>)</div></pre></td></tr></table></figure><p>叠加的这一步非常容易出错，原因在于，要求叠加的所有图片大小是一样的。而视野不同导致的卷积核的大小不同，也会导致最终输出的图像大小的变化，因此，需要恰当的调整zero-padding的数目来使得最终输出图像的大小保持一致。</p><p>另外稍微提一下，全连接层的输入向量大小的确定方法。全连接层是将上一步所得到的图像reshape为一个一维的向量之后，作为它的输入，因此，输入向量的长度为： <code>in_channels = nFeatureMap * height * weight</code>。</p><p>网络整体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(Net, self).__init__()</div><div class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">1</span>)</div><div class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">1</span>)</div><div class="line">        self.conv2_drop = nn.Dropout2d() </div><div class="line">        self.fc1 = nn.Linear(<span class="number">40</span> * <span class="number">4</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">50</span>) </div><div class="line">        self.fc2 = nn.Linear(<span class="number">50</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line">        self.conv_rate_1 = nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">2</span>, padding=<span class="number">2</span>) </div><div class="line">        self.conv_rate_2 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">3</span>, padding=<span class="number">3</span>) </div><div class="line">        self.conv_rate_3 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">4</span>, padding=<span class="number">4</span>)</div><div class="line">        self.conv_rate_4 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">5</span>, padding=<span class="number">5</span>)</div><div class="line">        self.conv_rate_5 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></div><div class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), <span class="number">2</span>)</div><div class="line">        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), <span class="number">2</span>))</div><div class="line">        x = self.conv_rate_1(x)</div><div class="line">        x2 = self.conv_rate_2(x)</div><div class="line">        x3 = self.conv_rate_3(x)</div><div class="line">        x4 = self.conv_rate_4(x)</div><div class="line">        x5 = self.conv_rate_5(x)</div><div class="line">        <span class="comment"># print(x.data.shape)</span></div><div class="line">        <span class="comment"># print(x2.data.shape)</span></div><div class="line">        <span class="comment"># print(x3.data.shape)</span></div><div class="line">        <span class="comment"># print(x4.data.shape)</span></div><div class="line">        <span class="comment"># print(x5.data.shape)</span></div><div class="line">        x = torch.cat([x2, x3, x4, x5], dim=<span class="number">1</span>)</div><div class="line"></div><div class="line">        <span class="comment"># for FC</span></div><div class="line">        x = x.view(<span class="number">-1</span>, self.num_flat_features(x))  <span class="comment"># origin is 320</span></div><div class="line">        x = F.relu(self.fc1(x))  <span class="comment"># fc-&gt;relu</span></div><div class="line">        x = F.dropout(x, training=self.training)  <span class="comment"># dropout</span></div><div class="line">        x = self.fc2(x)</div><div class="line">        <span class="keyword">return</span> F.log_softmax(x)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_flat_features</span><span class="params">(self, x)</span>:</span></div><div class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># all dimensions except the batch dimension</span></div><div class="line">        num_features = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</div><div class="line">            num_features *= s</div><div class="line">        <span class="keyword">return</span> num_features</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/11/23/Torch_DeepLab/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深度学习第七章：深度学习中的正则化</title>
      <link>https://wangwlj.com/2017/10/22/DL_chap_7/</link>
      <guid>https://wangwlj.com/2017/10/22/DL_chap_7/</guid>
      <pubDate>Sun, 22 Oct 2017 11:19:39 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;7-1-参数范式惩罚&quot;&gt;&lt;a href=&quot;#7-1-参数范式惩罚&quot; class=&quot;headerlink&quot; title=&quot;7.1 参数范式惩罚&quot;&gt;&lt;/a&gt;7.1 参数范式惩罚&lt;/h2&gt;&lt;p&gt;对目标模型J添加一个参数范数惩罚$\Omega (\theta)$，限制模型
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="7-1-参数范式惩罚"><a href="#7-1-参数范式惩罚" class="headerlink" title="7.1 参数范式惩罚"></a>7.1 参数范式惩罚</h2><p>对目标模型J添加一个参数范数惩罚$\Omega (\theta)$，限制模型 的学习能力。正则化后的目标函数记为：<br>$$\tilde{J}(\theta ;X,y) = J(\theta ;X,y) +\alpha \Omega (\theta)$$</p><p>我们通常只对权重做惩罚而不对偏置做正则惩罚。</p><p>神经网络情况下，有时候希望对网络的每一层使用单独的惩罚，并分配不同的$\alpha$系数。寻找合适的多个超参数的代价很大，因此为了减少搜索空间，我们会在所以层使用相同的权重衰减。</p><p>符号约束说明：向量$w$表示所有应受范数惩罚影响的权重，而向量$\theta$表示所有参数（包括w和无须正则化的参数）。</p><h3 id="7-1-1-L-2-参数正则化"><a href="#7-1-1-L-2-参数正则化" class="headerlink" title="7.1.1 $L^2$参数正则化"></a>7.1.1 $L^2$参数正则化</h3><p><em>5.2节</em>中已经见过最简单的、最常见的$L^2$参数范数惩罚。其正则项为：<br>$$\Omega (\theta) = \frac 12 ||w||^2_2$$</p><p>令$w^\ast $为未正则化的目标函数取得最小训练误差时的权重向量，即$w^\ast =\text {argmin}_w J(w)$，并在$w^\ast $的邻域对目标函数做<strong>二次近似</strong>。</p><p>近似的$\hat J (\theta)$如下：</p><p>$$\hat J (\theta) = J (w^\ast) + \frac 12 (w-w^\ast)^TH(w-w^\ast) $$</p><p>其中，$H$是$J$在$w^\ast $处计算的Hessian矩阵（关于$w$）。因为$w^\ast $被定义为最优，所以该二次近似中<strong>没有一阶项</strong>。同样地，因为$w^\ast $是$J$的一个最优点，可以得出$H$是<strong>半正定</strong>。</p><h3 id="7-1-2-L-1-正则化"><a href="#7-1-2-L-1-正则化" class="headerlink" title="7.1.2 $L^1$正则化"></a>7.1.2 $L^1$正则化</h3><h2 id="7-2-作为约束的范数惩罚"><a href="#7-2-作为约束的范数惩罚" class="headerlink" title="7.2 作为约束的范数惩罚"></a>7.2 作为约束的范数惩罚</h2><h2 id="7-3-正则化和欠约束问题"><a href="#7-3-正则化和欠约束问题" class="headerlink" title="7.3 正则化和欠约束问题"></a>7.3 正则化和欠约束问题</h2><h2 id="7-4-数据集增强"><a href="#7-4-数据集增强" class="headerlink" title="7.4 数据集增强"></a>7.4 数据集增强</h2><p>使用更多的数据进行训练。</p><p>创建假数据并添加到训练集中。</p><p>图像：沿着训练图像每个方向平移几个像素。旋转。缩放。</p><p>数据集增强对语音识别也是有效的。</p><p>网络输入层注入噪声，</p><p>算法性能对比时，应确保算法使用同一 人工设计的数据集增强方案。</p><h2 id="7-5-噪声鲁棒性"><a href="#7-5-噪声鲁棒性" class="headerlink" title="7.5 噪声鲁棒性"></a>7.5 噪声鲁棒性</h2><h2 id="7-6-半监督学习"><a href="#7-6-半监督学习" class="headerlink" title="7.6 半监督学习"></a>7.6 半监督学习</h2><p>在半监督学习的框架下，$P(x)$产生的未标记样本和$P(x,y)$中的标记样本都用于估计$P(y|x)$或者根据x预测y。</p><p>半监督学习通常是学习一个表示：$h=f(x)$。学习表示的目的是<strong>使相同类的样本有类似的表示</strong>。</p><p>无监督学习可以为如何在空间聚集样本提供有用的线索。</p><p>模型的构建：生成模型$P(x)$或$P(x,y)$与判别模型$P(y|x)$共享参数，而不用分离无监督和监督部分。<br>权衡监督模型准则$-\text{log}P(y|x)$和无监督(或生成)模型准则$-\text{log}P(x)$或$-\text{log}P(x,y)$。</p><p>生成模型准则表达了对 监督学习问题的特殊形式的先验知识，即$P(x)$的结构通过某种共享参宿的方式连接到$P(y|x)$。</p><h2 id="7-7-多任务学习"><a href="#7-7-多任务学习" class="headerlink" title="7.7 多任务学习"></a>7.7 多任务学习</h2><h2 id="7-8-提前终止"><a href="#7-8-提前终止" class="headerlink" title="7.8 提前终止"></a>7.8 提前终止</h2><p>在训练有足够表示能力甚至会过拟合的大模型时，经常会出现：训练误差随着时间推移逐渐降低但验证集的误差会再次上升。</p><p>此时，我们只需要返回验证集误差最低的参数设置。</p><p>在每次验证集误差有所改善时，我们存储模型参数的副本。当验证集的误差在事先指定的循环次数内没有进一步改善时，算法就会终止。</p><p>这就是提前终止（early stopping）。</p><p>两个代价：一是训练步数作为超参数，训练期间需要定期评估验证集。而是需要保持最佳的参数副本。</p><p>提前终止是一个不显眼的正则化形式。</p><p>提前终止需要验证集，意味着一部分训练数据不能馈送到模型。<br>为了更好地利用这部分数据，可以在提前终止的首次训练后，进行额外的训练。在第二轮（额外的）训练中，所有的训练数据都被包括在内。</p><p>未完待续。</p><h2 id="7-9-参数绑定和参数共享"><a href="#7-9-参数绑定和参数共享" class="headerlink" title="7.9 参数绑定和参数共享"></a>7.9 参数绑定和参数共享</h2><h2 id="7-10-稀疏表示"><a href="#7-10-稀疏表示" class="headerlink" title="7.10 稀疏表示"></a>7.10 稀疏表示</h2><h2 id="7-13-Bagging和其他集成方法"><a href="#7-13-Bagging和其他集成方法" class="headerlink" title="7.13 Bagging和其他集成方法"></a>7.13 Bagging和其他集成方法</h2><p>Bagging(bootstrap aggregating)是通过结合几个模型降低泛化误差的技术。</p><p>主要想法是分别训练几个不同的模型，然后让所有模型表决测试样例的输出。</p><p>这是机器学习的一项常规策略，被称为：<strong>模型平均</strong>（model averaging）。采用这种策略的技术被称为：<strong>集成方法</strong>。</p><h2 id="7-12-Dropout"><a href="#7-12-Dropout" class="headerlink" title="7.12 Dropout"></a>7.12 Dropout</h2><h2 id="7-13-对抗训练"><a href="#7-13-对抗训练" class="headerlink" title="7.13 对抗训练"></a>7.13 对抗训练</h2><h2 id="7-14-切面距离、正切传播和流形正切分类器"><a href="#7-14-切面距离、正切传播和流形正切分类器" class="headerlink" title="7.14 切面距离、正切传播和流形正切分类器"></a>7.14 切面距离、正切传播和流形正切分类器</h2>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/10/22/DL_chap_7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深度学习第九章：卷机网络</title>
      <link>https://wangwlj.com/2017/10/20/DL_chap_9/</link>
      <guid>https://wangwlj.com/2017/10/20/DL_chap_9/</guid>
      <pubDate>Fri, 20 Oct 2017 02:43:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;9-1-卷积运算&quot;&gt;&lt;a href=&quot;#9-1-卷积运算&quot; class=&quot;headerlink&quot; title=&quot;9.1 卷积运算&quot;&gt;&lt;/a&gt;9.1 卷积运算&lt;/h2&gt;&lt;p&gt;卷积的第一个参数： 输入，第二个参数： 核函数。输出有时被称为特征映射。&lt;/p&gt;
&lt;p&gt;对于
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="9-1-卷积运算"><a href="#9-1-卷积运算" class="headerlink" title="9.1 卷积运算"></a>9.1 卷积运算</h2><p>卷积的第一个参数： 输入，第二个参数： 核函数。输出有时被称为特征映射。</p><p>对于二维图像I，二维的核K。卷积可以写为：</p><p>$$S(i,j) = (I\times K )(i,j) = \sum_m \sum_n I(m,n)K(i-m,j-n)$$</p><p>卷积是可交换的。可以等价地写为：</p><p>$$S(i,j) = (K\times I )(i,j) = \sum_m \sum_n I(i-m,j-n)K(m,n)$$</p><p>卷积运算可交换性的出现时因为我们将核相对输入进行了<strong>翻转</strong>(flip)，从m增大的角度来看，输入的索引在增大，但是核的索引在减小。</p><p>互相关函数。和卷积一样，但是没有对核翻转</p><p>$$S(i,j) = (I\times K )(i,j) = \sum_m \sum_n I(i+m,j+n)K(m,n)$$</p><h2 id="9-2-动机"><a href="#9-2-动机" class="headerlink" title="9.2 动机"></a>9.2 动机</h2><p>卷积运算的三个重要思想：</p><p>参数共享–绑定的权重。在一个模型的多个函数中使用相同的参数。</p><p>平移等变–输入改变，输出也以同样的方式改变。</p><h2 id="9-3-池化"><a href="#9-3-池化" class="headerlink" title="9.3 池化"></a>9.3 池化</h2><p>池化函数：使用某一位置的相邻输出的总体统计特征来代替网络在该位置的输出。</p><p>最大池化函数（Max pooling）：相邻矩形区域内的最大值</p><p>其他常用的池化函数：相邻区域内的平均值，L2范数，基于距中心像素位置的加权平均函数。</p><p>局部平移不变性。</p><p>池化综合了全部邻居的反馈，这使得<strong>池化单元少于探测单元</strong>成为可能，我们可以通过综合池化区域的<strong>k个像素</strong>的统计特征而不是单个像素来实现。这种方式提高了网络的计算效率，因为<strong>下一层少了约k倍的输入</strong>。（downsampling）</p><h2 id="9-4-卷积与池化作为一种无限强的先验"><a href="#9-4-卷积与池化作为一种无限强的先验" class="headerlink" title="9.4 卷积与池化作为一种无限强的先验"></a>9.4 卷积与池化作为一种无限强的先验</h2><p>先验概率分布（第5.2节）。弱先验具有较高的熵值，强先验具有较低的熵值。</p><p>一个<strong>无限强的先验</strong>需要对一些参数的概率置零并且完全禁止对这些参数赋值。</p><p>可以把<strong>卷机网络</strong>类比为全连接网络，但对于这个全连接网络的权重有一个无限强的先验。这个无限强的先验是说一个隐藏单元的权重必须和它邻居的权重相同，但可以在空间上移动。这个先验也要求除了那些处在隐藏单元的小的空间连续的接受域内的权重以外，其余的权重为零。 </p><p>类似地，使用<strong>池化</strong>也是一个无限强的先验：每个单元都具有对少量平移的不变性。</p><p><strong>卷积和池化可能导致欠拟合</strong>。</p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/10/20/DL_chap_9/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
