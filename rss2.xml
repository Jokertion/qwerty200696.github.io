<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>wangwlj&#39;s Blog</title>
    <link>http://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Thu, 01 Feb 2018 15:29:32 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>摄影 | 152年一遇的月全食</title>
      <link>http://wangwlj.com/2018/02/01/photo_total_lunar_eclipse/</link>
      <guid>http://wangwlj.com/2018/02/01/photo_total_lunar_eclipse/</guid>
      <pubDate>Thu, 01 Feb 2018 15:06:31 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/large/c38a0784gy1fo1cdvwz8dj22ch26j1kz.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ws1.sinaimg.cn/large/c38a0784gy1fo1cdvwz8dj22ch26j1kz.jpg" alt="image"></p><a id="more"></a><p>2018年01月31日晚上（也就是昨天）的月全食据说是152年一遇的月全食。</p><p>大概是今天看到了如下这张图片之后，想着自己也可以弄一张类似的照片。<br><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=efca4ecac9177f3e0439f45f11a650a2/0bd162d9f2d3572c2fdd40a08a13632762d0c38b.jpg" alt=""></p><p>于是便有了封面图的诞生。</p><p>这应该是第三次拍摄月亮了。</p><p>第一次是一个偶然的白天，晴空万里，一抬头居然发现了月亮。<br><img src="http://wx1.sinaimg.cn/large/c38a0784gy1fo1d5e3r4nj20ku0z3gmd.jpg" alt="image"></p><p>第二次，是2016年11月14日出现了超级大月亮，当时也拍摄了几张照片，顺便也附带上。<br><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fo1cuub8wgj20vq0lqjru.jpg" alt="image"><br><img src="http://ws2.sinaimg.cn/large/c38a0784gy1fo1cv4h6eej20zk0mewex.jpg" alt="image"></p><p>第三次就是昨天晚上的月全食啦。<br>就以封面图结束吧。以后等照片多了，说不定就弄个照片墙～</p><p><img src="http://ws1.sinaimg.cn/large/c38a0784gy1fo1cdvwz8dj22ch26j1kz.jpg" alt="image"></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/02/01/photo_total_lunar_eclipse/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(9) 第十一章 散列表</title>
      <link>http://wangwlj.com/2018/01/30/algorithm_tutorial_chapter_11/</link>
      <guid>http://wangwlj.com/2018/01/30/algorithm_tutorial_chapter_11/</guid>
      <pubDate>Tue, 30 Jan 2018 14:39:47 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ws1.sinaimg.cn/mw690/c38a0784ly1fnxit86pfwj211y0lc7of.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ws1.sinaimg.cn/mw690/c38a0784ly1fnxit86pfwj211y0lc7of.jpg" alt=""></p><a id="more"></a><p>直接寻址表(<code>direct-address table</code>)缺点：如果全域U很大，分配直接寻址表T也不太现实；另一方面，实际存储的关键字集合<code>K</code>相对于<code>U</code>来说可能很小，导致浪费空间。</p><h2 id="散列表综述"><a href="#散列表综述" class="headerlink" title="散列表综述"></a>散列表综述</h2><p>散列表（<code>hash table</code>，也叫哈希表），支持<code>INSERT</code>、<code>SEARCH</code>、<code>DELETE</code>操作。</p><p>散列表可以使得在表小的情况下仍能够保存数据，并且能够在常数时间<code>O(1)</code>内完成查询。为什么是常数时间呢？因为我们不需要比较，不需要遍历查找，只要计算出地址，有待查询的值那么就找到了；没有，那么表中就不存在。</p><p>把关键字<code>k</code>映射到槽<code>h(k)</code>上的过程称为散列。<code>h</code>表示散列函数(<code>hash function</code>)，由关键字k计算出槽(<code>slot</code>)的位置。</p><p>多个关键字映射到同一个数组下标位置(槽)称为碰撞（或冲突，<code>collision</code>）。</p><p>好的散列函数应使每个关键字都等可能地散列到m个槽位中。</p><h3 id="链接法解决冲突"><a href="#链接法解决冲突" class="headerlink" title="链接法解决冲突"></a>链接法解决冲突</h3><p>链接法：把散列到同一个槽的所有元素都放在一个链表中。槽中存放指向该槽的所有元素的链表的表头；如果不存在这样的元素，则槽中为<code>NIL</code>。</p><h3 id="链接法散列的分析"><a href="#链接法散列的分析" class="headerlink" title="链接法散列的分析"></a>链接法散列的分析</h3><p>一个存放n个元素的、具有m个槽位的散列表T，其<strong>装载因子</strong>(<code>load factor</code>)为：$\alpha = \frac nm$，表示一个链的平均存储元素数。</p><p>简单均匀散列(<code>simple uniform hashing</code>)：一个给定元素，等可能地散列到m个槽位中的任意一个上，且与其他元素被散列到什么位置无关。</p><blockquote><p>在简单均匀散列的假设下，对于用链接法解决冲突的散列表，一次不成功查找的平均时间为$\Theta(1+\alpha)$，一次成功查找所需的平均时间也为$\Theta(1+\alpha)$</p></blockquote><p>当散列表的槽数与表中元素个数成正比，则有$n= \text{O}(m)$，查找需要常数时间$n= \text{O}(m)$。当链表为双向链表时，插入和删除的最坏情况也是$n= \text{O}(1)$。</p><h2 id="Hash函数（11-3，P147）"><a href="#Hash函数（11-3，P147）" class="headerlink" title="Hash函数（11.3，P147）"></a>Hash函数（11.3，P147）</h2><p>我们如何设计一个好的Hash函数（哈希函数，散列函数）？本节介绍了三种设计哈希函数的方法：除法散列、乘法散列和全域散列。</p><h3 id="好的哈希函数的特点"><a href="#好的哈希函数的特点" class="headerlink" title="好的哈希函数的特点"></a>好的哈希函数的特点</h3><p>这里有两个要点：</p><p>一个好的哈希函数应该能够将关键字均匀的分配到哈希表T中；</p><p>而关键字的分布率不应该影响这种均匀性。</p><h3 id="除法散列法"><a href="#除法散列法" class="headerlink" title="除法散列法"></a>除法散列法</h3><p>定义<code>hash</code>函数为 $h(k) = k \;\text{mod}\; m$</p><p><code>m</code>取值的原则就是<code>m</code>选为质数且不能太接近<code>2</code>或者<code>10</code>的幂次。</p><p>原因：键值的低位可能具有某种分布规律，如果选择<code>2</code>或者<code>10</code>的幂次容易出现冲突。比如$2^r$，关键字只会考虑二进制的低<code>r</code>位；十进制类似。</p><h3 id="乘法散列法"><a href="#乘法散列法" class="headerlink" title="乘法散列法"></a>乘法散列法</h3><p>乘法散列法：公式为：$h(k) = m(kA\; \text{mod}\; 1) $</p><p>其中，$0&lt;A&lt;1$。</p><p>一般的实现方法如下：假设计算机字长是<code>w</code>位，限制A是形如$A =\frac {s}{2^w}$的分数，整数<code>s</code>取值范围为$0&lt; s &lt;2^w $。用整数$s=A\cdot 2^w$乘上<code>k</code>，其结果是2w位的值$r_1 2^w + r_0 $</p><p>A的取值理想情况为$ A \approx \sqrt 5-1 = 0.6180339887\cdots $。（这不就是黄金分割率么……）根据A的取值计算s的值。</p><p>乘法散列法的优点是<code>m</code>的取值不是很关键，一般取为<code>m=2^r</code>。</p><h3 id="11-3-4"><a href="#11-3-4" class="headerlink" title="11.3-4"></a>11.3-4</h3><p>考虑一个大小为<code>m=1000</code>的散列表和一个对应的散列函数<code>h(k)=m(kAmod1)</code>,其中<code>A=(√5-1)/2</code>,试计算关键字61,62,63,64和65被映射到位置。</p><p>直接根据公式计算，实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;  </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"><span class="keyword">const</span> <span class="keyword">double</span> A=(<span class="built_in">sqrt</span>(<span class="number">5</span>)<span class="number">-1</span>)/<span class="number">2.0</span>;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> m)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">double</span> x=(A*k-(<span class="keyword">int</span>)(A*k))*m;  </div><div class="line">    <span class="keyword">return</span> x;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">   <span class="keyword">int</span> k;  </div><div class="line">   <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;k)  </div><div class="line">   &#123;  </div><div class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hash["</span>&lt;&lt;k&lt;&lt;<span class="string">"]="</span>&lt;&lt;hash(k,<span class="number">1000</span>)&lt;&lt;<span class="built_in">endl</span>;  </div><div class="line">   &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><p>开放寻址法是另一种解决冲突的方法。</p><p>开放寻址法的特点：装载因子不会超过1；不用指针就可以计算出槽的序列。</p><p>插入元素的过程叫做探查(<code>probe</code>)：连续地检查散列表，直到找到一个空槽来放置待插入的关键字为止。检查顺序依赖于待插入的关键字</p><p>开放寻址法的散列函数有第二个参数：探查序号。</p><p>插入元素的伪码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">HASH-INSERT(T,k)</div><div class="line">i = 0</div><div class="line">    repeat</div><div class="line">    j = h(k, i)</div><div class="line">        if T[j] = NIL</div><div class="line">        T[j] = k </div><div class="line">            return j</div><div class="line">        else i = i + 1</div><div class="line">    util i == m</div><div class="line">    error &quot;hash table overflow&quot;</div></pre></td></tr></table></figure></p><p>查找元素的伪码：（由于是依次插入，因此可以依次查找；有个前提：关键字不会被删除）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HASH-SEARCH(T,k)</div><div class="line">i = 0</div><div class="line">    repeat</div><div class="line">    j = h(k, i)</div><div class="line">        if T[j] = K </div><div class="line">            return j</div><div class="line">        else i = i + 1</div><div class="line">    util T[j] == NIl or i == m</div><div class="line">    return NIL</div></pre></td></tr></table></figure></p><p>在开放寻址法中，删除操作比较困难，但也有解决办法，在必须删除关键字的应用中，往往采用链接法解决碰撞。</p><h3 id="三种探查技术"><a href="#三种探查技术" class="headerlink" title="三种探查技术"></a>三种探查技术</h3><p>三种探查技术来计算探查序列：</p><p>1)线性探查：<br>$$h(k,i)=(h’(k)+i)\text{mod}\; m,\; i=0,1,\cdots,m-1$$<br>线性探查存在问题：一次群集(primary clustering)。</p><p>2)二次探查：<br>$$h(k,i)=(h’(k)+c_1i+c_2i^2)\text{mod}\; m, \; i=0,1,\cdots,m-1$$<br>二次探查存在问题：二次群集(secondary clustering)。二次探查与线性探查都是初始位置决定了探查序列，且只有m个探查序列被使用到。</p><p>3)双重探查：<br>$$h(k,i)=(h_1(k)+ih_2(k))\text{mod}\; m, \; i=0,1,\cdots,m-1 $$<br>双重探查要求值$h_2(k)$与表的大小<code>m</code>互素。一种简便的方法是：<code>m</code>取<code>2</code>的幂，$h_2(k)$只产生奇数；或者m为素数，h2总是返回比m小的正整数。</p><p>由于每一对可能的$ (h_1(k), h_2(k))$都会产生一个不同的探查序列，因此双重散列法用到了$\Theta(m^2) $种探查序列。</p><p>双重散列的例子：<br>$$h_1(k) = k \;\text{mod}\; m ,\;h_2(k) = 1+(k\; \text{mod} \;m’) $$<br>取m为素数，$m’ $略小于m（比如，m-1）</p><h3 id="开放寻址散列的分析："><a href="#开放寻址散列的分析：" class="headerlink" title="开放寻址散列的分析："></a>开放寻址散列的分析：</h3><blockquote><p>定理11.6 给定一个装载因子<code>a=n/m&lt;1</code>的开放寻址散列表，假设散列是均匀的，在一次不成功的查找中，期望的探查数至多为<code>1/(1-a)</code>.。</p></blockquote><p>不成功的查找即：最后一次查找为<code>NIL</code>，且前面的<code>Hash table</code>查找都是被占用但是不包含所查的关键字。因此，可以推论插入的期望值，即：插入前需要做一次不成功的查找。</p><blockquote><p>推论11.7 均匀散列，平均情况下，向一个装载因子为a的开放寻址散列表中插入一个元素时，至多需要做<code>1/(1-a)</code>次探查。</p></blockquote><p>查找的过程和插入类似，假设待查找的关键字k的插入位置为i，则，根据推论11.7，有探查的期望次数至多为$1/(1-i/m) = m/(m - i)$。对散列表的所有n个关键字求平均，则得到一次成功查找的探查期望次数：<br>$$\begin{align}<br>\frac 1 n \sum_{i = 0}^{n-1} \frac {m}{m-i}<br>&amp; = \frac mn \sum_{i = 0}^{n-1}\frac {1}{m-i} =\frac 1\alpha \sum_{k = m-n+1}^{n} \frac 1k \leqslant\frac 1 \alpha \int_{m-n}^{m}\frac 1x dx\\<br>&amp; =\frac 1\alpha ln \frac m{m-n} = \frac 1a ln\frac1{1-a}<br>\end{align}$$</p><p>因此得到定理11.8：</p><blockquote><p>定理11.8 给定一个装载因子为<code>a&lt;1</code>的开放寻址散列表，假设散列是均匀的，一次成功查找中的期望探查数至多为<code>(1/a)ln(1/(1-a))</code>.</p></blockquote><h3 id="11-4-1"><a href="#11-4-1" class="headerlink" title="11.4-1"></a>11.4-1</h3><p>考虑将关键字10,22,31,4,15,28,17,88,59用<strong>开放寻址法</strong>插入到一个长度为<code>m=11</code>的散列表中，主散列函数为<code>h&#39;(k)=k mod m</code>.说明用线性探查，二次探查<code>(c1=1,c2=3)</code>以及双重散列<code>h2(k)=1+(k mod (m-1))</code>将这些关键字插入散列表的结果。</p><p>C++实现代码：<br><a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_11/hash_table.cpp" target="_blank" rel="external">Introduction_to_Algorithms/Part_3/Chap_11/hash_table.cpp</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt; // for memset</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Null -1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DELETED -2</span></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * 算法导论习题11.4-1 开放寻址法实现散列表。</span></div><div class="line"><span class="comment"> * 顺便也实现了搜索与删除。</span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * Linux下g++5.4.0编译通过。</span></div><div class="line"><span class="comment"> * 命令：</span></div><div class="line"><span class="comment"> *   $ g++ -o hash_table.out hash_table.cpp -std=c++11</span></div><div class="line"><span class="comment"> *   $ ./hash_table.out</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">11</span>;  <span class="comment">//槽位数量</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1 = <span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> c2 = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> *T)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; T[i] &lt;&lt; <span class="string">' '</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> k % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 线性探查</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">linear_probing</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (key + i) % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//二次探查</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">quadratic_probing</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (key + c1 * i + c2 * i * i) % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//双重散列</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">double_hashing</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (key + i * (<span class="number">1</span> + key % (m - <span class="number">1</span>))) % m;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span> (*) (<span class="keyword">int</span>, <span class="keyword">int</span>);   <span class="comment">//函数指针</span></div><div class="line">PF hash_functions[<span class="number">3</span>] = &#123;linear_probing, quadratic_probing, double_hashing&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 判断探查的状态：当槽为空或者已到末尾时，为True</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">probe_state</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> T[j] == Null || T[j] == DELETED || T[j] == <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_insert</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> key, PF hash_function)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> k = key;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> j = hash_function(k, i);  <span class="comment">//这里通过函数指针，可以在调用时选择线性、二次及双重探查。关于函数指针的简单介绍，可以查看http://wangwlj.com/2018/01/06/CPP_06/</span></div><div class="line">        <span class="keyword">if</span> (probe_state(T, j))</div><div class="line">        &#123;</div><div class="line">            T[j] = k;</div><div class="line">            <span class="keyword">return</span> j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> ++i;</div><div class="line">    &#125; <span class="keyword">while</span> (i != m);</div><div class="line"></div><div class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">"hash table overflow"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_search</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> k, PF hash_function)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">        j = hash_function(k, i);  <span class="comment">//这里可以替换成二次，双重探查。插入，查找，删除函数同时被替换  </span></div><div class="line">        <span class="keyword">if</span> (T[j] == k)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> j;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> ++i;</div><div class="line">    &#125; <span class="keyword">while</span> (!probe_state(T, j));</div><div class="line">    <span class="keyword">return</span> Null;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hash_delete</span><span class="params">(<span class="keyword">int</span> T[], <span class="keyword">int</span> k, PF hash_function)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">int</span> j = hash_search(T, k, hash_function);  <span class="comment">//首先先找到该关键字k  </span></div><div class="line">    <span class="keyword">if</span> (j != Null)  </div><div class="line">    &#123;  </div><div class="line">       T[j] = DELETED;  <span class="comment">//如果找到了，那么设置其为空。  </span></div><div class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"关键字："</span> &lt;&lt; k &lt;&lt; <span class="string">" 删除成功！"</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"待删除的数据不在表中！"</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> key[<span class="number">9</span>] = &#123;<span class="number">10</span>, <span class="number">22</span>, <span class="number">31</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">28</span>, <span class="number">17</span>, <span class="number">88</span>, <span class="number">59</span>&#125;;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> T[<span class="number">11</span>];</div><div class="line">   </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123; </div><div class="line">        <span class="built_in">memset</span>(T, <span class="number">0</span>, <span class="keyword">sizeof</span>(T));  <span class="comment">// 初始化T为全零</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</div><div class="line">            hash_insert(T, key[j], hash_functions[i]); </div><div class="line">        &#125;</div><div class="line">    Print(T);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"搜索关键字：88，返回结果："</span> &lt;&lt; hash_search(T, <span class="number">88</span>, hash_functions[i]) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    hash_delete(T, <span class="number">88</span>, hash_functions[i]);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除 88 之后元素为："</span>;</div><div class="line">    Print(T);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>算法导论 第三版 中文版</li><li><a href="http://blog.csdn.net/z84616995z/article/details/21329071" target="_blank" rel="external">算法导论第十一(11)章散列(Hash)表</a></li><li><a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7713307" target="_blank" rel="external">算法导论-第11章-散列表</a></li><li><a href="http://wangwlj.com/2018/01/06/CPP_06/">C++ Primer学习笔记：(六)函数</a></li></ul>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/30/algorithm_tutorial_chapter_11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(8) 第十章 基本数据结构</title>
      <link>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_10/</link>
      <guid>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_10/</guid>
      <pubDate>Sat, 27 Jan 2018 09:11:56 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fnva4kd9a0j20k50j5wjm.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;本章介绍几种基本的结构：栈、队列、链表和有根树。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fnva4kd9a0j20k50j5wjm.jpg" alt=""><br>本章介绍几种基本的结构：栈、队列、链表和有根树。</p><a id="more"></a><h2 id="栈和队列（10-1，P129）"><a href="#栈和队列（10-1，P129）" class="headerlink" title="栈和队列（10.1，P129）"></a>栈和队列（10.1，P129）</h2><p>栈和队列都是动态集合。</p><h3 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h3><p><strong>概念定义</strong>：栈采用<strong><font color="FA1C1C">先进后出</font></strong>策略（LIFO）。基本操作是<strong>压入（PUSH）</strong>和<strong>弹出（POP）</strong>。如果<code>s.top=0</code>，表示栈空，如果试图对空栈进行<code>POP</code>操作会发生下溢（<code>underflow</code>）。如果<code>s.top&gt;n</code>,表示栈满，如果进行<code>PUSH</code>操作会发生上溢（<code>overflow</code>）。</p><p>栈的Python实现代码链接：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_10/stack.py" target="_blank" rel="external">Introduction_to_Algorihtms/stack_my.py</a></p><h3 id="队列queue"><a href="#队列queue" class="headerlink" title="队列queue"></a>队列queue</h3><p><strong>概念定义</strong>：队列采用<strong><font color="FA1C1C">先进先出</font></strong>策略（FIFO）。基本操作是<strong>入队（enqueue）</strong>和<strong>出队（dequeue）</strong>。如果<code>head=tail</code>，表示队列为空，如果试图对空队列进行<code>enqueue</code>操作会发生下溢（<code>underflow</code>）。如果<code>head=tail+1</code>,表示队列满，如果进行<code>dequeue</code>操作会发生上溢（<code>overflow</code>）。</p><p>队列的Python实现：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_10/queue.py" target="_blank" rel="external">Introduction_to_Algorihtms/queue_my.py</a></p><h2 id="链表（10-2，P131）"><a href="#链表（10-2，P131）" class="headerlink" title="链表（10.2，P131）"></a>链表（10.2，P131）</h2><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。</p><p>双向链表(<code>doubly linked list</code>)的每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个(前一个)结点地址的指针域。 </p><p>未排序双向链表的Python实现代码：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms/blob/master/Part_3/Chap_10/list.py" target="_blank" rel="external">Introduction_to_Algorihtms/list_my.py</a></p><h2 id="指针和对象的实现（10-3，P134）"><a href="#指针和对象的实现（10-3，P134）" class="headerlink" title="指针和对象的实现（10.3，P134）"></a>指针和对象的实现（10.3，P134）</h2><p>当有些语言不支持指针和对象数据类型时，我们可以用数组和数组下标构造对象和指针。这种链表称为<a href="http://baike.baidu.com/link?url=GFeesiUYKbcXr0Q4vPTOK518GTn6z4DnzuBNxiplK80cT9bzyAVcqpX8G9Huw8yC" target="_blank" rel="external">静态链表</a>。</p><h3 id="对象的多数组表示"><a href="#对象的多数组表示" class="headerlink" title="对象的多数组表示"></a>对象的多数组表示</h3><p>用三个数组<code>next</code> <code>key</code> <code>prev</code> 分别表示链表的后继/数据/前驱。<br>多数组表示只能表示同构对象（所有对象有相同的属性）。而单数组表示可以表示异构对象（比如对象具有不同的长度）。</p><h3 id="对象的单数组表示"><a href="#对象的单数组表示" class="headerlink" title="对象的单数组表示"></a>对象的单数组表示</h3><p>用一个数组即可表示双链表，这种表示法比较灵活，因为它允许不同长度的对象存储于同一数组中。一般地我们考虑的数据结构多是由同构的元素构成，因此采用对象的多数组表示法足够满足我们的需求。</p><h3 id="对象的分配与释放"><a href="#对象的分配与释放" class="headerlink" title="对象的分配与释放"></a>对象的分配与释放</h3><p>把自由(<code>free</code>)对象保存在一个单链表中，称为自由表(<code>free list</code>)。</p><p>自由表只使用next数组，该数组只存储链表中的next指针。自由表的头存储在全局变量free中。</p><p>自由表的实现类似与栈：下一个被分配的对象就是最后被释放的对象（后进先出）。</p><h2 id="有根树的表示（10-4，P137）"><a href="#有根树的表示（10-4，P137）" class="headerlink" title="有根树的表示（10.4，P137）"></a>有根树的表示（10.4，P137）</h2><p>用链式结构表示有根树。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树<code>T</code>具有三个属性：<code>p</code>，<code>left</code>，<code>right</code>分别存放指向父节点、左孩子节点和右孩子节点的指针。<br>如果<code>x.p=NIL</code>，则<code>x</code>是根节点。属性<code>T.root</code>指向整棵树<code>T</code>的根节点。</p><p>更多关于二叉树的内容将在第12章中介绍。本次就暂不实现二叉树。</p><h3 id="分支无限制的有根树"><a href="#分支无限制的有根树" class="headerlink" title="分支无限制的有根树"></a>分支无限制的有根树</h3><p>两种表示方法。一种是将<code>left</code>，<code>right</code>扩展为$child_1,\cdots,child_k$，这种方法的缺点是若<code>k</code>很大，但是多数节点只有少量的孩子，则会浪费大量存储空间。</p><p>第二种方法是左孩子右兄弟表示法(<code>left-child,right-sibling representation</code>)。每个节点除了父节点指针<code>p</code>，还有两个指针:<br><code>x.left-child</code>表示节点<code>x</code>最左边的孩子节点；<code>x.right-sibling</code>表示右侧相邻的兄弟节点。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.算法导论 中文 第三版<br>2.<a href="http://blog.csdn.net/z84616995z/article/details/19202773" target="_blank" rel="external">算法导论第十章基本数据结构</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(7) 第八章 线性排序算法</title>
      <link>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_8/</link>
      <guid>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_8/</guid>
      <pubDate>Sat, 27 Jan 2018 08:26:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;任何比较排序在最坏情况下都要经过$\Theta(n\text{lg}n)$次比较。&lt;/p&gt;
&lt;p&gt;本文介绍三种线性时间排序的算法：计数排序，基数排序以及桶排序。因此，这些都不属于比较排序。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>任何比较排序在最坏情况下都要经过$\Theta(n\text{lg}n)$次比较。</p><p>本文介绍三种线性时间排序的算法：计数排序，基数排序以及桶排序。因此，这些都不属于比较排序。</p><a id="more"></a><p>本文所有实现代码均已放在<code>GitHub</code>上，欢迎查看：<a href="https://github.com/qwerty200696/Introduction_to_Algorithms" target="_blank" rel="external">GitHub链接</a></p><h2 id="本章概述"><a href="#本章概述" class="headerlink" title="本章概述"></a>本章概述</h2><p>非比较排序指使用一些非比较的操作来确定排序顺序的排序算法，对于非比较排序，下界O(nlgn)不适用。</p><p>计数排序是稳定排序，若n个数据的取值范围是<code>[0..k]</code>，则运行时间为<code>O(n+k)</code>，运行空间是<code>O(n+k)</code></p><p>基数排序也是稳定排序，需要另一个稳定排序作为基础，若n个d位数，每一位有k种取值可能，所用的稳定排序运行时间为<code>O(n+k)</code>，则基数排序的时间是<code>O(d(n+k))</code></p><p>桶排序也是稳定排序，当输入数据符合均匀分布时，桶排序可以以线性时间运行。所设所有元素均匀分布在区间<code>[0,1)</code>上，把区间[0,1)划分成n个相同大小的子区间（桶），对各个桶中的数进行排序，把依次把各桶中的元素列出来。</p><h2 id="计数排序（8-2，P108）"><a href="#计数排序（8-2，P108）" class="headerlink" title="计数排序（8.2，P108）"></a>计数排序（8.2，P108）</h2><p>计数排序(<code>counting sort</code>)是使用输入元素的实际值来确定其在数组中的位置。</p><p>计数排序的一个重要特性就是它是稳定的：即对于相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同。也就是说，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。</p><p>计数排序的伪代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">COUNTING_SORT(A,B,k)</div><div class="line">      <span class="keyword">for</span> i=<span class="number">0</span> to k</div><div class="line">        <span class="keyword">do</span> C[i] = <span class="number">0</span></div><div class="line">      <span class="keyword">for</span> j=<span class="number">1</span> to length(A)</div><div class="line">          <span class="keyword">do</span> C[A[j]] = C[A[j]]+<span class="number">1</span>   <span class="comment">//C[i]中包含等于元素i的个数</span></div><div class="line">      <span class="keyword">for</span> i=<span class="number">1</span> to k</div><div class="line">          <span class="keyword">do</span> C[i] = C[i] + C[i<span class="number">-1</span>]  <span class="comment">//C[i]中包含小于等于元素i的个数</span></div><div class="line">      <span class="keyword">for</span> j=length[A] downto <span class="number">1</span></div><div class="line">          <span class="keyword">do</span> B[C[A[j]]] = A[j]</div><div class="line">             C[A[j]] = C[A[j]] <span class="number">-1</span></div></pre></td></tr></table></figure></p><p>计数排序的<code>Python</code>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Author：wangwlj</span></div><div class="line"><span class="comment"># 计数排序</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(A)</span>:</span></div><div class="line">    k = max(A)  <span class="comment"># k is max of A</span></div><div class="line">    C = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, k + <span class="number">1</span>):</div><div class="line">        C.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        C[A[j]] = C[A[j]] + <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k + <span class="number">1</span>):</div><div class="line">        C[i] = C[i] + C[i - <span class="number">1</span>]</div><div class="line"></div><div class="line">    B = []  <span class="comment"># output</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        B.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        <span class="comment"># m = A[j],n  = C[m],k = B[n - 1]  # for test</span></div><div class="line">        B[C[A[j]] - <span class="number">1</span>] = A[j]  <span class="comment"># B[n] start from 0, so need -1</span></div><div class="line">        C[A[j]] = C[A[j]] - <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> B</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    A = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>]</div><div class="line">    B = counting_sort(A)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(B)):</div><div class="line">        print(B[i], end=<span class="string">" "</span>)</div></pre></td></tr></table></figure></p><h3 id="练习8-2-3"><a href="#练习8-2-3" class="headerlink" title="练习8.2-3"></a>练习8.2-3</h3><p>在<code>COUNTING_SORT</code>过程中，第四个for循环为什么是<code>for j=length[A] downto 1</code>，而不是<code>for j=1 to length[A]</code>？</p><p><strong>为了保证算法是稳定的</strong>。由于是从前往后计数排序，两个数相同的时候，计数值较大的数对应于数组中靠后的元素，所以在输出时需要逆序。</p><h2 id="基数排序（8-3，P110）"><a href="#基数排序（8-3，P110）" class="headerlink" title="基数排序（8.3，P110）"></a>基数排序（8.3，P110）</h2><p>基数排序(<code>radix sort</code>)按有效位从低到高依次排序。</p><p>伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RADIX_SORT(A,d）</div><div class="line">    for i=1 to d</div><div class="line">          use a stable sort to sort array A on digit i</div></pre></td></tr></table></figure></p><p>基数排序一般采用<strong>计数排序</strong>作为中间稳定排序。</p><p>基数排序的<code>python</code>实现请参阅下面的练习题<code>8.3-4</code>。</p><h3 id="练习8-3-1"><a href="#练习8-3-1" class="headerlink" title="练习8.3-1"></a>练习8.3-1</h3><p>说明<code>RADIX-SORT</code>在如下英文单词上的操作过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">    A = &#123;COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB, BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX&#125;  </div><div class="line">==&gt; A = &#123;SEA, TEA, MOB, TAB, DOG, RUG, DIG, BIG, BAR, EAR, TAR, COW, ROW, NOW, BOX, FOX&#125;  </div><div class="line">==&gt; A = &#123;TAB, BAR, EAR, TAR, SEA, TEA, DIG, BIG, MOB, DOG, COW, ROW, NOW, BOX, FOX, RUB&#125;  </div><div class="line">==&gt; A = &#123;BAR, BIG, BOX, COW, DIG, DOG, EAR, FOX, MOB, NOW, ROW, TAB, TAR, TEA, SEA, RUB&#125;</div></pre></td></tr></table></figure></p><h3 id="练习8-3-4"><a href="#练习8-3-4" class="headerlink" title="练习8.3-4"></a>练习8.3-4</h3><p>题目：在<code>O(n)</code>时间内对<code>[0..n^3-1]</code>之间的n个整数排序。</p><p>思路：把整数转换为n进制再排序，每个数有三位，每位的取值范围是[0..n-1]，再进行基数排序</p><p>实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">n = <span class="number">5</span></div><div class="line">base_k = <span class="number">5</span>  <span class="comment"># bask could be any number. In test 8.3-4 is 5(equal to n)</span></div><div class="line">d = <span class="number">3</span>  <span class="comment"># 8.3-4</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stable_sort</span><span class="params">(A, index)</span>:</span>  <span class="comment"># similar with counting sort,</span></div><div class="line">    C = []  <span class="comment"># C：统计每位数上可能出现的k个数的次数</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, base_k + <span class="number">1</span>):  <span class="comment"># the number is in range of base_k（k）</span></div><div class="line">        C.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        <span class="comment"># 统计当前位上的数出现的次数</span></div><div class="line">        num = int(A[j] % pow(base_k, index) / pow(base_k, index - <span class="number">1</span>))  <span class="comment"># the base number</span></div><div class="line">        <span class="comment"># print(A[j], ' 当前位编号：', index, '当前值：', num, )  # for test</span></div><div class="line">        C[num] = C[num] + <span class="number">1</span>  <span class="comment"># the count of the base number (C - num)</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, base_k + <span class="number">1</span>):</div><div class="line">        C[i] = C[i] + C[i - <span class="number">1</span>]</div><div class="line"></div><div class="line">    B = []  <span class="comment"># output</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        B.append(<span class="number">0</span>)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(A) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">        num = int(A[j] % pow(base_k, index) / pow(base_k, index - <span class="number">1</span>))</div><div class="line">        B[C[num] - <span class="number">1</span>] = A[j]  <span class="comment"># B[n] start from 0, so need -1</span></div><div class="line">        C[num] = C[num] - <span class="number">1</span></div><div class="line">    <span class="keyword">return</span> B</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(A)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, d + <span class="number">1</span>):</div><div class="line">        A = stable_sort(A, i)</div><div class="line">    <span class="comment"># for i in range(0, len(A)):</span></div><div class="line">    <span class="comment">#     print(A[i], end=' ')</span></div><div class="line">    <span class="keyword">return</span> A</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    <span class="comment"># A = [114, 18, 35, 74, 36]</span></div><div class="line">    A = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n):</div><div class="line">        A.append(random.randint(<span class="number">0</span>, pow(n, <span class="number">3</span>)))</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">' '</span>)</div><div class="line">    print(<span class="string">'\n'</span>)</div><div class="line"></div><div class="line">    A = radix_sort(A)</div><div class="line">    print(<span class="string">'After radix_sort：'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</div><div class="line">        print(A[i], end=<span class="string">' '</span>)</div></pre></td></tr></table></figure></p><h2 id="桶排序（8-4，P112）"><a href="#桶排序（8-4，P112）" class="headerlink" title="桶排序（8.4，P112）"></a>桶排序（8.4，P112）</h2><p>桶排序(<code>bucket sort</code>)假设输入数据服从均匀分布，平均情况下它的时间代价为$\text{O}_n$，与计数排序类似，因为对输入数据做了某种假设，桶排序的速度也很快。具体来说，计数排序假设输入数据都属于一个小区间的整数，而桶排序则假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.算法导论 中文 第三版<br>2.<a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7678859" target="_blank" rel="external">算法导论 第8章 线性时间排序</a>这个包含习题答案，很不错<br>3.<a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/7685839" target="_blank" rel="external">算法导论8.3-4</a><br>4.<a href="http://blog.csdn.net/qing0706/article/details/50117873" target="_blank" rel="external">MIT算法导论-第五讲-线性时间排序</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/27/algorithm_tutorial_chapter_8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python数据结构之链表</title>
      <link>http://wangwlj.com/2018/01/26/python_linkedlist/</link>
      <guid>http://wangwlj.com/2018/01/26/python_linkedlist/</guid>
      <pubDate>Fri, 26 Jan 2018 14:56:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/c38a0784ly1fnvahij9xbj20jm0ejgr2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;主要实现了链表的三个功能：链表的查找、插入与删除。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/c38a0784ly1fnvahij9xbj20jm0ejgr2.jpg" alt=""><br>主要实现了链表的三个功能：链表的查找、插入与删除。<br><a id="more"></a></p><p>最近在看《算法导论》，看到第十章——基本数据结构中，提到了链表，于是用<code>Python</code>进行了实现。算法导论中只给出了三个操作：链表的查找、插入与删除。于是，暂时也只实现了这三个。</p><p>下面进行简要的介绍：</p><p>我们首先定义一个节点的类，用来存储链表中的每个节点。每个节点都有三个属性：节点存储的元素值，指向上一个节点的指针以及指向下一个节点的指针。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span>  <span class="comment"># 链表的每个节点</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, _prev=None, _next=None)</span>:</span></div><div class="line">        self.value = value</div><div class="line">        self.prev = _prev</div><div class="line">        self.next = _next</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>  <span class="comment"># 在print时默认返回value</span></div><div class="line">        <span class="keyword">return</span> str(self.value)</div></pre></td></tr></table></figure></p><p>其中，<code>__str__</code>函数使得在print一个Node对象的时候打印其value值。</p><p>接着我们定义链表类List。Python中<code>list</code>是一个关键字，表示序列，故避免重复，也可以把链表叫做<code>LinkedList</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.head = <span class="keyword">None</span>  <span class="comment"># init as a empty list</span></div></pre></td></tr></table></figure></p><p>上述初始化函数中的<code>self.head = None</code>将链表初始化为空链表。</p><p>接着分别实现搜索、插入和删除三个功能。可以对照着书中的伪码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, key)</span>:</span></div><div class="line">    x = self.head</div><div class="line">    <span class="keyword">while</span> x.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> x.value != key:</div><div class="line">        x = x.next</div><div class="line">    <span class="keyword">return</span> x</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, x)</span>:</span></div><div class="line">    <span class="comment"># 插入节点x作为新的头节点</span></div><div class="line">    x.next = self.head</div><div class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        self.head.prev = x</div><div class="line">    self.head = x</div><div class="line">    x.prev = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, x)</span>:</span></div><div class="line">    <span class="comment"># x is in list and known (can use search to find)</span></div><div class="line">    <span class="keyword">if</span> x.prev <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        x.prev.next = x.next</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        self.head = x.next</div><div class="line"></div><div class="line">    <span class="keyword">if</span> x.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        x.next.prev = x.prev</div></pre></td></tr></table></figure></p><p>下面的这个<code>show_value</code>函数是为了依次打印链表的元素，不是必须的，可以跳过。<code>__str__</code>与Node中的类似，实现了可以直接打印一个List的对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_value</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment"># 依次打印链表的值</span></div><div class="line">    x = self.head</div><div class="line">    print(<span class="string">"The List Value is:"</span>, end=<span class="string">' '</span>)</div><div class="line">    <span class="keyword">while</span> x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        print(x.value, end=<span class="string">' '</span>)</div><div class="line">        x = x.next</div><div class="line">    print()</div><div class="line">    <span class="keyword">return</span> <span class="string">'show_value'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="comment"># 支持直接print一个List的对象</span></div><div class="line">    <span class="keyword">return</span> self.show_value() + <span class="string">" in List"</span></div></pre></td></tr></table></figure></p><p>最后是主函数，对上述实现进行简单的测试。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    l = List()</div><div class="line">    l.insert(Node(<span class="number">5</span>))</div><div class="line">    l.insert(Node(<span class="number">4</span>))</div><div class="line">    l.insert(Node(<span class="number">3</span>))</div><div class="line">    n = l.search(<span class="number">5</span>)</div><div class="line">    print(<span class="string">"search value: "</span>, n.value, n.prev, n.next,</div><div class="line">          <span class="string">"\nhead: "</span>, l.head.value, l.head.prev, l.head.next)</div><div class="line">    l.delete(n)</div><div class="line">    print(<span class="string">"head: "</span>, l.head.value, l.head.prev, l.head.next)</div><div class="line">    l.insert(Node(<span class="number">6</span>))  <span class="comment"># always insert as head.</span></div><div class="line">    l.insert(Node(<span class="number">7</span>))</div><div class="line">    l.insert(Node(<span class="number">8</span>))</div><div class="line">    l.show_value()</div><div class="line"></div><div class="line">    n = l.search(<span class="number">7</span>)</div><div class="line">    print(<span class="string">"search value:"</span>, n, n.prev, n.next,</div><div class="line">          <span class="string">"\nhead:"</span>, l.head, l.head.prev, l.head.next)</div><div class="line"></div><div class="line">    l.delete(l.search(<span class="number">6</span>))</div><div class="line">    print(l)</div></pre></td></tr></table></figure></p><p>完整的代码放在Github上了，仅供参考。链接为：<a href="https://github.com/qwerty200696/Introduction_to_Algorihtms/blob/master/list_my.py" target="_blank" rel="external">Introduction_to_Algorihtms/list_my.py</a></p>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/26/python_linkedlist/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(十)泛型算法</title>
      <link>http://wangwlj.com/2018/01/20/CPP_10/</link>
      <guid>http://wangwlj.com/2018/01/20/CPP_10/</guid>
      <pubDate>Sat, 20 Jan 2018 15:00:35 GMT</pubDate>
      <description>
      
        &lt;p&gt;标准库并没有给每个容器添加大量功能，而是提供了一组算法，这些算法大多数都独立于任何特定的容器。这些算法是通用的(&lt;code&gt;generic&lt;/code&gt;，或称泛型的)：可以用于不同类型的容器或者元素。算法通过在迭代器上进行操作来实现类型无关。&lt;/p&gt;
&lt;p&gt;算法不直接改变所操作序列的大小。它们会将一个元素从一个位置拷贝到另一个位置，但不会直接添加或删除元素。&lt;br&gt;虽然算法不能向序列添加元素，但是插入迭代器可以做到。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>标准库并没有给每个容器添加大量功能，而是提供了一组算法，这些算法大多数都独立于任何特定的容器。这些算法是通用的(<code>generic</code>，或称泛型的)：可以用于不同类型的容器或者元素。算法通过在迭代器上进行操作来实现类型无关。</p><p>算法不直接改变所操作序列的大小。它们会将一个元素从一个位置拷贝到另一个位置，但不会直接添加或删除元素。<br>虽然算法不能向序列添加元素，但是插入迭代器可以做到。</p><a id="more"></a><h2 id="概述（10-1，P336）"><a href="#概述（10-1，P336）" class="headerlink" title="概述（10.1，P336）"></a>概述（10.1，P336）</h2><p>顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或者尾元素之后位置的迭代器。</p><p>标准库定义了大约100个类型无关的对序列进行操作的算法。序列可以是标准库类型中的元素、一个内置数组或者是（例如）通过读写一个流来生成的。</p><p>大多数算法都定义在头文件<code>algorithm</code>中。标准库还在文件<code>numeric</code>中定义了一组数值泛型算法。</p><h2 id="初识泛型算法（10-2，P338）"><a href="#初识泛型算法（10-2，P338）" class="headerlink" title="初识泛型算法（10.2，P338）"></a>初识泛型算法（10.2，P338）</h2><p><code>accumulate</code>：定义在头文件<code>numeric</code>中。作用是对范围求和。</p><p><code>euqal</code>：定义在头文件<code>algorithm</code>中。作用是判断给定两个区间是否相等。假定第二个序列至少与第一个序列一样长。</p><p><code>fill</code>：定义在头文件algorithm中。作用是对给定区间全部赋予某值。</p><p><code>fill_n</code>：定义在头文件algorithm中。作用是对给定迭代器后的n个元素赋予某值。</p><p><code>back_inserter</code>：定义在头文件<code>iterator</code>中。得到指向容器尾部的迭代器。</p><h3 id="重排容器元素的算法"><a href="#重排容器元素的算法" class="headerlink" title="重排容器元素的算法"></a>重排容器元素的算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>&#125;;</div><div class="line">sort(words.begin(),words.end());</div><div class="line"><span class="keyword">auto</span> end_unique = unique(words.begin(),words.end());</div><div class="line">words.erase(end_unique,words.end());</div></pre></td></tr></table></figure><p>消除重复单词的程序：使用到了下面这三个算法：</p><ul><li><code>sort</code>：定义在头文件<code>algorithm</code>中。对指定区间排序；</li><li><code>unique</code>：定义在头文件<code>algorithm</code>中。“消除”重复项，返回指向不重复值范围末尾的迭代器；</li><li><code>erase</code>：容器操作，而不是算法。删除指定范围内的元素。</li></ul><h2 id="定制操作（10-3）"><a href="#定制操作（10-3）" class="headerlink" title="定制操作（10.3）"></a>定制操作（10.3）</h2><h3 id="向算法传递函数（10-3-1）"><a href="#向算法传递函数（10-3-1）" class="headerlink" title="向算法传递函数（10.3.1）"></a>向算法传递函数（10.3.1）</h3><p><strong>谓词(predicate)</strong>是一个可调用的表达式，其返回结果是一个能用作条件的值。谓词分为：一元谓词和二元谓词。几元谓词接受几元参数。</p><p>使用谓词的排序版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>&#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Before: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = words.begin();iter != words.end(); ++iter)&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">"  "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">sort(words.begin(),words.end(), isShorter); <span class="comment">//使用谓词进行排序</span></div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After sort: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s: words)&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"  "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Before: the  quick  red  fox  red  the  slow  </div><div class="line">After sort: the  red  fox  red  the  slow  quick</div></pre></td></tr></table></figure></p><p>可以看到三个字母的都在最前面，接着是长度为4,然后是长度为5的。</p><p>有时候我们希望长度相同的元素按照字典进行排序，此时可用<code>stable_sort</code>算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> s1.size() &lt; s2.size();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</div><div class="line"><span class="comment">//按字典顺序排序</span></div><div class="line">sort(words.begin(),words.end());</div><div class="line"></div><div class="line"><span class="keyword">auto</span> end_unique = unique(words.begin(),words.end());</div><div class="line">words.erase(end_unique,words.end());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>, <span class="string">"seen"</span>&#125;;</div><div class="line"></div><div class="line">elimDups(words);</div><div class="line"></div><div class="line">stable_sort(words.begin(), words.end(), isShorter);</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After stable_sort: "</span>;</div><div class="line"> <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s: words)&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">"  "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>输出为：</p><blockquote><p><code>After sort: fox  red  the  seen  slow  quick</code></p></blockquote><h3 id="lambda表达式-10-3-2，P345"><a href="#lambda表达式-10-3-2，P345" class="headerlink" title="lambda表达式(10.3.2，P345)"></a>lambda表达式(10.3.2，P345)</h3><p>可调用对象：对于一个对象或一个表达式，如果可以对其使用调用运算符，则称为可调用的；可调用的对象有：函数、函数指针、重载函数调用运算符的类和<code>lambda</code>表达式。</p><p><code>lambda</code>表达式形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[capture list](parameter list)-&gt;return type&#123;function body&#125;;</div></pre></td></tr></table></figure></p><p><code>capture list</code>是一个<code>lambda</code>所在函数中定义的局部变量的列表（通常为空）；<br><code>return type</code>、<code>parameter list</code>和<code>function body</code>分别表示返回类型、参数列表和函数体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> s1.size() &lt; s2.size();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words)</span></span>&#123;</div><div class="line"><span class="comment">//按字典顺序排序</span></div><div class="line">sort(words.begin(),words.end());</div><div class="line"></div><div class="line"><span class="keyword">auto</span> end_unique = unique(words.begin(),words.end());</div><div class="line">words.erase(end_unique,words.end());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type sz)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"><span class="comment">// 将words按字典序排序，删除重复单词</span></div><div class="line">elimDups(words); </div><div class="line"></div><div class="line"><span class="comment">// 按长度排序，长度相同的单词维持字典序</span></div><div class="line">stable_sort(words.begin(), words.end(), isShorter); </div><div class="line"></div><div class="line"><span class="comment">// 获取一个迭代器，指向第一个满足size()&gt;=sz的元素</span></div><div class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), [sz](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)&#123; <span class="keyword">return</span> a.size() &gt;= sz; &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 计算满足size&gt;=sz元素的数目</span></div><div class="line"><span class="keyword">auto</span> count = words.end() - wc;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; count &lt;&lt; <span class="string">" "</span> &lt;&lt; ( (count&gt;<span class="number">1</span>) ? <span class="string">"word"</span> : <span class="string">"words"</span> ) &lt;&lt; <span class="string">" of length "</span> &lt;&lt; sz &lt;&lt; <span class="string">" or longer"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="comment">//打印长度大于等于给定值的单词，每个单词后面接一个空格</span></div><div class="line">for_each(wc,words.end(),[](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a)&#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span>; &#125;);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words = &#123;<span class="string">"the"</span>, <span class="string">"quick"</span>, <span class="string">"red"</span>, <span class="string">"fox"</span>,<span class="string">"red"</span>, <span class="string">"the"</span>,<span class="string">"slow"</span>, <span class="string">"seen"</span>&#125;;</div><div class="line">biggies(words,<span class="number">4</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="lambda捕获与返回（10-3-3，P349）"><a href="#lambda捕获与返回（10-3-3，P349）" class="headerlink" title="lambda捕获与返回（10.3.3，P349）"></a>lambda捕获与返回（10.3.3，P349）</h3><p>捕获方式分为显式捕获、隐式捕获与混合使用。</p><p>显式捕获分为值捕获与引用捕获。<br>值捕获：与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是在调用时拷贝。</p><p>隐式捕获：在捕获列表写一个<code>&amp;</code>（引用捕获）或者<code>=</code>（值捕获）。</p><p>混合使用隐式捕获和显式捕获：捕获列表第一个元素必须是一个<code>&amp;</code>或<code>=</code>，并且显式捕获的变量必须采用与隐式捕获不同的方式。</p><h3 id="参数绑定（10-3-4，P354）"><a href="#参数绑定（10-3-4，P354）" class="headerlink" title="参数绑定（10.3.4，P354）"></a>参数绑定（10.3.4，P354）</h3><p>标准库<code>bind</code>函数：定义在头文件：<code>functional</code>；它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。</p><p>调用<code>bind</code>的形式：</p><blockquote><p>auto newCallable=bind(callable, arg_list);</p></blockquote><p><code>newCallable</code>本身是一个可调用对象，<code>arg_list</code>是一个逗号分隔的参数列表，对应给定的callable的参数。<code>arg_list</code>中的参数可能包含形如<code>_n</code>的名字，<code>_1</code>是<code>newCallable</code>的第一个参数,<code>_2</code>为第二个参数，依次类推。</p><p><code>_n</code>参数在命名空间<code>placeholders</code>中，需要如下声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</div></pre></td></tr></table></figure></p><p><code>bind</code>拷贝参数而不能拷贝<code>ostream</code>。我们可以使用<code>ref</code>函数。</p><p>函数<code>ref</code>返回一个对象，包含给定引用，此对象是可以拷贝的。标准库中还有一个<code>cref</code>函数，生成一个保存<code>const</code>引用的类。与<code>bind</code>一样，函数<code>ref</code>和<code>cref</code>也定义在头文件<code>functional</code>中。</p><h2 id="再探迭代器（10-4）"><a href="#再探迭代器（10-4）" class="headerlink" title="再探迭代器（10.4）"></a>再探迭代器（10.4）</h2><p>标准库在头文件<code>iterator</code>中定义了几种迭代器：</p><ul><li>插入迭代器：这些迭代器被绑定到一个容器上，可用来向容器插入元素。</li><li>流迭代器：这些迭代器被绑定到输入或输出流上，可用来遍历所有关联的IO流。</li><li>反向迭代器：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。</li><li>移动迭代器：这些专用的迭代器不是拷贝其中的元素，而是移动它们。</li></ul><h3 id="插入迭代器（10-4-1，P358）"><a href="#插入迭代器（10-4-1，P358）" class="headerlink" title="插入迭代器（10.4.1，P358）"></a>插入迭代器（10.4.1，P358）</h3><table><thead><tr><th>插入器的三种类型</th><th></th></tr></thead><tbody><tr><td>back_inserter</td><td>创建一个使用<code>push_back</code>的迭代器</td></tr><tr><td>front_inserter</td><td>创建一个使用<code>push_front</code>的迭代器</td></tr><tr><td>inserter</td><td>创建一个使用<code>insert</code>的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将插入到给定迭代器所表示的元素之前。</td></tr></tbody></table><p>练习10.28：分别使用上述三种插入迭代器将vector的内容拷贝到容器中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">1</span>; i&lt;=<span class="number">9</span>; ++i)</div><div class="line">&#123;</div><div class="line">v.push_back(i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; di, dbi, dfi;</div><div class="line">copy(v.begin(), v.end(), inserter(di, di.begin())); <span class="comment">// 接收两个参数</span></div><div class="line">copy(v.begin(), v.end(), back_inserter(dbi));</div><div class="line">copy(v.begin(), v.end(), front_inserter(dfi));</div></pre></td></tr></table></figure></p><p>三个插入器的最终结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">inserter:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </div><div class="line">back_inserter:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </div><div class="line">front_inserter:<span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></div></pre></td></tr></table></figure></p><h3 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h3><h4 id="istream-iterator操作"><a href="#istream-iterator操作" class="headerlink" title="istream_iterator操作"></a>istream_iterator操作</h4><table><thead><tr><th><code>istream_iterator</code>操作</th><th>含义</th></tr></thead><tbody><tr><td><code>istream_iterator&lt;T&gt; in(is)</code></td><td>in从输入流is读取类型为T的值</td></tr><tr><td><code>istream_iterator&lt;T&gt; end;</code></td><td>读取类型为T的值的<code>istream_iterator</code>迭代器，表示尾后位置 （默认初始化）</td></tr><tr><td><code>in1 == in2</code></td><td>in1和in2必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同</td></tr><tr><td><code>in1 != in2</code></td><td>的输入，则两者相等</td></tr><tr><td><code>*in</code></td><td>返回从流中读取的值</td></tr><tr><td><code>in-&gt;mem</code></td><td>与<code>(*in).mem</code>的含义相同</td></tr><tr><td>++in,in++</td><td>使用元素类型所定义的&gt;&gt;运算符从输入流中读取下一值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值</td></tr></tbody></table><p>计算从标准输入的值的和：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; in_iter(<span class="built_in">cin</span>), eof;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sum is: "</span> &lt;&lt; accumulate(in_iter, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><h4 id="ostream-iterator操作"><a href="#ostream-iterator操作" class="headerlink" title="ostream_iterator操作"></a>ostream_iterator操作</h4><table><thead><tr><th><code>ostream_iterator</code>操作</th><th>含义</th></tr></thead><tbody><tr><td><code>ostream_iterator&lt;T&gt; out(os);</code></td><td>out将类型为T的值写到输出流os中</td></tr><tr><td><code>ostream_iterator&lt;T&gt; out(os,d);</code></td><td>out将类型为T的值写到输出流os中，每个值后面都输出一个d。d指向一个空字符结尾的字符数组</td></tr><tr><td>out = val;</td><td>用<code>&lt;&lt;</code>运算符将val写入到out所绑定的ostream中。val的类型必须与out可写的类型兼容。</td></tr><tr><td><code>*out,++out,out++;</code></td><td>这些运算符是存在的，但不对out做任何事情。每个运算符都返回out</td></tr></tbody></table><p>使用流迭代器输出vector的内容：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</div><div class="line">ostream_iterator&lt;<span class="keyword">int</span>&gt; out_iter(<span class="built_in">cout</span>, <span class="string">" "</span>);</div><div class="line">copy(v.begin(),v.end(),out_iter);</div></pre></td></tr></table></figure></p><h3 id="反向迭代器（10-4-3，P363）"><a href="#反向迭代器（10-4-3，P363）" class="headerlink" title="反向迭代器（10.4.3，P363）"></a>反向迭代器（10.4.3，P363）</h3><p>sort函数正向与逆序排序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</div><div class="line"></div><div class="line">sort(v.begin(),v.end());</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After sort: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = v.begin(); i != v.end(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">sort(v.rbegin(),v.rend());</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After reverse sort: "</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = v.begin(); i != v.end(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">After sort: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </div><div class="line">After reverse sort: <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></div></pre></td></tr></table></figure></p><p>使用反向迭代器逆序打印一个vector(练习10.34)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"逆序打印："</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = v.crbegin(); i != v.crend(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>输出结果为：</p><blockquote><p>逆序打印：8 9 2 6 4 7 1 5 3 </p></blockquote><p>使用<code>find</code>在一个int的<code>list</code>中查找最后一个值为<code>0</code>的元素（练习10.36）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> it = find(v.cbegin(),v.cend(),<span class="number">0</span>);</div><div class="line"><span class="keyword">auto</span> itr = find(v.crbegin(),v.crend(),<span class="number">0</span>);</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"迭代器的指向位置： "</span> &lt;&lt; *it &lt;&lt; *itr &lt;&lt;*(itr.base()) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After find: "</span> ;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = it; i != v.cend(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"After reverse find: "</span> ;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = itr.base(); i != v.cend(); ++i)</div><div class="line">&#123;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="string">" "</span> ;</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p><p>输出为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">迭代器的指向位置： <span class="number">006</span></div><div class="line">After find: <span class="number">0</span> <span class="number">7</span> <span class="number">4</span> <span class="number">0</span> <span class="number">6</span> <span class="number">2</span> <span class="number">9</span> <span class="number">8</span> </div><div class="line">After reverse find: <span class="number">6</span> <span class="number">2</span> <span class="number">9</span> <span class="number">8</span></div></pre></td></tr></table></figure></p><h2 id="泛型算法结构（10-5）"><a href="#泛型算法结构（10-5）" class="headerlink" title="泛型算法结构（10.5）"></a>泛型算法结构（10.5）</h2><h3 id="迭代器类别"><a href="#迭代器类别" class="headerlink" title="迭代器类别"></a>迭代器类别</h3><table><thead><tr><th>迭代器类别</th><th></th></tr></thead><tbody><tr><td>输入迭代器</td><td>只读，不写；单遍扫描，只能递增</td></tr><tr><td>输出迭代器</td><td>只写，不读；单遍扫描，只能递增</td></tr><tr><td>前向迭代器</td><td>可读写，多遍扫描，只能递增</td></tr><tr><td>双向迭代器</td><td>可读写，多遍扫描，可递增递减</td></tr><tr><td>随机访问迭代器</td><td>可读写，多遍扫描，支持全部迭代器运算</td></tr></tbody></table><h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3><p>4种算法形参模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alg(beg,end,other args);</div><div class="line">alg(beg,end,dest,other args);</div><div class="line">alg(beg,end,beg2,other args);</div><div class="line">alg(beg,end,beg2,end2,other args);</div></pre></td></tr></table></figure></p><p>其中，<code>alg</code>是算法的名字，<code>beg</code>和<code>end</code>是算法所操作的输入范围。<code>dest</code>、<code>beg2</code>和<code>end2</code>，都是迭代器参数。<br><code>dest</code>参数表示算法可以写入的目的位置的迭代器，算法假定：不管写入多少个元素都是安全的。</p><h3 id="算法命名规范"><a href="#算法命名规范" class="headerlink" title="算法命名规范"></a>算法命名规范</h3><p>一些算法使用重载参数形式传递一个谓词。</p><p><code>_if</code>版本的算法：接受一个元素值的算法通常有一个接受谓词版本的算法，加上后缀<code>_if</code></p><p>区分拷贝元素的版本和不拷贝元素的版本：重排元素的算法通常直接写回给定的输入序列，也可以将元素写到一个指定的输出目的的位置，此类算法在名字后面加上<code>_copy</code></p><h2 id="特定容器算法（10-6）"><a href="#特定容器算法（10-6）" class="headerlink" title="特定容器算法（10.6）"></a>特定容器算法（10.6）</h2><h3 id="list和forward-list成员函数版本的算法"><a href="#list和forward-list成员函数版本的算法" class="headerlink" title="list和forward_list成员函数版本的算法"></a>list和forward_list成员函数版本的算法</h3><table><thead><tr><th>list和forward_list成员函数版本的算法</th><th>含义</th></tr></thead><tbody><tr><td>lst.merga(lst2)   </td></tr><tr><td>lst.megra(lst2,comp)</td><td>将来自lst2的元素合并入lst。lst和lst2都必须是有序的。元素将从lst2中删除。在合并之后，lst2变成空。第一个版本使用&lt;运算符；第二个版本使用给定的比较操作。</td></tr><tr><td>lst.remove(val)</td></tr><tr><td>lst.remove_if(pred)</td><td>调用erase删除掉与给定值相等(==)或令一元谓词为真的每个元素</td></tr><tr><td>lst.reverse()</td><td>反转lst中元素的顺序</td></tr><tr><td>lst.sort() </td></tr><tr><td>lst.sort(comp)</td><td>使用&lt;或给定比较操作排序元素</td></tr><tr><td>lst.unique()</td></tr><tr><td>lst.unique(pred)</td><td>调用erase删除同一个值的连续拷贝。第一个版本使用==；第二个版本使用给定的二元谓词</td></tr></tbody></table><h3 id="list和forward-list的splice成员函数的参数"><a href="#list和forward-list的splice成员函数的参数" class="headerlink" title="list和forward_list的splice成员函数的参数"></a>list和forward_list的splice成员函数的参数</h3><table><thead><tr><th>lst.splice(args)或flst.splice_after(args)</th><th>含义</th></tr></thead><tbody><tr><td>(p,lst2)</td><td>p是一个指向lst中元素的迭代器，或一个指向flst首前位置的迭代器。函数将lst2的所有元素移动到lst中p之前的位置或是flst中p之后的位置。将元素从lst2中删除。lst2的类型必须与lst或flst相同，且不能是同一个链表。</td></tr><tr><td>(p,lst2,p2)</td><td>p2是一个指向lst2中位置的有效迭代器。将p2指向的元素移动到lst中，或将p2之后的元素移动到flst中。lst2可以是与lst或flst相同的链表。</td></tr><tr><td>(p,lst2,b,e)</td><td>b和e必须表示lst2中的合法范围。将给定范围中的元素从lst2移动到lst或flst。lst2与lst(或flst)可以是相同的链表，但p不能指向给定范围中元素。</td></tr></tbody></table><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>泛型算法：generic algorithm<br>谓词：predicate<br>一元谓词：unary predicate<br>二元谓词：binary predicate</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49803965" target="_blank" rel="external">C++primer第五版第十章学习笔记</a></li><li><a href="http://blog.csdn.net/libin1105/article/details/48706281" target="_blank" rel="external">《C++primer(第五版)》学习之路-第十章：泛型算法</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/20/CPP_10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(九)顺序容器</title>
      <link>http://wangwlj.com/2018/01/18/CPP_09/</link>
      <guid>http://wangwlj.com/2018/01/18/CPP_09/</guid>
      <pubDate>Thu, 18 Jan 2018 13:56:55 GMT</pubDate>
      <description>
      
        &lt;p&gt;本章是第三章内容的扩展，完成本章的学习后，对标准库顺序容器知识的掌握就完整了。&lt;/p&gt;
&lt;p&gt;元素在顺序容器中的位置与其加入容器时的位置相对应。 标准库还定义了几种关联容器（第11章），关联容器中元素的位置由元素相关联的关键字决定。&lt;/p&gt;
&lt;p&gt;顺序容器有：&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;deque&lt;/code&gt;、&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;forward_list&lt;/code&gt;、&lt;code&gt;array&lt;/code&gt;与&lt;code&gt;string&lt;/code&gt;。&lt;br&gt;容器适配器有：&lt;code&gt;stack&lt;/code&gt;、&lt;code&gt;queue&lt;/code&gt;与&lt;code&gt;priority_queue&lt;/code&gt;。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>本章是第三章内容的扩展，完成本章的学习后，对标准库顺序容器知识的掌握就完整了。</p><p>元素在顺序容器中的位置与其加入容器时的位置相对应。 标准库还定义了几种关联容器（第11章），关联容器中元素的位置由元素相关联的关键字决定。</p><p>顺序容器有：<code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>、<code>array</code>与<code>string</code>。<br>容器适配器有：<code>stack</code>、<code>queue</code>与<code>priority_queue</code>。</p><a id="more"></a><h2 id="顺序容器概述（9-1，P292）"><a href="#顺序容器概述（9-1，P292）" class="headerlink" title="顺序容器概述（9.1，P292）"></a>顺序容器概述（9.1，P292）</h2><table><thead><tr><th>顺序容器类型</th><th>含义</th></tr></thead><tbody><tr><td>vector</td><td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢</td></tr><tr><td>deque</td><td>双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td></tr><tr><td>list</td><td>双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快</td></tr><tr><td>forward_list</td><td>单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快</td></tr><tr><td>array</td><td>固定大小数组。支持快速随机访问。不能添加或删除元素。</td></tr><tr><td>string</td><td>与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。</td></tr></tbody></table><p>以下是一些选择容器的基本原则：</p><p>⑴.除非你有很好的理由选择其他容器，否则应使用<code>vector</code></p><p>⑵.如果你的程序有很多小的元素，且额外开销很重要，则不要使用<code>list</code>或<code>forward_list</code></p><p>⑶.如果程序要求随机访问元素，应使用<code>vector</code>或<code>deque</code></p><p>⑷.如果程序需要<strong>在中间位置插入或删除元素</strong>，应使用<code>list</code>或<code>forward_list</code></p><p>⑸.如果程序需要<strong>在头尾位置插入或删除元素</strong>，但不会在中间位置进行插入或删除操作，则使用<code>deque</code></p><p>⑹.如果程序只有在读取输入时才需要再容器中间位置插入元素，随后需要随机访问元素，则</p><p>–首先，确定是否真的需要再容器中间位置添加元素。当处理输入数据时，通常可以很容易地向<code>vector</code>追加数据，然后再调用标准库的<code>sort</code>函数来重排容器中的元素，从而避免在中间位置添加元素。</p><p>–如果必须在中间位置插入元素，考虑在输入阶段使用<code>list</code>，一旦输入完成，将<code>list</code>中的内容拷贝到一个<code>vector</code>中。</p><h2 id="容器库概览（9-2，P294）"><a href="#容器库概览（9-2，P294）" class="headerlink" title="容器库概览（9.2，P294）"></a>容器库概览（9.2，P294）</h2><p>本节介绍对所有容器都适用的操作。</p><h3 id="容器操作表"><a href="#容器操作表" class="headerlink" title="容器操作表"></a>容器操作表</h3><table><thead><tr><th>类型别名</th><th></th></tr></thead><tbody><tr><td>iterator</td><td>此容器类型的迭代器类型</td></tr><tr><td>const_iterator</td><td>可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td>size_type</td><td>无符号整数类型，足够保存此种容器类型最大可能容器的大小</td></tr><tr><td>different_type</td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>reference</td><td>元素的左值类型；与value_type含义相同</td></tr><tr><td>const_reference</td><td>元素的const左值类型</td></tr></tbody></table><table><thead><tr><th>构造函数</th><th></th></tr></thead><tbody><tr><td>C c;</td><td>默认构造函数，构造空容器</td></tr><tr><td>C c1(c2);</td><td>构造c2的拷贝c1</td></tr><tr><td>C c(b,e);</td><td>构造c，将迭代器b和e指定范围内的元素拷贝到c(array不支持)</td></tr><tr><td>C c{a,b,c…};</td><td>列表初始化c</td></tr></tbody></table><table><thead><tr><th>赋值与swap</th><th></th></tr></thead><tbody><tr><td>c1 = c2</td><td>将c1中的元素替换为c2中元素</td></tr><tr><td>c1 = {a,b,c..}</td><td>将c1中的元素替换为列表中的元素</td></tr><tr><td>a.swap(b)</td><td>交换a和b的元素</td></tr><tr><td>swap(a,b)</td><td>与a.swap(b)等价</td></tr></tbody></table><table><thead><tr><th>大小</th><th></th></tr></thead><tbody><tr><td>c.size()</td><td>c中元素的数目（不支持forward_list）</td></tr><tr><td>c.max_size()</td><td>c可保存的的最大元素数目</td></tr><tr><td>c.empty()</td><td>若c中存储了元素，返回false，否则返回true</td></tr></tbody></table><table><thead><tr><th>添加/删除元素（不适用于array）</th><th></th></tr></thead><tbody><tr><td>注：在不同容器中，这些操作的接口都不同</td></tr><tr><td>c.insert(args)</td><td>将args中的元素拷贝进c</td></tr><tr><td>c.emplace(inits)</td><td>使用inits构造c中的一个元素</td></tr><tr><td>c.erase(args)</td><td>删除args指定的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素，返回void</td></tr></tbody></table><table><thead><tr><th>关系运算符</th><th></th></tr></thead><tbody><tr><td>==,!=</td><td>所有容器都支持相等（不等）操作</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>关系运算符(无序关联容器不支持)</td></tr></tbody></table><table><thead><tr><th>获取迭代器</th><th></th></tr></thead><tbody><tr><td>c.begin(),c.end()</td><td>返回指向c的首元素和尾元素之后位置的迭代器</td></tr><tr><td>c.cbegin(),c.cend()</td><td>返回const_iterator</td></tr></tbody></table><table><thead><tr><th>反向容器的额外成员</th><th></th></tr></thead><tbody><tr><td>reverse_iterator</td><td>按逆序寻址元素的迭代器</td></tr><tr><td>const_reverse_iterator</td><td>不能修改元素的逆序迭代器</td></tr><tr><td>c.rbegin(),c.rend()</td><td>返回指向c的尾元素和首元素之前位置的迭代器</td></tr><tr><td>c.crbegin(),c.crend()</td><td>返回const_reverse_iterator</td></tr></tbody></table><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器范围(<code>iterator range</code>)：<code>[begin,end)</code>，左闭合区间(<code>left-inclusive interval</code>)</p><p>迭代器的运算符（表3.6，P96）</p><table><thead><tr><th>迭代器的运算符</th><th>含义</th></tr></thead><tbody><tr><td><code>*iter</code></td><td>返回迭代器所指元素的引用</td></tr><tr><td>iter-&gt;mem</td><td>解引用iter并获取该元素的名为mem的成员，等价于<code>(*iter).mem</code></td></tr><tr><td>++iter</td><td>令iter指示容器中的下一个元素</td></tr><tr><td>++iter</td><td>令iter指示容器中的上一个元素</td></tr><tr><td>iter1 == iter2</td><td>判断两个迭代器是否相等（指向同一个位置则相等，包括尾后）</td></tr><tr><td>iter1 != iter2</td><td>判断两个迭代器是否不相等（指向同一个位置则相等，包括尾后）</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(begin != end)&#123;</div><div class="line">*begin = val;</div><div class="line">    ++begin;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果<code>begin</code>与<code>end</code>相等，则范围为空；如果<code>begin</code>与<code>end</code>不等，则范围至少包含一个元素，且<code>begin</code>指向该范围中的第一个元素；我们可以对<code>begin</code>递增若干次，使得<code>begin==end</code>。</p><h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3><h3 id="容器定义和初始化-9-2-4，P299"><a href="#容器定义和初始化-9-2-4，P299" class="headerlink" title="容器定义和初始化(9.2.4，P299)"></a>容器定义和初始化(9.2.4，P299)</h3><table><thead><tr><th>容器定义和初始化</th><th></th></tr></thead><tbody><tr><td>C c</td><td>默认构造函数。如果C是一个array，则c中元素按默认方式初始化，否则c为空</td></tr><tr><td><code>C c1(c2)</code> 与 <code>C c1 = c2</code></td><td>c1初始化为c2的拷贝。c1和c2必须是相同类型。</td></tr><tr><td><code>C c{a,b,c...}</code>与<code>C c = {a,b,c..}</code></td><td>c初始化为初始化列表中元素的拷贝。列表中元素的类型必须与C的元素类型相容。对于array类型，列表中元素数目必须等于或少于array的大小，任何遗漏的元素都进行值初始化。</td></tr><tr><td>C c(b,e)</td><td>c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与C的元素类型相容（对array不适用）</td></tr><tr><td>C seq(n)</td><td>seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的</td></tr><tr><td>C seq(n,t)</td><td>seq包含n个初始化为值t的元素</td></tr></tbody></table><p>$\color{red}{\heartsuit}$ <font color="0D54BD">只有顺序容器（不包括array）的构造函数才能接受大小参数。</font>关联容器并不支持。【上表中的倒数两个】</p><p>$\color{red}{\heartsuit}$ <font color="0D54BD">当一个容器初始化为另一个容器的拷贝时，两个容器的容器类型必须相同。</font></p><p>标准库array的大小也是类型的一部分。定义一个array时，除了指定元素类型，还需要指定容器大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,42&gt;</div><div class="line"><span class="built_in">array</span>&lt;<span class="built_in">string</span>,10&gt;::size_type i;</div></pre></td></tr></table></figure></p><h3 id="赋值与swap-9-2-5，P302"><a href="#赋值与swap-9-2-5，P302" class="headerlink" title="赋值与swap(9.2.5，P302)"></a>赋值与swap(9.2.5，P302)</h3><p>赋值、交换以及assign：</p><table><thead><tr><th>容器赋值运算</th><th></th></tr></thead><tbody><tr><td><code>c1 = c2</code></td><td>将c1中的元素替换为c2中元素的拷贝。c1和c2必须具有相同的类型</td></tr><tr><td><code>c = {a,b,c..}</code></td><td>将c1中元素替换为初始化列表中元素的拷贝</td></tr><tr><td><code>swap(c1,c2)</code>与<code>c1.swap(c2)</code>等价</td><td>交换c1和c2中的元素。c1和c2必须具有相同的类型。swap通常比从c2向c1拷贝元素快得多。</td></tr><tr><td><strong>assign操作不适用于关联容器和array</strong></td></tr><tr><td>seq.assign(b,e)</td><td>将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素</td></tr><tr><td>seq.assign(il)</td><td>将seq中的元素替换为初始化列表il中的元素</td></tr><tr><td>seq.assign(n,t)</td><td>将seq中的元素替换为n个值为t的元素 </td></tr></tbody></table><p>$\color{red}{\heartsuit}$ <font color="0D54BD">使用assign：允许我们使用不同但相容的类型赋值。</font></p><p>除了array外，swap不对任何元素进行拷贝、删除或者插入操作，因此可以保证常数时间内完成。<br>与其它容器不同，swap两个array会真正交换它们的元素。指针和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应的元素的值进行了交换。</p><p>除了string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。<br>特殊的，对一个string 调用swap会导致迭代器和指针失效。</p><p>forward_list支持max_size和empty，但不支持size。其它每个容器都有三个有关大小的操作。</p><h2 id="顺序容器操作-9-3，P305"><a href="#顺序容器操作-9-3，P305" class="headerlink" title="顺序容器操作(9.3，P305)"></a>顺序容器操作(9.3，P305)</h2><h3 id="向顺序容器中添加元素"><a href="#向顺序容器中添加元素" class="headerlink" title="向顺序容器中添加元素"></a>向顺序容器中添加元素</h3><table><thead><tr><th>向顺序容器添加元素的操作</th><th>含义</th></tr></thead><tbody><tr><td>c.push_back(t)</td><td>在c的尾部创建一个值为t或由args创建的元素，返回void</td></tr><tr><td>c.emplace_back(args)</td></tr><tr><td>c.push_front(t)</td><td>在c的头部创建一个值为t或由args创建的元素。返回void</td></tr><tr><td>c.emplace_front(args)</td></tr><tr><td>c.insert(p,t)</td><td>在迭代器p指向的元素<strong>之前</strong>创建一个值为t或由args创建的元素。返回指向新添加元素的迭 </td></tr><tr><td>c.emplace(p,args)</td><td>代器。 </td></tr><tr><td>c.insert(p,n,t)</td><td>在迭代器p指向的元素<strong>之前</strong>插入n个值为t的元素。返回指向新添加的第一个元素的迭代器；若n为0，则返回p</td></tr><tr><td>c.insert(p,b,e)</td><td>将迭代器b和e指定的范围内的元素插入迭代器p指向的元素<strong>之前</strong>。b和e不能指向c中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回p</td></tr><tr><td>c.insert(p,il)</td><td>il是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素<strong>之前</strong>。返回指向新添加的第一个元素的迭代器；若列表为空，则返回p</td></tr></tbody></table><table><thead><tr><th>添加元素操作</th><th>描述</th><th>vector</th><th>list</th><th>forward_list</th><th>array</th><th>deque</th></tr></thead><tbody><tr><td>push_back/emplace_back</td><td>尾部添加元素</td><td>ok</td><td>ok</td><td>不支持</td><td>不支持</td><td>ok</td></tr><tr><td>push_front/emplace_front</td><td>首部添加元素</td><td>不支持</td><td>ok</td><td>OK</td><td>不支持</td><td>ok</td></tr><tr><td>insert(p, t)/insert(p, n, t)/insert(p, b, e)/insert(p, {…})</td><td><strong>在指定p位置<font color="0D54BD">之前</font>插入元素</strong></td><td>ok</td><td>ok</td><td>有自己专用版本</td><td>不支持</td><td>ok</td></tr><tr><td>emplace</td><td>插入元素</td><td>ok</td><td>ok</td><td>有自己专用版本</td><td>不支持</td><td>ok</td></tr></tbody></table><p>添加元素会改变容器的大小，array不支持这些操作。forward_list有自己专有版本的insert和emplace。forward_list不支持push_back和emplace_back。</p><p>vector和string不支持push_front和emplace_front。将元素insert插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时。</p><p>emplace函数直接在容器中构造函数，传递给emplace函数的参数必须与元素类型相匹配。</p><h3 id="访问元素-9-3-2，P309"><a href="#访问元素-9-3-2，P309" class="headerlink" title="访问元素(9.3.2，P309)"></a>访问元素(9.3.2，P309)</h3><table><thead><tr><th>访问元素的操作</th><th>含义</th></tr></thead><tbody><tr><td>c.back()</td><td>返回c中尾元素的引用。若c为空，函数行为未定义</td></tr><tr><td>c.front()</td><td>返回c中首元素的引用。若c为空，函数行为未定义</td></tr><tr><td>c[n]</td><td>返回c中下标为n的元素的引用，n是一个无符号的整数。若n&gt;=c.size()，则函数行为未定义。</td></tr><tr><td>c.at(n)</td><td>返回下标为n的元素的引用。如果下标越界，则抛出一out_of_range异常。</td></tr></tbody></table><p>at和下标操作只适用于string,vector,deque和array。<br>back不适用于forward_list。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!c.empty())</div><div class="line">&#123;</div><div class="line">    c.front() = <span class="number">42</span>;</div><div class="line">    <span class="keyword">auto</span> &amp;v = c.back(); <span class="comment">// 获得指向最后一个元素的引用</span></div><div class="line">    v = <span class="number">1024</span>;</div><div class="line">    <span class="keyword">auto</span> v2 = c.back(); <span class="comment">// v2不是引用，只是c.back()的一个拷贝</span></div><div class="line">    v2 = <span class="number">0</span>; <span class="comment">// 没有改变c中的元素</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"v: "</span>&lt;&lt; v &lt;&lt;<span class="string">"  v2: "</span> &lt;&lt; v2 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果希望下标是合法的，可以使用at函数；如果下标越界，则抛出一个out_of_range异常。</p><h3 id="删除元素（9-3-3，P311）"><a href="#删除元素（9-3-3，P311）" class="headerlink" title="删除元素（9.3.3，P311）"></a>删除元素（9.3.3，P311）</h3><p>这些操作会改变容器大小，所以不适用于array；forward_list有特殊版本的erase；forward_list不支持pop_back；vector和string不支持pop_front。</p><table><thead><tr><th>删除元素操作</th><th>含义</th></tr></thead><tbody><tr><td>c.pop_back()</td><td>删除c中尾元素。若c为空，则函数行为未定义。函数返回void</td></tr><tr><td>c.pop_front()</td><td>删除c中首元素。若c为空，则函数行为未定义。函数返回void</td></tr><tr><td>c.erase(p)</td><td>删除迭代器p所指定的元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后(off_the_end)迭代器。若p是尾后迭代器，则函数行为未定义。</td></tr><tr><td>c.erase(b,e)</td><td>删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器</td></tr><tr><td>c.clear()</td><td>删除c中所有元素。返回void</td></tr></tbody></table><p>删除一个<code>list</code>中的所有奇数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></div><div class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</div><div class="line"><span class="keyword">auto</span> it = lst.begin();</div><div class="line"><span class="keyword">while</span>(it != lst.end())</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(*it % <span class="number">2</span>)  <span class="comment">// 如果是奇数</span></div><div class="line">        it = lst.erase(it); <span class="comment">//删除此元素，返回下一个元素</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        ++it; <span class="comment">// 递增</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="特殊的forward-list操作"><a href="#特殊的forward-list操作" class="headerlink" title="特殊的forward_list操作"></a>特殊的forward_list操作</h3><table><thead><tr><th>在forward_list中插入或删除元素的操作</th><th>含义</th></tr></thead><tbody><tr><td>lst.before_begin()</td><td>返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。</td></tr><tr><td>lst.cbefore_begin()</td><td>cbefore_begin()返回一个const_iterator</td></tr><tr><td>lst.insert_after(p,t)</td><td>在迭代器p之后的位置插入元素，t是一个对象</td></tr><tr><td>lst.insert_after(p,n,t)</td><td>t是一个对象，n是数量</td></tr><tr><td>lst.insert_after(p,b,e)</td><td>b和e是表示范围的一对迭代器(b和e不能指向lst内)</td></tr><tr><td>lst.insert_after(p,il)</td><td>il是一个花括号列表。</td></tr><tr><td>insert_after小结</td><td>返回一个指向最后一个插入的元素的迭代器。如果范围为空，则返回p。若p为尾后迭代器，则函数行为未定义</td></tr><tr><td>emplace_after(p,args)</td><td>使用args在p指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若p为尾后迭代器，则函数行为未定义。</td></tr><tr><td>lst.earse_after(p)</td><td>删除p指向的位置之后的元素，或删除从b之后直到(但不包含)e之间的元素。返回一个</td></tr><tr><td>lst.earse_after(b,e)</td><td>指向被删元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。如果p指向lst的尾元素或者是一个尾后迭代器，则函数行为未定义。</td></tr></tbody></table><p>删除一个<code>forward_list</code>中的所有奇数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">forward_list&lt;<span class="keyword">int</span>&gt; flst = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</div><div class="line"><span class="keyword">auto</span> curr = flst.begin();</div><div class="line"><span class="keyword">auto</span> prev = flst.before_begin();</div><div class="line"><span class="keyword">while</span>(curr != flst.end())</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(*curr % <span class="number">2</span>)</div><div class="line">        curr = flst.erase_after(prev);</div><div class="line">    <span class="keyword">else</span> </div><div class="line">        prev = curr++; <span class="comment">//或者 prev=curr; curr++; //或者 prev++;curr++; </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="改变容器大小（9-3-5，P314）"><a href="#改变容器大小（9-3-5，P314）" class="headerlink" title="改变容器大小（9.3.5，P314）"></a>改变容器大小（9.3.5，P314）</h3><table><thead><tr><th>顺序容器大小操作</th><th>含义</th></tr></thead><tbody><tr><td>c.resize(n)</td><td>调整c的大小为n个元素。若<code>n&lt;c.size()</code>，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化</td></tr><tr><td>c.resize(n,t)</td><td>调整c的大小为n个元素。任何新添加的元素都初始化为值t。</td></tr></tbody></table><p><code>resize</code>不适用于<code>array</code>。<code>resize</code>用来增大或者缩小容器。</p><h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><p>向容器添加元素之后：</p><p>⑴.如果容器是<code>vector</code>或<code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未被重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。</p><p>⑵.对于<code>deque</code>，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</p><p>⑶.对于<code>list</code>和<code>forward_list</code>，指向容器的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍然有效。</p><p>当我们删除一个元素后：</p><p>⑴.对于<code>list</code>和<code>forward_list</code>，指向容器其他位置的迭代器(包括尾后迭代器和首前迭代器)、指针和引用仍然有效。</p><p>⑵.对于<code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被删除元素之外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。</p><p>⑶.对于<code>vector</code>和<code>string</code>，指向被删元素之前元素的迭代器、引用和指针仍然有效。</p><p>注：当我们删除元素时，尾后迭代器总是会失效。</p><p>$\color{red}{\heartsuit}$ <font color="0D54BD">由于向迭代器添加元素和从迭代器删除元素的代码可能会使得迭代器失效，因此必须保证每次改变容器的操作之后都能正确地重新定位迭代器。</font></p><p>$\color{red}{\heartsuit}$ <font color="0D54BD">添加或删除元素的循环过程必须反复调用end，而不能在循环之前保存end返回的迭代器。</font></p><h2 id="vector是如何增长的（9-4，P317）"><a href="#vector是如何增长的（9-4，P317）" class="headerlink" title="vector是如何增长的（9.4，P317）"></a>vector是如何增长的（9.4，P317）</h2><p>1.容器大小管理操作</p><p><code>shrink_to_fit</code>只使用于<code>vector</code>、<code>string</code>和<code>deque</code>；<code>capacity</code>和<code>reserve</code>只适用于<code>vector</code>和<code>string</code></p><table><thead><tr><th>容器大小管理操作</th><th>含义</th></tr></thead><tbody><tr><td>c.shrink_to_fit()</td><td>请将capacity()减少为与size()相同大小</td></tr><tr><td>c.capacity()</td><td>不重新分配内存空间的话，c可以保存多少元素</td></tr><tr><td>c.reserve(n)</td><td>分配至少能容纳n个元素的内存空间</td></tr></tbody></table><p>2.当添加的数超出了<code>vector</code>原本分配的最大容量，<code>vector</code>的实现采用的策略是在每次需要分配新内存空间时将当前容量翻倍。</p><p>程序测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= <span class="number">33</span>; ++i)&#123;</div><div class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"size: "</span>&lt;&lt; vec.size() &lt;&lt;<span class="string">"capacity: "</span>&lt;&lt; vec.capacity() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">       vec.push_back(i);</div><div class="line">   &#125;</div></pre></td></tr></table></figure><h2 id="额外的string操作（9-5，P320）"><a href="#额外的string操作（9-5，P320）" class="headerlink" title="额外的string操作（9.5，P320）"></a>额外的string操作（9.5，P320）</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><table><thead><tr><th>构造string的其他方法</th><th>含义</th></tr></thead><tbody><tr><td>string s(cp,n)</td><td>s是cp指向的数组中前n个字符的拷贝。此数组至少应该包含n个字符。</td></tr><tr><td>string s(s2,pos2)</td><td>s是string s2从下标pos2开始的字符的拷贝。若pos2&gt;s2.size()，构造函数的行为未定义</td></tr><tr><td>string s(s2,pos2,len2)</td><td>s是string s2从下标pos2开始len2个字符的拷贝。若pos2&gt;s2.size()，构造函数的行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符。</td></tr></tbody></table><h3 id="子字符串操作"><a href="#子字符串操作" class="headerlink" title="子字符串操作"></a>子字符串操作</h3><p><code>s.substr(pos,n)</code>：返回一个<code>string</code>，包含s中从pos开始的n个字符的拷贝。<code>pos</code>的默认值为<code>0</code>。<code>n</code>的默认值为<code>s.size()-pos</code>，即拷贝从pos开始的所有字符。</p><h3 id="改变string的其他方法"><a href="#改变string的其他方法" class="headerlink" title="改变string的其他方法"></a>改变string的其他方法</h3><table><thead><tr><th>修改string的操作</th><th>含义</th></tr></thead><tbody><tr><td>s.insert(pos,args)</td><td>在pos之前插入args指定的字符。pos可以是一个下标或一个迭代器。接受下标的版本返回一个指向s的引用；接受迭代器的版本返回指向第一个插入字符的迭代器。</td></tr><tr><td>s.earse(pos,len)</td><td>删除从位置pos开始的len个字符。如果len被省略，则删除从pos开始直至s末尾的所有字符。返回一个指向s的引用。</td></tr><tr><td>s.assign(args)</td><td>将s中的字符替换为args指定的字符。返回一个指向s的引用</td></tr><tr><td>s.append(args)</td><td>将args追加到s。返回一个指向s的引用</td></tr><tr><td>s.replace(range,args)</td><td>删除s中范围range内的字符，替换为args指定的字符。range或者是一个下标和一个长度，或者是一对指向s的迭代器。返回一个指向s的引用</td></tr></tbody></table><h3 id="string搜索操作（9-5-3，P325）"><a href="#string搜索操作（9-5-3，P325）" class="headerlink" title="string搜索操作（9.5.3，P325）"></a>string搜索操作（9.5.3，P325）</h3><p><code>string</code>类提供了6个不同的搜索函数，每个函数都有4个重载版本。</p><p>每个搜索操作都会返回一个<code>string::size_type</code>值，表示匹配发生位置的下标。</p><p>如果搜索失败，则返回一个名为<code>string::npos</code>的static成员。标准库将<code>npos</code>定义成一个<code>const string::size_type</code>类型，并初始化为<code>-1</code>。</p><p><code>string</code>搜索函数返回<code>string::size_type</code>值，该类型时一个<code>unsigned</code>类型，因此我们应该尽量不要使用带符号类型来保存这些返回值。</p><table><thead><tr><th>string搜索操作</th><th>含义</th></tr></thead><tbody><tr><td>s.find(args)</td><td>查找s中args第一次出现的位置</td></tr><tr><td>s.rfind(args)</td><td>查找s中args最后一次出现的位置</td></tr><tr><td>s.find_first_of(args)</td><td>在s中查找args中任何一个字符第一次出现的位置</td></tr><tr><td>s.find_last_of(args)</td><td>　在s中查找args中任何一个字符最后第一次出现的位置</td></tr><tr><td>s.find_first_not_of(args)</td><td>在s中查找第一个不在args中的字符</td></tr><tr><td>s.find_last_not_of(args)</td><td>在s中查找最后一个不在args中的字符  </td></tr></tbody></table><table><thead><tr><th>args的形式</th><th>含义</th></tr></thead><tbody><tr><td>c,pos</td><td>从s中位置pos开始查找字符c。pos默认为0</td></tr><tr><td>s2,pos</td><td>从s中位置pos开始查找字符串s2。pos默认为0</td></tr><tr><td>cp,pos</td><td>从s中位置pos开始查找指针cp指向的以空字符结尾的C风格字符串。pos默认为0</td></tr><tr><td>cp,pos,n</td><td>从s中位置pos开始查找指针cp指向的数组的前n个字符。pos和n无默认值</td></tr></tbody></table><h3 id="字符串比较函数-9-5-4，P327"><a href="#字符串比较函数-9-5-4，P327" class="headerlink" title="字符串比较函数(9.5.4，P327)"></a>字符串比较函数(9.5.4，P327)</h3><table><thead><tr><th>s.compare(args)中args形式</th><th>含义</th></tr></thead><tbody><tr><td>s2</td><td>比较s和s2</td></tr><tr><td>pos1,n1,s2</td><td>将s中从pos1开始的n1个字符与s2比较</td></tr><tr><td>pos1,n1,s2,pos2,n2</td><td>将s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符进行比较</td></tr><tr><td>cp</td><td>比较s与cp指向的以空字符结尾的字符数组</td></tr><tr><td>pos1,n1,cp</td><td>将s中从pos1开始的n1个字符与cp指向的以空字符结尾的字符数组进行比较</td></tr><tr><td>pos1,n1,cp,n2</td><td>将s中从pos1开始的n1个字符与cp指向的地址开始的n2个字符进行比较</td></tr></tbody></table><h3 id="string和数值之间的转换-9-5-5，P327"><a href="#string和数值之间的转换-9-5-5，P327" class="headerlink" title="string和数值之间的转换(9.5.5，P327)"></a>string和数值之间的转换(9.5.5，P327)</h3><p>string参数中第一个非空白符必须是符号(+或-)或数字。它可以以0x或0X开头来表示十六进制数。对那些将字符串转换为浮点值的函数，string参数也可以以小数点开头，并可有包含e或E来表示指数部分。对于那些将字符串转换为整型值的函数，根据基数不同，string参数可以包含字母字符，对应大于数字9的数</p><p>如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常。如果转换得到的数值无法用任何类型表示，则抛出一个out_of_range异常</p><table><thead><tr><th>string和数值之间的转换</th><th>含义</th></tr></thead><tbody><tr><td>to_string(val)</td><td>一组重载函数，返回数值val的string表示。val可以是任何算术类型。对每个浮点类型和int或更大的整型，都有相应版本的to_string。与往常一样，小整型会被提升。</td></tr><tr><td>stoi(s,p,b)</td><td>返回s的起始子串(表示整数内容)的数值，返回值类型分别是int,long,unsigned long,long long,</td></tr><tr><td>stol(s,p,b)</td><td>unsigned long long。b表示转换所用的基数，默认值是10。p是size_t指针，用来保存s中第一个</td></tr><tr><td>stoul(s,p,b)</td><td>非数值字符下标，p默认为0，即函数不保存下标。</td></tr><tr><td>stoll(s,p,b) </td></tr><tr><td>stoull(s,p,b) </td></tr><tr><td>stof(s,p)</td><td>返回s的起始子串(表示浮点数内容)的数值，返回值类型分别是float,double或long double。参数</td></tr><tr><td>stod(s,p)</td><td>p的作用于整数转换函数中一样</td></tr><tr><td>stold(s,p)</td></tr></tbody></table><h2 id="容器适配器（9-6，P329）"><a href="#容器适配器（9-6，P329）" class="headerlink" title="容器适配器（9.6，P329）"></a>容器适配器（9.6，P329）</h2><p>标准库定义了三个顺序容器适配器：<code>stack</code>、<code>queue</code>和<code>priority_queue</code>。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，stack适配器接受一个顺序容器（除array或forward_list）。</p><p>所有容器适配器都支持的操作和类型：</p><table><thead><tr><th>容器适配器都支持的操作和类型</th><th>含义</th></tr></thead><tbody><tr><td>size_type</td><td>一种类型，足以保存当前类型的最大对象的大小</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>container_type</td><td>实现适配器的底层容器类型</td></tr><tr><td>A a;</td><td>创建一个名为a的空适配器</td></tr><tr><td>A a(c);</td><td>创建一个名为a的适配器，带有容器c的一个拷贝</td></tr><tr><td>关系运算符</td><td>每个适配器都支持所有关系运算符:==,!=,&lt;,&lt;=,&gt;,&gt;=，这些运算符返回底层容器的比较结果</td></tr><tr><td>a.empty()</td><td>若a包含任何元素，返回false，否则返回true</td></tr><tr><td>a.size()</td><td>返回a中元素数目</td></tr><tr><td>swap(a,b)</td><td>交换a和b的内容，a和b必须有相同类型，包括底层容器类型也必须相同</td></tr><tr><td>a.swap(b)</td></tr></tbody></table><h3 id="栈适配器的其他操作"><a href="#栈适配器的其他操作" class="headerlink" title="栈适配器的其他操作"></a>栈适配器的其他操作</h3><table><thead><tr><th>栈适配器的其他操作</th><th>含义</th></tr></thead><tbody><tr><td>s.pop()</td><td>删除栈顶元素，但不返回该元素值</td></tr><tr><td>s.push(item)</td><td>创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，或者由args构造</td></tr><tr><td>s.emplace(args)</td></tr><tr><td>s.top()</td><td>返回栈顶元素，但不将元素弹出栈</td></tr></tbody></table><h3 id="queue和priority-queue的其他操作"><a href="#queue和priority-queue的其他操作" class="headerlink" title="queue和priority_queue的其他操作"></a><code>queue</code>和<code>priority_queue</code>的其他操作</h3><table><thead><tr><th><code>queue</code>和<code>priority_queue</code>的其他操作</th><th>含义</th></tr></thead><tbody><tr><td>q.pop()</td><td>返回queue的首元素或priority_queue的最高优先级元素，但不删除此元素</td></tr><tr><td>q.front()</td><td>返回首元素，但不删除此元素</td></tr><tr><td>q.back()</td><td>返回尾元素，但不删除此元素，只适用于queue</td></tr><tr><td>q.top()</td><td>返回优先级最高的元素，但不删除此元素，只适用于priority_queue</td></tr><tr><td>q.push(item)</td><td>在queue末尾或priority_queue中恰当的位置创建一个元素，其值为item，或者有args构造</td></tr><tr><td>q.emplace(args)</td></tr></tbody></table><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>适配器：adaptor<br>容器：container<br>迭代器范围：iterator range<br>首前迭代器： off-the-beginning iterator<br>尾后迭代器： off-the-end iterator<br>顺序容器： sequential container<br>左闭合区间： left-inclusive interval</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49800101" target="_blank" rel="external">C++primer第五版第九章学习笔记</a></li><li><a href="http://blog.csdn.net/libin1105/article/details/48676235" target="_blank" rel="external">《C++primer(第五版)》学习之路-第九章：顺序容器</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/18/CPP_09/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(八)IO类</title>
      <link>http://wangwlj.com/2018/01/17/CPP_08/</link>
      <guid>http://wangwlj.com/2018/01/17/CPP_08/</guid>
      <pubDate>Wed, 17 Jan 2018 05:18:49 GMT</pubDate>
      <description>
      
        &lt;p&gt;C++使用标准库类来处理面向流的输入和输出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iostream处理控制台IO&lt;/li&gt;
&lt;li&gt;fstream处理命名文件IO&lt;/li&gt;
&lt;li&gt;stringstream完成内存string的IO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类fstream和stringstream都继承自iostream。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>C++使用标准库类来处理面向流的输入和输出：</p><ul><li>iostream处理控制台IO</li><li>fstream处理命名文件IO</li><li>stringstream完成内存string的IO</li></ul><p>类fstream和stringstream都继承自iostream。<br><a id="more"></a></p><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>头文件<code>iostream</code>包含所有<code>i/o</code>流所需的基本信息，并定义有四个标准<code>i/o</code>流对象：</p><ul><li>cin：标准输入流对象（与标准输入设备连接）</li><li>cout ：标准输出流（与标准输出设备连接）</li><li>cerr ：非缓冲的标准错误流（默认设备为显示器）</li><li>clog ：经缓冲的标准错误流（默认设备为打印机）</li></ul><p>IO对象没有拷贝或者赋值。</p><h3 id="条件状态-P8-1-1，P279"><a href="#条件状态-P8-1-1，P279" class="headerlink" title="条件状态(P8.1.1，P279)"></a>条件状态(P8.1.1，P279)</h3><p>IO类定义了一些函数和标志，可以帮助我们访问和操纵流的条件状态(<code>condition state</code>)。</p><table><thead><tr><th style="text-align:center">条件状态</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">strm::iostate</td><td>由各个iostream类定义，用于定义条件状态</td></tr><tr><td style="text-align:center">strm::badbit</td><td>strm::iostate类型的值，用于指出被破坏的流</td></tr><tr><td style="text-align:center">strm::failbit</td><td>strm::iostate类型的值，用于指出失败的IO操作</td></tr><tr><td style="text-align:center">strm::eofbit</td><td>strm::iostate类型的值，用于指出流已经到达文件的结束符</td></tr><tr><td style="text-align:center">s.eof()</td><td>如果设置了流s的eofbit值，该函数返回true</td></tr><tr><td style="text-align:center">s.bad()</td><td>如果设置了流s的badbit值，该函数返回true</td></tr><tr><td style="text-align:center">s.fail()</td><td>如果设置了流s的failbit值，该函数返回true</td></tr><tr><td style="text-align:center">s.good()</td><td>如果流s处于有效状态，该函数返回true</td></tr><tr><td style="text-align:center">s.clear()</td><td>清空流s的所有状态，并设为true</td></tr><tr><td style="text-align:center">s.clear(flag)</td><td>给流s的某个条件状态位设置为true。flag，类型是strm::iostate</td></tr><tr><td style="text-align:center">s.setstate(flag)</td><td>给流s的添加指定条件。flag，类型是strm::iostate</td></tr><tr><td style="text-align:center">s.rdstate()</td><td>返回流s的当前条件，返回值类型是strm::iostate</td></tr></tbody></table><h3 id="刷新输出缓冲区"><a href="#刷新输出缓冲区" class="headerlink" title="刷新输出缓冲区"></a>刷新输出缓冲区</h3><p><code>endl</code> 操纵符，用于输出一个换行符并刷新缓冲区。<br><code>flush</code>操纵符，用于刷新流，但不在输出中添加任何字符。<br><code>ends</code>操作符，这个操纵符在缓冲区中插入空字符<code>null</code>，然后刷新它。</p><blockquote><p>如果程序崩溃（异常终止），输出缓冲区不会刷新。</p></blockquote><h2 id="文件输入输出-8-2，P283"><a href="#文件输入输出-8-2，P283" class="headerlink" title="文件输入输出(8.2，P283)"></a>文件输入输出(8.2，P283)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>; <span class="comment">//构建一个ifstream并打开给定文件</span></div><div class="line">ofstream out; <span class="comment">//输出文件流，没有与任何文件关联</span></div><div class="line">out.open(iflie +<span class="string">".copy"</span>); <span class="comment">//打开指定的文件</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>(out)  <span class="comment">//检查open是否成功</span></div></pre></td></tr></table></figure><h3 id="文件模式-8-2-2，P286"><a href="#文件模式-8-2-2，P286" class="headerlink" title="文件模式(8.2.2，P286)"></a>文件模式(8.2.2，P286)</h3><p>文件模式有：<code>in</code>,  <code>out</code>,  <code>app</code>（append的缩写，追加模式，写操作前定位到文件末尾）,  <code>ate</code>,  <code>trunk</code>（截断文件）,  <code>binary</code>。</p><blockquote><p>保留<code>ofstream</code>打开的文件中已有数据的唯一方法：显式地指定<code>app</code>或<code>in</code>模式。</p></blockquote><h2 id="string流-8-3，P287"><a href="#string流-8-3，P287" class="headerlink" title="string流(8.3，P287)"></a>string流(8.3，P287)</h2><p>标准库定义了三种类型的字符串流：<br><code>istringstream</code>，由<code>istream</code>派生而来，提供读<code>string</code>的功能。<br><code>ostringstream</code>，由<code>ostream</code>派生而来，提供写<code>string</code>的功能。<br><code>stringstream</code>，由<code>iostream</code>派生而来，提供读写<code>string</code>的功能。</p><p>stringstream 特定的操作：</p><table><thead><tr><th>stringstream 特有的操作</th><th>含义</th></tr></thead><tbody><tr><td>sstream strm;</td><td>strm是一个未绑定的stringstream对象。sstream是头文件sstream中定义的一个类型</td></tr><tr><td>sstream strm(s);</td><td>strm是一个sstream对象，保存string s的一个拷贝。此构造函数是explict的。</td></tr><tr><td>strm.str()</td><td>返回strm所保存的string的拷贝</td></tr><tr><td>strm.str(s)</td><td>将string s拷贝到strm中。返回void</td></tr></tbody></table><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>继承： inheritance<br>条件状态： condition state<br>文件模式： file mode<br>文件流： file stream<br>字符串流： string stream</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49799679" target="_blank" rel="external">C++primer第五版第八章学习笔记</a></li><li><a href="http://blog.csdn.net/libin1105/article/details/48675765" target="_blank" rel="external">《C++primer(第五版)》学习之路-第八章：IO库</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/17/CPP_08/#disqus_thread</comments>
    </item>
    
    <item>
      <title>C++ Primer学习笔记：(七)类</title>
      <link>http://wangwlj.com/2018/01/16/CPP_07/</link>
      <guid>http://wangwlj.com/2018/01/16/CPP_07/</guid>
      <pubDate>Tue, 16 Jan 2018 14:21:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;类是数据的抽象(&lt;code&gt;data abstraction&lt;/code&gt;)和封装(&lt;code&gt;encapsulation&lt;/code&gt;)。数据抽象是一种将接口(&lt;code&gt;interface&lt;/code&gt;)和实现(&lt;code&gt;implemention&lt;/code&gt;)分离的设计技术。接口是指用户可以对类使用的操作集。实现包括类的数据成员和接口函数体。封装使得类的使用者不必关注类内部是如何实现的，因为这些是类的设计者需要关注的。&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>类是数据的抽象(<code>data abstraction</code>)和封装(<code>encapsulation</code>)。数据抽象是一种将接口(<code>interface</code>)和实现(<code>implemention</code>)分离的设计技术。接口是指用户可以对类使用的操作集。实现包括类的数据成员和接口函数体。封装使得类的使用者不必关注类内部是如何实现的，因为这些是类的设计者需要关注的。<br><a id="more"></a></p><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="类的定义和声明"><a href="#类的定义和声明" class="headerlink" title="类的定义和声明"></a>类的定义和声明</h3><p>类由类成员组成。类成员包括属性，字段，成员函数，构造函数，析构函数等组成。</p><p>类设计应该遵从抽象封装性。</p><p>类抽象性指对于类的使用者来说只需知道类接口即可使用类功能。类的具体实现由设计者负责。即使某个功能发生了变更但由于使用者是以接口方式调用类所以用户代码无需做任何修改。</p><p>类封装性指类用户只需知道类的功能无需了解具体实现。实现代码对用户来说不可见。</p><p>C++类没有访问级别限制，定义类时不能用<code>public</code> 或 <code>private</code> 做修饰。类成员有访问级别，可以定义 <code>public protect private</code>。</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>每一个类的内部都有一个隐含的this指针，该参数是由系统负责维护。它的类型是<code>CLASSTYPE *const this;</code>，即指向某个类的const指针。所以this指针在初始化以后就不能改变。系统使用this指针来指明函数使用的是哪个实例的数据成员。</p><p>在调用成员函数时，系统会自动传递类实例的地址给this指针：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CLASSTYPE exm;  </div><div class="line">exm.func();</div></pre></td></tr></table></figure></p><p>可以将该函数调用理解为：<code>CLASSTYPE::func(&amp;exm);</code></p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>在调用成员函数时，会传递类实例的地址给<code>this</code>指针。如果该实例是const对象，那么非const指针是无法指向const对象的。可以在函数参数列表后加上<code>const</code>来表明是const成员函数。</p><p>因此，this也是指向常量的指针。</p><h3 id="类的作用域与成员函数"><a href="#类的作用域与成员函数" class="headerlink" title="类的作用域与成员函数"></a>类的作用域与成员函数</h3><p>编译器分两步处理类：</p><ul><li>首先编译成员的声明，</li><li>然后编译成员函数体。</li></ul><p>因此，成员函数体可以随意使用类中的其他成员。（不管定义先后）</p><h3 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> Sales_data::avg_price() <span class="keyword">const</span>&#123;</div><div class="line"><span class="keyword">if</span>(units_old)</div><div class="line">    <span class="keyword">return</span> revenue/units_old;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Sales_data &amp; Sales_data::combine(<span class="keyword">const</span> Sales_data &amp;rhs) <span class="keyword">const</span>&#123;</div><div class="line">units_old += rhs.units_old; <span class="comment">//把rhs的成员加到this对象上</span></div><div class="line">    revenue += rhs.revenue;</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回调用该函数的对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因此，执行<code>total.combine(trans)</code>语句时，是更新了变量total的值。</p><blockquote><p>引用类型返回左值。<code>return *this;</code>解引用this指针获得执行该函数的对象，也就是返回total的引用。</p></blockquote><h3 id="定义类相关的非成员函数-7-1-3-P234"><a href="#定义类相关的非成员函数-7-1-3-P234" class="headerlink" title="定义类相关的非成员函数(7.1.3,P234)"></a>定义类相关的非成员函数(7.1.3,P234)</h3><p>类的辅助函数，比如add，read和print等。概念上属于类的接口的组成部分，但实际上不属于类本身。</p><p>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件中。</p><h3 id="构造函数-7-1-4，P235"><a href="#构造函数-7-1-4，P235" class="headerlink" title="构造函数(7.1.4，P235)"></a>构造函数(7.1.4，P235)</h3><p>构造函数(<code>constructor</code>)是特殊的成员函数。在类对象定义时被调用。不能通过定义的类对象调用构造函数，<strong>构造函数可以定义多个或者说构造函数允许重载。</strong></p><p>如果没有定义任何构造函数，系统就会给类分配一个无参的默认构造函数(<code>default constructor</code>)，类只要定义了一个构造函数，编译器也不会再生成默认构造函数。只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。</p><p>定义类对象时不能写成 <code>Sales_item myobj();</code>，编译器会理解成：一个返回 Sales_item 类型叫 myobj的函数声明。 正确写法是去掉后面的括号。</p><p>构造函数<strong>不允许定义成 const</strong>，这样定义会产生语法错误： <code>Sales_item() const {};</code></p><p>构造函数在执行时会做类数据成员的初始化工作。从概念上讲，可以认为构造函数分两个阶段执行：（1）初始化阶段；（2）普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。</p><p>不管成员是否在构造函数初始化列表中显式初始化，类类型的数据成员总是在初始化阶段初始化。初始化发生在计算阶段开始之前。</p><h4 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Sales_data&#123;</div><div class="line"><span class="comment">//新增的构造函数</span></div><div class="line">Sales_data() = <span class="keyword">default</span>;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s): bookNo(s) &#123;&#125;</div><div class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, unsighed n, <span class="keyword">double</span> p): bookNo(s), units_sold(n), revenue(p*n) &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//之前已有的其他成员</span></div><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</div><div class="line"><span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line"><span class="keyword">unsigned</span> units_old = <span class="number">0</span>;</div><div class="line"><span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上述代码中，<code>= default</code>要求编译器生成默认构造函数。<br><code>Sales_data(const std::string &amp;s, unsighed n, double p): bookNo(s), units_sold(n), revenue(p*n) {}</code>中的冒号和花括号之间的部分叫做<font color="0AAA00"><strong>构造函数初始值列表</strong>(<code>constractor initialize list</code>)</font>。</p><blockquote><p>如果编译器不支持类内初始值，那么所有构造函数都应该显式地初始化每个内置类型的成员。</p></blockquote><p>当然也可以在类外定义构造函数。</p><h3 id="拷贝、赋值和析构-7-1-5，P239"><a href="#拷贝、赋值和析构-7-1-5，P239" class="headerlink" title="拷贝、赋值和析构(7.1.5，P239)"></a>拷贝、赋值和析构(7.1.5，P239)</h3><p>尽管编译器能为我们合成拷贝、赋值和析构的操作，但某些情况下可能无法正常工作。如分配和管理动态内存的类<code>（13.1.4, P447）</code>。</p><h2 id="访问控制与封装-7-2，P240"><a href="#访问控制与封装-7-2，P240" class="headerlink" title="访问控制与封装(7.2，P240)"></a>访问控制与封装(7.2，P240)</h2><p>访问说明符(<code>access specifiers</code>)：加强类的封装性：</p><ul><li>public：在整个程序内可被访问；</li><li>private：可以被类的成员函数访问。</li></ul><p><font color="0AAA00"><strong>使用class和struct唯一的区别就是默认的访问权限</strong></font>：<br><code>struct</code>默认是<code>public</code>，<code>class</code>默认是<code>private</code>。</p><h3 id="友元-7-2-1，P241"><a href="#友元-7-2-1，P241" class="headerlink" title="友元(7.2.1，P241)"></a>友元(7.2.1，P241)</h3><p>友元(<code>friend</code>)：<code>friend</code>关键字，允许其他类或者函数访问类的私有成员。</p><h2 id="类的其他特性-7-3，P243"><a href="#类的其他特性-7-3，P243" class="headerlink" title="类的其他特性(7.3，P243)"></a>类的其他特性(7.3，P243)</h2><p>可变数据成员(<code>mutable data member</code>)：永远不会是const，即使是const对象的成员。</p><p>类内初始值：必须以符号=或者花括号。</p><h3 id="返回-this的成员函数-7-3-2，P246"><a href="#返回-this的成员函数-7-3-2，P246" class="headerlink" title="返回*this的成员函数(7.3.2，P246)"></a>返回<code>*this</code>的成员函数(7.3.2，P246)</h3><p>返回值是调用对象的引用，返回引用的函数是左值的，意味着这些函数返回对象本身。</p><p>如果返回类型不是引用，则返回的是<code>*this</code>的副本。</p><h2 id="类的作用域-7-4，P253"><a href="#类的作用域-7-4，P253" class="headerlink" title="类的作用域(7.4，P253)"></a>类的作用域(7.4，P253)</h2><p>编译器处理完全部声明后，才会处理成员函数的定义。</p><h2 id="构造函数再探-7-5，P257"><a href="#构造函数再探-7-5，P257" class="headerlink" title="构造函数再探(7.5，P257)"></a>构造函数再探(7.5，P257)</h2><p>成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过<strong>构造函数初始值列表</strong>为这些成员提供初值。</p><h3 id="委托构造函数-7-5-2，P261"><a href="#委托构造函数-7-5-2，P261" class="headerlink" title="委托构造函数(7.5.2，P261)"></a>委托构造函数(7.5.2，P261)</h3><p>委托构造函数(<code>delegating constructor</code>)：使用使用所属类的其他构造函数执行自己的初始化过程。成员初始值列表唯一，是类名本身。</p><p><code>explicit</code>：抑制构造函数定义的隐式转换，只对一个实参的构造函数有效。且只能在类内声明的时候采用<code>explicit</code>关键字。</p><p>字面值常量类：<code>constexpr</code></p><h2 id="类的静态成员-7-6，P269"><a href="#类的静态成员-7-6，P269" class="headerlink" title="类的静态成员(7.6，P269)"></a>类的静态成员(7.6，P269)</h2><p>一般来说，我们不能在类内初始化静态成员。相反，必须在类的外部定义和初始化每个静态成员。</p><p>定义并且初始化一个静态成员：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> Account::interestRate = initRate();</div></pre></td></tr></table></figure></p><p>定义静态数据成员的方式和在类外定义成员函数差不多。</p><p>只有字面值常量类型<code>constexpr</code>的静态成员可以在类内，且初始值必须是常量表达式。</p><p>如果类内部声明提供了初始值，则外部定义时不能提供初始值。</p><p>静态数据成员可以是不完全类型，如类类型；非静态成员只能是类的指针或者引用。</p><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>class 关键字： class keyword<br>构造函数： constructor<br>构造函数初始值列表： constructor initializer list<br>类的作用域： class scope<br>委托构造函数： delegating constructor<br>显示构造函数： explicit constructor<br>接口：interface<br>数据抽象：data abstraction<br>可变数据成员： mutable data member<br>友元： friend</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>C++ Primer 中文第五版</li><li><a href="http://blog.csdn.net/sunhero2010/article/details/49798749" target="_blank" rel="external">C++primer第五版第七章学习笔记</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/16/CPP_07/#disqus_thread</comments>
    </item>
    
    <item>
      <title>判断int是否为3的幂—— Leetcode(326)</title>
      <link>http://wangwlj.com/2018/01/13/leetcode_326_power_of_3/</link>
      <guid>http://wangwlj.com/2018/01/13/leetcode_326_power_of_3/</guid>
      <pubDate>Sat, 13 Jan 2018 14:15:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;leetcode链接：&lt;a href=&quot;https://leetcode.com/problems/power-of-three/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;326. Power of Three&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an integer, write a function to determine if it is a power of three.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Could you do it without using any loop / recursion?&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>leetcode链接：<a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></p><blockquote><p>Given an integer, write a function to determine if it is a power of three.</p><p>Follow up:<br>Could you do it without using any loop / recursion?</p></blockquote><a id="more"></a><p>一般的通用解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfThree(int n) &#123;</div><div class="line">        while (n &gt;= 3 )&#123;</div><div class="line">            if(n % 3 != 0)</div><div class="line">                return false;</div><div class="line">            n /= 3;   </div><div class="line">        &#125;</div><div class="line">        return n&gt;0 &amp;&amp; n != 2;     </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>上述可以通过，但是题目说最好尝试一下非循环或者递归的解法。</p><p>我感觉此类方法就是有点取巧了。如，找出<code>int</code>范围内最大的3的倍数，所以任何3的倍数<code>n</code>都可以被其整除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isPowerOfThree(int n) &#123;</div><div class="line">        //方法2</div><div class="line">        const int maxint = 0x7fffffff;</div><div class="line">        //假设3^k 是int范围内最大的3的幂</div><div class="line">        int k = int(log(maxint) / log(3));</div><div class="line">        int max_power_3 = pow(3,k);</div><div class="line">        return n&gt;0 &amp;&amp; max_power_3 % n ==0;  </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>或者将上述代码压缩到一行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; <span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="number">3</span>,<span class="keyword">int</span>(<span class="built_in">log</span>(<span class="number">0x7fffffff</span>) / <span class="built_in">log</span>(<span class="number">3</span>)))) % n == <span class="number">0</span>;</div></pre></td></tr></table></figure></p><blockquote><p><code>pow</code>函数在头文件<code>math.h</code>中。</p></blockquote><p>同类题：</p><ol><li><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="external">231. Power of Two</a></li><li><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="external">326. Power of Three</a></li><li><a href="https://leetcode.com/problems/power-of-four/description/" target="_blank" rel="external">342. Power of Four</a></li></ol>]]></content:encoded>
      
      <comments>http://wangwlj.com/2018/01/13/leetcode_326_power_of_3/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
