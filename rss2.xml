<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>王立杰的博客</title>
    <link>https://wangwlj.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>所谓王者，必卓然特立，争当人杰。</description>
    <pubDate>Mon, 25 Dec 2017 02:38:47 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>C++ Primer学习笔记：(1/2)开始、变量与基本类型</title>
      <link>https://wangwlj.com/2017/12/25/CPP_01_02/</link>
      <guid>https://wangwlj.com/2017/12/25/CPP_01_02/</guid>
      <pubDate>Mon, 25 Dec 2017 02:31:35 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;第一章-开始&quot;&gt;&lt;a href=&quot;#第一章-开始&quot; class=&quot;headerlink&quot; title=&quot;第一章 开始&quot;&gt;&lt;/a&gt;第一章 开始&lt;/h1&gt;&lt;h2 id=&quot;include指令-P6-1-2&quot;&gt;&lt;a href=&quot;#include指令-P6-1-2&quot; cla
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="第一章-开始"><a href="#第一章-开始" class="headerlink" title="第一章 开始"></a>第一章 开始</h1><h2 id="include指令-P6-1-2"><a href="#include指令-P6-1-2" class="headerlink" title="include指令(P6,1.2)"></a>include指令(P6,1.2)</h2><p>通常情况下<code>#include</code>指令必须在所有函数之外。include和它想包含的头文件名字必须在同一行里，不然会报错。</p><p>一般情况下我们把include指令放在源文件代码内容的最前面，当你在源文件中使用<code>#include</code>声明了一个头文件，效果相当于你把整个头文件黏贴到对应的那一行上。</p><h2 id="编译器-P14-1-4"><a href="#编译器-P14-1-4" class="headerlink" title="编译器(P14,1.4)"></a>编译器(P14,1.4)</h2><p>编译器的一部分工作是寻找程序文本中的错误。<br>常见错误类型：</p><ul><li>语法错误(syntax error)</li><li>类型错误(type error)</li><li>声明错误(declaration error)</li></ul><p><strong>“编辑-编译-调试”（edit-compile-debug）</strong>周期。</p><h2 id="文件重定向-P19-1-5"><a href="#文件重定向-P19-1-5" class="headerlink" title="文件重定向(P19,1.5)"></a>文件重定向(P19,1.5)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span> addItems &lt;infile &gt;outfile</div></pre></td></tr></table></figure><h2 id="专业术语-P23"><a href="#专业术语-P23" class="headerlink" title="专业术语(P23)"></a>专业术语(P23)</h2><ol><li>花括号 curly brace</li><li>内置类型 built-in type</li><li>形参列表 parameter list</li><li>字符串字面值常量 string literal</li><li>操作符 manipulator</li><li>变量 variable</li><li>初始化 initialize</li><li>注释 comments</li><li>集成开发环境 Integrated Developed Environment,IDE</li><li>条件 condition</li><li>赋值 assignment</li><li>表达式 expression</li><li>语法错误 syntax error</li><li>方法（类方法） method</li></ol><h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="C-语言关于类型的规定-P30-2-1-1"><a href="#C-语言关于类型的规定-P30-2-1-1" class="headerlink" title="C++语言关于类型的规定(P30,2.1.1)"></a>C++语言关于类型的规定(P30,2.1.1)</h2><p>C++语言的基本类型的设定与硬件紧密相关，因此很多类型的内存尺寸也都只是给了一个范围，其实各家IDE（LLVM，GCC，Visaul C++）的实现都是在范围内，具体的实现细节都是不确定的。</p><p>其中bool最小尺寸未定义，char最小尺寸是8位，wchar_t和char16_t的最小尺寸都是16位，char32_t的最小尺寸是32位，int的最小尺寸是16位，long和long long的最小尺寸分别是32位和64位，对于浮点型数据的表现尺寸是按照精度计算的，其中float的最小尺寸精度是小数点后6位(通常占内存32bytes)，double（通常占内存 64bytes）和long double(通常占内存 96~128bytes)的最小尺寸精度则是小数点后10位(实际可能比这个精度要大一些，比如float小数点后有效位为7，double为16)。</p><p>int不得小于short,long不得小于int,long long不得小于long。float,double,long double也应该是精度递增（或者相同）的关系。</p><p>要特别注意的是，<strong>扩展的字符类型</strong>(char16_t，char32_t，wchar_t)<strong>和布尔类型都没有带符号和无符号之分</strong>（尽管它们也确实属于算数类型）。</p><h2 id="类型转换-P32-2-1-2"><a href="#类型转换-P32-2-1-2" class="headerlink" title="类型转换(P32,2.1.2)"></a>类型转换(P32,2.1.2)</h2><p>程序自动执行的类型转换操作发生在程序里IDE预期我们使用A类型但是实际上我们使用B类型的时候，B类型的对象会自动转换为A类型的，如果没法转换，程序就会报错。赋值操作中就可能发生这样的情况。</p><p>我们先看赋值操作里表达式里面发生的自动转换，赋值操作A=B中，等号左边的A被叫做<strong>左值</strong>，B被叫做<strong>右值</strong>，程序期待事情是你给定的右值和左值类型完全相同。如果不相同，这里就会发生<strong>强制的类型转换</strong>，即把B的类型转化为A的类型。如果把一个超出左值类型表达范围的数赋值给左值，左值又是一个无符号类型，比如<code>unsigned char c=-1;</code>这时-1（整型，负的），右值会转化为无符号字符型，初始值对无符号类型表示数值总数取模，然后求余数，这个余数就是转化后的数。</p><p>因为C++没有明确规定有符号类型的数应该如何表示，因此如果把一个超出左值类型表达范围的数赋值给左值，左值又是一个有符号类型，这种行为的结果是不一定的，因为C++标准委员会没有规定这样做之后到底会发生什么，因此各个IDE可能会有不同的实现。我们把这种不确定造成结果的行为叫做<strong>未定义行为</strong>。</p><p><strong>建议：避免无法预知和依赖于环境的行为</strong>。</p><p><strong>提示：切勿混用带符号类型和无符号类型</strong>。</p><h2 id="转义序列-P36，2-1-3"><a href="#转义序列-P36，2-1-3" class="headerlink" title="转义序列(P36，2.1.3)"></a>转义序列(P36，2.1.3)</h2><p>字符的转义序列可以为<code>\</code>后面加上最多3个8进制数字（如果多于3个不会引发报错，多出的部分会被当成字符），或者<code>\x</code>后面加上最多两个16进制数字（多出会报错）。数字转换成10进制后的大小不得超过字符集的限定范围。一般的字面值转义无此限制，不过，一般的字面值的类型是不确定的。10进制数字类型字面值会被转换为能够容纳这个数的带符号整数类型，其他进制中它们则会被转换为能容纳它们的占内存最小的类型的值。</p><p>在最新的C++14标准中，数字字面值里还允许以0b或者0B开头，后面加上二进制数成为二进制字面值。如0B101，代表数字5；0b11，代表数字3。</p><p>指定字面值的常量：当使用一个长整型字面值时，请使用大写字母<code>L</code>来标记，因为小写字母<code>l</code>和数字<code>1</code>太容易混淆了。</p><h2 id="变量-P38"><a href="#变量-P38" class="headerlink" title="变量(P38)"></a>变量(P38)</h2><h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>C++11标准：列表初始化(list initialization)，用一组花括号来初始化变量。下面的第三种：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> units_sold = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</div></pre></td></tr></table></figure></p><h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p><strong>变量能且只能被定义一次，但是可以被多次声明。</strong>声明变量：在变量名前添加关键字<code>extern</code>，而且不要显示地初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;        <span class="comment">// 仅仅是声明</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">0</span>;     <span class="comment">// 声明且定义</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> v;             <span class="comment">// 声明且定义</span></div><div class="line"><span class="keyword">int</span> a = <span class="number">0</span>;        <span class="comment">// 声明且定义</span></div></pre></td></tr></table></figure></p><p>在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。</p><p>补：</p><blockquote><p>extern外部变量声明其实是在IDE进行编译的时候告诉IDE，这有一个外部变量你要去别的地方找。因此我们应该掌握编译链接这套流程才能够更加方便的会用extern。假设有一个头文件a.h，这个头文件里面定义了int aaa=0;还有一个源文件b.cpp。这个b.cpp里面使用了extern int aaa;这样的语句，那么这个b.cpp是编译不了的。因为头文件如果不被别的源文件引用，是不参与被编译为obj的过程的，一旦它不参与这个过程，它里面声明的aaa这个全局变量其实就不存在，因此在b.cpp里面外部生命一个不存在的变量自然就是非法的。另外，使用extern也要和static做区分并考量它在别的文件中会不会造成内存污染等问题。这里应该掌握分离式编译的编译和链接特性再使用extern比较好。</p></blockquote><p><strong>静态类型</strong>(P42)</p><h3 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h3><p><strong>初始化所有指针</strong>： 初始化为nullptr或0。</p><p><strong>void *指针</strong>(P50)：特殊的指针类型，可以存放任意对象的地址。我们对该指针中到底是个什么类型的对象并不了解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p1,p2;</div></pre></td></tr></table></figure><p>其中，p1是指向int的指针，p2是int。(强调变量具有的复合类型。)</p><p><strong>指向指针的指针</strong>：通过<code>*</code>的个数可以区分指针的级别，即：<code>**</code>表示指向指针的指针，<code>***</code>表示指向指针的指针的指针。</p><p><strong>指向指针的引用</strong>(P52)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</div><div class="line"><span class="keyword">int</span> *p;</div><div class="line"><span class="keyword">int</span> *&amp;r = p; <span class="comment">//r是对指针p的引用</span></div><div class="line"></div><div class="line">r = &amp;i; <span class="comment">//r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span></div><div class="line">*r = <span class="number">0</span>; <span class="comment">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></div></pre></td></tr></table></figure></p><p><font color="00cc00"><strong>面对一条比较复杂的指针或者引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义</strong></font>。<br>离变量名最近的符号（此例中是<code>&amp;r</code>的符号<code>&amp;</code>）对<strong>变量的类型有最直接的影响</strong>，因此<code>r</code>是一个引用。声明符的其余部分用以确定<code>r</code>引用的类型是是什么，此例中的符号<code>*</code>说明<code>r</code>引用的是一个指针。最后，声明的基本数据类型部分指出<code>r</code>引用的是一个<code>int</code>指针。</p><h2 id="顶层const-P57-2-4-3"><a href="#顶层const-P57-2-4-3" class="headerlink" title="顶层const(P57,2.4.3)"></a>顶层const(P57,2.4.3)</h2><p>顶层const是对const而言的，“顶层”可以用来修饰<code>const</code>状态的形容词。一个<code>const</code>使对象本身的值固定，这个<code>const</code>就被称为顶层const;一个<code>const</code>是对象指向或引用的对象成为固定值，这个const就被称为底层const。</p><p>顶层和底层const对拷贝来说密切相关，有相同底层const资格的两个对象才能够互相拷贝，而且顶层const声明变量之后不允许再次改变const的值。<br><code>int p,const int *a＝&amp;p;</code>这种语句中的const就是底层const。<br>像<code>int v1=9;const int *p=&amp;v1;int *p2=p;</code>这种语句如果能够通过编译，那么我们就可以使用p2的性质改变p1指向的常量的值，但是常量的值是不能够被改变的，因此这种变相改变常量的值的表达式都是错误的。可以通过分析const级别得到表达式中常量是否被更改，从而判断语句的正确性。</p><p>说到底，顶层底层说的是对拷贝控制的约束。总的规则就是“不能改变常量的值”。因此“拷入和拷出的对象都要有相同的底层const资格，或者两个对象数据类型必须能转换”，例如，有<code>int *p1,const int *p2;</code>。p1没有底层const,p2有底层const。p1=p2;这时<code>const int*</code>不能转换成<code>int *</code>(如果转换，就违反了“不能改变常量的值这一约束条件”)，因此<code>p1=p2;</code>不合法。<code>p2=p1;``int *</code>能够转换成<code>const int *</code>,因此<code>p2=p1</code>合法。</p><h2 id="constexpr-P58-2-4-4"><a href="#constexpr-P58-2-4-4" class="headerlink" title="constexpr(P58,2.4.4)"></a>constexpr(P58,2.4.4)</h2><p>我们在了解<code>constexpr</code>之前，应该先了解<strong>常量表达式</strong>。所谓常量就是固定的量，那么常量表达式就是值固定不变的表达式，这里“值固定不变”，指的是程序编译阶段，常量表达式的值就能被确定下来之后也不能对其进行任何种方式的修改。因此这个固定，是编译之后固定的。像<code>cout&lt;&lt;1234&lt;&lt;endl;</code>中的1234，就是常量表达式，显然，字面值是常量表达式。</p><p><code>constexpr</code>的作用之一就是帮助程序员在IDE的提示下查看一个赋值语句是不是常量表达式。使用的方式包含在声明语句里面，形如<code>constexpr 变量类型 变量名=右值;</code>如果右值是一个常量，这条语句就是正确的。在所有函数体外声明的全局变量的地址就符合“在编译期间能确定，编译后值不被改变”这两个条件，因此也属于常量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>; <span class="comment">// 20是常量表达式</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>; <span class="comment">// mf+1是常量表达式</span></div><div class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = size(); <span class="comment">//只有当size是一个constexpr函数时，才是一条正确的语句。</span></div></pre></td></tr></table></figure></p><p>另外，用constexpr声明的指针(比如，<code>constexpr int *p=&amp;v1;</code>中的<code>*p</code>，相当于<code>int *const p=&amp;v1;</code>)都是顶层const，即指针本身值固定。但是指针指向的内容是可以变的。引用也一样。</p><p><strong>定义于函数体之外的变量的地址是固定的，可以用来初始化constexpr指针</strong>。</p><p>当你使用constexpr定义引用变量的时候，这个变量引用的对象只能是全局基本数据类型（引用类型除外的）变量（因为要求的内存地址必须是固定不变的）。constexpr引用的结果和正常的引用的结果是一致的，因为引用本身就是固定不变的，因此相当于顶层const修饰的constexpr对引用类型类说没有特殊的意义。 </p><h2 id="类型别名-P61-2-4-4"><a href="#类型别名-P61-2-4-4" class="headerlink" title="类型别名(P61,2.4.4)"></a>类型别名(P61,2.4.4)</h2><p>使用<code>typedef int zhengxing;</code>这种对简单的类型名进行替换的方式无疑是非常直观并且好理解的，但是在涉及到复杂的类型名的时候往往会出现各种各样的问题。</p><p>比如<code>typedef char *Pstring;</code>这条语句是不是就意味着我们看到<code>Pstring</code>就可以用<code>char *</code>替换呢。其实并不是，实际上类型别名不只是替换的规则，而是要复杂很多。</p><p>比如我们遇到<code>const Pstring a;</code>的时候，按照替换的规则，这条语句就相当于<code>const char * a;</code>这里的const这种情况下是底层const，但是结果并不是这样的，这条语句正确的等同语句应该是<code>char *const a;</code>是一个顶层const，即指针本身是一个常量。让我们来分析一下为什么是这个样子，而不是简单的替换就行了。<code>typedef char *Pstring；</code>这条语句就是说<code>Pstring</code>是一个类型别名，它是什么类型的类型别名呢？Pstring是 指向char的指针的类型别名，也就是说，这个类型修饰的对象必须是一个指针，这个指针也必须指向char而不能指向别的什么东西，比如，不能指向<code>const char</code>。我们再看看<code>const Pstring a;</code>这个语句，首先a一定是指向char的指针。所以这个前面的const应该是用来修饰这个指针本身。也就是说，这个指针是<strong>常量指针</strong>而非指向常量的指针。这一点非常重要。</p><p><code>const char * a</code>这个语句里面，实际上类型是<code>const char</code>，<code>*</code>是声明符的一部分。我们说过，定义一个变量由两部分组成，类型名和声明符，声明符可以是<code>*</code>或者<code>&amp;</code>加上变量名的形式。而类型别名只是给类型一个别名，至于声明符是怎样的，不在它修饰的范围内。因此在有const的情况下，就可以看出来这两者之间的区别还是很明显的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</div><div class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//cstr是指向char的常量指针</span></div><div class="line"><span class="keyword">const</span> pstring *ps; <span class="comment">//ps是一个指针，它的对象是指向char的常量指针。</span></div></pre></td></tr></table></figure><p>pstring实际上是指向char的指针，因此，const pstring就是指向char的常量指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const char *cstr = 0; //是对const pstring的错误理解</div></pre></td></tr></table></figure></p><p>数据类型就变成了<code>char</code>，<code>*</code>成为了声明符的一部分。这样改写的结果是，<code>const char</code>成了基本数据类型。cstr是一个指针，指向了常量字符。</p><h2 id="auto类型声明符-P61-2-5-2"><a href="#auto类型声明符-P61-2-5-2" class="headerlink" title="auto类型声明符(P61,2.5.2)"></a>auto类型声明符(P61,2.5.2)</h2><p>C++11中引入的auto主要有两种用途：自动类型推断和返回值占位。auto在C++98中的标识临时变量的语义，由于使用极少且多余，在C++11中已被删除。前后两个标准的auto，完全是两个概念。</p><p><code>auto</code>变量通过初始化语句，计算出右值的类型，并推导出左值的类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i=<span class="number">0</span>, &amp;r = i;</div><div class="line"><span class="keyword">auto</span> a = r; <span class="comment">// a是一个整数（r是i的别名，而i是一个整数）</span></div></pre></td></tr></table></figure></p><p>这个过程中auto将会忽视顶层const和引用类型，可用<code>const auto &amp;a=i;</code>这种方式显式地指出了：指出要推导的结果是带顶层指针属性的或者是引用属性的。</p><p>auto推导多个值时，这些值的类型必须是一样的。因为auto是利用初始化赋值，因此它的行为基本上也和初始化有关。</p><p>关于auto的更多用法：<a href="http://blog.csdn.net/zxh2075/article/details/9235591" target="_blank" rel="external">【C++11】新特性——auto的使用</a></p><h2 id="decltype类型指示符-P62-2-5-3"><a href="#decltype类型指示符-P62-2-5-3" class="headerlink" title="decltype类型指示符(P62,2.5.3)"></a>decltype类型指示符(P62,2.5.3)</h2><p>有时候会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为此，C++11新标准引入第二种类型说明符<code>decltype</code>。</p><p><code>decltype</code>不通过计算，只通过推算出变量应有的值，表达式本身应有的值和函数的返回值来<strong>推导类型</strong>。</p><p>对于变量类型，<code>decltype</code>保留顶层const和引用的属性。对于表达式，<strong>解引用表达式(如:<code>int i=1; int *p=&amp;i; decltype (*p) a=i;</code>中的<code>*p</code>,对p解引用是<code>int &amp;</code>类型的)和带括号的表达式，（如：<code>decltype ((a+1)) c=i;</code>）的结果都将是引用类型</strong>。因为decltype通过处理表达式得到结果，因此更详细的内容在<em>第四章</em>将会被提到。有的表达式返回左值，有的表达式返回右值，返回左值的表达式在decltype类型推导下得到的将是引用的结果。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">42</span>,*p = &amp;i, &amp;r = i;</div><div class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">//正确，加法结果为int，因此b是一个（未初始化的）int</span></div><div class="line"><span class="keyword">decltype</span>(*p) c; <span class="comment">//错误，c是int&amp;，必须初始化</span></div><div class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">//错误，c是int&amp;，必须初始化</span></div><div class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">//正确，e是一个（未初始化的）int</span></div></pre></td></tr></table></figure></p><blockquote><p><strong>decltype((variable)) (注意是双层括号)的结果永远是引用</strong>，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。</p></blockquote><p>补：</p><ol><li><p>一般情况下，出现数组名的表达式时会把数组名转换为<strong>指针</strong>，而用decltype一个数组名时，其返回类型是<strong>该数组的类型</strong>，如有int ia[10]，则<code>decltype(ia) da</code>，此时da也为包含10个int元素的数组。用于函数时也一样，不会自动把函数名转换为指针，而是返回该函数类型。</p></li><li><p>如果作用于一个取地址运算符，则为指向指针的指针，如有int p，则<code>decltype(&amp;p)</code>的结果是<code>int **</code>类型。</p></li></ol><h2 id="用关键字struct自定义数据结构"><a href="#用关键字struct自定义数据结构" class="headerlink" title="用关键字struct自定义数据结构"></a>用关键字struct自定义数据结构</h2><p>使用struct关键字定义类的形式如<code>struct 类名｛数据成员类型1 数据成员名1；数据成员类型2 数据成员名2;｝;</code>，C++11规定可以给类内成员提供类内初始值用于初始化用我们自定义类创建的对象实例中的成员的值。形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> student=<span class="number">0</span>;</div><div class="line">    <span class="keyword">float</span> numbers=<span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><blockquote><p> 很多新手程序员忘记在类定义的最后加上分号。</p></blockquote><h2 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span>&#123;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</div><div class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</div><div class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure><p>头文件保护符依赖于预处理变量。如<code>#define DEBUG</code>，此时<code>DEBUG</code>就是预处理器变量。预处理变量无视C++语言中关于作用域的规则。</p><blockquote><p>头文件保护符很简单， 程序员只要<strong>习惯性加上</strong>就可以了，没必要太在乎你的程序到底需不需要。</p></blockquote><h2 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h2><p>1.算数类型 arithmetic type<br>2.整型 integral type<br>3.转换 convert<br>4.不可打印 nonprintable<br>5.转义序列 escape sequence<br>6.类型说明符 type specifier<br>7.分离式编译 separate compilation<br>8.声明 declaration<br>9.声明符 declarator<br>10.静态类型 statically typed<br>11.类型检查 type checking<br>12.标识符 identifier<br>13.内层作用域 inner scope<br>14.复合类型 compound type<br>15.左值引用 lvalue reference<br>16.预处理 preprocessor<br>17.临时量 temporary<br>18.指向常量的指针 pointer to const<br>19.常量指针 const pointer<br>20.字面值类型 literal type<br>21.类型别名 type alias<br>22.类内初始值 in-class initializer<br>23.预处理器 preprocessor<br>24.头文件保护符 header guard</p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/25/CPP_01_02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>photoshop白色背景图片转换为透明背景</title>
      <link>https://wangwlj.com/2017/12/21/ps_white2transparent/</link>
      <guid>https://wangwlj.com/2017/12/21/ps_white2transparent/</guid>
      <pubDate>Thu, 21 Dec 2017 13:45:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;1.打开Adobe Photoshop以及待处理的图片，如果图层上有“锁”的标志，就双击进行解锁；&lt;br&gt;&lt;img src=&quot;https://images2.imgbox.com/4e/6d/W7BRQIVn_o.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.在图层上右击，
        
      
      </description>
      
      <content:encoded><![CDATA[<p>1.打开Adobe Photoshop以及待处理的图片，如果图层上有“锁”的标志，就双击进行解锁；<br><img src="https://images2.imgbox.com/4e/6d/W7BRQIVn_o.png" alt="1"></p><p>2.在图层上右击，选择最上方的“混合选项”；<br><img src="https://images2.imgbox.com/40/79/k93NwYyF_o.png" alt=""></p><p>3.在混合选项中的本图层中，拖动右侧的白色小三角，向左滑动至适当位置。<br><img src="https://images2.imgbox.com/e4/a0/9gpxW33B_o.png" alt=""></p><p>4.效果展示。滑动之前的效果：<br><img src="https://images2.imgbox.com/93/b7/CRkJk51e_o.jpg" alt=""><br>滑动之后的效果：<br><img src="https://images2.imgbox.com/64/5c/lcI8vPjg_o.jpg" alt=""></p><p>5.存储。选择“文件”中的“存储为”；<br><img src="https://images2.imgbox.com/90/bf/osDfROqU_o.png" alt=""></p><p>在弹出窗口中选择保存类型为“PNG”格式，保存即可。也可以根据需要，选择合适的格式。<br><img src="https://images2.imgbox.com/18/da/M04vdmM2_o.png" alt=""></p><p>最后附上全文的<a href="https://wx3.sinaimg.cn/mw1024/c38a0784ly1fmop679zh6j215z2sn7wh.jpg" target="_blank" rel="external">图片链接</a>。</p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/21/ps_white2transparent/#disqus_thread</comments>
    </item>
    
    <item>
      <title>个人博客的域名注册与备案流程</title>
      <link>https://wangwlj.com/2017/12/19/blog_domain_register/</link>
      <guid>https://wangwlj.com/2017/12/19/blog_domain_register/</guid>
      <pubDate>Tue, 19 Dec 2017 04:17:15 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;域名注册&quot;&gt;&lt;a href=&quot;#域名注册&quot; class=&quot;headerlink&quot; title=&quot;域名注册&quot;&gt;&lt;/a&gt;域名注册&lt;/h2&gt;&lt;p&gt;简要说一下为什么选择&lt;strong&gt;万网&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看到网上的教程一般都是推荐到国外网站注册，如go
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h2><p>简要说一下为什么选择<strong>万网</strong>。</p><p>看到网上的教程一般都是推荐到国外网站注册，如godaddy，Gandi，Namesilo等等。<br>但一般都是比较早期的回答(2011-13)了，目前(2017/12)来说，仅从<strong>价格</strong>因素考虑，阿里云万网域名是普遍低于国外网站的。</p><p><strong>万网域名注册地址</strong>：<a href="https://wanwang.aliyun.com/domain/" target="_blank" rel="external">https://wanwang.aliyun.com/domain/</a></p><p>另外，关于<strong>域名后缀</strong>选择问题，一般来说，<strong>首选com域名</strong>，不推荐cn域名（国内监管严格的原因？）。其次，个人博客站点可以考虑其他后缀，如net，top，me(貌似万网不支持了)，xyz等等。</p><p>选择了心仪的域名之后，购买。以阿里云为例，购买完成后，点击右上角的<strong>控制台</strong>；进入控制台后，选择左下角的<strong>域名与网站（万网）</strong>下的<strong>域名</strong>，进入域名列表界面。</p><p>可以看到，右方出现了三个选项【续费】、【解析】【管理】<br><img src="https://images2.imgbox.com/cc/51/JLumBDiL_o.png" alt="域名列表界面"></p><p>点击<strong>解析</strong>，按照操作，添加解析即可。主要填写三个参数：记录类型、主机记录和记录值。</p><p><strong>记录类型</strong>：CNAME是跳转到其他网址，我的是github博客，就直接让他跳转到github博客即可。A是指向IPV4地址。</p><p><strong>主机记录</strong>是网址的前缀，比如说注册的网址是xxx.com，那么blog.xxx.com的主机记录就是blog，xxx.com的主机记录可以不填，也可以填上一个@</p><p>给出我目前的解析值作为参考。<br><img src="https://images2.imgbox.com/8f/d8/befX67KY_o.png" alt="解析值"><br>第一个是为了让百度搜索引擎抓取的，每个网址的主机记录都不同，可以忽略。</p><h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p>我使用的是<a href="http://wangwlj.com/2017/09/08/blog_setup/">hexo+Github搭建个人博客</a>，因此，只买了域名（也可以不买，直接使用github.io地址），没有买云服务器、虚拟主机之类的，因此无法备案。</p><p>简而言之，备案需要有<strong>服务器</strong>，然后到服务器提供商处备案即可。</p><p>阿里云官方的备案完整流程，可供备案参考：<a href="https://help.aliyun.com/knowledge_detail/36895.html" target="_blank" rel="external">https://help.aliyun.com/knowledge_detail/36895.html</a></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/19/blog_domain_register/#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo博客优化之实现来必力评论功能</title>
      <link>https://wangwlj.com/2017/12/18/blog_comment/</link>
      <guid>https://wangwlj.com/2017/12/18/blog_comment/</guid>
      <pubDate>Mon, 18 Dec 2017 12:11:50 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;评论功能概述&quot;&gt;&lt;a href=&quot;#评论功能概述&quot; class=&quot;headerlink&quot; title=&quot;评论功能概述&quot;&gt;&lt;/a&gt;评论功能概述&lt;/h2&gt;&lt;p&gt;目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="评论功能概述"><a href="#评论功能概述" class="headerlink" title="评论功能概述"></a>评论功能概述</h2><p>目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。</p><p>可用的评论系统大概有：</p><ul><li><p>HyperComments：<a href="https://www.hypercomments.com" target="_blank" rel="external">https://www.hypercomments.com</a> （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气，，）</p></li><li><p>来必力：<a href="https://livere.com" target="_blank" rel="external">https://livere.com</a> （来自韩国，使用邮箱注册。）</p></li><li><p>畅言： <a href="http://changyan.kuaizhan.com" target="_blank" rel="external">http://changyan.kuaizhan.com</a> （安装需要备案号。不太好用。）</p></li><li><p>Gitment： <a href="https://github.com/imsun/gitment" target="_blank" rel="external">https://github.com/imsun/gitment</a> （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。）</p></li><li><p>Valine:  <a href="https://github.com/xCss/Valine" target="_blank" rel="external">https://github.com/xCss/Valine</a> (基于Leancloud的极简风评论系统，用了下，没效果，是我Next主题的原因还是？）</p></li></ul><p>综上，最终采用了来必力。</p><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>打开来必力官网：<br><a href="https://livere.com" target="_blank" rel="external">https://livere.com</a></p><p>按套路注册（有可能注册上面要花费点功夫）。（貌似需要科学上网？之前没科学上网好像登录界面显示不了）。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>点击上方的安装，选择免费的city版本。</p><p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fml5edyp4bj20wt0lymyx.jpg" alt=""></p><p>并点击现在安装，出现如下界面。<br><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fml5ekh4erj20yh0me0uf.jpg" alt=""></p><p>复制其中的uid字段。</p><p>打开主题目录下的<code>blog/themes/next/_config.yml</code>配置文件，定位到<code>livere_uid</code>字段，粘贴上刚刚复制的UID。</p><p>至此，大功告成。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>测试评论如图所示：<br><img src="https://images2.imgbox.com/b3/f1/9s6btT5a_o.png" alt=""></p><h2 id="设置提醒"><a href="#设置提醒" class="headerlink" title="设置提醒"></a>设置提醒</h2><p>当有新评论出现时，通过邮箱提醒。</p><p>点击<code>右上角-&gt;管理页面</code>。选择<code>评论提醒</code>，按照下图设置，输入邮箱、选择间隔时间。</p><p><img src="https://images2.imgbox.com/36/9a/23YhEmlz_o.png" alt=""></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/18/blog_comment/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(2) 第三章函数的增长</title>
      <link>https://wangwlj.com/2017/12/13/algorithm_tutorial_chapter_3/</link>
      <guid>https://wangwlj.com/2017/12/13/algorithm_tutorial_chapter_3/</guid>
      <pubDate>Wed, 13 Dec 2017 14:51:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;3-1-渐近记号&quot;&gt;&lt;a href=&quot;#3-1-渐近记号&quot; class=&quot;headerlink&quot; title=&quot;3.1 渐近记号&quot;&gt;&lt;/a&gt;3.1 渐近记号&lt;/h2&gt;&lt;p&gt;$\Theta、 \text{O}和\Omega $三种记号的图示：&lt;br&gt;&lt;img src
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="3-1-渐近记号"><a href="#3-1-渐近记号" class="headerlink" title="3.1 渐近记号"></a>3.1 渐近记号</h2><p>$\Theta、 \text{O}和\Omega $三种记号的图示：<br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_1.png" alt="1"></p><h3 id="先看第一幅图-a-——-Theta-记号"><a href="#先看第一幅图-a-——-Theta-记号" class="headerlink" title="先看第一幅图(a)——$\Theta$记号"></a>先看第一幅图(a)——$\Theta$记号</h3><p>若存在正常量$c_1,c_2,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant c_1g(n)\leqslant f(n) \leqslant c_2g(n)$，则$f(n)$属于集合$\Theta(g(n))$，<br>可以记为$f(n)\in \Theta(g(n))$，我们通常用$f(n)=\Theta(g(n))$表达相同的概念。</p><p>上述公式的含义：函数f(n)能“夹入”$c_1g(n)$和$c_2g(n)$之间。换句话说，对所有的$n\geqslant n_0$，函数$f(n)$在一个常量因子内等于$g(n)$，我们称$g(n)$是$f(n)$的一个渐近紧确界(asymptotically tight bound)。</p><p>实例：可以用上述的形式化定义来证明：$\frac{1}{2}n^2-3n =\Theta(n^2)$，以及$6n^3 \neq \Theta(n^2)$。</p><p>渐近正函数就是对足够大的n均为正的函数。</p><p>直觉上，一个渐近正函数的低阶项 在确定渐近确界时可以被忽略，因为对于大的n，它们是无足轻重的。</p><p>一般来说，对任意多项式$p(n)=\sum_{i=0}^d a_i n^i$，其中$a_i$为常量且$a_d&gt;0$（最高阶的系数大于零），则有$p(n)=\Theta(n_d)$。</p><h3 id="接着看图-b-——-text-O-记号"><a href="#接着看图-b-——-text-O-记号" class="headerlink" title="接着看图(b)——$\text{O}$记号"></a>接着看图(b)——$\text{O}$记号</h3><p>$\Theta$记号渐近地给出了一个函数的上界和下届。当只有一个<em>渐近上界</em>时，使用$\text{O}$记号。</p><p>$\text{O}(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant  f(n) \leqslant cg(n)}$</p><p>我们记$f(n)=\text{O}(g(n))$表示$f(n)$是集合$\text{O}(g(n))$的成员。注意$f(n)=\Theta(g(n))$蕴含了$f(n)=\text{O}(g(n))$，因为$\Theta$记号是一个比$\text{O}$记号更强的概念。</p><p>使用$\text{O}$记号，我们常常可以仅仅通过检查算法的总体结构来描述算法的运行时间。$\text{O}$记号描述上界，对插入排序算法的最坏情况运行时间的界$\text{O}(n^2)$也适合于该算法对每个输入的运行时间。该算法对每个输入的运行时间都有一个界，这就是综合性描述。</p><h3 id="最后看图-c-——-Omega-记号"><a href="#最后看图-c-——-Omega-记号" class="headerlink" title="最后看图(c)——$\Omega$记号"></a>最后看图(c)——$\Omega$记号</h3><p>正如$\text{O}$记号提供了渐近上界，$\Omega$记号提供了渐进下界。</p><p>$\Omega(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant  cg(n) \leqslant f(n)}$</p><p>于是，由此引出了定理3.1。</p><h4 id="定理-3-1"><a href="#定理-3-1" class="headerlink" title="定理 3.1"></a>定理 3.1</h4><p>对任意两个函数$f(n)$和$g(n)$，我们有$f(n)=\Theta(g(n))$，当且仅当$f(n)=\text{O}(g(n))$且$f(n)=\Omega(g(n))$。</p><p>当一个算法的运行时间为$\Omega(g(n))$时，我们意指不管n是什么规模，只要n足够大，对那个输入的运行时间至少是$g(n)$的常数倍。</p><h3 id="等式和不等式中的渐近记号"><a href="#等式和不等式中的渐近记号" class="headerlink" title="等式和不等式中的渐近记号"></a>等式和不等式中的渐近记号</h3><p>当渐近记号出现在某个公式中时，我们将其解释为代表某个我们不关注名称的匿名函数。</p><p>例如：$2n^2+3n+1 = 2n^2 +\Theta(n)$。</p><p>按这种方式使用渐记号可以帮助消除一个等式中无关紧要的细节与混乱。</p><p>例如：归并排序的最坏情况运行时间：<br>$$T(n) = 2T(n/2)+\Theta(n)$$<br>如果只对T(n)的渐近行为感兴趣，就没必要准确说明所以低阶项，它们都被理解为包含在由项$\Theta(n)$表示的匿名函数中。</p><p>在某些例子中，渐近记号出现在等式的左边，如：<br>$$2n^2+\Theta(n) = \Theta(n^2) $$</p><p>无论怎么选择等号左边的匿名函数，总有一种办法来选择等号右边的匿名函数使等式成立。</p><h3 id="text-o-记号"><a href="#text-o-记号" class="headerlink" title="$\text{o}$记号"></a>$\text{o}$记号</h3><p>$\text{o}$记号，非渐近紧确的上界。</p><p>$\text{o}(g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant  f(n) &lt; cg(n)}$。</p><p>$\text{O}$记号与$\text{o}$记号类似，主要的区别 是在$f(n)=\text{O}(g(n))$中，界$0\leqslant  f(n) \leqslant cg(n)$对某个常量$c&gt;0$成立，但在$f(n)=\text{o}(g(n))$中，界$0\leqslant  f(n) &lt; cg(n)$对所有常量$c&gt;0$成立。</p><p>直观上，在$\text{o}$记号中，当n趋向于无穷时，函数$f(n)$相对于$g(n)$来说变得微不足道了，即：<br>$$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = 0$$</p><h3 id="omega-记号"><a href="#omega-记号" class="headerlink" title="$\omega$记号"></a>$\omega$记号</h3><p>非渐近紧确下界。</p><p>$\omega (g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant cg(n) &lt;  f(n) }$。</p><p>$$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = \infty $$</p><h3 id="渐近运算的运算性质"><a href="#渐近运算的运算性质" class="headerlink" title="渐近运算的运算性质"></a>渐近运算的运算性质</h3><p>传递性、自反性、对称性与转置对称性：<br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_2.png" alt="2"><br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_3.png" alt="3"><br>而且：两个函数f和g的渐近比较关系可与实数a与b之间的比较做类比： </p><ul><li>f(n)=O(g(n)) 类似于a&lt;= b </li><li>f(n)=Ω(g(n)) 类似于a&gt;= b </li><li>f(n)=Θ(g(n)) 类似于a= b </li><li>f(n)=o(g(n)) 类似于a&lt; b </li><li>f(n)=w(g(n)) 类似于a&gt; b</li></ul><p>三分性：虽然实数具有三分性，即对于任意两个实数a、b，下列三种情况必须有一种成立：$a<b$，$a=b$或$a>b$。但是不是所有函数都可以渐近比较。</b$，$a=b$或$a></p><h2 id="3-2-标准记号与常用函数"><a href="#3-2-标准记号与常用函数" class="headerlink" title="3.2 标准记号与常用函数"></a>3.2 标准记号与常用函数</h2><h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><p>单调递增/单调递减：包含等号；严格递增/严格递减：不包含等号。</p><h3 id="向下取整与向上取整"><a href="#向下取整与向上取整" class="headerlink" title="向下取整与向上取整"></a>向下取整与向上取整</h3><p>x的向下取整：$\lfloor x \rfloor$；x的向上取整：$\lceil x \rceil$。</p><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>对任意整数a和正整数n，$a\ \text{mod}\ n$ 的值就是商a/n的余数。<br>$$a\ \text{mod}\ n = a-n\lfloor a/n\rfloor $$</p><p>若$(a\ \text{mod}\ n)=(b\ \text{mod}\ n)$，则记$a\equiv b(\text{mod}n)$</p><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>给定一个非负整数d，n的d次多项式$p(n)$：<br>$$p(n)=\sum_{i=0}^d a_i n^i$$<br>其中，$a_d \neq 0 $。</p><p>多项式为渐近正的当且仅当$a_d &gt; 0 $。对于一个d次渐近正的多项式$p(n)$，有$p(n)=\Theta(n^d)$</p><p>若对于某个常量k，有$f(n)=\text{O}(n^k)$，则称函数$f(n)$是多项式有界的。</p><h3 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h3><p>对所有使得$a&gt;1$的实常量a和b，有<br>$$\lim_{n\rightarrow \infty} \frac{n^b}{a^n} = 0$$<br>据此可得：<br>$$n^b = \text{o}(a^n)$$</p><h3 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h3><p>以2为底的自然数：<br>$$\text{lg}n = \text{log}_2n$$<br>自然对数：<br>$$\text{ln}n = \text{log}_en$$<br>取幂：<br>$$\text{lg}^kn = (\text{lg}n)^k$$<br>复合：<br>$$\text{lg}\text{lg}n =\text{lg} (\text{lg}n)$$</p><p>一个重要的记号约定：对数函数只适用于公式中的下一项，所以$\text{lg}n+k$意思是指$(\text{lg}n)+k$</p><p>对于$a&gt;0,b&gt;0,c&gt;0$和n，有<br>$$a = b^{\text{log}_ba}$$<br>$$\text{log}_c(ab) = \text{log}_ca +\text{log}_cb$$<br>$$\text{log}_b(a^n) = n\text{log}_ba$$<br>$$\text{log}_ba =\frac{\text{log}_ca}{\text{log}_cb} $$<br>$$\text{log}_b(1/a) =- \text{log}_ba $$<br>$$\text{log}_ba =\frac{1}{\text{log}_ab} $$<br>$$a^{\text{log}_bc} = c^{\text{log}_ba}$$<br>其中，上述等式的对数底不为1。</p><p>对任意常量a，有<br>$$\text{log}^bn = \text{o}(n^a)$$<br>表示任意正的多项式函数都比任意多对数函数增长得快。</p><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>$n!$，读作“n的阶乘”。其定义为对整数$n \geqslant 0$：<br>$$n! = \begin{cases}<br>1 &amp; 若n=0\\<br>n\cdot (n-1)! &amp; 若n&gt;0<br>\end{cases}$$</p><p>阶乘函数的一个弱上界是$n! \leqslant n^n$，因为在阶乘中，n项的每项最多为n。</p><h4 id="斯特林-Stirling-近似公式"><a href="#斯特林-Stirling-近似公式" class="headerlink" title="斯特林(Stirling)近似公式"></a>斯特林(Stirling)近似公式</h4><p>$$n!=\sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n})) $$</p><p>由上述公式可以证明：<br>$$n! = o(n^n)$$<br>$$n! = \omega(2^n)$$<br>$$\text{lg}n! = \Theta(n\text{lg}n)$$</p><h3 id="多重函数"><a href="#多重函数" class="headerlink" title="多重函数"></a>多重函数</h3><p>记号$f^{(i)}(n)$表示f(n)重复i次作用于一个初值n上。对非负整数i，我们递归地定义：<br>$$f^{(i)}(n)=\begin{cases}<br>n &amp; 若i=0 \\<br>f(f^{(i-1)}(n)) &amp; 若i&gt;0<br>\end{cases}$$</p><h3 id="多重对数函数"><a href="#多重对数函数" class="headerlink" title="多重对数函数"></a>多重对数函数</h3><p>$\text{lg}^*n$表示多重对数，多重对数增长非常慢。</p><h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>斐波那契数的递归定义：<br>$$F_0 = 0$$<br>$$F_1 = 1$$<br>$$F_i = F_{i-1}+F_{i-2}, i \geqslant 2$$</p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/13/algorithm_tutorial_chapter_3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>算法导论详解(1) 第二章算法基础</title>
      <link>https://wangwlj.com/2017/12/12/algorithm_tutolrial_chapter_2/</link>
      <guid>https://wangwlj.com/2017/12/12/algorithm_tutolrial_chapter_2/</guid>
      <pubDate>Tue, 12 Dec 2017 13:43:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;第二章-算法基础&quot;&gt;&lt;a href=&quot;#第二章-算法基础&quot; class=&quot;headerlink&quot; title=&quot;第二章 算法基础&quot;&gt;&lt;/a&gt;第二章 算法基础&lt;/h1&gt;&lt;h2 id=&quot;伪码说明&quot;&gt;&lt;a href=&quot;#伪码说明&quot; class=&quot;headerlink&quot; 
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="第二章-算法基础"><a href="#第二章-算法基础" class="headerlink" title="第二章 算法基础"></a>第二章 算法基础</h1><h2 id="伪码说明"><a href="#伪码说明" class="headerlink" title="伪码说明"></a>伪码说明</h2><ol><li><p>数组A[1,…,n]长度为n的待排序序列。<br>注意，书中的下标都是从1开始的。python中是从0开始的。</p></li><li><p>伪码中，A的长度用A.length表示。python中使用len(A)表示。</p></li><li>缩进表示块结构。提高代码清晰度。</li><li>while, for, repeat-until 在循环结束后，循环计数器仍然保持其值。</li><li>符号“//”后面是注释。</li><li>数组元素通过“数组名[下标]”这样的形式来访问。</li><li>复合数据通常被组织成<em>对象</em>，对象又由<em>属性</em>组成。</li><li>return允许返回多个值</li><li>按值把参数传递给过程，被调用过程接收其参数自身的副本。</li><li>布尔运算符“and”和“or”都是短路的。</li></ol><h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><p>插入排序的Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(A)</span>:</span></div><div class="line">    length = len(A)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, length):</div><div class="line">        key = A[j]</div><div class="line">        i = j - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key:</div><div class="line">            A[i + <span class="number">1</span>] = A[i]</div><div class="line">            i = i - <span class="number">1</span></div><div class="line">        A[i + <span class="number">1</span>] = key</div><div class="line">    <span class="keyword">return</span> A</div><div class="line">A = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">8</span>, ]</div><div class="line">print(insertion_sort(A))</div></pre></td></tr></table></figure></p><p>对插入排序的简单理解：<br>从第二个数开始，依次比较前面的数和key的大小，若大于key，则后移。<br>最后将key插入到最前方停下的位置。<br>j是遍历数组每个元素；<br>i是每个元素前面、需要移动的最前方。</p><p>形象的解释：插入纸牌：key是当前带插入的牌，找到插入的位置，先把每个大的都往后挪一个位置出来，再把key插入到空出来的位置。</p><h2 id="2-2-分析算法"><a href="#2-2-分析算法" class="headerlink" title="2.2 分析算法"></a>2.2 分析算法</h2><p>RAM（Random-access machine,RAM）模型:单处理器计算模型，指令一条接一条地执行，没有并发操作。</p><p>真实计算机如何设计，RAM模型就是如何设计的，RAM模型包含真实计算机的常见指令：算术指令（加减乘除，取余，向下取整，向上取整），数据移动指令（装入、存储和复制）和控制指令（条件与无条件转移、子程序调用与返回）。</p><p>灰色区域：真实计算机中未列出的指令。如指数运算算是常量时间的指令吗？</p><p>答案：①一般情况下不是，如$x^y$，当x和y都是实数的时候。②在受限情况下，可以当做一个常量时间的操作。如$2^k$是一个常量的操作。</p><p>一个整数的各位左移k位等价于将该整数乘以$2^k$。</p><h3 id="插入排序算法的分析"><a href="#插入排序算法的分析" class="headerlink" title="插入排序算法的分析"></a>插入排序算法的分析</h3><p>算法需要的时间与输入规模同步增长，通常把一个程序的运行时间描述成其输入规模的函数。</p><p>输入规模的最佳概念依赖于研究的问题。</p><p>一个算法在特定输入上的运行时间是指执行的基本操作数或步数。<br>算法的运行时间是执行每条语句的运行时间之和。</p><p>若数组已排好序，则出现最佳情况：$T(n)=an+b$<br>若数组已反向排序（即按递减序排好序），则导致最坏情况：$T(n)=an^2+b$，是n的二次函数。</p><h3 id="最坏情况与平均情况分析"><a href="#最坏情况与平均情况分析" class="headerlink" title="最坏情况与平均情况分析"></a>最坏情况与平均情况分析</h3><p>本书往往集中于只求<em>最坏情况运行时间</em>，即对于规模为n的任何输入，算法的最长时间。</p><p>书中给出了三个理由，在此不详述。其中一点是平均情况往往与最坏情况一样差。</p><h3 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h3><p>最坏情况运行时间表示为：$T(n)=an^2+b$。</p><p>现在我们做出一种更简化的抽象：我们真正感兴趣的运行时间的$增长率$或$增长量级$。</p><h2 id="2-3-设计算法"><a href="#2-3-设计算法" class="headerlink" title="2.3 设计算法"></a>2.3 设计算法</h2><h3 id="2-3-1-分治法"><a href="#2-3-1-分治法" class="headerlink" title="2.3.1 分治法"></a>2.3.1 分治法</h3><p>许多算法在结构上是递归的，算法依次或多次递归地调用其自身以解决紧密相关的若干子问题。</p><p>分治模式在每层递归时都有三个步骤：</p><ul><li>分解原问题为若干子问题；</li><li>解决这些子问题，递归地求解各子问题。</li><li>合并这些子问题的解成原问题的解。</li></ul><p><em>归并排序</em>算法完全遵循分治模式。归并算法的关键在于合并。<br>归并排序的的基本步骤如下：</p><ol><li>把待排序的数组分为左数组和右数组</li><li>对左数组和右数组进行迭代排序</li><li>将左数组和右数组进行合并</li></ol><p>显然这些基本步骤符合分治模式在每一层递归上的三个步骤：分解、解决、合并。</p><h2 id="2-3-2-归并排序算法（分治算法）"><a href="#2-3-2-归并排序算法（分治算法）" class="headerlink" title="2.3.2 归并排序算法（分治算法）"></a>2.3.2 归并排序算法（分治算法）</h2><p>MERGE(A,p,q,r)：完成合并。A是一个数组，p,q,r是数组的下标，满足$p\leqslant q&lt;r$。假设A[p..q]与A[q+1..r]都已排好序，MERGE函数的目的就是合并这两个子数组形成单一的已排好序的数组A[p..r]。</p><p>形象地描述：同样以插入排序时的扑克牌为例，现在的情况是有两堆牌（两个输入堆），牌面朝上（可见，已排序），每次选取两堆中较小的放入到输出堆，牌面朝下。重复这个步骤，直到一个输入堆为空，则把另一个输入堆直接牌面朝下的放置到输出堆。</p><p>MERGE-SORT(A,p,r)排序子数组A[p,r]中的元素。若$p\geqslant r$，则该子数组最多只有一个元素，所以已经排好序，直接返回。否则，分解步骤。计算下表q，将A[p..r]分为A[p..q]和A[q+1..r]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># author: wangwlj</span></div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"></div><div class="line">MAX = <span class="number">1</span> &lt;&lt; <span class="number">31</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(A, p, q, r)</span>:</span></div><div class="line">    n1 = q - p + <span class="number">1</span></div><div class="line">    n2 = r - q</div><div class="line">    L = []</div><div class="line">    R = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n1):</div><div class="line">        L.append(A[p + i])  <span class="comment"># 因为我初始化为空列表，所以直接赋值的话会报错，只能以append的形式追加值。</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n2):</div><div class="line">        R.append(A[q + i + <span class="number">1</span>])</div><div class="line">    L.append(MAX)  <span class="comment"># 使用无穷大作为哨兵</span></div><div class="line">    R.append(MAX)</div><div class="line">    <span class="keyword">assert</span> len(L) == n1 + <span class="number">1</span> <span class="keyword">and</span> len(R) == n2 + <span class="number">1</span></div><div class="line"></div><div class="line">    i = <span class="number">0</span>  <span class="comment"># python是从0开始</span></div><div class="line">    j = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(p, r + <span class="number">1</span>):  <span class="comment"># 需要加1，因为首尾每个都算</span></div><div class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]:</div><div class="line">            A[k] = L[i]</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            A[k] = R[j]</div><div class="line">            j += <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = floor((p + r) / <span class="number">2</span>)</div><div class="line">        merge_sort(A, p, q)</div><div class="line">        merge_sort(A, q + <span class="number">1</span>, r)  <span class="comment"># 首尾都包含了，所以要加1</span></div><div class="line">        merge(A, p, q, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># test function</span></div><div class="line">    A = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>]</div><div class="line">    merge_sort(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)</div><div class="line">    print(A)</div></pre></td></tr></table></figure><p>上述代码测试成功。</p><h3 id="2-3-2-分析分治算法"><a href="#2-3-2-分析分治算法" class="headerlink" title="2.3.2 分析分治算法"></a>2.3.2 分析分治算法</h3><p>假设把原问题分解为a个子问题，每个子问题的规模都是原问题的1/b。（对于归并排序，a和b都是2，然而在许多分治算法中，$a\neq b $。）</p><p>求解规模为n/b的子问题，需要$T(n/b)$的时间，所以需要花费$aT(n/b)$的时间来求解a个子问题。</p><p>下面分析归并排序n个数的最坏情况运行时间$T(n)$的递归式。</p><ul><li>分解：分解步骤只计算子数组的中间位置，需要常量时间，因此，$D(n)=\Theta(n)$</li><li>解决：递归地求解两个规模为n/2的子问题，将贡献$2T(n/2)$的运行时间。</li><li>合并：n个子元素的数组上的merge需要$\Theta(n)$的时间（线性复杂度），所以$C(n)=\Theta(n)$。</li></ul><p>$D(n)$和$C(n)$相加的和，仍然是n的线性复杂度，即$\Theta(n)$。再与“解决”步骤相加，为：<br>$$T(n) =<br> \begin{cases}<br>  \Theta(1) &amp; 若n=1 \\<br> 2T(n/2)+\Theta(n) &amp;  若n&gt;1\\<br>  \end{cases}<br>  $$</p><p>在第四章，我们将看到“主定理”，可以用该定理来证明$T(n)$ 为$\Theta(n\text{lg}n)$。（即时间复杂度为nlgn）</p><p>运行时间为$\Theta(n\text{lg}n)$的归并排序优于运行时间为$\Theta(n^2)$的插入排序。</p><p>$T(n) =\Theta(n\text{lg}n)$的直观理解：<br><img src="/2017/12/12/algorithm_tutolrial_chapter_2/merge_sort_complexity.png" alt="归并排序复杂度的直观理解"><br>由(d)图，每层对n等分，可以展开为lgn层(再加上原来的一层，一共lgn+1层)。每层的复杂度都是cn，所以总的复杂度为$cn\text{lg}n+cn = cn(\text{lg}n+1)$。</p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/12/algorithm_tutolrial_chapter_2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一起开始机器学习吧——知乎live笔记</title>
      <link>https://wangwlj.com/2017/12/12/Start_Machine_Learning_review/</link>
      <guid>https://wangwlj.com/2017/12/12/Start_Machine_Learning_review/</guid>
      <pubDate>Tue, 12 Dec 2017 09:02:37 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;问答干货&quot;&gt;&lt;a href=&quot;#问答干货&quot; class=&quot;headerlink&quot; title=&quot;问答干货&quot;&gt;&lt;/a&gt;问答干货&lt;/h2&gt;&lt;p&gt;①练手项目推荐：《机器学习实战》,从零开始写机器学习算法代码，有实际的项目。有一定了解之后，去Kaggle上找竞赛做。&lt;/p
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="问答干货"><a href="#问答干货" class="headerlink" title="问答干货"></a>问答干货</h2><p>①练手项目推荐：《机器学习实战》,从零开始写机器学习算法代码，有实际的项目。有一定了解之后，去Kaggle上找竞赛做。</p><p>②教程推荐：公开课（吴恩达、coursera等），coursera上吴恩达的公开课</p><p>③语言推荐：python，MATLAB。很多开源工具（MXNet，Tensorflow，Keras）都有Python接口。</p><p>④python方面，网上有很多博客，比如廖雪峰的博客，感觉只需要了解即可，会用就行；传统算法入门的话，推荐李航的《统计学习方法》,入门最合适。最近出了Bengio的《Deep learning》书，有中文翻译，前面章节全是传统算法。不推荐一上来就看大家都说的《pattern recognition and machine learning》以及《模式分类》,这两本书不适合入门。</p><p>⑤完全零基础的入门性质的资料：视频：<a href="https://www.youtube.com/watch?v=IpGxLWOIZy4&amp;t=9s" target="_blank" rel="external">https://www.youtube.com/watch?v=IpGxLWOIZy4&amp;t=9s</a><br>机器学习入门： <a href="http://www.cnblogs.com/subconscious/p/4107357.html" target="_blank" rel="external">http://www.cnblogs.com/subconscious/p/4107357.html</a></p><p>⑥数学基础课：数学（概率、线代、高数、随机过程，排名分先后）</p><p>⑦发论文经验：目前我只是有paper在投，还没有成功发过，哈哈。经验嘛，主要就是一定要敢于否定自己，我在写的paper一共两篇，每一篇都几乎改了七八次，每次都很严格地要求自己。同时，最好要把paper发给同组的人一起看看，不同的角度给你提问题，会帮助你认识到自己容易忽视的问题。视觉方面发paper其实很容易的。通常来说你需要在同一个数据集上跟最好的方法做对比。</p><p>⑧我数学基础不太牢固 想一边看机器学习一边补数学 但有很多数学符号甚至都不认识 百度也没法搜索 你有什么建议吗？<br>答：专业书籍都有符号索引表；学习简单的数学工具，如latex；matrix cookbook 矩阵常用的手册。</p><h2 id="PPT干货"><a href="#PPT干货" class="headerlink" title="PPT干货"></a>PPT干货</h2><ul><li>机器学习常用分类：监督学习、半监督学习、无监督学习、增强学习</li><li><p>②无监督才是世界的本质，标注数据往往要花费大量的人力物力。<br>没有标注这么做呢？迁移学习是可以类比无监督学习来做的事情。<br>人是有类比能力的，计算机可以吗？我们想让它有这个能力。（就是迁移学习）<br>通过迁移学习的方式可以部分地接近无监督学习的目标。<br>迁移学习的好处是什么？利用已有的知识，节约新学习的成本。<br>但需要找到两者的相似性。骑自行车-&gt;开汽车？ 不行！ 需要有相似性。<br>深度学习算是对迁移学习的改进（我的总结）？，因为深度学习不像迁移学习需要手动提取特征。</p></li><li><p>准备工作<br>  理论知识（高数、概率、线性代数、随机过程）<br>  编码能力（Python, Matlab, Java）</p></li><li>基本入门<br>  李航《统计学习方法》<br>  周志华《机器学习》<br>  吴恩达公开课<br>  Kaggle竞赛</li><li><p>进阶提高<br>  《模式分类》、《PRML》<br>  ICML、NIPS等国际会议<br>  做自己的研究工作</p></li><li><p>书籍资料整理：<a href="https://github.com/ty4z2008/Qix/blob/master/dl.md" target="_blank" rel="external">https://github.com/ty4z2008/Qix/blob/master/dl.md</a><br>  入门资料：<a href="http://www.cnblogs.com/subconscious/p/4107357.html" target="_blank" rel="external">http://www.cnblogs.com/subconscious/p/4107357.html</a><br>  公开课：<a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">http://open.163.com/special/opencourse/machinelearning.html</a><br>  Kaggle竞赛：<a href="https://www.kaggle.com/" target="_blank" rel="external">https://www.kaggle.com/</a></p></li></ul>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/12/Start_Machine_Learning_review/#disqus_thread</comments>
    </item>
    
    <item>
      <title>python爬虫实战--selenium模拟登录并自动点击</title>
      <link>https://wangwlj.com/2017/12/09/HDHome_clawler_tutorial/</link>
      <guid>https://wangwlj.com/2017/12/09/HDHome_clawler_tutorial/</guid>
      <pubDate>Sat, 09 Dec 2017 14:57:45 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;python爬虫实战–selenium模拟登录网站HDH并刷魔力值&quot;&gt;&lt;a href=&quot;#python爬虫实战–selenium模拟登录网站HDH并刷魔力值&quot; class=&quot;headerlink&quot; title=&quot;python爬虫实战–selenium模拟登录网站H
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="python爬虫实战–selenium模拟登录网站HDH并刷魔力值"><a href="#python爬虫实战–selenium模拟登录网站HDH并刷魔力值" class="headerlink" title="python爬虫实战–selenium模拟登录网站HDH并刷魔力值"></a>python爬虫实战–selenium模拟登录网站HDH并刷魔力值</h1><h2 id="任务介绍"><a href="#任务介绍" class="headerlink" title="任务介绍"></a>任务介绍</h2><p>最近刚刚注册了某个网站：<a href="http://hdhome.org/" target="_blank" rel="external">HDHome</a>，该站有新手考核任务，其中有一项是需要达到魔力值5000。在魔力值获取方式中，我们看到这一项：“说谢谢 = 0.5个魔力值”，而网站存活种子数量达到16000+，也就意味着对每个种子说一下谢谢，轻松达到8000+的魔力值，于是，这个项目应运而生。</p><p>实现思路：<br>获取种子的页面，在每个页面中找到说谢谢的按钮，并点击后，关闭。依次进行下去即可。</p><p>相似任务：</p><p>实现对某论坛的自动回复，实现自动获取所有帖子的信息等等相关操作，无论是否需要模拟登录、模拟鼠标操作还是直接解析网站元素。</p><h2 id="selenium-牛刀小试"><a href="#selenium-牛刀小试" class="headerlink" title="selenium 牛刀小试"></a>selenium 牛刀小试</h2><p>首先导入相关的库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> selenium.webdriver <span class="keyword">as</span> webdriver</div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</div><div class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</div><div class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</div><div class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</div></pre></td></tr></table></figure><p>这是整个程序里面用到的所有内容。<br>其中，<code>webdriver</code>是主浏览器，<code>selenium</code>都是基于整个浏览器的对象；<code>WebDriverWait、EC、By</code>是等待网页元素加载相关的操作；<code>Keys</code>是键值，如<code>Keys.CONTROL</code>，<code>Keys.ENTER</code>等等，<code>ActionChains</code>是用鼠标进行一系列的操作。</p><p><code>webdriver</code>可用的浏览器有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">webdriver.Firefox</div><div class="line">webdriver.FirefoxProfile</div><div class="line">webdriver.Chrome</div><div class="line">webdriver.ChromeOptions</div><div class="line">webdriver.Ie</div><div class="line">webdriver.Opera</div><div class="line">webdriver.PhantomJS</div><div class="line">webdriver.Remote</div><div class="line">webdriver.DesiredCapabilities</div><div class="line">webdriver.ActionChains</div><div class="line">webdriver.TouchActions</div><div class="line">webdriver.Proxy</div></pre></td></tr></table></figure></p><p>一开始我选择的是Chrome浏览器，后来改为了Firefox火狐。Chrome浏览器在执行单个元素（如验证码）截图时有坑（下文有详细说），所以后来才用的Firefox。此外，PhantomJS是匿名浏览器，没有显式的窗口。</p><p>那么，开始写程序吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">driver = webdriver.Firefox()</div><div class="line">login_url = <span class="string">"http://hdhome.org/login.php"</span></div><div class="line">login_failed_url = <span class="string">"http://hdhome.org/takelogin.php"</span></div><div class="line">driver.get(login_url)</div><div class="line"><span class="keyword">while</span> self.driver.current_url == login_url <span class="keyword">or</span> self.driver.current_url == login_failed_url:</div><div class="line">    time.sleep(<span class="number">10</span>)</div><div class="line"><span class="comment"># do something</span></div></pre></td></tr></table></figure></p><p>首先，实体化浏览器driver，执行<code>driver = webdriver.Firefox()</code>这句的时候，就会有firefox浏览器弹出来了。当执行到<code>driver.get(login_url)</code>时，浏览器转到相应的网址，后面的while语句是用来等待我们手动登录的，当我们手动登录成功后，会进入到<code>&quot;http://hdhome.org/index.php&quot;</code>，与login_url及login_failed_url都不同。接着便可以做自己想做的事情了。</p><p>我们发现单个种子的网址是类似这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">single_link = <span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i)</div></pre></td></tr></table></figure></p><p>i可以从1到30000多。于是，我们可以这样写程序，依次对每个种子执行“说谢谢”操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">saythanks</span><span class="params">(link)</span>:</span></div><div class="line">    driver.get(link)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        driver.find_element_by_xpath(<span class="string">"//input[@id='saythanks']"</span>).click()</div><div class="line">        print(link, <span class="string">" succeed\n"</span>)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        print(link, <span class="string">" not succeed\n"</span>)</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">        <span class="keyword">pass</span></div><div class="line">        </div><div class="line">START = <span class="number">1</span></div><div class="line">END = <span class="number">30000</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(START, END):</div><div class="line">    link = <span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i)</div><div class="line">    saythanks(link)</div><div class="line">driver.close()</div></pre></td></tr></table></figure></p><p>其中，我们使用<code>try</code>、<code>except</code>、<code>finally</code>语句来尝试定位到’saythanks’说谢谢的按钮元素。由于有时候加载较慢就会找不到，或者是这个种子已经被删除了，所以也导致找不到该元素。</p><p>其中定位网页元素的方法有一下几种：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># locate single element in a page:</span></div><div class="line">find_element_by_id</div><div class="line">find_element_by_name</div><div class="line">find_element_by_xpath</div><div class="line">find_element_by_link_text</div><div class="line">find_element_by_partial_link_text</div><div class="line">find_element_by_tag_name</div><div class="line">find_element_by_class_name</div><div class="line">find_element_by_css_selector</div><div class="line"></div><div class="line"><span class="comment"># To find multiple elements (these methods will return a list):</span></div><div class="line">find_elements_by_name</div><div class="line">find_elements_by_xpath</div><div class="line">find_elements_by_link_text</div><div class="line">find_elements_by_partial_link_text</div><div class="line">find_elements_by_tag_name</div><div class="line">find_elements_by_class_name</div><div class="line">find_elements_by_css_selector</div></pre></td></tr></table></figure></p><p>从上面可以看出，我们也可以用<code>find_element_by_id(&quot;saythanks&quot;)</code>同样可以找到说谢谢的按钮。</p><p>附上到目前为止的所有程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master/hdh_try_2.py" target="_blank" rel="external">GitHub地址1</a><br>完整程序中加上了logging模块，将输出日志也导入到了文件，方面以后查阅。</p><h2 id="改进一：使用多线程多标签"><a href="#改进一：使用多线程多标签" class="headerlink" title="改进一：使用多线程多标签"></a>改进一：使用多线程多标签</h2><p>在上述模块中，可以看到，我们按照种子的顺序依次进行相应的操作。在种子数量很多的时候，会显得很慢，于是，有了这个改进：使用多线程。</p><p>我们使用multiprocessing库。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div></pre></td></tr></table></figure></p><p>先来看一个使用该多线程库的示例程序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(fn)</span>:</span></div><div class="line">    <span class="comment"># fn: 函数参数是数据列表的一个元素</span></div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> fn * fn</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    testFL = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">    print(<span class="string">'shunxu:'</span>)  <span class="comment"># 顺序执行(也就是串行执行，单进程)</span></div><div class="line">    s = time.time()</div><div class="line">    <span class="keyword">for</span> fn <span class="keyword">in</span> testFL:</div><div class="line">        run(fn)</div><div class="line"></div><div class="line">    e1 = time.time()</div><div class="line">    print(<span class="string">"顺序执行时间："</span>, int(e1 - s))</div><div class="line"></div><div class="line">    print(<span class="string">'concurrent:'</span>)  <span class="comment"># 创建多个进程，并行执行</span></div><div class="line">    pool = Pool(<span class="number">5</span>)  <span class="comment"># 创建拥有5个进程数量的进程池</span></div><div class="line">    <span class="comment"># testFL:要处理的数据列表，run：处理testFL列表中数据的函数</span></div><div class="line">    rl = pool.map(run, testFL)</div><div class="line">    pool.close()  <span class="comment"># 关闭进程池，不再接受新的进程</span></div><div class="line">    pool.join()  <span class="comment"># 主进程阻塞等待子进程的退出</span></div><div class="line">    e2 = time.time()</div><div class="line">    print(<span class="string">"并行执行时间："</span>, int(e2 - e1))</div><div class="line">    print(rl)</div></pre></td></tr></table></figure></p><p>于是，模仿上述程序，我们也使用多线程来执行说谢谢。说谢谢的过程其实有两步：一是打开网页，二是对每个网页定位到每个元素并点击。</p><p>如果对一、二两个步骤都执行多线程会出错，可能是由于多窗口的原因。因此我目前只对打开网页的步骤执行了多线程的操作。</p><p>上述也提到了，要同时打开多个窗口，则需要使用浏览器的多标签功能。打开一个新的标签的程序需要执行js脚本，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_url</span><span class="params">(url)</span>:</span></div><div class="line">    newwindow = <span class="string">'window.open("&#123;&#125;")'</span>.format(url)</div><div class="line">    driver.execute_script(newwindow)</div></pre></td></tr></table></figure></p><p>于是多线程部分的改进如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">START = <span class="number">25980</span></div><div class="line">    END = <span class="number">30000</span></div><div class="line">    Thread_Num = <span class="number">3</span></div><div class="line">    t = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(START, END, Thread_Num):</div><div class="line"></div><div class="line">        pool = Pool(Thread_Num)</div><div class="line">        all_links = [<span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(i, i + Thread_Num)]</div><div class="line">        print(all_links)</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            rl = pool.map(open_url, all_links)</div><div class="line">            pool.close()</div><div class="line">            pool.join()</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            print(<span class="string">"multi thread start failed, next!!"</span>)</div><div class="line">            logging.info(<span class="string">"multi thread start failed, next!!"</span>)</div><div class="line">            time.sleep(<span class="number">5</span>)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="comment"># 通过移动句柄来说谢谢</span></div><div class="line">        saythanks()</div><div class="line">        <span class="comment"># sleep more</span></div><div class="line">        time.sleep(<span class="number">0.5</span>)</div><div class="line">        <span class="keyword">if</span> t % <span class="number">3</span> == <span class="number">0</span>:</div><div class="line">            time.sleep(<span class="number">0.5</span>)</div><div class="line">        <span class="keyword">if</span> t % <span class="number">5</span> == <span class="number">0</span>:</div><div class="line">            driver.switch_to.window(driver.window_handles[<span class="number">0</span>])</div><div class="line">            driver.refresh()</div><div class="line">            mystr = driver.find_elements_by_xpath(<span class="string">'//span[@class="medium"]'</span>)[<span class="number">0</span>].text</div><div class="line">            bonus = re.search(<span class="string">"\s[0-9,.]*\s"</span>, mystr).group()</div><div class="line">            usrName = re.search(<span class="string">"\s[a-zA-Z0-9]*\s"</span>, mystr).group()</div><div class="line">            print(driver.current_url, <span class="string">"normal refresh,&#123;&#125;bonus is&#123;&#125;now..."</span>.format(usrName, bonus))</div><div class="line">            logging.info(driver.current_url + <span class="string">"normal refresh,&#123;&#125;bonus is&#123;&#125;now..."</span>.format(usrName, bonus))</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">        t = t + <span class="number">1</span></div><div class="line">    driver.quit()</div><div class="line">    logging.info(<span class="string">"&#123;&#125;: driver quit, program stop."</span>.format(</div><div class="line">        time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime(time.time()))))</div></pre></td></tr></table></figure></p><p>为了不让浏览器检测到，我只是用了三个线程，可以适当的增加。saythanks()下面的部分程序是为了增加更多的延迟并且显示相应的信息。其中<code>if t % 5 == 0:</code>中，我们移动到主页上，进行刷新操作，然后定位到用户信息那一栏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bonus = re.search(&quot;\s[0-9,.]*\s&quot;, mystr).group()</div><div class="line">usrName = re.search(&quot;\s[a-zA-Z0-9]*\s&quot;, mystr).group()</div></pre></td></tr></table></figure></p><p>这个部分使用了re正则项来找出当前的魔力值以及用户名，并显示出来。</p><p>其中，说谢谢的程序也需要对多标签进行相应的改进，程序如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">saythanks</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> len(driver.window_handles) &gt; <span class="number">1</span>:</div><div class="line">        driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            WebDriverWait(driver, <span class="number">20</span>).until(EC.presence_of_element_located((By.ID, <span class="string">"outer"</span>)))</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            driver.refresh()</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">            print(driver.current_url, <span class="string">" refresh ---"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            driver.find_element_by_xpath(<span class="string">"//input[@id='saythanks']"</span>).click()</div><div class="line">            print(driver.current_url, <span class="string">" succeed"</span>)</div><div class="line">            logging.info(driver.current_url + <span class="string">" succeed~"</span>)</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            print(driver.current_url, <span class="string">" not succeed"</span>)</div><div class="line">            logging.info(driver.current_url + <span class="string">" not succeed!"</span>)</div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">            driver.close()</div><div class="line">            driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure></p><p>通过在不同窗口的句柄之间移动，来依次进行说谢谢的步骤。<br>在每个网页加载的时候，我们执行了等待的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebDriverWait(driver, <span class="number">20</span>).until(EC.presence_of_element_located((By.ID, <span class="string">"outer"</span>)))</div></pre></td></tr></table></figure></p><p>一直等到最外层的元素出现。我选择的”outer”这个元素，是在无论这个种子是否存在的时候都会出现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure><p>将窗口转移到最后打开的那个窗口。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">driver.close()</div><div class="line">driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure></p><p>关闭当前的个窗口，并转到当前的最后一个窗口。需要注意的是：窗口虽然关闭了，但是，driver依旧会停在那个已经失效的窗口，并不会自动的转到新的窗口（虽然在浏览器中看上去到了新的窗口），所以，需要我们自己手动的移动窗口的句柄。</p><p>这边还存在一个问题，就是多标签的时候，自动切换标签的时候，浏览器会自动弹出来。这样子便有点烦人，毕竟我们只是想让他在后台自己跑， 所以，我加上了一个虚拟窗口，使用的是<code>pyvirtualdisplay</code>库。</p><p>以下是<code>pyvirtualdisplay</code>库在ubuntu中的安装步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pip install pyvirtualdisplay</div><div class="line">sudo apt install xvfb</div><div class="line">sudo apt install xserver-xephyr</div></pre></td></tr></table></figure></p><p>下面是<code>pyvirtualdisplay</code>具体的使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from pyvirtualdisplay import Display</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    display = Display(visible=1, size=(800, 600))</div><div class="line">    display.start()</div></pre></td></tr></table></figure></p><p>把虚拟窗口放在一开始处的位置即可。<br>也可以将visible改为0，浏览器就完全不可见了。</p><p>最后附上这个阶段的完整程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master/hdh_try_4.py" target="_blank" rel="external">github地址2</a></p><h2 id="改进二：验证码保存-面向对象编程"><a href="#改进二：验证码保存-面向对象编程" class="headerlink" title="改进二：验证码保存+面向对象编程"></a>改进二：验证码保存+面向对象编程</h2><p>验证码保存：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">code = self.driver.find_element_by_xpath(<span class="string">"//img[@alt='CAPTCHA']"</span>)</div><div class="line">        img = code.screenshot_as_png</div><div class="line">        img_name = <span class="string">"./code/code&#123;&#125;.png"</span>.format(time.strftime(<span class="string">'%Y-%m-%d_%H%M%S'</span>, time.localtime(time.time())))</div><div class="line">        <span class="keyword">with</span> open(img_name, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(img)</div><div class="line">        rec_code = self.code_recog(img_name)</div></pre></td></tr></table></figure></p><p>其中，验证码保存步骤使用了selenium自带的<em>元素截图</em>功能，而不是全屏截图。这边正是我从chrome浏览器改为firefox浏览器的真实原因。chrome浏览器中的元素截图不可用！会报错！故此选用firefox浏览器。</p><p>面向对象编程就是对函数使用了类，把多个函数合并到了同一个类中去。</p><p>完整程序在最后给出。</p><h2 id="改进三：使用pyqt获得验证码图片"><a href="#改进三：使用pyqt获得验证码图片" class="headerlink" title="改进三：使用pyqt获得验证码图片"></a>改进三：使用pyqt获得验证码图片</h2><p>思路是：从网页中解析到验证码的图片，然后下载到本地；接着使用pyqt弹出一个窗口，窗口中显示获取到的验证码，手动输入验证码后点击关闭。</p><p>简化了每次登录的流程，账号、密码记录在程序中自动输入，只需要手动输入验证码。</p><p>其中，基于pyqt5图形界面的窗口部分的程序如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># CodeRecognition.py</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets, QtGui</div><div class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeRecognition</span><span class="params">(QtWidgets.QWidget)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span></div><div class="line">        QtWidgets.QWidget.__init__(self, parent)</div><div class="line">        self.setWindowTitle(<span class="string">"请手动输入验证码"</span>)</div><div class="line">        self.resize(<span class="number">250</span>, <span class="number">150</span>)</div><div class="line">        self.center()</div><div class="line">        <span class="comment"># 界面初始化</span></div><div class="line">        self.code_edit = QLineEdit()</div><div class="line">        self.label_code = QtWidgets.QLabel()</div><div class="line">        self.init_interface()</div><div class="line">        self.img_path = <span class="string">'./image_3.png'</span></div><div class="line">        self.show_code_img()</div><div class="line">        <span class="comment"># 输出的识别码</span></div><div class="line">        self.out_code = <span class="string">'To_be_recognize'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_interface</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        label1 = QtWidgets.QLabel(<span class="string">'请输入验证码：'</span>, self)</div><div class="line">        label2 = QtWidgets.QLabel(<span class="string">'输入完成后点击关闭按钮即可。'</span>, self)</div><div class="line">        self.code_edit.setToolTip(<span class="string">'请输入验证码'</span>)</div><div class="line">        button2 = QtWidgets.QPushButton(<span class="string">'关闭'</span>, self)</div><div class="line"></div><div class="line">        grid = QGridLayout()</div><div class="line">        grid.setSpacing(<span class="number">0</span>)</div><div class="line"></div><div class="line">        grid.addWidget(self.label_code, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">        grid.addWidget(label1, <span class="number">1</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(self.code_edit, <span class="number">2</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(label2, <span class="number">3</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(button2, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 关闭窗口</span></div><div class="line">        button2.clicked.connect(self.close)</div><div class="line">        self.setLayout(grid)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 该语句用来计算出显示器的分辨率（screen.width, screen.height）</span></div><div class="line">        screen = QtWidgets.QDesktopWidget().screenGeometry()</div><div class="line">        size = self.geometry()</div><div class="line">        self.move((screen.width() - size.width()) / <span class="number">2</span>, (screen.height() - size.height()) / <span class="number">2</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_text</span><span class="params">(self)</span>:</span></div><div class="line">        self.out_code = self.code_edit.text()</div><div class="line">        <span class="comment"># print(self.out_code)</span></div><div class="line">        <span class="keyword">return</span> self.out_code</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_code_img</span><span class="params">(self)</span>:</span></div><div class="line">        img = QtGui.QPixmap(self.img_path)</div><div class="line">        self.label_code.setPixmap(img)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span></div><div class="line">        code = self.get_text()</div><div class="line">        <span class="keyword">if</span> len(code) &lt; <span class="number">4</span> <span class="keyword">or</span> len(code) &gt;= <span class="number">8</span>:</div><div class="line">            QtWidgets.QMessageBox.about(self, <span class="string">"验证码输入错误"</span>, <span class="string">"请注意：\n验证码一般为4-6位，请重新输入!"</span>)</div><div class="line">            event.ignore()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            event.accept()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    app = QtWidgets.QApplication(sys.argv)</div><div class="line">    center = CodeRecognition()</div><div class="line"></div><div class="line">    <span class="comment"># 改变输入的图片。</span></div><div class="line">    path = <span class="string">"image_2.png"</span></div><div class="line">    center.img_path = path</div><div class="line">    center.show_code_img()</div><div class="line"></div><div class="line">    center.show()</div><div class="line">    app.exec_()</div><div class="line">    rec_code = center.get_text()</div><div class="line">    print(<span class="string">"识别的验证码为："</span>, rec_code)</div></pre></td></tr></table></figure></p><p>之前学过qt的同学看起来应该不困难，没有学过qt<br>的同学想要入门的话建议查看官方文档或者小甲鱼论坛的<a href="http://bbs.fishc.com/forum.php?mod=collection&amp;action=view&amp;ctid=153" target="_blank" rel="external">pyqt连接</a>。</p><p>最后附上完整的程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master" target="_blank" rel="external">github地址3</a></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/12/09/HDHome_clawler_tutorial/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python-基础篇</title>
      <link>https://wangwlj.com/2017/11/27/python_base_NJU_1/</link>
      <guid>https://wangwlj.com/2017/11/27/python_base_NJU_1/</guid>
      <pubDate>Mon, 27 Nov 2017 09:14:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;python基础&quot;&gt;&lt;a href=&quot;#python基础&quot; class=&quot;headerlink&quot; title=&quot;python基础&quot;&gt;&lt;/a&gt;python基础&lt;/h1&gt;&lt;p&gt;本文是学习南京大学Python玩转数据基础篇的笔记整理。&lt;/p&gt;
&lt;h2 id=&quot;pytho
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><p>本文是学习南京大学Python玩转数据基础篇的笔记整理。</p><h2 id="python类型"><a href="#python类型" class="headerlink" title="python类型"></a>python类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ol><li>整型/长整型： 长度与机器有关。长整型：整型值后面加上L。</li><li>布尔型：True、False。</li><li>浮点型：数学中的实数。可以用科学计数法表示。 float</li><li>复数型：虚数部分用j。</li></ol><pre><code>x = 2.4+ 5jOut[9]: (2.4+5j)type(x)Out[10]: complex</code></pre><p>复数可以对实数和复数部分分离。imag、real。</p><p>复数的共轭：conjugate()</p><pre><code>x.realOut[11]: 2.4x.imagOut[12]: 5.0x.conjugate()Out[13]: (2.4-5j)</code></pre><h3 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h3><p>字符串，列表[]，元组()</p><p>字符串：<br>        三种表示方式：单引号，双引号，三引号。<br>        可以使用索引操作符。</p><h3 id="映设类型"><a href="#映设类型" class="headerlink" title="映设类型"></a>映设类型</h3><p>字典：<br>        大括号{}鉴别；<br>        类似于哈希表的键值对。</p><h2 id="python运算"><a href="#python运算" class="headerlink" title="python运算"></a>python运算</h2><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><pre><code>+ - × /取余 %乘方 **整除 //  ----地板除</code></pre><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><pre><code>数值的比较：按值的大小字符串的比较：按ASCII码值的大小</code></pre><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><pre><code>not and or</code></pre><h3 id="字符运算"><a href="#字符运算" class="headerlink" title="字符运算"></a>字符运算</h3><pre><code>r / R,  ---原始字符串u / U</code></pre><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><pre><code>&lt;左移 &gt;右移</code></pre><h2 id="函数、模块与包"><a href="#函数、模块与包" class="headerlink" title="函数、模块与包"></a>函数、模块与包</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数可以看成类似于数学中的函数。完成一个特定功能的一段代码。如绝对值函数<code>abs()</code>，类型函数<code>type()</code>，四舍五入函数<code>round()</code>。</p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>如何查看python中自带的内建函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dir(__builtins__)</div></pre></td></tr></table></figure></p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>非内建函数如何使用呢？</p><p>如floor()函数，不是内建函数，但包含在math的头文件中，因此只需要导入该模块即可，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div></pre></td></tr></table></figure></p><p>什么是模块？<br>模块就是一个完整的python文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">文件：物理上的组织方式：math.py</div><div class="line">模块：逻辑上的组织方式：math</div></pre></td></tr></table></figure></p><p>Python中通常用<code>import 模块</code>的方式将现成模块中的函数、类重用到其他代码块中。</p><p>可以导入多个模快。可以从模块中导入指定的模块属性（把指定的名称导入）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleName</div><div class="line"><span class="keyword">import</span> ModuleName1,ModuleName2,...</div><div class="line"><span class="keyword">from</span> Module1 <span class="keyword">import</span> ModuleElement</div></pre></td></tr></table></figure></p><h3 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h3><p>包是有层次的文件目录结构。</p><p>比如说如下的目录结构定义了一个由模块和子包组成的Python应用程序执行环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">AAA/</div><div class="line">    __init__.py</div><div class="line">    bbb.py</div><div class="line">    CCC/</div><div class="line">    __init__.py</div><div class="line">        c1.py</div><div class="line">        c2.py</div><div class="line">    DDD/</div><div class="line">    __init__.py</div><div class="line">        d1.py</div><div class="line">    EEE/</div><div class="line">    ...</div></pre></td></tr></table></figure></p><p>因此，我们可以这样使用该包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> AAA.CCC.c1</div><div class="line">AAA.CCC.c1.func1(<span class="number">123</span>)</div></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> AAA.CCC.c1 <span class="keyword">import</span> func1</div><div class="line">func1(<span class="number">123</span>)</div></pre></td></tr></table></figure></p><h3 id="库（library）"><a href="#库（library）" class="headerlink" title="库（library）"></a>库（library）</h3><p>库是一组具有相关功能的模块的集合。<br>Python的一大特色就是具有强大的标准库、以及第三方库、以及自定义的模块。</p><h2 id="条件、循环与中断语句"><a href="#条件、循环与中断语句" class="headerlink" title="条件、循环与中断语句"></a>条件、循环与中断语句</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>if语句<br>else语句<br>elif语句：多分支情况下使用</p><p>其中，条件语句可以嵌套使用。</p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for iter_var in interable_object:</div><div class="line">    suite_to_repeat</div></pre></td></tr></table></figure><p>可以明确循环的次数，一般用在：</p><ul><li>遍历一个数据集的成员</li><li><p>在列表解析中使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">in</span>[<span class="number">4</span>]: [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</div><div class="line">Out[<span class="number">4</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div><div class="line"><span class="keyword">in</span>[<span class="number">5</span>]: [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)<span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</div><div class="line">Out[<span class="number">5</span>]: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure></li><li><p>在生成器表达式中使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">in</span>[<span class="number">6</span>]: (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)<span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>)</div><div class="line">Out[<span class="number">6</span>]: &lt;generator object &lt;genexpr&gt; at <span class="number">0x7f44af56f570</span>&gt;</div></pre></td></tr></table></figure></li></ul><p>可用于迭代的对象（iterable object）有：String、 List、Tuple、Dictionary、File。</p><h3 id="range语句"><a href="#range语句" class="headerlink" title="range语句"></a>range语句</h3><p>一般与for语句配合使用。</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while expression:</div><div class="line">suitr_to_repeat</div></pre></td></tr></table></figure></p><p>其中，expression是条件表达式，当expression的值为    True的时候，执行suitr_to_repeat的代码块。</p><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>while循环中的break与for循环中的break。</p><h3 id="循环中的else语句"><a href="#循环中的else语句" class="headerlink" title="循环中的else语句"></a>循环中的else语句</h3><p>循环中的else：<br>如果是正常结束，就执行else中的代码；break处中止，就不执行else。</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h3 id="自定义函数的创建："><a href="#自定义函数的创建：" class="headerlink" title="自定义函数的创建："></a>自定义函数的创建：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def function_name([arguments]):</div><div class="line">    &quot;optional documentation string&quot;</div><div class="line">    function_suite</div></pre></td></tr></table></figure><p>其中，def下一行可以是函数文档。～～～～～要学会使用函数文档！！</p><h3 id="自定义函数的调用"><a href="#自定义函数的调用" class="headerlink" title="自定义函数的调用"></a>自定义函数的调用</h3><p>函数名加上函数运算符，一对小括号。</p><p>括号之间是所有可选的参数，即使没有参数，小括号也不能省略。</p><p>参数问题，有参数就必须加上去。除非有默认值的可以不需要。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>函数的参数可以有一个默认值，如果提供有默认值，在函数定义中，默认参数以赋值语句的形式提供。</p><p>默认参数的值可以改变。</p><p>默认参数一般需要放置在参数列表的最后。默认参数后面不能有非默认参数。</p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数是让调用者通过使用参数名区分参数。允许你改变参数列表中的参数顺序。</p><h3 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h3><p>函数可以像参数一样传递给另外一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def addMe2Me(x):</div><div class="line">    return (x+x)</div><div class="line">def self(f,y):</div><div class="line">    print f(y)</div><div class="line"></div><div class="line">&gt;&gt;&gt; self(addMe2Me,2.2)</div><div class="line">4.4</div></pre></td></tr></table></figure></p><h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>匿名函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 普通的函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_add</span><span class="params">(x,y)</span>:</span> <span class="keyword">return</span> x+y</div><div class="line"><span class="comment"># 匿名函数</span></div><div class="line"><span class="keyword">lambda</span> x, y : x + y</div><div class="line">my_add = <span class="keyword">lambda</span> x, y : x + y</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_add(<span class="number">3</span>,<span class="number">5</span>)</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>函数内部就是局部变量。</p><p>函数内部可以调用全局变量，使用<code>global</code>语句。</p><p>当全局变量和局部变量使用的是同一个名字时，内层会屏蔽外层。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归介绍"><a href="#递归介绍" class="headerlink" title="递归介绍"></a>递归介绍</h3><p>递归必须有边界条件，即停止递归的条件。 如n==0 或者n==1的情况。</p><p>递归的代码更简洁，更符合自然逻辑，更容易理解。</p><p>递归的执行方式：逐层递归调用，遇到边界条件停止递归，逐层返回调用至最初层，系统资源的消耗比循环大。</p><h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Filename: Hanoi.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span><span class="params">(a, b, c, n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">        print(a, <span class="string">'-&gt;'</span>, c)</div><div class="line"></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        hanoi(a, c, b, n - <span class="number">1</span>)</div><div class="line">        print(a, <span class="string">'-&gt;'</span>, c)</div><div class="line">        hanoi(b, a, c, n - <span class="number">1</span>)</div><div class="line"></div><div class="line"></div><div class="line">hanoi(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a -&gt; c</div><div class="line">a -&gt; b</div><div class="line">c -&gt; b</div><div class="line">a -&gt; c</div><div class="line">b -&gt; a</div><div class="line">b -&gt; c</div><div class="line">a -&gt; c</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/11/27/python_base_NJU_1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>DeepLab简介及其pytorch实现</title>
      <link>https://wangwlj.com/2017/11/23/Torch_DeepLab/</link>
      <guid>https://wangwlj.com/2017/11/23/Torch_DeepLab/</guid>
      <pubDate>Thu, 23 Nov 2017 14:48:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;pytorch实现DeepLab&quot;&gt;&lt;a href=&quot;#pytorch实现DeepLab&quot; class=&quot;headerlink&quot; title=&quot;pytorch实现DeepLab&quot;&gt;&lt;/a&gt;pytorch实现DeepLab&lt;/h1&gt;&lt;p&gt;使用pytorch搭建Dee
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="pytorch实现DeepLab"><a href="#pytorch实现DeepLab" class="headerlink" title="pytorch实现DeepLab"></a>pytorch实现DeepLab</h1><p>使用pytorch搭建DeepLab。</p><h2 id="DeepLab简介"><a href="#DeepLab简介" class="headerlink" title="DeepLab简介"></a>DeepLab简介</h2><p>DeepLab文章的下载地址：<a href="https://arxiv.org/abs/1606.00915" target="_blank" rel="external">https://arxiv.org/abs/1606.00915</a></p><p>该文章的主要思想之一：<br>提出了Atrous convolution（带孔卷积）。<br>扩大视野但不增加计算量。</p><p>所谓的带孔卷积，就是在卷积核之间加上0。rate参数为2（torch中对应的参数为dilation）的示意图如下<br><img src="/2017/11/23/Torch_DeepLab/2.png" alt="Atrous convolution(rate=2)" title="Atrous convolution(rate=2)"></p><p>rate = 2就是在原卷积核相邻两个元素之间补上一个0，假设原卷积核为3x3，rate = 2的带孔卷积核的大小就为<code>3+(3-1) × (rate-1)=5</code>。</p><p>下图是不同rate的带孔卷积。</p><p><img src="/2017/11/23/Torch_DeepLab/different_rate.png" alt="different_rate"></p><p>以<code>rate = 12</code> 为例，带孔卷积的核的大小为：<code>3+(3-1)x(12-1)=25</code>，即新卷积核的大小为：<code>25*25</code>。</p><p>总的来说，对于<code>rate=r</code>的带孔卷积，在连接着的卷积核元素间插入<code>r-1</code>个元素。因此，扩展后的卷积核大小为$k_{new}=k+(k-1)(r-1)$。</p><h2 id="pytorch实现deeplab"><a href="#pytorch实现deeplab" class="headerlink" title="pytorch实现deeplab"></a>pytorch实现deeplab</h2><p>笔者主要目的是实现一下不同视野的concat过程。</p><p>在torch中，卷积函数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</div><div class="line">nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, groups=<span class="number">1</span>, bias=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p><p>其中的dilation参数就是带孔卷积的参数（也就是tensorFlow下的rate），默认情况下为1，就是普通的卷积，所以带孔卷积只需要修改这个参数就可以了。</p><p>比如说，我们已经写好了不同的视野下的卷积，然后需要将他们的feature map叠加起来，torch中使用<code>torch.cat(inputs, dimension=0)</code>函数来进行叠加。torch的参数一般是四个维度的：<code>[n_batch_size, n_feature_map, height, weight]</code>，所以参数中的<code>dimension = 1</code>就是对<code>feature map</code>叠加。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = torch.cat([x2, x3, x4, x5], dim=<span class="number">1</span>)</div></pre></td></tr></table></figure><p>叠加的这一步非常容易出错，原因在于，要求叠加的所有图片大小是一样的。而视野不同导致的卷积核的大小不同，也会导致最终输出的图像大小的变化，因此，需要恰当的调整zero-padding的数目来使得最终输出图像的大小保持一致。</p><p>另外稍微提一下，全连接层的输入向量大小的确定方法。全连接层是将上一步所得到的图像reshape为一个一维的向量之后，作为它的输入，因此，输入向量的长度为： <code>in_channels = nFeatureMap * height * weight</code>。</p><p>网络整体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(Net, self).__init__()</div><div class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">1</span>)</div><div class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">1</span>)</div><div class="line">        self.conv2_drop = nn.Dropout2d() </div><div class="line">        self.fc1 = nn.Linear(<span class="number">40</span> * <span class="number">4</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">50</span>) </div><div class="line">        self.fc2 = nn.Linear(<span class="number">50</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line">        self.conv_rate_1 = nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">2</span>, padding=<span class="number">2</span>) </div><div class="line">        self.conv_rate_2 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">3</span>, padding=<span class="number">3</span>) </div><div class="line">        self.conv_rate_3 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">4</span>, padding=<span class="number">4</span>)</div><div class="line">        self.conv_rate_4 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">5</span>, padding=<span class="number">5</span>)</div><div class="line">        self.conv_rate_5 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></div><div class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), <span class="number">2</span>)</div><div class="line">        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), <span class="number">2</span>))</div><div class="line">        x = self.conv_rate_1(x)</div><div class="line">        x2 = self.conv_rate_2(x)</div><div class="line">        x3 = self.conv_rate_3(x)</div><div class="line">        x4 = self.conv_rate_4(x)</div><div class="line">        x5 = self.conv_rate_5(x)</div><div class="line">        <span class="comment"># print(x.data.shape)</span></div><div class="line">        <span class="comment"># print(x2.data.shape)</span></div><div class="line">        <span class="comment"># print(x3.data.shape)</span></div><div class="line">        <span class="comment"># print(x4.data.shape)</span></div><div class="line">        <span class="comment"># print(x5.data.shape)</span></div><div class="line">        x = torch.cat([x2, x3, x4, x5], dim=<span class="number">1</span>)</div><div class="line"></div><div class="line">        <span class="comment"># for FC</span></div><div class="line">        x = x.view(<span class="number">-1</span>, self.num_flat_features(x))  <span class="comment"># origin is 320</span></div><div class="line">        x = F.relu(self.fc1(x))  <span class="comment"># fc-&gt;relu</span></div><div class="line">        x = F.dropout(x, training=self.training)  <span class="comment"># dropout</span></div><div class="line">        x = self.fc2(x)</div><div class="line">        <span class="keyword">return</span> F.log_softmax(x)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_flat_features</span><span class="params">(self, x)</span>:</span></div><div class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># all dimensions except the batch dimension</span></div><div class="line">        num_features = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</div><div class="line">            num_features *= s</div><div class="line">        <span class="keyword">return</span> num_features</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://wangwlj.com/2017/11/23/Torch_DeepLab/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
