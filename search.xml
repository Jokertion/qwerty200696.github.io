<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[个人博客的域名注册与备案流程]]></title>
      <url>/2017/12/19/blog_domain_register/</url>
      <content type="html"><![CDATA[<h2 id="域名注册"><a href="#域名注册" class="headerlink" title="域名注册"></a>域名注册</h2><p>简要说一下为什么选择<strong>万网</strong>。</p>
<p>看到网上的教程一般都是推荐到国外网站注册，如godaddy，Gandi，Namesilo等等。<br>但一般都是比较早期的回答(2011-13)了，目前(2017/12)来说，仅从<strong>价格</strong>因素考虑，阿里云万网域名是普遍低于国外网站的。</p>
<p><strong>万网域名注册地址</strong>：<a href="https://wanwang.aliyun.com/domain/" target="_blank" rel="external">https://wanwang.aliyun.com/domain/</a></p>
<p>另外，关于<strong>域名后缀</strong>选择问题，一般来说，<strong>首选com域名</strong>，不推荐cn域名（国内监管严格的原因？）。其次，个人博客站点可以考虑其他后缀，如net，top，me(貌似万网不支持了)，xyz等等。</p>
<p>选择了心仪的域名之后，购买。以阿里云为例，购买完成后，点击右上角的<strong>控制台</strong>；进入控制台后，选择左下角的<strong>域名与网站（万网）</strong>下的<strong>域名</strong>，进入域名列表界面。</p>
<p>可以看到，右方出现了三个选项【续费】、【解析】【管理】<br><img src="https://images2.imgbox.com/cc/51/JLumBDiL_o.png" alt="域名列表界面"></p>
<p>点击<strong>解析</strong>，按照操作，添加解析即可。主要填写三个参数：记录类型、主机记录和记录值。</p>
<p><strong>记录类型</strong>：CNAME是跳转到其他网址，我的是github博客，就直接让他跳转到github博客即可。A是指向IPV4地址。</p>
<p><strong>主机记录</strong>是网址的前缀，比如说注册的网址是xxx.com，那么blog.xxx.com的主机记录就是blog，xxx.com的主机记录可以不填，也可以填上一个@</p>
<p>给出我目前的解析值作为参考。<br><img src="https://images2.imgbox.com/8f/d8/befX67KY_o.png" alt="解析值"><br>第一个是为了让百度搜索引擎抓取的，每个网址的主机记录都不同，可以忽略。</p>
<h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p>我使用的是<a href="http://wangwlj.com/2017/09/08/blog_setup/">hexo+Github搭建个人博客</a>，因此，只买了域名（也可以不买，直接使用github.io地址），没有买云服务器、虚拟主机之类的，因此无法备案。</p>
<p>简而言之，备案需要有<strong>服务器</strong>，然后到服务器提供商处备案即可。</p>
<p>阿里云官方的备案完整流程，可供备案参考：<a href="https://help.aliyun.com/knowledge_detail/36895.html" target="_blank" rel="external">https://help.aliyun.com/knowledge_detail/36895.html</a></p>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 域名 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客优化之实现来必力评论功能]]></title>
      <url>/2017/12/18/blog_comment/</url>
      <content type="html"><![CDATA[<h2 id="评论功能概述"><a href="#评论功能概述" class="headerlink" title="评论功能概述"></a>评论功能概述</h2><p>目前博客站点使用的评论功能，多说，网易云跟贴都已经下线。Disqus也被挡在墙外，友言貌似也不行。</p>
<p>可用的评论系统大概有：</p>
<ul>
<li><p>HyperComments：<a href="https://www.hypercomments.com" target="_blank" rel="external">https://www.hypercomments.com</a> （来自俄罗斯的评论系统，使用谷歌账号注册。可以访问，不会用，好气，，）</p>
</li>
<li><p>来必力：<a href="https://livere.com" target="_blank" rel="external">https://livere.com</a> （来自韩国，使用邮箱注册。）</p>
</li>
<li><p>畅言： <a href="http://changyan.kuaizhan.com" target="_blank" rel="external">http://changyan.kuaizhan.com</a> （安装需要备案号。不太好用。）</p>
</li>
<li><p>Gitment： <a href="https://github.com/imsun/gitment" target="_blank" rel="external">https://github.com/imsun/gitment</a> （有点小bug，比如说每次需要手动初始化，登录时会跳到主页。。）</p>
</li>
<li><p>Valine:  <a href="https://github.com/xCss/Valine" target="_blank" rel="external">https://github.com/xCss/Valine</a> (基于Leancloud的极简风评论系统，用了下，没效果，是我Next主题的原因还是？）</p>
</li>
</ul>
<p>综上，最终采用了来必力。</p>
<h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>打开来必力官网：<br><a href="https://livere.com" target="_blank" rel="external">https://livere.com</a></p>
<p>按套路注册（有可能注册上面要花费点功夫）。（貌似需要科学上网？之前没科学上网好像登录界面显示不了）。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>点击上方的安装，选择免费的city版本。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fml5edyp4bj20wt0lymyx.jpg" alt=""></p>
<p>并点击现在安装，出现如下界面。<br><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fml5ekh4erj20yh0me0uf.jpg" alt=""></p>
<p>复制其中的uid字段。</p>
<p>打开主题目录下的<code>blog/themes/next/_config.yml</code>配置文件，定位到<code>livere_uid</code>字段，粘贴上刚刚复制的UID。</p>
<p>至此，大功告成。</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>测试评论如图所示：<br><img src="https://images2.imgbox.com/b3/f1/9s6btT5a_o.png" alt=""></p>
<h2 id="设置提醒"><a href="#设置提醒" class="headerlink" title="设置提醒"></a>设置提醒</h2><p>当有新评论出现时，通过邮箱提醒。</p>
<p>点击<code>右上角-&gt;管理页面</code>。选择<code>评论提醒</code>，按照下图设置，输入邮箱、选择间隔时间。</p>
<p><img src="https://images2.imgbox.com/36/9a/23YhEmlz_o.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> 来必力 </tag>
            
            <tag> 评论功能 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法导论详解(2) 第三章函数的增长]]></title>
      <url>/2017/12/13/algorithm_tutorial_chapter_3/</url>
      <content type="html"><![CDATA[<h2 id="3-1-渐近记号"><a href="#3-1-渐近记号" class="headerlink" title="3.1 渐近记号"></a>3.1 渐近记号</h2><p>$\Theta、 \text{O}和\Omega $三种记号的图示：<br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_1.png" alt="1"></p>
<h3 id="先看第一幅图-a-——-Theta-记号"><a href="#先看第一幅图-a-——-Theta-记号" class="headerlink" title="先看第一幅图(a)——$\Theta$记号"></a>先看第一幅图(a)——$\Theta$记号</h3><p>若存在正常量$c_1,c_2,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant c_1g(n)\leqslant f(n) \leqslant c_2g(n)$，则$f(n)$属于集合$\Theta(g(n))$，<br>可以记为$f(n)\in \Theta(g(n))$，我们通常用$f(n)=\Theta(g(n))$表达相同的概念。</p>
<p>上述公式的含义：函数f(n)能“夹入”$c_1g(n)$和$c_2g(n)$之间。换句话说，对所有的$n\geqslant n_0$，函数$f(n)$在一个常量因子内等于$g(n)$，我们称$g(n)$是$f(n)$的一个渐近紧确界(asymptotically tight bound)。</p>
<p>实例：可以用上述的形式化定义来证明：$\frac{1}{2}n^2-3n =\Theta(n^2)$，以及$6n^3 \neq \Theta(n^2)$。</p>
<p>渐近正函数就是对足够大的n均为正的函数。</p>
<p>直觉上，一个渐近正函数的低阶项 在确定渐近确界时可以被忽略，因为对于大的n，它们是无足轻重的。</p>
<p>一般来说，对任意多项式$p(n)=\sum_{i=0}^d a_i n^i$，其中$a_i$为常量且$a_d&gt;0$（最高阶的系数大于零），则有$p(n)=\Theta(n_d)$。</p>
<h3 id="接着看图-b-——-text-O-记号"><a href="#接着看图-b-——-text-O-记号" class="headerlink" title="接着看图(b)——$\text{O}$记号"></a>接着看图(b)——$\text{O}$记号</h3><p>$\Theta$记号渐近地给出了一个函数的上界和下届。当只有一个<em>渐近上界</em>时，使用$\text{O}$记号。</p>
<p>$\text{O}(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant  f(n) \leqslant cg(n)}$</p>
<p>我们记$f(n)=\text{O}(g(n))$表示$f(n)$是集合$\text{O}(g(n))$的成员。注意$f(n)=\Theta(g(n))$蕴含了$f(n)=\text{O}(g(n))$，因为$\Theta$记号是一个比$\text{O}$记号更强的概念。</p>
<p>使用$\text{O}$记号，我们常常可以仅仅通过检查算法的总体结构来描述算法的运行时间。$\text{O}$记号描述上界，对插入排序算法的最坏情况运行时间的界$\text{O}(n^2)$也适合于该算法对每个输入的运行时间。该算法对每个输入的运行时间都有一个界，这就是综合性描述。</p>
<h3 id="最后看图-c-——-Omega-记号"><a href="#最后看图-c-——-Omega-记号" class="headerlink" title="最后看图(c)——$\Omega$记号"></a>最后看图(c)——$\Omega$记号</h3><p>正如$\text{O}$记号提供了渐近上界，$\Omega$记号提供了渐进下界。</p>
<p>$\Omega(g(n))={f(n)：$存在正常量$c,n_0$，使得对所有$n\geqslant n_0$，有$0\leqslant  cg(n) \leqslant f(n)}$</p>
<p>于是，由此引出了定理3.1。</p>
<h4 id="定理-3-1"><a href="#定理-3-1" class="headerlink" title="定理 3.1"></a>定理 3.1</h4><p>对任意两个函数$f(n)$和$g(n)$，我们有$f(n)=\Theta(g(n))$，当且仅当$f(n)=\text{O}(g(n))$且$f(n)=\Omega(g(n))$。</p>
<p>当一个算法的运行时间为$\Omega(g(n))$时，我们意指不管n是什么规模，只要n足够大，对那个输入的运行时间至少是$g(n)$的常数倍。</p>
<h3 id="等式和不等式中的渐近记号"><a href="#等式和不等式中的渐近记号" class="headerlink" title="等式和不等式中的渐近记号"></a>等式和不等式中的渐近记号</h3><p>当渐近记号出现在某个公式中时，我们将其解释为代表某个我们不关注名称的匿名函数。</p>
<p>例如：$2n^2+3n+1 = 2n^2 +\Theta(n)$。</p>
<p>按这种方式使用渐记号可以帮助消除一个等式中无关紧要的细节与混乱。</p>
<p>例如：归并排序的最坏情况运行时间：<br>$$T(n) = 2T(n/2)+\Theta(n)$$<br>如果只对T(n)的渐近行为感兴趣，就没必要准确说明所以低阶项，它们都被理解为包含在由项$\Theta(n)$表示的匿名函数中。</p>
<p>在某些例子中，渐近记号出现在等式的左边，如：<br>$$2n^2+\Theta(n) = \Theta(n^2) $$</p>
<p>无论怎么选择等号左边的匿名函数，总有一种办法来选择等号右边的匿名函数使等式成立。</p>
<h3 id="text-o-记号"><a href="#text-o-记号" class="headerlink" title="$\text{o}$记号"></a>$\text{o}$记号</h3><p>$\text{o}$记号，非渐近紧确的上界。</p>
<p>$\text{o}(g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant  f(n) &lt; cg(n)}$。</p>
<p>$\text{O}$记号与$\text{o}$记号类似，主要的区别 是在$f(n)=\text{O}(g(n))$中，界$0\leqslant  f(n) \leqslant cg(n)$对某个常量$c&gt;0$成立，但在$f(n)=\text{o}(g(n))$中，界$0\leqslant  f(n) &lt; cg(n)$对所有常量$c&gt;0$成立。</p>
<p>直观上，在$\text{o}$记号中，当n趋向于无穷时，函数$f(n)$相对于$g(n)$来说变得微不足道了，即：<br>$$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = 0$$</p>
<h3 id="omega-记号"><a href="#omega-记号" class="headerlink" title="$\omega$记号"></a>$\omega$记号</h3><p>非渐近紧确下界。</p>
<p>$\omega (g(n))={f(n)：$对任意正常量$c&gt;0$，存在正常量$n_0&gt;0$，使得对所有$n\geqslant n_0$，有$0\leqslant cg(n) &lt;  f(n) }$。</p>
<p>$$\lim_{n\rightarrow \infty} \frac{f(n)}{g(n)} = \infty $$</p>
<h3 id="渐近运算的运算性质"><a href="#渐近运算的运算性质" class="headerlink" title="渐近运算的运算性质"></a>渐近运算的运算性质</h3><p>传递性、自反性、对称性与转置对称性：<br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_2.png" alt="2"><br><img src="/2017/12/13/algorithm_tutorial_chapter_3/algorithm_chap_3_3.png" alt="3"><br>而且：两个函数f和g的渐近比较关系可与实数a与b之间的比较做类比： </p>
<ul>
<li>f(n)=O(g(n)) 类似于a&lt;= b </li>
<li>f(n)=Ω(g(n)) 类似于a&gt;= b </li>
<li>f(n)=Θ(g(n)) 类似于a= b </li>
<li>f(n)=o(g(n)) 类似于a&lt; b </li>
<li>f(n)=w(g(n)) 类似于a&gt; b</li>
</ul>
<p>三分性：虽然实数具有三分性，即对于任意两个实数a、b，下列三种情况必须有一种成立：$a<b$，$a=b$或$a>b$。但是不是所有函数都可以渐近比较。</b$，$a=b$或$a></p>
<h2 id="3-2-标准记号与常用函数"><a href="#3-2-标准记号与常用函数" class="headerlink" title="3.2 标准记号与常用函数"></a>3.2 标准记号与常用函数</h2><h3 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h3><p>单调递增/单调递减：包含等号；严格递增/严格递减：不包含等号。</p>
<h3 id="向下取整与向上取整"><a href="#向下取整与向上取整" class="headerlink" title="向下取整与向上取整"></a>向下取整与向上取整</h3><p>x的向下取整：$\lfloor x \rfloor$；x的向上取整：$\lceil x \rceil$。</p>
<h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>对任意整数a和正整数n，$a\ \text{mod}\ n$ 的值就是商a/n的余数。<br>$$a\ \text{mod}\ n = a-n\lfloor a/n\rfloor $$</p>
<p>若$(a\ \text{mod}\ n)=(b\ \text{mod}\ n)$，则记$a\equiv b(\text{mod}n)$</p>
<h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><p>给定一个非负整数d，n的d次多项式$p(n)$：<br>$$p(n)=\sum_{i=0}^d a_i n^i$$<br>其中，$a_d \neq 0 $。</p>
<p>多项式为渐近正的当且仅当$a_d &gt; 0 $。对于一个d次渐近正的多项式$p(n)$，有$p(n)=\Theta(n^d)$</p>
<p>若对于某个常量k，有$f(n)=\text{O}(n^k)$，则称函数$f(n)$是多项式有界的。</p>
<h3 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h3><p>对所有使得$a&gt;1$的实常量a和b，有<br>$$\lim_{n\rightarrow \infty} \frac{n^b}{a^n} = 0$$<br>据此可得：<br>$$n^b = \text{o}(a^n)$$</p>
<h3 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h3><p>以2为底的自然数：<br>$$\text{lg}n = \text{log}_2n$$<br>自然对数：<br>$$\text{ln}n = \text{log}_en$$<br>取幂：<br>$$\text{lg}^kn = (\text{lg}n)^k$$<br>复合：<br>$$\text{lg}\text{lg}n =\text{lg} (\text{lg}n)$$</p>
<p>一个重要的记号约定：对数函数只适用于公式中的下一项，所以$\text{lg}n+k$意思是指$(\text{lg}n)+k$</p>
<p>对于$a&gt;0,b&gt;0,c&gt;0$和n，有<br>$$a = b^{\text{log}_ba}$$<br>$$\text{log}_c(ab) = \text{log}_ca +\text{log}_cb$$<br>$$\text{log}_b(a^n) = n\text{log}_ba$$<br>$$\text{log}_ba =\frac{\text{log}_ca}{\text{log}_cb} $$<br>$$\text{log}_b(1/a) =- \text{log}_ba $$<br>$$\text{log}_ba =\frac{1}{\text{log}_ab} $$<br>$$a^{\text{log}_bc} = c^{\text{log}_ba}$$<br>其中，上述等式的对数底不为1。</p>
<p>对任意常量a，有<br>$$\text{log}^bn = \text{o}(n^a)$$<br>表示任意正的多项式函数都比任意多对数函数增长得快。</p>
<h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><p>$n!$，读作“n的阶乘”。其定义为对整数$n \geqslant 0$：<br>$$n! = \begin{cases}<br>1 &amp; 若n=0\\<br>n\cdot (n-1)! &amp; 若n&gt;0<br>\end{cases}$$</p>
<p>阶乘函数的一个弱上界是$n! \leqslant n^n$，因为在阶乘中，n项的每项最多为n。</p>
<h4 id="斯特林-Stirling-近似公式"><a href="#斯特林-Stirling-近似公式" class="headerlink" title="斯特林(Stirling)近似公式"></a>斯特林(Stirling)近似公式</h4><p>$$n!=\sqrt{2\pi n}(\frac{n}{e})^n(1+\Theta(\frac{1}{n})) $$</p>
<p>由上述公式可以证明：<br>$$n! = o(n^n)$$<br>$$n! = \omega(2^n)$$<br>$$\text{lg}n! = \Theta(n\text{lg}n)$$</p>
<h3 id="多重函数"><a href="#多重函数" class="headerlink" title="多重函数"></a>多重函数</h3><p>记号$f^{(i)}(n)$表示f(n)重复i次作用于一个初值n上。对非负整数i，我们递归地定义：<br>$$f^{(i)}(n)=\begin{cases}<br>n &amp; 若i=0 \\<br>f(f^{(i-1)}(n)) &amp; 若i&gt;0<br>\end{cases}$$</p>
<h3 id="多重对数函数"><a href="#多重对数函数" class="headerlink" title="多重对数函数"></a>多重对数函数</h3><p>$\text{lg}^*n$表示多重对数，多重对数增长非常慢。</p>
<h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p>斐波那契数的递归定义：<br>$$F_0 = 0$$<br>$$F_1 = 1$$<br>$$F_i = F_{i-1}+F_{i-2}, i \geqslant 2$$</p>
]]></content>
      
        <categories>
            
            <category> 算法导论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> algorithm </tag>
            
            <tag> 函数渐近 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法导论详解(1) 第二章算法基础]]></title>
      <url>/2017/12/12/algorithm_tutolrial_chapter_2/</url>
      <content type="html"><![CDATA[<h1 id="第二章-算法基础"><a href="#第二章-算法基础" class="headerlink" title="第二章 算法基础"></a>第二章 算法基础</h1><h2 id="伪码说明"><a href="#伪码说明" class="headerlink" title="伪码说明"></a>伪码说明</h2><ol>
<li><p>数组A[1,…,n]长度为n的待排序序列。<br>注意，书中的下标都是从1开始的。python中是从0开始的。</p>
</li>
<li><p>伪码中，A的长度用A.length表示。python中使用len(A)表示。</p>
</li>
<li>缩进表示块结构。提高代码清晰度。</li>
<li>while, for, repeat-until 在循环结束后，循环计数器仍然保持其值。</li>
<li>符号“//”后面是注释。</li>
<li>数组元素通过“数组名[下标]”这样的形式来访问。</li>
<li>复合数据通常被组织成<em>对象</em>，对象又由<em>属性</em>组成。</li>
<li>return允许返回多个值</li>
<li>按值把参数传递给过程，被调用过程接收其参数自身的副本。</li>
<li>布尔运算符“and”和“or”都是短路的。</li>
</ol>
<h2 id="2-1-插入排序"><a href="#2-1-插入排序" class="headerlink" title="2.1 插入排序"></a>2.1 插入排序</h2><p>插入排序的Python实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(A)</span>:</span></div><div class="line">    length = len(A)</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, length):</div><div class="line">        key = A[j]</div><div class="line">        i = j - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key:</div><div class="line">            A[i + <span class="number">1</span>] = A[i]</div><div class="line">            i = i - <span class="number">1</span></div><div class="line">        A[i + <span class="number">1</span>] = key</div><div class="line">    <span class="keyword">return</span> A</div><div class="line">A = [<span class="number">5</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">8</span>, ]</div><div class="line">print(insertion_sort(A))</div></pre></td></tr></table></figure></p>
<p>对插入排序的简单理解：<br>从第二个数开始，依次比较前面的数和key的大小，若大于key，则后移。<br>最后将key插入到最前方停下的位置。<br>j是遍历数组每个元素；<br>i是每个元素前面、需要移动的最前方。</p>
<p>形象的解释：插入纸牌：key是当前带插入的牌，找到插入的位置，先把每个大的都往后挪一个位置出来，再把key插入到空出来的位置。</p>
<h2 id="2-2-分析算法"><a href="#2-2-分析算法" class="headerlink" title="2.2 分析算法"></a>2.2 分析算法</h2><p>RAM（Random-access machine,RAM）模型:单处理器计算模型，指令一条接一条地执行，没有并发操作。</p>
<p>真实计算机如何设计，RAM模型就是如何设计的，RAM模型包含真实计算机的常见指令：算术指令（加减乘除，取余，向下取整，向上取整），数据移动指令（装入、存储和复制）和控制指令（条件与无条件转移、子程序调用与返回）。</p>
<p>灰色区域：真实计算机中未列出的指令。如指数运算算是常量时间的指令吗？</p>
<p>答案：①一般情况下不是，如$x^y$，当x和y都是实数的时候。②在受限情况下，可以当做一个常量时间的操作。如$2^k$是一个常量的操作。</p>
<p>一个整数的各位左移k位等价于将该整数乘以$2^k$。</p>
<h3 id="插入排序算法的分析"><a href="#插入排序算法的分析" class="headerlink" title="插入排序算法的分析"></a>插入排序算法的分析</h3><p>算法需要的时间与输入规模同步增长，通常把一个程序的运行时间描述成其输入规模的函数。</p>
<p>输入规模的最佳概念依赖于研究的问题。</p>
<p>一个算法在特定输入上的运行时间是指执行的基本操作数或步数。<br>算法的运行时间是执行每条语句的运行时间之和。</p>
<p>若数组已排好序，则出现最佳情况：$T(n)=an+b$<br>若数组已反向排序（即按递减序排好序），则导致最坏情况：$T(n)=an^2+b$，是n的二次函数。</p>
<h3 id="最坏情况与平均情况分析"><a href="#最坏情况与平均情况分析" class="headerlink" title="最坏情况与平均情况分析"></a>最坏情况与平均情况分析</h3><p>本书往往集中于只求<em>最坏情况运行时间</em>，即对于规模为n的任何输入，算法的最长时间。</p>
<p>书中给出了三个理由，在此不详述。其中一点是平均情况往往与最坏情况一样差。</p>
<h3 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h3><p>最坏情况运行时间表示为：$T(n)=an^2+b$。</p>
<p>现在我们做出一种更简化的抽象：我们真正感兴趣的运行时间的$增长率$或$增长量级$。</p>
<h2 id="2-3-设计算法"><a href="#2-3-设计算法" class="headerlink" title="2.3 设计算法"></a>2.3 设计算法</h2><h3 id="2-3-1-分治法"><a href="#2-3-1-分治法" class="headerlink" title="2.3.1 分治法"></a>2.3.1 分治法</h3><p>许多算法在结构上是递归的，算法依次或多次递归地调用其自身以解决紧密相关的若干子问题。</p>
<p>分治模式在每层递归时都有三个步骤：</p>
<ul>
<li>分解原问题为若干子问题；</li>
<li>解决这些子问题，递归地求解各子问题。</li>
<li>合并这些子问题的解成原问题的解。</li>
</ul>
<p><em>归并排序</em>算法完全遵循分治模式。归并算法的关键在于合并。<br>归并排序的的基本步骤如下：</p>
<ol>
<li>把待排序的数组分为左数组和右数组</li>
<li>对左数组和右数组进行迭代排序</li>
<li>将左数组和右数组进行合并</li>
</ol>
<p>显然这些基本步骤符合分治模式在每一层递归上的三个步骤：分解、解决、合并。</p>
<h2 id="2-3-2-归并排序算法（分治算法）"><a href="#2-3-2-归并排序算法（分治算法）" class="headerlink" title="2.3.2 归并排序算法（分治算法）"></a>2.3.2 归并排序算法（分治算法）</h2><p>MERGE(A,p,q,r)：完成合并。A是一个数组，p,q,r是数组的下标，满足$p\leqslant q&lt;r$。假设A[p..q]与A[q+1..r]都已排好序，MERGE函数的目的就是合并这两个子数组形成单一的已排好序的数组A[p..r]。</p>
<p>形象地描述：同样以插入排序时的扑克牌为例，现在的情况是有两堆牌（两个输入堆），牌面朝上（可见，已排序），每次选取两堆中较小的放入到输出堆，牌面朝下。重复这个步骤，直到一个输入堆为空，则把另一个输入堆直接牌面朝下的放置到输出堆。</p>
<p>MERGE-SORT(A,p,r)排序子数组A[p,r]中的元素。若$p\geqslant r$，则该子数组最多只有一个元素，所以已经排好序，直接返回。否则，分解步骤。计算下表q，将A[p..r]分为A[p..q]和A[q+1..r]。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># author: wangwlj</span></div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> floor</div><div class="line"></div><div class="line">MAX = <span class="number">1</span> &lt;&lt; <span class="number">31</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(A, p, q, r)</span>:</span></div><div class="line">    n1 = q - p + <span class="number">1</span></div><div class="line">    n2 = r - q</div><div class="line">    L = []</div><div class="line">    R = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n1):</div><div class="line">        L.append(A[p + i])  <span class="comment"># 因为我初始化为空列表，所以直接赋值的话会报错，只能以append的形式追加值。</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n2):</div><div class="line">        R.append(A[q + i + <span class="number">1</span>])</div><div class="line">    L.append(MAX)  <span class="comment"># 使用无穷大作为哨兵</span></div><div class="line">    R.append(MAX)</div><div class="line">    <span class="keyword">assert</span> len(L) == n1 + <span class="number">1</span> <span class="keyword">and</span> len(R) == n2 + <span class="number">1</span></div><div class="line"></div><div class="line">    i = <span class="number">0</span>  <span class="comment"># python是从0开始</span></div><div class="line">    j = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(p, r + <span class="number">1</span>):  <span class="comment"># 需要加1，因为首尾每个都算</span></div><div class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]:</div><div class="line">            A[k] = L[i]</div><div class="line">            i += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            A[k] = R[j]</div><div class="line">            j += <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(A, p, r)</span>:</span></div><div class="line">    <span class="keyword">if</span> p &lt; r:</div><div class="line">        q = floor((p + r) / <span class="number">2</span>)</div><div class="line">        merge_sort(A, p, q)</div><div class="line">        merge_sort(A, q + <span class="number">1</span>, r)  <span class="comment"># 首尾都包含了，所以要加1</span></div><div class="line">        merge(A, p, q, r)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    <span class="comment"># test function</span></div><div class="line">    A = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>]</div><div class="line">    merge_sort(A, <span class="number">0</span>, len(A) - <span class="number">1</span>)</div><div class="line">    print(A)</div></pre></td></tr></table></figure>
<p>上述代码测试成功。</p>
<h3 id="2-3-2-分析分治算法"><a href="#2-3-2-分析分治算法" class="headerlink" title="2.3.2 分析分治算法"></a>2.3.2 分析分治算法</h3><p>假设把原问题分解为a个子问题，每个子问题的规模都是原问题的1/b。（对于归并排序，a和b都是2，然而在许多分治算法中，$a\neq b $。）</p>
<p>求解规模为n/b的子问题，需要$T(n/b)$的时间，所以需要花费$aT(n/b)$的时间来求解a个子问题。</p>
<p>下面分析归并排序n个数的最坏情况运行时间$T(n)$的递归式。</p>
<ul>
<li>分解：分解步骤只计算子数组的中间位置，需要常量时间，因此，$D(n)=\Theta(n)$</li>
<li>解决：递归地求解两个规模为n/2的子问题，将贡献$2T(n/2)$的运行时间。</li>
<li>合并：n个子元素的数组上的merge需要$\Theta(n)$的时间（线性复杂度），所以$C(n)=\Theta(n)$。</li>
</ul>
<p>$D(n)$和$C(n)$相加的和，仍然是n的线性复杂度，即$\Theta(n)$。再与“解决”步骤相加，为：<br>$$T(n) =<br> \begin{cases}<br>  \Theta(1) &amp; 若n=1 \\<br> 2T(n/2)+\Theta(n) &amp;  若n&gt;1\\<br>  \end{cases}<br>  $$</p>
<p>在第四章，我们将看到“主定理”，可以用该定理来证明$T(n)$ 为$\Theta(n\text{lg}n)$。（即时间复杂度为nlgn）</p>
<p>运行时间为$\Theta(n\text{lg}n)$的归并排序优于运行时间为$\Theta(n^2)$的插入排序。</p>
<p>$T(n) =\Theta(n\text{lg}n)$的直观理解：<br><img src="/2017/12/12/algorithm_tutolrial_chapter_2/merge_sort_complexity.png" alt="归并排序复杂度的直观理解"><br>由(d)图，每层对n等分，可以展开为lgn层(再加上原来的一层，一共lgn+1层)。每层的复杂度都是cn，所以总的复杂度为$cn\text{lg}n+cn = cn(\text{lg}n+1)$。</p>
]]></content>
      
        <categories>
            
            <category> 算法导论 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法导论 </tag>
            
            <tag> algorithm </tag>
            
            <tag> 插入排序 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 分治 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一起开始机器学习吧——知乎live笔记]]></title>
      <url>/2017/12/12/Start_Machine_Learning_review/</url>
      <content type="html"><![CDATA[<h2 id="问答干货"><a href="#问答干货" class="headerlink" title="问答干货"></a>问答干货</h2><p>①练手项目推荐：《机器学习实战》,从零开始写机器学习算法代码，有实际的项目。有一定了解之后，去Kaggle上找竞赛做。</p>
<p>②教程推荐：公开课（吴恩达、coursera等），coursera上吴恩达的公开课</p>
<p>③语言推荐：python，MATLAB。很多开源工具（MXNet，Tensorflow，Keras）都有Python接口。</p>
<p>④python方面，网上有很多博客，比如廖雪峰的博客，感觉只需要了解即可，会用就行；传统算法入门的话，推荐李航的《统计学习方法》,入门最合适。最近出了Bengio的《Deep learning》书，有中文翻译，前面章节全是传统算法。不推荐一上来就看大家都说的《pattern recognition and machine learning》以及《模式分类》,这两本书不适合入门。</p>
<p>⑤完全零基础的入门性质的资料：视频：<a href="https://www.youtube.com/watch?v=IpGxLWOIZy4&amp;t=9s" target="_blank" rel="external">https://www.youtube.com/watch?v=IpGxLWOIZy4&amp;t=9s</a><br>机器学习入门： <a href="http://www.cnblogs.com/subconscious/p/4107357.html" target="_blank" rel="external">http://www.cnblogs.com/subconscious/p/4107357.html</a></p>
<p>⑥数学基础课：数学（概率、线代、高数、随机过程，排名分先后）</p>
<p>⑦发论文经验：目前我只是有paper在投，还没有成功发过，哈哈。经验嘛，主要就是一定要敢于否定自己，我在写的paper一共两篇，每一篇都几乎改了七八次，每次都很严格地要求自己。同时，最好要把paper发给同组的人一起看看，不同的角度给你提问题，会帮助你认识到自己容易忽视的问题。视觉方面发paper其实很容易的。通常来说你需要在同一个数据集上跟最好的方法做对比。</p>
<p>⑧我数学基础不太牢固 想一边看机器学习一边补数学 但有很多数学符号甚至都不认识 百度也没法搜索 你有什么建议吗？<br>答：专业书籍都有符号索引表；学习简单的数学工具，如latex；matrix cookbook 矩阵常用的手册。</p>
<h2 id="PPT干货"><a href="#PPT干货" class="headerlink" title="PPT干货"></a>PPT干货</h2><ul>
<li>机器学习常用分类：监督学习、半监督学习、无监督学习、增强学习</li>
<li><p>②无监督才是世界的本质，标注数据往往要花费大量的人力物力。<br>没有标注这么做呢？迁移学习是可以类比无监督学习来做的事情。<br>人是有类比能力的，计算机可以吗？我们想让它有这个能力。（就是迁移学习）<br>通过迁移学习的方式可以部分地接近无监督学习的目标。<br>迁移学习的好处是什么？利用已有的知识，节约新学习的成本。<br>但需要找到两者的相似性。骑自行车-&gt;开汽车？ 不行！ 需要有相似性。<br>深度学习算是对迁移学习的改进（我的总结）？，因为深度学习不像迁移学习需要手动提取特征。</p>
</li>
<li><p>准备工作<br>  理论知识（高数、概率、线性代数、随机过程）<br>  编码能力（Python, Matlab, Java）</p>
</li>
<li>基本入门<br>  李航《统计学习方法》<br>  周志华《机器学习》<br>  吴恩达公开课<br>  Kaggle竞赛</li>
<li><p>进阶提高<br>  《模式分类》、《PRML》<br>  ICML、NIPS等国际会议<br>  做自己的研究工作</p>
</li>
<li><p>书籍资料整理：<a href="https://github.com/ty4z2008/Qix/blob/master/dl.md" target="_blank" rel="external">https://github.com/ty4z2008/Qix/blob/master/dl.md</a><br>  入门资料：<a href="http://www.cnblogs.com/subconscious/p/4107357.html" target="_blank" rel="external">http://www.cnblogs.com/subconscious/p/4107357.html</a><br>  公开课：<a href="http://open.163.com/special/opencourse/machinelearning.html" target="_blank" rel="external">http://open.163.com/special/opencourse/machinelearning.html</a><br>  Kaggle竞赛：<a href="https://www.kaggle.com/" target="_blank" rel="external">https://www.kaggle.com/</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python爬虫实战--selenium模拟登录并自动点击]]></title>
      <url>/2017/12/09/HDHome_clawler_tutorial/</url>
      <content type="html"><![CDATA[<h1 id="python爬虫实战–selenium模拟登录网站HDH并刷魔力值"><a href="#python爬虫实战–selenium模拟登录网站HDH并刷魔力值" class="headerlink" title="python爬虫实战–selenium模拟登录网站HDH并刷魔力值"></a>python爬虫实战–selenium模拟登录网站HDH并刷魔力值</h1><h2 id="任务介绍"><a href="#任务介绍" class="headerlink" title="任务介绍"></a>任务介绍</h2><p>最近刚刚注册了某个网站：<a href="http://hdhome.org/" target="_blank" rel="external">HDHome</a>，该站有新手考核任务，其中有一项是需要达到魔力值5000。在魔力值获取方式中，我们看到这一项：“说谢谢 = 0.5个魔力值”，而网站存活种子数量达到16000+，也就意味着对每个种子说一下谢谢，轻松达到8000+的魔力值，于是，这个项目应运而生。</p>
<p>实现思路：<br>获取种子的页面，在每个页面中找到说谢谢的按钮，并点击后，关闭。依次进行下去即可。</p>
<p>相似任务：</p>
<p>实现对某论坛的自动回复，实现自动获取所有帖子的信息等等相关操作，无论是否需要模拟登录、模拟鼠标操作还是直接解析网站元素。</p>
<h2 id="selenium-牛刀小试"><a href="#selenium-牛刀小试" class="headerlink" title="selenium 牛刀小试"></a>selenium 牛刀小试</h2><p>首先导入相关的库：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> selenium.webdriver <span class="keyword">as</span> webdriver</div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</div><div class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</div><div class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</div><div class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</div></pre></td></tr></table></figure>
<p>这是整个程序里面用到的所有内容。<br>其中，<code>webdriver</code>是主浏览器，<code>selenium</code>都是基于整个浏览器的对象；<code>WebDriverWait、EC、By</code>是等待网页元素加载相关的操作；<code>Keys</code>是键值，如<code>Keys.CONTROL</code>，<code>Keys.ENTER</code>等等，<code>ActionChains</code>是用鼠标进行一系列的操作。</p>
<p><code>webdriver</code>可用的浏览器有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">webdriver.Firefox</div><div class="line">webdriver.FirefoxProfile</div><div class="line">webdriver.Chrome</div><div class="line">webdriver.ChromeOptions</div><div class="line">webdriver.Ie</div><div class="line">webdriver.Opera</div><div class="line">webdriver.PhantomJS</div><div class="line">webdriver.Remote</div><div class="line">webdriver.DesiredCapabilities</div><div class="line">webdriver.ActionChains</div><div class="line">webdriver.TouchActions</div><div class="line">webdriver.Proxy</div></pre></td></tr></table></figure></p>
<p>一开始我选择的是Chrome浏览器，后来改为了Firefox火狐。Chrome浏览器在执行单个元素（如验证码）截图时有坑（下文有详细说），所以后来才用的Firefox。此外，PhantomJS是匿名浏览器，没有显式的窗口。</p>
<p>那么，开始写程序吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">driver = webdriver.Firefox()</div><div class="line">login_url = <span class="string">"http://hdhome.org/login.php"</span></div><div class="line">login_failed_url = <span class="string">"http://hdhome.org/takelogin.php"</span></div><div class="line">driver.get(login_url)</div><div class="line"><span class="keyword">while</span> self.driver.current_url == login_url <span class="keyword">or</span> self.driver.current_url == login_failed_url:</div><div class="line">    time.sleep(<span class="number">10</span>)</div><div class="line"><span class="comment"># do something</span></div></pre></td></tr></table></figure></p>
<p>首先，实体化浏览器driver，执行<code>driver = webdriver.Firefox()</code>这句的时候，就会有firefox浏览器弹出来了。当执行到<code>driver.get(login_url)</code>时，浏览器转到相应的网址，后面的while语句是用来等待我们手动登录的，当我们手动登录成功后，会进入到<code>&quot;http://hdhome.org/index.php&quot;</code>，与login_url及login_failed_url都不同。接着便可以做自己想做的事情了。</p>
<p>我们发现单个种子的网址是类似这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">single_link = <span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i)</div></pre></td></tr></table></figure></p>
<p>i可以从1到30000多。于是，我们可以这样写程序，依次对每个种子执行“说谢谢”操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">saythanks</span><span class="params">(link)</span>:</span></div><div class="line">    driver.get(link)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        driver.find_element_by_xpath(<span class="string">"//input[@id='saythanks']"</span>).click()</div><div class="line">        print(link, <span class="string">" succeed\n"</span>)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        print(link, <span class="string">" not succeed\n"</span>)</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line">        <span class="keyword">pass</span></div><div class="line">        </div><div class="line">START = <span class="number">1</span></div><div class="line">END = <span class="number">30000</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(START, END):</div><div class="line">    link = <span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i)</div><div class="line">    saythanks(link)</div><div class="line">driver.close()</div></pre></td></tr></table></figure></p>
<p>其中，我们使用<code>try</code>、<code>except</code>、<code>finally</code>语句来尝试定位到’saythanks’说谢谢的按钮元素。由于有时候加载较慢就会找不到，或者是这个种子已经被删除了，所以也导致找不到该元素。</p>
<p>其中定位网页元素的方法有一下几种：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># locate single element in a page:</span></div><div class="line">find_element_by_id</div><div class="line">find_element_by_name</div><div class="line">find_element_by_xpath</div><div class="line">find_element_by_link_text</div><div class="line">find_element_by_partial_link_text</div><div class="line">find_element_by_tag_name</div><div class="line">find_element_by_class_name</div><div class="line">find_element_by_css_selector</div><div class="line"></div><div class="line"><span class="comment"># To find multiple elements (these methods will return a list):</span></div><div class="line">find_elements_by_name</div><div class="line">find_elements_by_xpath</div><div class="line">find_elements_by_link_text</div><div class="line">find_elements_by_partial_link_text</div><div class="line">find_elements_by_tag_name</div><div class="line">find_elements_by_class_name</div><div class="line">find_elements_by_css_selector</div></pre></td></tr></table></figure></p>
<p>从上面可以看出，我们也可以用<code>find_element_by_id(&quot;saythanks&quot;)</code>同样可以找到说谢谢的按钮。</p>
<p>附上到目前为止的所有程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master/hdh_try_2.py" target="_blank" rel="external">GitHub地址1</a><br>完整程序中加上了logging模块，将输出日志也导入到了文件，方面以后查阅。</p>
<h2 id="改进一：使用多线程多标签"><a href="#改进一：使用多线程多标签" class="headerlink" title="改进一：使用多线程多标签"></a>改进一：使用多线程多标签</h2><p>在上述模块中，可以看到，我们按照种子的顺序依次进行相应的操作。在种子数量很多的时候，会显得很慢，于是，有了这个改进：使用多线程。</p>
<p>我们使用multiprocessing库。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div></pre></td></tr></table></figure></p>
<p>先来看一个使用该多线程库的示例程序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(fn)</span>:</span></div><div class="line">    <span class="comment"># fn: 函数参数是数据列表的一个元素</span></div><div class="line">    time.sleep(<span class="number">1</span>)</div><div class="line">    <span class="keyword">return</span> fn * fn</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    testFL = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line">    print(<span class="string">'shunxu:'</span>)  <span class="comment"># 顺序执行(也就是串行执行，单进程)</span></div><div class="line">    s = time.time()</div><div class="line">    <span class="keyword">for</span> fn <span class="keyword">in</span> testFL:</div><div class="line">        run(fn)</div><div class="line"></div><div class="line">    e1 = time.time()</div><div class="line">    print(<span class="string">"顺序执行时间："</span>, int(e1 - s))</div><div class="line"></div><div class="line">    print(<span class="string">'concurrent:'</span>)  <span class="comment"># 创建多个进程，并行执行</span></div><div class="line">    pool = Pool(<span class="number">5</span>)  <span class="comment"># 创建拥有5个进程数量的进程池</span></div><div class="line">    <span class="comment"># testFL:要处理的数据列表，run：处理testFL列表中数据的函数</span></div><div class="line">    rl = pool.map(run, testFL)</div><div class="line">    pool.close()  <span class="comment"># 关闭进程池，不再接受新的进程</span></div><div class="line">    pool.join()  <span class="comment"># 主进程阻塞等待子进程的退出</span></div><div class="line">    e2 = time.time()</div><div class="line">    print(<span class="string">"并行执行时间："</span>, int(e2 - e1))</div><div class="line">    print(rl)</div></pre></td></tr></table></figure></p>
<p>于是，模仿上述程序，我们也使用多线程来执行说谢谢。说谢谢的过程其实有两步：一是打开网页，二是对每个网页定位到每个元素并点击。</p>
<p>如果对一、二两个步骤都执行多线程会出错，可能是由于多窗口的原因。因此我目前只对打开网页的步骤执行了多线程的操作。</p>
<p>上述也提到了，要同时打开多个窗口，则需要使用浏览器的多标签功能。打开一个新的标签的程序需要执行js脚本，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_url</span><span class="params">(url)</span>:</span></div><div class="line">    newwindow = <span class="string">'window.open("&#123;&#125;")'</span>.format(url)</div><div class="line">    driver.execute_script(newwindow)</div></pre></td></tr></table></figure></p>
<p>于是多线程部分的改进如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">START = <span class="number">25980</span></div><div class="line">    END = <span class="number">30000</span></div><div class="line">    Thread_Num = <span class="number">3</span></div><div class="line">    t = <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(START, END, Thread_Num):</div><div class="line"></div><div class="line">        pool = Pool(Thread_Num)</div><div class="line">        all_links = [<span class="string">"http://hdhome.org/details.php?id=&#123;&#125;&amp;hit=1"</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(i, i + Thread_Num)]</div><div class="line">        print(all_links)</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            rl = pool.map(open_url, all_links)</div><div class="line">            pool.close()</div><div class="line">            pool.join()</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            print(<span class="string">"multi thread start failed, next!!"</span>)</div><div class="line">            logging.info(<span class="string">"multi thread start failed, next!!"</span>)</div><div class="line">            time.sleep(<span class="number">5</span>)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="comment"># 通过移动句柄来说谢谢</span></div><div class="line">        saythanks()</div><div class="line">        <span class="comment"># sleep more</span></div><div class="line">        time.sleep(<span class="number">0.5</span>)</div><div class="line">        <span class="keyword">if</span> t % <span class="number">3</span> == <span class="number">0</span>:</div><div class="line">            time.sleep(<span class="number">0.5</span>)</div><div class="line">        <span class="keyword">if</span> t % <span class="number">5</span> == <span class="number">0</span>:</div><div class="line">            driver.switch_to.window(driver.window_handles[<span class="number">0</span>])</div><div class="line">            driver.refresh()</div><div class="line">            mystr = driver.find_elements_by_xpath(<span class="string">'//span[@class="medium"]'</span>)[<span class="number">0</span>].text</div><div class="line">            bonus = re.search(<span class="string">"\s[0-9,.]*\s"</span>, mystr).group()</div><div class="line">            usrName = re.search(<span class="string">"\s[a-zA-Z0-9]*\s"</span>, mystr).group()</div><div class="line">            print(driver.current_url, <span class="string">"normal refresh,&#123;&#125;bonus is&#123;&#125;now..."</span>.format(usrName, bonus))</div><div class="line">            logging.info(driver.current_url + <span class="string">"normal refresh,&#123;&#125;bonus is&#123;&#125;now..."</span>.format(usrName, bonus))</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">        t = t + <span class="number">1</span></div><div class="line">    driver.quit()</div><div class="line">    logging.info(<span class="string">"&#123;&#125;: driver quit, program stop."</span>.format(</div><div class="line">        time.strftime(<span class="string">'%Y-%m-%d %H:%M:%S'</span>, time.localtime(time.time()))))</div></pre></td></tr></table></figure></p>
<p>为了不让浏览器检测到，我只是用了三个线程，可以适当的增加。saythanks()下面的部分程序是为了增加更多的延迟并且显示相应的信息。其中<code>if t % 5 == 0:</code>中，我们移动到主页上，进行刷新操作，然后定位到用户信息那一栏：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bonus = re.search(&quot;\s[0-9,.]*\s&quot;, mystr).group()</div><div class="line">usrName = re.search(&quot;\s[a-zA-Z0-9]*\s&quot;, mystr).group()</div></pre></td></tr></table></figure></p>
<p>这个部分使用了re正则项来找出当前的魔力值以及用户名，并显示出来。</p>
<p>其中，说谢谢的程序也需要对多标签进行相应的改进，程序如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">saythanks</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> len(driver.window_handles) &gt; <span class="number">1</span>:</div><div class="line">        driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            WebDriverWait(driver, <span class="number">20</span>).until(EC.presence_of_element_located((By.ID, <span class="string">"outer"</span>)))</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            driver.refresh()</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">            print(driver.current_url, <span class="string">" refresh ---"</span>)</div><div class="line"></div><div class="line">        <span class="comment"># noinspection PyBroadException</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            driver.find_element_by_xpath(<span class="string">"//input[@id='saythanks']"</span>).click()</div><div class="line">            print(driver.current_url, <span class="string">" succeed"</span>)</div><div class="line">            logging.info(driver.current_url + <span class="string">" succeed~"</span>)</div><div class="line">        <span class="keyword">except</span>:</div><div class="line">            print(driver.current_url, <span class="string">" not succeed"</span>)</div><div class="line">            logging.info(driver.current_url + <span class="string">" not succeed!"</span>)</div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">            driver.close()</div><div class="line">            driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure></p>
<p>通过在不同窗口的句柄之间移动，来依次进行说谢谢的步骤。<br>在每个网页加载的时候，我们执行了等待的操作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WebDriverWait(driver, <span class="number">20</span>).until(EC.presence_of_element_located((By.ID, <span class="string">"outer"</span>)))</div></pre></td></tr></table></figure></p>
<p>一直等到最外层的元素出现。我选择的”outer”这个元素，是在无论这个种子是否存在的时候都会出现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure>
<p>将窗口转移到最后打开的那个窗口。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">driver.close()</div><div class="line">driver.switch_to.window(driver.window_handles[<span class="number">-1</span>])</div></pre></td></tr></table></figure></p>
<p>关闭当前的个窗口，并转到当前的最后一个窗口。需要注意的是：窗口虽然关闭了，但是，driver依旧会停在那个已经失效的窗口，并不会自动的转到新的窗口（虽然在浏览器中看上去到了新的窗口），所以，需要我们自己手动的移动窗口的句柄。</p>
<p>这边还存在一个问题，就是多标签的时候，自动切换标签的时候，浏览器会自动弹出来。这样子便有点烦人，毕竟我们只是想让他在后台自己跑， 所以，我加上了一个虚拟窗口，使用的是<code>pyvirtualdisplay</code>库。</p>
<p>以下是<code>pyvirtualdisplay</code>库在ubuntu中的安装步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pip install pyvirtualdisplay</div><div class="line">sudo apt install xvfb</div><div class="line">sudo apt install xserver-xephyr</div></pre></td></tr></table></figure></p>
<p>下面是<code>pyvirtualdisplay</code>具体的使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from pyvirtualdisplay import Display</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    display = Display(visible=1, size=(800, 600))</div><div class="line">    display.start()</div></pre></td></tr></table></figure></p>
<p>把虚拟窗口放在一开始处的位置即可。<br>也可以将visible改为0，浏览器就完全不可见了。</p>
<p>最后附上这个阶段的完整程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master/hdh_try_4.py" target="_blank" rel="external">github地址2</a></p>
<h2 id="改进二：验证码保存-面向对象编程"><a href="#改进二：验证码保存-面向对象编程" class="headerlink" title="改进二：验证码保存+面向对象编程"></a>改进二：验证码保存+面向对象编程</h2><p>验证码保存：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">code = self.driver.find_element_by_xpath(<span class="string">"//img[@alt='CAPTCHA']"</span>)</div><div class="line">        img = code.screenshot_as_png</div><div class="line">        img_name = <span class="string">"./code/code&#123;&#125;.png"</span>.format(time.strftime(<span class="string">'%Y-%m-%d_%H%M%S'</span>, time.localtime(time.time())))</div><div class="line">        <span class="keyword">with</span> open(img_name, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(img)</div><div class="line">        rec_code = self.code_recog(img_name)</div></pre></td></tr></table></figure></p>
<p>其中，验证码保存步骤使用了selenium自带的<em>元素截图</em>功能，而不是全屏截图。这边正是我从chrome浏览器改为firefox浏览器的真实原因。chrome浏览器中的元素截图不可用！会报错！故此选用firefox浏览器。</p>
<p>面向对象编程就是对函数使用了类，把多个函数合并到了同一个类中去。</p>
<p>完整程序在最后给出。</p>
<h2 id="改进三：使用pyqt获得验证码图片"><a href="#改进三：使用pyqt获得验证码图片" class="headerlink" title="改进三：使用pyqt获得验证码图片"></a>改进三：使用pyqt获得验证码图片</h2><p>思路是：从网页中解析到验证码的图片，然后下载到本地；接着使用pyqt弹出一个窗口，窗口中显示获取到的验证码，手动输入验证码后点击关闭。</p>
<p>简化了每次登录的流程，账号、密码记录在程序中自动输入，只需要手动输入验证码。</p>
<p>其中，基于pyqt5图形界面的窗口部分的程序如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># CodeRecognition.py</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets, QtGui</div><div class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> *</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeRecognition</span><span class="params">(QtWidgets.QWidget)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None)</span>:</span></div><div class="line">        QtWidgets.QWidget.__init__(self, parent)</div><div class="line">        self.setWindowTitle(<span class="string">"请手动输入验证码"</span>)</div><div class="line">        self.resize(<span class="number">250</span>, <span class="number">150</span>)</div><div class="line">        self.center()</div><div class="line">        <span class="comment"># 界面初始化</span></div><div class="line">        self.code_edit = QLineEdit()</div><div class="line">        self.label_code = QtWidgets.QLabel()</div><div class="line">        self.init_interface()</div><div class="line">        self.img_path = <span class="string">'./image_3.png'</span></div><div class="line">        self.show_code_img()</div><div class="line">        <span class="comment"># 输出的识别码</span></div><div class="line">        self.out_code = <span class="string">'To_be_recognize'</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_interface</span><span class="params">(self)</span>:</span></div><div class="line"></div><div class="line">        label1 = QtWidgets.QLabel(<span class="string">'请输入验证码：'</span>, self)</div><div class="line">        label2 = QtWidgets.QLabel(<span class="string">'输入完成后点击关闭按钮即可。'</span>, self)</div><div class="line">        self.code_edit.setToolTip(<span class="string">'请输入验证码'</span>)</div><div class="line">        button2 = QtWidgets.QPushButton(<span class="string">'关闭'</span>, self)</div><div class="line"></div><div class="line">        grid = QGridLayout()</div><div class="line">        grid.setSpacing(<span class="number">0</span>)</div><div class="line"></div><div class="line">        grid.addWidget(self.label_code, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line">        grid.addWidget(label1, <span class="number">1</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(self.code_edit, <span class="number">2</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(label2, <span class="number">3</span>, <span class="number">0</span>)</div><div class="line">        grid.addWidget(button2, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 关闭窗口</span></div><div class="line">        button2.clicked.connect(self.close)</div><div class="line">        self.setLayout(grid)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 该语句用来计算出显示器的分辨率（screen.width, screen.height）</span></div><div class="line">        screen = QtWidgets.QDesktopWidget().screenGeometry()</div><div class="line">        size = self.geometry()</div><div class="line">        self.move((screen.width() - size.width()) / <span class="number">2</span>, (screen.height() - size.height()) / <span class="number">2</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_text</span><span class="params">(self)</span>:</span></div><div class="line">        self.out_code = self.code_edit.text()</div><div class="line">        <span class="comment"># print(self.out_code)</span></div><div class="line">        <span class="keyword">return</span> self.out_code</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_code_img</span><span class="params">(self)</span>:</span></div><div class="line">        img = QtGui.QPixmap(self.img_path)</div><div class="line">        self.label_code.setPixmap(img)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closeEvent</span><span class="params">(self, event)</span>:</span></div><div class="line">        code = self.get_text()</div><div class="line">        <span class="keyword">if</span> len(code) &lt; <span class="number">4</span> <span class="keyword">or</span> len(code) &gt;= <span class="number">8</span>:</div><div class="line">            QtWidgets.QMessageBox.about(self, <span class="string">"验证码输入错误"</span>, <span class="string">"请注意：\n验证码一般为4-6位，请重新输入!"</span>)</div><div class="line">            event.ignore()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            event.accept()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    app = QtWidgets.QApplication(sys.argv)</div><div class="line">    center = CodeRecognition()</div><div class="line"></div><div class="line">    <span class="comment"># 改变输入的图片。</span></div><div class="line">    path = <span class="string">"image_2.png"</span></div><div class="line">    center.img_path = path</div><div class="line">    center.show_code_img()</div><div class="line"></div><div class="line">    center.show()</div><div class="line">    app.exec_()</div><div class="line">    rec_code = center.get_text()</div><div class="line">    print(<span class="string">"识别的验证码为："</span>, rec_code)</div></pre></td></tr></table></figure></p>
<p>之前学过qt的同学看起来应该不困难，没有学过qt<br>的同学想要入门的话建议查看官方文档或者小甲鱼论坛的<a href="http://bbs.fishc.com/forum.php?mod=collection&amp;action=view&amp;ctid=153" target="_blank" rel="external">pyqt连接</a>。</p>
<p>最后附上完整的程序：<br><a href="https://github.com/qwerty200696/HDHome_crawler/blob/master" target="_blank" rel="external">github地址3</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> selenium </tag>
            
            <tag> HDHome </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python-基础篇]]></title>
      <url>/2017/11/27/python_base_NJU_1/</url>
      <content type="html"><![CDATA[<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><p>本文是学习南京大学Python玩转数据基础篇的笔记整理。</p>
<h2 id="python类型"><a href="#python类型" class="headerlink" title="python类型"></a>python类型</h2><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ol>
<li>整型/长整型： 长度与机器有关。长整型：整型值后面加上L。</li>
<li>布尔型：True、False。</li>
<li>浮点型：数学中的实数。可以用科学计数法表示。 float</li>
<li>复数型：虚数部分用j。</li>
</ol>
<pre><code>x = 2.4+ 5j
Out[9]: (2.4+5j)
type(x)
Out[10]: complex
</code></pre><p>复数可以对实数和复数部分分离。imag、real。</p>
<p>复数的共轭：conjugate()</p>
<pre><code>x.real
Out[11]: 2.4
x.imag
Out[12]: 5.0
x.conjugate()
Out[13]: (2.4-5j)
</code></pre><h3 id="序列类型"><a href="#序列类型" class="headerlink" title="序列类型"></a>序列类型</h3><p>字符串，列表[]，元组()</p>
<p>字符串：<br>        三种表示方式：单引号，双引号，三引号。<br>        可以使用索引操作符。</p>
<h3 id="映设类型"><a href="#映设类型" class="headerlink" title="映设类型"></a>映设类型</h3><p>字典：<br>        大括号{}鉴别；<br>        类似于哈希表的键值对。</p>
<h2 id="python运算"><a href="#python运算" class="headerlink" title="python运算"></a>python运算</h2><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><pre><code>+ - × /
取余 %
乘方 **
整除 //  ----地板除
</code></pre><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><pre><code>数值的比较：按值的大小
字符串的比较：按ASCII码值的大小
</code></pre><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><pre><code>not and or
</code></pre><h3 id="字符运算"><a href="#字符运算" class="headerlink" title="字符运算"></a>字符运算</h3><pre><code>r / R,  ---原始字符串
u / U
</code></pre><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><pre><code>&lt;左移 &gt;右移
</code></pre><h2 id="函数、模块与包"><a href="#函数、模块与包" class="headerlink" title="函数、模块与包"></a>函数、模块与包</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数可以看成类似于数学中的函数。完成一个特定功能的一段代码。如绝对值函数<code>abs()</code>，类型函数<code>type()</code>，四舍五入函数<code>round()</code>。</p>
<h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><p>如何查看python中自带的内建函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dir(__builtins__)</div></pre></td></tr></table></figure></p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>非内建函数如何使用呢？</p>
<p>如floor()函数，不是内建函数，但包含在math的头文件中，因此只需要导入该模块即可，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> math</div></pre></td></tr></table></figure></p>
<p>什么是模块？<br>模块就是一个完整的python文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">文件：物理上的组织方式：math.py</div><div class="line">模块：逻辑上的组织方式：math</div></pre></td></tr></table></figure></p>
<p>Python中通常用<code>import 模块</code>的方式将现成模块中的函数、类重用到其他代码块中。</p>
<p>可以导入多个模快。可以从模块中导入指定的模块属性（把指定的名称导入）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ModuleName</div><div class="line"><span class="keyword">import</span> ModuleName1,ModuleName2,...</div><div class="line"><span class="keyword">from</span> Module1 <span class="keyword">import</span> ModuleElement</div></pre></td></tr></table></figure></p>
<h3 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h3><p>包是有层次的文件目录结构。</p>
<p>比如说如下的目录结构定义了一个由模块和子包组成的Python应用程序执行环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">AAA/</div><div class="line">    __init__.py</div><div class="line">    bbb.py</div><div class="line">    CCC/</div><div class="line">    	__init__.py</div><div class="line">        c1.py</div><div class="line">        c2.py</div><div class="line">    DDD/</div><div class="line">    	__init__.py</div><div class="line">        d1.py</div><div class="line">    EEE/</div><div class="line">    	...</div></pre></td></tr></table></figure></p>
<p>因此，我们可以这样使用该包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> AAA.CCC.c1</div><div class="line">AAA.CCC.c1.func1(<span class="number">123</span>)</div></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> AAA.CCC.c1 <span class="keyword">import</span> func1</div><div class="line">func1(<span class="number">123</span>)</div></pre></td></tr></table></figure></p>
<h3 id="库（library）"><a href="#库（library）" class="headerlink" title="库（library）"></a>库（library）</h3><p>库是一组具有相关功能的模块的集合。<br>Python的一大特色就是具有强大的标准库、以及第三方库、以及自定义的模块。</p>
<h2 id="条件、循环与中断语句"><a href="#条件、循环与中断语句" class="headerlink" title="条件、循环与中断语句"></a>条件、循环与中断语句</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>if语句<br>else语句<br>elif语句：多分支情况下使用</p>
<p>其中，条件语句可以嵌套使用。</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for iter_var in interable_object:</div><div class="line">    suite_to_repeat</div></pre></td></tr></table></figure>
<p>可以明确循环的次数，一般用在：</p>
<ul>
<li>遍历一个数据集的成员</li>
<li><p>在列表解析中使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">in</span>[<span class="number">4</span>]: [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</div><div class="line">Out[<span class="number">4</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</div><div class="line"><span class="keyword">in</span>[<span class="number">5</span>]: [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)<span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</div><div class="line">Out[<span class="number">5</span>]: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure>
</li>
<li><p>在生成器表达式中使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">in</span>[<span class="number">6</span>]: (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)<span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>)</div><div class="line">Out[<span class="number">6</span>]: &lt;generator object &lt;genexpr&gt; at <span class="number">0x7f44af56f570</span>&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>可用于迭代的对象（iterable object）有：String、 List、Tuple、Dictionary、File。</p>
<h3 id="range语句"><a href="#range语句" class="headerlink" title="range语句"></a>range语句</h3><p>一般与for语句配合使用。</p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">while expression:</div><div class="line">	suitr_to_repeat</div></pre></td></tr></table></figure></p>
<p>其中，expression是条件表达式，当expression的值为    True的时候，执行suitr_to_repeat的代码块。</p>
<h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><p>while循环中的break与for循环中的break。</p>
<h3 id="循环中的else语句"><a href="#循环中的else语句" class="headerlink" title="循环中的else语句"></a>循环中的else语句</h3><p>循环中的else：<br>如果是正常结束，就执行else中的代码；break处中止，就不执行else。</p>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><h3 id="自定义函数的创建："><a href="#自定义函数的创建：" class="headerlink" title="自定义函数的创建："></a>自定义函数的创建：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def function_name([arguments]):</div><div class="line">    &quot;optional documentation string&quot;</div><div class="line">    function_suite</div></pre></td></tr></table></figure>
<p>其中，def下一行可以是函数文档。～～～～～要学会使用函数文档！！</p>
<h3 id="自定义函数的调用"><a href="#自定义函数的调用" class="headerlink" title="自定义函数的调用"></a>自定义函数的调用</h3><p>函数名加上函数运算符，一对小括号。</p>
<p>括号之间是所有可选的参数，即使没有参数，小括号也不能省略。</p>
<p>参数问题，有参数就必须加上去。除非有默认值的可以不需要。</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>函数的参数可以有一个默认值，如果提供有默认值，在函数定义中，默认参数以赋值语句的形式提供。</p>
<p>默认参数的值可以改变。</p>
<p>默认参数一般需要放置在参数列表的最后。默认参数后面不能有非默认参数。</p>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数是让调用者通过使用参数名区分参数。允许你改变参数列表中的参数顺序。</p>
<h3 id="传递函数"><a href="#传递函数" class="headerlink" title="传递函数"></a>传递函数</h3><p>函数可以像参数一样传递给另外一个参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def addMe2Me(x):</div><div class="line">    return (x+x)</div><div class="line">def self(f,y):</div><div class="line">    print f(y)</div><div class="line"></div><div class="line">&gt;&gt;&gt; self(addMe2Me,2.2)</div><div class="line">4.4</div></pre></td></tr></table></figure></p>
<h3 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h3><p>匿名函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 普通的函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_add</span><span class="params">(x,y)</span>:</span> <span class="keyword">return</span> x+y</div><div class="line"><span class="comment"># 匿名函数</span></div><div class="line"><span class="keyword">lambda</span> x, y : x + y</div><div class="line">my_add = <span class="keyword">lambda</span> x, y : x + y</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>my_add(<span class="number">3</span>,<span class="number">5</span>)</div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>函数内部就是局部变量。</p>
<p>函数内部可以调用全局变量，使用<code>global</code>语句。</p>
<p>当全局变量和局部变量使用的是同一个名字时，内层会屏蔽外层。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归介绍"><a href="#递归介绍" class="headerlink" title="递归介绍"></a>递归介绍</h3><p>递归必须有边界条件，即停止递归的条件。 如n==0 或者n==1的情况。</p>
<p>递归的代码更简洁，更符合自然逻辑，更容易理解。</p>
<p>递归的执行方式：逐层递归调用，遇到边界条件停止递归，逐层返回调用至最初层，系统资源的消耗比循环大。</p>
<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Filename: Hanoi.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hanoi</span><span class="params">(a, b, c, n)</span>:</span></div><div class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</div><div class="line">        print(a, <span class="string">'-&gt;'</span>, c)</div><div class="line"></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        hanoi(a, c, b, n - <span class="number">1</span>)</div><div class="line">        print(a, <span class="string">'-&gt;'</span>, c)</div><div class="line">        hanoi(b, a, c, n - <span class="number">1</span>)</div><div class="line"></div><div class="line"></div><div class="line">hanoi(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">a -&gt; c</div><div class="line">a -&gt; b</div><div class="line">c -&gt; b</div><div class="line">a -&gt; c</div><div class="line">b -&gt; a</div><div class="line">b -&gt; c</div><div class="line">a -&gt; c</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DeepLab简介及其pytorch实现]]></title>
      <url>/2017/11/23/Torch_DeepLab/</url>
      <content type="html"><![CDATA[<h1 id="pytorch实现DeepLab"><a href="#pytorch实现DeepLab" class="headerlink" title="pytorch实现DeepLab"></a>pytorch实现DeepLab</h1><p>使用pytorch搭建DeepLab。</p>
<h2 id="DeepLab简介"><a href="#DeepLab简介" class="headerlink" title="DeepLab简介"></a>DeepLab简介</h2><p>DeepLab文章的下载地址：<a href="https://arxiv.org/abs/1606.00915" target="_blank" rel="external">https://arxiv.org/abs/1606.00915</a></p>
<p>该文章的主要思想之一：<br>提出了Atrous convolution（带孔卷积）。<br>扩大视野但不增加计算量。</p>
<p>所谓的带孔卷积，就是在卷积核之间加上0。rate参数为2（torch中对应的参数为dilation）的示意图如下<br><img src="/2017/11/23/Torch_DeepLab/2.png" alt="Atrous convolution(rate=2)" title="Atrous convolution(rate=2)"></p>
<p>rate = 2就是在原卷积核相邻两个元素之间补上一个0，假设原卷积核为3x3，rate = 2的带孔卷积核的大小就为<code>3+(3-1) × (rate-1)=5</code>。</p>
<p>下图是不同rate的带孔卷积。</p>
<p><img src="/2017/11/23/Torch_DeepLab/different_rate.png" alt="different_rate"></p>
<p>以<code>rate = 12</code> 为例，带孔卷积的核的大小为：<code>3+(3-1)x(12-1)=25</code>，即新卷积核的大小为：<code>25*25</code>。</p>
<p>总的来说，对于<code>rate=r</code>的带孔卷积，在连接着的卷积核元素间插入<code>r-1</code>个元素。因此，扩展后的卷积核大小为$k_{new}=k+(k-1)(r-1)$。</p>
<h2 id="pytorch实现deeplab"><a href="#pytorch实现deeplab" class="headerlink" title="pytorch实现deeplab"></a>pytorch实现deeplab</h2><p>笔者主要目的是实现一下不同视野的concat过程。</p>
<p>在torch中，卷积函数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</div><div class="line">nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, groups=<span class="number">1</span>, bias=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p>
<p>其中的dilation参数就是带孔卷积的参数（也就是tensorFlow下的rate），默认情况下为1，就是普通的卷积，所以带孔卷积只需要修改这个参数就可以了。</p>
<p>比如说，我们已经写好了不同的视野下的卷积，然后需要将他们的feature map叠加起来，torch中使用<code>torch.cat(inputs, dimension=0)</code>函数来进行叠加。torch的参数一般是四个维度的：<code>[n_batch_size, n_feature_map, height, weight]</code>，所以参数中的<code>dimension = 1</code>就是对<code>feature map</code>叠加。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = torch.cat([x2, x3, x4, x5], dim=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>叠加的这一步非常容易出错，原因在于，要求叠加的所有图片大小是一样的。而视野不同导致的卷积核的大小不同，也会导致最终输出的图像大小的变化，因此，需要恰当的调整zero-padding的数目来使得最终输出图像的大小保持一致。</p>
<p>另外稍微提一下，全连接层的输入向量大小的确定方法。全连接层是将上一步所得到的图像reshape为一个一维的向量之后，作为它的输入，因此，输入向量的长度为： <code>in_channels = nFeatureMap * height * weight</code>。</p>
<p>网络整体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(Net, self).__init__()</div><div class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">1</span>)</div><div class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>, <span class="number">10</span>, kernel_size=<span class="number">5</span>, padding=<span class="number">1</span>)</div><div class="line">        self.conv2_drop = nn.Dropout2d() </div><div class="line">        self.fc1 = nn.Linear(<span class="number">40</span> * <span class="number">4</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">50</span>) </div><div class="line">        self.fc2 = nn.Linear(<span class="number">50</span>, <span class="number">10</span>)</div><div class="line"></div><div class="line">        self.conv_rate_1 = nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">2</span>, padding=<span class="number">2</span>) </div><div class="line">        self.conv_rate_2 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">3</span>, padding=<span class="number">3</span>) </div><div class="line">        self.conv_rate_3 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">4</span>, padding=<span class="number">4</span>)</div><div class="line">        self.conv_rate_4 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">3</span>, dilation=<span class="number">5</span>, padding=<span class="number">5</span>)</div><div class="line">        self.conv_rate_5 = nn.Conv2d(<span class="number">20</span>, <span class="number">40</span>, kernel_size=<span class="number">1</span>, padding=<span class="number">0</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></div><div class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), <span class="number">2</span>)</div><div class="line">        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), <span class="number">2</span>))</div><div class="line">        x = self.conv_rate_1(x)</div><div class="line">        x2 = self.conv_rate_2(x)</div><div class="line">        x3 = self.conv_rate_3(x)</div><div class="line">        x4 = self.conv_rate_4(x)</div><div class="line">        x5 = self.conv_rate_5(x)</div><div class="line">        <span class="comment"># print(x.data.shape)</span></div><div class="line">        <span class="comment"># print(x2.data.shape)</span></div><div class="line">        <span class="comment"># print(x3.data.shape)</span></div><div class="line">        <span class="comment"># print(x4.data.shape)</span></div><div class="line">        <span class="comment"># print(x5.data.shape)</span></div><div class="line">        x = torch.cat([x2, x3, x4, x5], dim=<span class="number">1</span>)</div><div class="line"></div><div class="line">        <span class="comment"># for FC</span></div><div class="line">        x = x.view(<span class="number">-1</span>, self.num_flat_features(x))  <span class="comment"># origin is 320</span></div><div class="line">        x = F.relu(self.fc1(x))  <span class="comment"># fc-&gt;relu</span></div><div class="line">        x = F.dropout(x, training=self.training)  <span class="comment"># dropout</span></div><div class="line">        x = self.fc2(x)</div><div class="line">        <span class="keyword">return</span> F.log_softmax(x)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_flat_features</span><span class="params">(self, x)</span>:</span></div><div class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># all dimensions except the batch dimension</span></div><div class="line">        num_features = <span class="number">1</span></div><div class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</div><div class="line">            num_features *= s</div><div class="line">        <span class="keyword">return</span> num_features</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PyTorch </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> pytorch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习第七章：深度学习中的正则化]]></title>
      <url>/2017/10/22/DL_chap_7/</url>
      <content type="html"><![CDATA[<h2 id="7-1-参数范式惩罚"><a href="#7-1-参数范式惩罚" class="headerlink" title="7.1 参数范式惩罚"></a>7.1 参数范式惩罚</h2><p>对目标模型J添加一个参数范数惩罚$\Omega (\theta)$，限制模型 的学习能力。正则化后的目标函数记为：<br>$$\tilde{J}(\theta ;X,y) = J(\theta ;X,y) +\alpha \Omega (\theta)$$</p>
<p>我们通常只对权重做惩罚而不对偏置做正则惩罚。</p>
<p>神经网络情况下，有时候希望对网络的每一层使用单独的惩罚，并分配不同的$\alpha$系数。寻找合适的多个超参数的代价很大，因此为了减少搜索空间，我们会在所以层使用相同的权重衰减。</p>
<p>符号约束说明：向量$w$表示所有应受范数惩罚影响的权重，而向量$\theta$表示所有参数（包括w和无须正则化的参数）。</p>
<h3 id="7-1-1-L-2-参数正则化"><a href="#7-1-1-L-2-参数正则化" class="headerlink" title="7.1.1 $L^2$参数正则化"></a>7.1.1 $L^2$参数正则化</h3><p><em>5.2节</em>中已经见过最简单的、最常见的$L^2$参数范数惩罚。其正则项为：<br>$$\Omega (\theta) = \frac 12 ||w||^2_2$$</p>
<p>令$w^\ast $为未正则化的目标函数取得最小训练误差时的权重向量，即$w^\ast =\text {argmin}_w J(w)$，并在$w^\ast $的邻域对目标函数做<strong>二次近似</strong>。</p>
<p>近似的$\hat J (\theta)$如下：</p>
<p>$$\hat J (\theta) = J (w^\ast) + \frac 12 (w-w^\ast)^TH(w-w^\ast) $$</p>
<p>其中，$H$是$J$在$w^\ast $处计算的Hessian矩阵（关于$w$）。因为$w^\ast $被定义为最优，所以该二次近似中<strong>没有一阶项</strong>。同样地，因为$w^\ast $是$J$的一个最优点，可以得出$H$是<strong>半正定</strong>。</p>
<h3 id="7-1-2-L-1-正则化"><a href="#7-1-2-L-1-正则化" class="headerlink" title="7.1.2 $L^1$正则化"></a>7.1.2 $L^1$正则化</h3><h2 id="7-2-作为约束的范数惩罚"><a href="#7-2-作为约束的范数惩罚" class="headerlink" title="7.2 作为约束的范数惩罚"></a>7.2 作为约束的范数惩罚</h2><h2 id="7-3-正则化和欠约束问题"><a href="#7-3-正则化和欠约束问题" class="headerlink" title="7.3 正则化和欠约束问题"></a>7.3 正则化和欠约束问题</h2><h2 id="7-4-数据集增强"><a href="#7-4-数据集增强" class="headerlink" title="7.4 数据集增强"></a>7.4 数据集增强</h2><p>使用更多的数据进行训练。</p>
<p>创建假数据并添加到训练集中。</p>
<p>图像：沿着训练图像每个方向平移几个像素。旋转。缩放。</p>
<p>数据集增强对语音识别也是有效的。</p>
<p>网络输入层注入噪声，</p>
<p>算法性能对比时，应确保算法使用同一 人工设计的数据集增强方案。</p>
<h2 id="7-5-噪声鲁棒性"><a href="#7-5-噪声鲁棒性" class="headerlink" title="7.5 噪声鲁棒性"></a>7.5 噪声鲁棒性</h2><h2 id="7-6-半监督学习"><a href="#7-6-半监督学习" class="headerlink" title="7.6 半监督学习"></a>7.6 半监督学习</h2><p>在半监督学习的框架下，$P(x)$产生的未标记样本和$P(x,y)$中的标记样本都用于估计$P(y|x)$或者根据x预测y。</p>
<p>半监督学习通常是学习一个表示：$h=f(x)$。学习表示的目的是<strong>使相同类的样本有类似的表示</strong>。</p>
<p>无监督学习可以为如何在空间聚集样本提供有用的线索。</p>
<p>模型的构建：生成模型$P(x)$或$P(x,y)$与判别模型$P(y|x)$共享参数，而不用分离无监督和监督部分。<br>权衡监督模型准则$-\text{log}P(y|x)$和无监督(或生成)模型准则$-\text{log}P(x)$或$-\text{log}P(x,y)$。</p>
<p>生成模型准则表达了对 监督学习问题的特殊形式的先验知识，即$P(x)$的结构通过某种共享参宿的方式连接到$P(y|x)$。</p>
<h2 id="7-7-多任务学习"><a href="#7-7-多任务学习" class="headerlink" title="7.7 多任务学习"></a>7.7 多任务学习</h2><h2 id="7-8-提前终止"><a href="#7-8-提前终止" class="headerlink" title="7.8 提前终止"></a>7.8 提前终止</h2><p>在训练有足够表示能力甚至会过拟合的大模型时，经常会出现：训练误差随着时间推移逐渐降低但验证集的误差会再次上升。</p>
<p>此时，我们只需要返回验证集误差最低的参数设置。</p>
<p>在每次验证集误差有所改善时，我们存储模型参数的副本。当验证集的误差在事先指定的循环次数内没有进一步改善时，算法就会终止。</p>
<p>这就是提前终止（early stopping）。</p>
<p>两个代价：一是训练步数作为超参数，训练期间需要定期评估验证集。而是需要保持最佳的参数副本。</p>
<p>提前终止是一个不显眼的正则化形式。</p>
<p>提前终止需要验证集，意味着一部分训练数据不能馈送到模型。<br>为了更好地利用这部分数据，可以在提前终止的首次训练后，进行额外的训练。在第二轮（额外的）训练中，所有的训练数据都被包括在内。</p>
<p>未完待续。</p>
<h2 id="7-9-参数绑定和参数共享"><a href="#7-9-参数绑定和参数共享" class="headerlink" title="7.9 参数绑定和参数共享"></a>7.9 参数绑定和参数共享</h2><h2 id="7-10-稀疏表示"><a href="#7-10-稀疏表示" class="headerlink" title="7.10 稀疏表示"></a>7.10 稀疏表示</h2><h2 id="7-13-Bagging和其他集成方法"><a href="#7-13-Bagging和其他集成方法" class="headerlink" title="7.13 Bagging和其他集成方法"></a>7.13 Bagging和其他集成方法</h2><p>Bagging(bootstrap aggregating)是通过结合几个模型降低泛化误差的技术。</p>
<p>主要想法是分别训练几个不同的模型，然后让所有模型表决测试样例的输出。</p>
<p>这是机器学习的一项常规策略，被称为：<strong>模型平均</strong>（model averaging）。采用这种策略的技术被称为：<strong>集成方法</strong>。</p>
<h2 id="7-12-Dropout"><a href="#7-12-Dropout" class="headerlink" title="7.12 Dropout"></a>7.12 Dropout</h2><h2 id="7-13-对抗训练"><a href="#7-13-对抗训练" class="headerlink" title="7.13 对抗训练"></a>7.13 对抗训练</h2><h2 id="7-14-切面距离、正切传播和流形正切分类器"><a href="#7-14-切面距离、正切传播和流形正切分类器" class="headerlink" title="7.14 切面距离、正切传播和流形正切分类器"></a>7.14 切面距离、正切传播和流形正切分类器</h2>]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习第九章：卷机网络]]></title>
      <url>/2017/10/20/DL_chap_9/</url>
      <content type="html"><![CDATA[<h2 id="9-1-卷积运算"><a href="#9-1-卷积运算" class="headerlink" title="9.1 卷积运算"></a>9.1 卷积运算</h2><p>卷积的第一个参数： 输入，第二个参数： 核函数。输出有时被称为特征映射。</p>
<p>对于二维图像I，二维的核K。卷积可以写为：</p>
<p>$$S(i,j) = (I\times K )(i,j) = \sum_m \sum_n I(m,n)K(i-m,j-n)$$</p>
<p>卷积是可交换的。可以等价地写为：</p>
<p>$$S(i,j) = (K\times I )(i,j) = \sum_m \sum_n I(i-m,j-n)K(m,n)$$</p>
<p>卷积运算可交换性的出现时因为我们将核相对输入进行了<strong>翻转</strong>(flip)，从m增大的角度来看，输入的索引在增大，但是核的索引在减小。</p>
<p>互相关函数。和卷积一样，但是没有对核翻转</p>
<p>$$S(i,j) = (I\times K )(i,j) = \sum_m \sum_n I(i+m,j+n)K(m,n)$$</p>
<h2 id="9-2-动机"><a href="#9-2-动机" class="headerlink" title="9.2 动机"></a>9.2 动机</h2><p>卷积运算的三个重要思想：</p>
<p>参数共享–绑定的权重。在一个模型的多个函数中使用相同的参数。</p>
<p>平移等变–输入改变，输出也以同样的方式改变。</p>
<h2 id="9-3-池化"><a href="#9-3-池化" class="headerlink" title="9.3 池化"></a>9.3 池化</h2><p>池化函数：使用某一位置的相邻输出的总体统计特征来代替网络在该位置的输出。</p>
<p>最大池化函数（Max pooling）：相邻矩形区域内的最大值</p>
<p>其他常用的池化函数：相邻区域内的平均值，L2范数，基于距中心像素位置的加权平均函数。</p>
<p>局部平移不变性。</p>
<p>池化综合了全部邻居的反馈，这使得<strong>池化单元少于探测单元</strong>成为可能，我们可以通过综合池化区域的<strong>k个像素</strong>的统计特征而不是单个像素来实现。这种方式提高了网络的计算效率，因为<strong>下一层少了约k倍的输入</strong>。（downsampling）</p>
<h2 id="9-4-卷积与池化作为一种无限强的先验"><a href="#9-4-卷积与池化作为一种无限强的先验" class="headerlink" title="9.4 卷积与池化作为一种无限强的先验"></a>9.4 卷积与池化作为一种无限强的先验</h2><p>先验概率分布（第5.2节）。弱先验具有较高的熵值，强先验具有较低的熵值。</p>
<p>一个<strong>无限强的先验</strong>需要对一些参数的概率置零并且完全禁止对这些参数赋值。</p>
<p>可以把<strong>卷机网络</strong>类比为全连接网络，但对于这个全连接网络的权重有一个无限强的先验。这个无限强的先验是说一个隐藏单元的权重必须和它邻居的权重相同，但可以在空间上移动。这个先验也要求除了那些处在隐藏单元的小的空间连续的接受域内的权重以外，其余的权重为零。 </p>
<p>类似地，使用<strong>池化</strong>也是一个无限强的先验：每个单元都具有对少量平移的不变性。</p>
<p><strong>卷积和池化可能导致欠拟合</strong>。</p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[import TensorFlow出错解决方案]]></title>
      <url>/2017/10/19/tensorflow_import_error/</url>
      <content type="html"><![CDATA[<h1 id="出错与解决历程"><a href="#出错与解决历程" class="headerlink" title="出错与解决历程"></a>出错与解决历程</h1><p>先介绍一下我的python环境：3.5.2</p>
<p>一开始是tensorflow找不到cudn的几个库，虽然问题不大。看到有教程说要升级tensorflow（<font color="#FF0000"> 请不要尝试升级 </font> ），于是抱着试试看的想法，升级了tensorflow版本：</p>
<blockquote>
<p>pip install –trusted-host pypi.python.org –upgrade tensorflow-gpu </p>
</blockquote>
<p>升级之后是1.3.0的最新版本。</p>
<p>接着<code>import tensorflow</code>的时候，出现错误：</p>
<pre><code>Traceback (most recent call last):
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 18, in swig_import_helper
    return importlib.import_module(mname)
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 986, in _gcd_import
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 969, in _find_and_load
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 958, in _find_and_load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 666, in _load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 577, in module_from_spec
  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 906, in create_module
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 222, in _call_with_frames_removed
ImportError: DLL load failed: The specified module could not be found.
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt;
    from tensorflow.python.pywrap_tensorflow_internal import *
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 21, in &lt;module&gt;
    _pywrap_tensorflow_internal = swig_import_helper()
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 20, in swig_import_helper
    return importlib.import_module(&apos;_pywrap_tensorflow_internal&apos;)
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
ImportError: No module named &apos;_pywrap_tensorflow_internal&apos;
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File &quot;&lt;pyshell#0&gt;&quot;, line 1, in &lt;module&gt;
    import tensorflow as tf
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\__init__.py&quot;, line 24, in &lt;module&gt;
    from tensorflow.python import *
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\__init__.py&quot;, line 51, in &lt;module&gt;
    from tensorflow.python import pywrap_tensorflow
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 52, in &lt;module&gt;
    raise ImportError(msg)
ImportError: Traceback (most recent call last):
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 18, in swig_import_helper
    return importlib.import_module(mname)
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 986, in _gcd_import
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 969, in _find_and_load
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 958, in _find_and_load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 666, in _load_unlocked
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 577, in module_from_spec
  File &quot;&lt;frozen importlib._bootstrap_external&gt;&quot;, line 906, in create_module
  File &quot;&lt;frozen importlib._bootstrap&gt;&quot;, line 222, in _call_with_frames_removed
ImportError: DLL load failed: The specified module could not be found.
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt;
    from tensorflow.python.pywrap_tensorflow_internal import *
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 21, in &lt;module&gt;
    _pywrap_tensorflow_internal = swig_import_helper()
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 20, in swig_import_helper
    return importlib.import_module(&apos;_pywrap_tensorflow_internal&apos;)
  File &quot;C:\Users\Admin\AppData\Local\Programs\Python\Python35\lib\importlib\__init__.py&quot;, line 126, in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
ImportError: No module named &apos;_pywrap_tensorflow_internal&apos;

Failed to load the native TensorFlow runtime.
See https://www.tensorflow.org/install/install_sources#common_installation_problems
for some common reasons and solutions.  Include the entire stack trace
above this error message when asking for help.
</code></pre><p>查找到相关解决方案：</p>
<p><a href="https://stackoverflow.com/questions/43942185/failed-to-load-the-native-tensorflow-runtime-python-3-5-2" target="_blank" rel="external">https://stackoverflow.com/questions/43942185/failed-to-load-the-native-tensorflow-runtime-python-3-5-2</a></p>
<p>按照高票回答上面做出来后，依旧无效。其中5.1步骤找“curses”，需要<code>pip install curses</code> (从<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>)</p>
<p>简直气疯了。然后，尝试下载了cuda cudnn 9.0的版本，并且加上了系统环境变量，依旧无效。</p>
<p>之后在贴吧<a href="http://tieba.baidu.com/p/5147977587" target="_blank" rel="external">http://tieba.baidu.com/p/5147977587</a>  看到11楼说：</p>
<blockquote>
<p>我也是同样的问题</p>
<p>是tensorflow-gpu版本不兼容的问题</p>
<p>之前是1.3 后来安装的的1.0.1</p>
<p>亲测有效</p>
</blockquote>
<p>于是回退tensorflow的版本。</p>
<p><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a></p>
<p>下载了1.1.0版本。</p>
<pre><code>Traceback (most recent call last):
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt;
    from tensorflow.python.pywrap_tensorflow_internal import *
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 35, in &lt;module&gt;
    _pywrap_tensorflow_internal = swig_import_helper()
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 30, in swig_import_helper
    _mod = imp.load_module(&apos;_pywrap_tensorflow_internal&apos;, fp, pathname, description)
  File &quot;D:\python\Python35\lib\imp.py&quot;, line 242, in load_module
    return load_dynamic(name, filename, file)
  File &quot;D:\python\Python35\lib\imp.py&quot;, line 342, in load_dynamic
    return _load(spec)
ImportError: DLL load failed: 找不到指定的模块。

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;D:/python/py3_prog/TensorFlow/setup_test.py&quot;, line 4, in &lt;module&gt;
    import tensorflow as tf
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\__init__.py&quot;, line 24, in &lt;module&gt;
    from tensorflow.python import *
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\__init__.py&quot;, line 51, in &lt;module&gt;
    from tensorflow.python import pywrap_tensorflow
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 52, in &lt;module&gt;
    raise ImportError(msg)
ImportError: Traceback (most recent call last):
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow.py&quot;, line 41, in &lt;module&gt;
    from tensorflow.python.pywrap_tensorflow_internal import *
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 35, in &lt;module&gt;
    _pywrap_tensorflow_internal = swig_import_helper()
  File &quot;D:\python\Python35\lib\site-packages\tensorflow\python\pywrap_tensorflow_internal.py&quot;, line 30, in swig_import_helper
    _mod = imp.load_module(&apos;_pywrap_tensorflow_internal&apos;, fp, pathname, description)
  File &quot;D:\python\Python35\lib\imp.py&quot;, line 242, in load_module
    return load_dynamic(name, filename, file)
  File &quot;D:\python\Python35\lib\imp.py&quot;, line 342, in load_dynamic
    return _load(spec)
ImportError: DLL load failed: 找不到指定的模块。


Failed to load the native TensorFlow runtime.

See https://www.tensorflow.org/install/install_sources#common_installation_problems

for some common reasons and solutions.  Include the entire stack trace
above this error message when asking for help.
</code></pre><p>提示缺少dll。在<code>c/windows/system32</code>中添加了一下<code>msvcp140.dll</code>  （680kb的，不是400多kb的）<br>问题终于解决。</p>
<p>dll问题具体方案：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=53587" target="_blank" rel="external">https://www.microsoft.com/en-us/download/details.aspx?id=53587</a>下载Microsoft Visual C++ 2015 Redistributable 并安装。</p>
<p>更多解决办法可参考：<a href="https://github.com/tensorflow/tensorflow/issues/8385" target="_blank" rel="external">https://github.com/tensorflow/tensorflow/issues/8385</a></p>
<h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><ul>
<li>千万不要去更新tensorflow的版本。能用就行，不要用最新的1.3.0版本。 </li>
<li>cuda，cudnn也不要用最新的9.0版本，就用8.0版本即可。</li>
<li>import tensorflow出错时，有几个方向检查：cudn/cudaa环境变量，dll库的问题，版本是否匹配：python3.5，回退tensorflow版本，回退cuda/cudnn版本。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TensorFlow系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习中防止过拟合的方法]]></title>
      <url>/2017/10/18/DL_overfitting/</url>
      <content type="html"><![CDATA[<h2 id="0-什么是过拟合"><a href="#0-什么是过拟合" class="headerlink" title="0. 什么是过拟合"></a>0. 什么是过拟合</h2><p>过拟合即在<strong>训练误差很小，而泛化误差很大</strong>，因为模型可能过于的复杂，使其”记住”了训练样本，然而其泛化误差却很大。</p>
<p><img src="/2017/10/18/DL_overfitting/overfitting_1.png" alt=""></p>
<p>在传统的机器学习方法中有很大防止过拟合的方法，同样这些方法很多也适合用于深度学习中，同时深度学习中又有一些独特的防止过拟合的方法，下面对其进行简单的梳理。</p>
<h2 id="1-获取更多数据"><a href="#1-获取更多数据" class="headerlink" title="1. 获取更多数据"></a>1. 获取更多数据</h2><p>让模型泛化的能力更好的最好办法就是使用<strong>更多的训练数据</strong>进行训练，但是在实践中，我们拥有的数据是有限的，解决这一问题可以人为的<strong>创造一些假数据</strong>添加到训练集中。</p>
<p>一个具体的例子:<br>在AlexNet中，将$256\times 256$图像随机的截取$224\times 224$大小，增加了许多的训练样本，同时可以对图像进行左右翻转，增加样本的个数，实验的结果可以可降低1%的误差。 </p>
<p>在神经网络中输入噪声也可以看做是数据增强的一种方式。</p>
<p>通俗得讲，<strong>数据集扩增</strong>即需要得到更多的符合要求的数据，即和已有的数据是独立同分布的，或者近似独立同分布的。一般有以下方法：</p>
<ul>
<li>从数据源头采集更多数据</li>
<li>复制原有数据并加上随机噪声</li>
<li>重采样</li>
<li>根据当前数据集估计数据分布参数，使用该分布产生更多数据等</li>
</ul>
<h2 id="2-选用合适的模型"><a href="#2-选用合适的模型" class="headerlink" title="2.选用合适的模型"></a>2.选用合适的模型</h2><h3 id="2-1-网络结构-Architecture"><a href="#2-1-网络结构-Architecture" class="headerlink" title="2.1 网络结构 Architecture"></a>2.1 网络结构 Architecture</h3><p>这个很好理解，减少网络的层数、神经元个数等均可以限制网络的拟合能力。</p>
<h3 id="2-2-参数范数惩罚-regularization"><a href="#2-2-参数范数惩罚-regularization" class="headerlink" title="2.2 参数范数惩罚 regularization"></a>2.2 参数范数惩罚 regularization</h3><p>范数正则化是一种非常普遍的方法，也是最常用的方法，假如优化: </p>
<p>$$minObj(\theta)=L(y,f(x))+\alpha G(\theta)$$</p>
<p>其中L为经验风险，其为在训练样本上的误差，而G为对参数的惩罚，也叫结构风险。α是平衡两者，如果太大则对应的惩罚越大，如过太小，甚至接近与0，则没有惩罚。</p>
<p>最常用的范数惩罚为L1，L2正则化。</p>
<h4 id="L1正则"><a href="#L1正则" class="headerlink" title="L1正则"></a>L1正则</h4><p>L1又被成为Lasso:<br>$$||w||1=|w1|+|w2|+…$$</p>
<p>即绝对值相加，其趋向于是一些参数为0。可以起到特征选择的作用。 </p>
<h4 id="L2正则"><a href="#L2正则" class="headerlink" title="L2正则"></a>L2正则</h4><p>L2正则化为: </p>
<p>$$||w||_2=w12+w22+…$$</p>
<p>L2范数是指向量各元素的平方和然后求平方根。它有两个美称，在回归里面，有人把有它的回归叫“岭回归”（<code>Ridge Regression</code>），有人也叫它“权值衰减<code>weight decay</code>”。它的强大功效是改善机器学习里面一个非常重要的问题：过拟合。</p>
<p>其趋向与，使权重很小。其又成为ridge。</p>
<p>拟合过程中通常都倾向于让<strong>权值尽可能小</strong>，最后构造一个所有参数都比较小的模型。因为一般认为<strong>参数值小的模型比较简单</strong>，能适应不同的数据集，也在一定程度上避免了过拟合现象。可以设想一下对于一个线性回归方程，若参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是『抗扰动能力强』。</p>
<p>这里也一句话总结下：通过L2范数，我们可以实现了对模型空间的限制，从而在一定程度上避免了过拟合。</p>
<p>关于更多正则化的内容可以参考《deep learning》第七章：深度学习中的正则化。</p>
<h3 id="2-3-训练时间-Early-stopping"><a href="#2-3-训练时间-Early-stopping" class="headerlink" title="2.3 训练时间 Early stopping"></a>2.3 训练时间 Early stopping</h3><p>当随着模型的能力提升，训练集的误差会先减小再增大，这样可以提前终止算法减缓过拟合现象。</p>
<p>Early stopping方法的具体做法是，在每一个Epoch结束时（一个Epoch集为对所有的训练数据的一轮遍历）计算validation data的accuracy，当accuracy不再提高时，就停止训练。这种做法很符合直观感受，因为accurary都不再提高了，在继续训练也是无益的，只会提高训练的时间。那么该做法的一个重点便是怎样才认为<code>validation accurary</code>不再提高了呢？并不是说<code>validation accuracy</code>一降下来便认为不再提高了，因为可能经过这个Epoch后，accuracy降低了，但是随后的Epoch又让accuracy又上去了，所以不能根据一两次的连续降低就判断不再提高。一般的做法是，在训练的过程中，记录到目前为止最好的<code>validation accuracy</code>，当连续10次Epoch（或者更多次）没达到最佳accuracy时，则可以认为accuracy不再提高了。此时便可以停止迭代了（<code>Early Stopping</code>）。这种策略也称为“<code>No-improvement-in-n</code>”，n即Epoch的次数，可以根据实际情况取，如10、20、30……</p>
<p>提前终止是一种很常用的缓解过拟合的方法，如在决策树的先剪枝的算法，提前终止算法，使得树的深度降低，防止其过拟合。</p>
<h3 id="添加噪声"><a href="#添加噪声" class="headerlink" title="添加噪声"></a>添加噪声</h3><p>给网络加噪声也有很多方法：</p>
<p>在输入中加噪声</p>
<p>在权值上加噪声</p>
<p>对网络的响应加噪声</p>
<h2 id="3-结合多种模型"><a href="#3-结合多种模型" class="headerlink" title="3. 结合多种模型"></a>3. 结合多种模型</h2><p>集成学习是一种比较奇特的方法，如果我们训练多个不同的模型，然后将它们的输出汇总，例如平均起来或者投票汇总，那么汇总的结果可以在一定程度上自动克服过拟合，哪怕每个模型都过拟合了。</p>
<h3 id="3-1-bagging-boosting"><a href="#3-1-bagging-boosting" class="headerlink" title="3.1 bagging boosting"></a>3.1 bagging boosting</h3><p><code>Bagging</code> 是 <code>Bootstrap Aggregating</code> 的简称。简单理解：就是分段函数的概念：用不同的模型拟合不同部分的训练集。</p>
<p>其实bagging的方法是可以起到正则化的作用，因为正则化就是要减少泛化误差，而bagging的方法可以<strong>组合多个模型</strong>起到<strong>减少泛化误差</strong>的作用。<br>在深度学习中同样可以使用此方法，但是其会<strong>增加计算和存储的成本</strong>。</p>
<p>由于训练网络本身就要耗费较多资源，所以一般不单独使用神经网络做<code>bagging</code>。</p>
<p>类似的还有<code>boosting</code>。</p>
<p>bagging中的模型是强模型，偏差低，方差高。目标是降低方差。在bagging中，每个模型的bias和variance近似相同，但是互相相关性不太高，因此一般不能降低Bias，而一定程度上能降低variance。典型的bagging是random forest。</p>
<p>boosting中每个模型是弱模型，偏差高，方差低。目标是通过平均降低偏差。boosting的基本思想就是用贪心法最小化损失函数，显然能降低偏差，但是通常模型的相关性很强，因此不能显著降低variance。典型的Boosting是adaboost，另外一个常用的并行Boosting算法是GBDT（gradient boosting decision tree）。这一类算法通常不容易出现过拟合。</p>
<h3 id="3-2-Dropout"><a href="#3-2-Dropout" class="headerlink" title="3.2 Dropout"></a>3.2 Dropout</h3><p>正则是通过在代价函数后面加上正则项来防止模型过拟合的。而在神经网络中，有一种方法是通过<strong>修改神经网络本身结构</strong>来实现的，其名为<code>Dropout</code>。该方法是在对网络进行训练时用一种技巧（<code>trick</code>），对于如下所示的三层人工神经网络： </p>
<p><img src="/2017/10/18/DL_overfitting/dropout_1.png" alt=""></p>
<p>对于上图所示的网络，在训练开始时，随机得删除一些（可以设定为一半，也可以为1/3，1/4等）隐藏层神经元，即认为这些神经元不存在，同时保持输入层与输出层神经元的个数不变，这样便得到如下的ANN： </p>
<p><img src="/2017/10/18/DL_overfitting/dropout_2.png" alt=""></p>
<p>然后按照BP学习算法对ANN中的参数进行学习更新（虚线连接的单元不更新，因为认为这些神经元被临时删除了）。这样一次迭代更新便完成了。下一次迭代中，同样随机删除一些神经元，与上次不一样，做随机选择。这样一直进行下去，直至训练结束。</p>
<p><code>Dropout</code>提供了一种廉价的<code>Bagging</code>集成近似，能够训练和评估指数级数量的神经网络。dropout可以随机的让一部分神经元失活，这样仿佛是bagging的采样过程，因此可以看做是bagging的廉价的实现。<br>但是它们训练不太一样，因为bagging，所有的模型都是独立的，而dropout下所有模型的参数是共享的。</p>
<p>通常可以这样理解<code>dropout</code>:假设我们要判别一只猫，有一个神经元说看到有毛就是猫，但是如果我让这个神经元失活，它还能判断出来是猫的话，这样就比较具有泛化的能力，减轻了过拟合的风险。</p>
<h2 id="4-Batch-Normalization"><a href="#4-Batch-Normalization" class="headerlink" title="4. Batch Normalization"></a>4. Batch Normalization</h2><p>在Google Inception V2中所采用，是一种非常有用的正则化方法，可以让大型的卷积网络训练速度加快很多倍，同事收敛后分类的准确率也可以大幅度的提高。<br>BN在训练某层时，会对每一个mini-batch数据进行标准化(normalization)处理，使输出规范到N(0,1)的正太分布，减少了Internal convariate shift(内部神经元分布的改变)，传统的深度神经网络在训练是，每一层的输入的分布都在改变，因此训练困难，只能选择用一个很小的学习速率，但是每一层用了BN后，可以有效的解决这个问题，学习速率可以增大很多倍。</p>
<h2 id="5-参数绑定与参数共享"><a href="#5-参数绑定与参数共享" class="headerlink" title="5. 参数绑定与参数共享"></a>5. 参数绑定与参数共享</h2><p>在卷积神经网络CNN中(计算机视觉与卷积神经网络 )，卷积层就是其中权值共享的方式，一个卷积核通过在图像上滑动从而实现共享参数，大幅度减少参数的个数，用卷积的形式是合理的，因为对于一副猫的图片来说，右移一个像素同样还是猫，其具有局部的特征。这是一种很好的缓解过拟合现象的方法。 </p>
<p>同样在RNN中用到的参数共享，在其整条时间链上可以进行参数的共享，这样才使得其能够被训练。</p>
<h2 id="6-辅助分类节点-auxiliary-classifiers"><a href="#6-辅助分类节点-auxiliary-classifiers" class="headerlink" title="6. 辅助分类节点(auxiliary classifiers)"></a>6. 辅助分类节点(auxiliary classifiers)</h2><p>在Google Inception V1中，采用了辅助分类节点的策略，即将中间某一层的输出用作分类，并按一个较小的权重加到最终的分类结果中，这样相当于做了模型的融合，同时给网络增加了反向传播的梯度信号，提供了额外的正则化的思想。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://blog.csdn.net/taoyanqi8932/article/details/71101699" target="_blank" rel="external">http://blog.csdn.net/taoyanqi8932/article/details/71101699</a></li>
<li><a href="http://blog.csdn.net/heyongluoyao8/article/details/49429629" target="_blank" rel="external">http://blog.csdn.net/heyongluoyao8/article/details/49429629</a></li>
<li><a href="https://www.zhihu.com/question/26760839" target="_blank" rel="external">https://www.zhihu.com/question/26760839</a></li>
<li><a href="https://www.zhihu.com/question/59201590" target="_blank" rel="external">https://www.zhihu.com/question/59201590</a></li>
<li><a href="https://www.zhihu.com/question/26898675" target="_blank" rel="external">https://www.zhihu.com/question/26898675</a></li>
<li>正则化 <a href="http://blog.csdn.net/jinping_shi/article/details/52433975" target="_blank" rel="external">http://blog.csdn.net/jinping_shi/article/details/52433975</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> overfitting </tag>
            
            <tag> 过拟合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[党的十九大报告全文]]></title>
      <url>/2017/10/18/Opening_ceremony_19th_CPC/</url>
      <content type="html"><![CDATA[<p>中国共产党第十九次全国代表大会开幕会今天上午9点在人民大会堂大礼堂举行。习近平代表第十八届中央委员会向党的十九大作报告。</p>
<p>以下是报告全文：</p>
<p>同志们：</p>
<p>现在，我代表第十八届中央委员会向大会作报告。</p>
<p>中国共产党第十九次全国代表大会，是在全面建成小康社会决胜阶段、中国特色社会主义进入新时代的关键时期召开的一次十分重要的大会。</p>
<p>大会的主题是：不忘初心，牢记使命，高举中国特色社会主义伟大旗帜，决胜全面建成小康社会，夺取新时代中国特色社会主义伟大胜利，为实现中华民族伟大复兴的中国梦不懈奋斗。</p>
<p>不忘初心，方得始终。中国共产党人的初心和使命，就是为中国人民谋幸福，为中华民族谋复兴。这个初心和使命是激励中国共产党人不断前进的根本动力。全党同志一定要永远与人民同呼吸、共命运、心连心，永远把人民对美好生活的向往作为奋斗目标，以永不懈怠的精神状态和一往无前的奋斗姿态，继续朝着实现中华民族伟大复兴的宏伟目标奋勇前进。</p>
<p>当前，国内外形势正在发生深刻复杂变化，我国发展仍处于重要战略机遇期，前景十分光明，挑战也十分严峻。全党同志一定要登高望远、居安思危，勇于变革、勇于创新，永不僵化、永不停滞，团结带领全国各族人民决胜全面建成小康社会，奋力夺取新时代中国特色社会主义伟大胜利。</p>
<p>一、过去五年的工作和历史性变革</p>
<p>十八大以来的五年，是党和国家发展进程中极不平凡的五年。面对世界经济复苏乏力、局部冲突和动荡频发、全球性问题加剧的外部环境，面对我国经济发展进入新常态等一系列深刻变化，我们坚持稳中求进工作总基调，迎难而上，开拓进取，取得了改革开放和社会主义现代化建设的历史性成就。</p>
<p>为贯彻十八大精神，党中央召开七次全会，分别就政府机构改革和职能转变、全面深化改革、全面推进依法治国、制定“十三五”规划、全面从严治党等重大问题作出决定和部署。五年来，我们统筹推进“五位一体”总体布局、协调推进“四个全面”战略布局，“十二五”规划胜利完成，“十三五”规划顺利实施，党和国家事业全面开创新局面。</p>
<p>经济建设取得重大成就。坚定不移贯彻新发展理念，坚决端正发展观念、转变发展方式，发展质量和效益不断提升。经济保持中高速增长，在世界主要国家中名列前茅，国内生产总值从五十四万亿元增长到八十万亿元，稳居世界第二，对世界经济增长贡献率超过百分之三十。供给侧结构性改革深入推进，经济结构不断优化，数字经济等新兴产业蓬勃发展，高铁、公路、桥梁、港口、机场等基础设施建设快速推进。农业现代化稳步推进，粮食生产能力达到一万二千亿斤。城镇化率年均提高一点二个百分点，八千多万农业转移人口成为城镇居民。区域发展协调性增强，“一带一路”建设、京津冀协同发展、长江经济带发展成效显著。创新驱动发展战略大力实施，创新型国家建设成果丰硕，天宫、蛟龙、天眼、悟空、墨子、大飞机等重大科技成果相继问世。南海岛礁建设积极推进。开放型经济新体制逐步健全，对外贸易、对外投资、外汇储备稳居世界前列。</p>
<p>全面深化改革取得重大突破。蹄疾步稳推进全面深化改革，坚决破除各方面体制机制弊端。改革全面发力、多点突破、纵深推进，着力增强改革系统性、整体性、协同性，压茬拓展改革广度和深度，推出一千五百多项改革举措，重要领域和关键环节改革取得突破性进展，主要领域改革主体框架基本确立。中国特色社会主义制度更加完善，国家治理体系和治理能力现代化水平明显提高，全社会发展活力和创新活力明显增强。</p>
<p>民主法治建设迈出重大步伐。积极发展社会主义民主政治，推进全面依法治国，党的领导、人民当家作主、依法治国有机统一的制度建设全面加强，党的领导体制机制不断完善，社会主义民主不断发展，党内民主更加广泛，社会主义协商民主全面展开，爱国统一战线巩固发展，民族宗教工作创新推进。科学立法、严格执法、公正司法、全民守法深入推进，法治国家、法治政府、法治社会建设相互促进，中国特色社会主义法治体系日益完善，全社会法治观念明显增强。国家监察体制改革试点取得实效，行政体制改革、司法体制改革、权力运行制约和监督体系建设有效实施。</p>
<p>思想文化建设取得重大进展。加强党对意识形态工作的领导，党的理论创新全面推进，马克思主义在意识形态领域的指导地位更加鲜明，中国特色社会主义和中国梦深入人心，社会主义核心价值观和中华优秀传统文化广泛弘扬，群众性精神文明创建活动扎实开展。公共文化服务水平不断提高，文艺创作持续繁荣，文化事业和文化产业蓬勃发展，互联网建设管理运用不断完善，全民健身和竞技体育全面发展。主旋律更加响亮，正能量更加强劲，文化自信得到彰显，国家文化软实力和中华文化影响力大幅提升，全党全社会思想上的团结统一更加巩固。</p>
<p>人民生活不断改善。深入贯彻以人民为中心的发展思想，一大批惠民举措落地实施，人民获得感显著增强。脱贫攻坚战取得决定性进展，六千多万贫困人口稳定脱贫，贫困发生率从百分之十点二下降到百分之四以下。教育事业全面发展，中西部和农村教育明显加强。就业状况持续改善，城镇新增就业年均一千三百万人以上。城乡居民收入增速超过经济增速，中等收入群体持续扩大。覆盖城乡居民的社会保障体系基本建立，人民健康和医疗卫生水平大幅提高，保障性住房建设稳步推进。社会治理体系更加完善，社会大局保持稳定，国家安全全面加强。</p>
<p>生态文明建设成效显著。大力度推进生态文明建设，全党全国贯彻绿色发展理念的自觉性和主动性显著增强，忽视生态环境保护的状况明显改变。生态文明制度体系加快形成，主体功能区制度逐步健全，国家公园体制试点积极推进。全面节约资源有效推进，能源资源消耗强度大幅下降。重大生态保护和修复工程进展顺利，森林覆盖率持续提高。生态环境治理明显加强，环境状况得到改善。引导应对气候变化国际合作，成为全球生态文明建设的重要参与者、贡献者、引领者。</p>
<p>强军兴军开创新局面。着眼于实现中国梦强军梦，制定新形势下军事战略方针，全力推进国防和军队现代化。召开古田全军政治工作会议，恢复和发扬我党我军光荣传统和优良作风，人民军队政治生态得到有效治理。国防和军队改革取得历史性突破，形成军委管总、战区主战、军种主建新格局，人民军队组织架构和力量体系实现革命性重塑。加强练兵备战，有效遂行海上维权、反恐维稳、抢险救灾、国际维和、亚丁湾护航、人道主义救援等重大任务，武器装备加快发展，军事斗争准备取得重大进展。人民军队在中国特色强军之路上迈出坚定步伐。</p>
<p>港澳台工作取得新进展。全面准确贯彻“一国两制”方针，牢牢掌握宪法和基本法赋予的中央对香港、澳门全面管治权，深化内地和港澳地区交流合作，保持香港、澳门繁荣稳定。坚持一个中国原则和“九二共识”，推动两岸关系和平发展，加强两岸经济文化交流合作，实现两岸领导人历史性会晤。妥善应对台湾局势变化，坚决反对和遏制“台独”分裂势力，有力维护台海和平稳定。</p>
<p>全方位外交布局深入展开。全面推进中国特色大国外交，形成全方位、多层次、立体化的外交布局，为我国发展营造了良好外部条件。实施共建“一带一路”倡议，发起创办亚洲基础设施投资银行，设立丝路基金，举办首届“一带一路”国际合作高峰论坛、亚太经合组织领导人非正式会议、二十国集团领导人杭州峰会、金砖国家领导人厦门会晤、亚信峰会。倡导构建人类命运共同体，促进全球治理体系变革。我国国际影响力、感召力、塑造力进一步提高，为世界和平与发展作出新的重大贡献。</p>
<p>全面从严治党成效卓著。全面加强党的领导和党的建设，坚决改变管党治党宽松软状况。推动全党尊崇党章，增强政治意识、大局意识、核心意识、看齐意识，坚决维护党中央权威和集中统一领导，严明党的政治纪律和政治规矩，层层落实管党治党政治责任。坚持照镜子、正衣冠、洗洗澡、治治病的要求，开展党的群众路线教育实践活动和“三严三实”专题教育，推进“两学一做”学习教育常态化制度化，全党理想信念更加坚定、党性更加坚强。贯彻新时期好干部标准，选人用人状况和风气明显好转。党的建设制度改革深入推进，党内法规制度体系不断完善。把纪律挺在前面，着力解决人民群众反映最强烈、对党的执政基础威胁最大的突出问题。出台中央八项规定，严厉整治形式主义、官僚主义、享乐主义和奢靡之风，坚决反对特权。巡视利剑作用彰显，实现中央和省级党委巡视全覆盖。坚持反腐败无禁区、全覆盖、零容忍，坚定不移“打虎”、“拍蝇”、“猎狐”，不敢腐的目标初步实现，不能腐的笼子越扎越牢，不想腐的堤坝正在构筑，反腐败斗争压倒性态势已经形成并巩固发展。</p>
<p>五年来的成就是全方位的、开创性的，五年来的变革是深层次的、根本性的。五年来，我们党以巨大的政治勇气和强烈的责任担当，提出一系列新理念新思想新战略，出台一系列重大方针政策，推出一系列重大举措，推进一系列重大工作，解决了许多长期想解决而没有解决的难题，办成了许多过去想办而没有办成的大事，推动党和国家事业发生历史性变革。这些历史性变革，对党和国家事业发展具有重大而深远的影响。</p>
<p>五年来，我们勇于面对党面临的重大风险考验和党内存在的突出问题，以顽强意志品质正风肃纪、反腐惩恶，消除了党和国家内部存在的严重隐患，党内政治生活气象更新，党内政治生态明显好转，党的创造力、凝聚力、战斗力显著增强，党的团结统一更加巩固，党群关系明显改善，党在革命性锻造中更加坚强，焕发出新的强大生机活力，为党和国家事业发展提供了坚强政治保证。</p>
<p>同时，必须清醒看到，我们的工作还存在许多不足，也面临不少困难和挑战。主要是：发展不平衡不充分的一些突出问题尚未解决，发展质量和效益还不高，创新能力不够强，实体经济水平有待提高，生态环境保护任重道远；民生领域还有不少短板，脱贫攻坚任务艰巨，城乡区域发展和收入分配差距依然较大，群众在就业、教育、医疗、居住、养老等方面面临不少难题；社会文明水平尚需提高；社会矛盾和问题交织叠加，全面依法治国任务依然繁重，国家治理体系和治理能力有待加强；意识形态领域斗争依然复杂，国家安全面临新情况；一些改革部署和重大政策措施需要进一步落实；党的建设方面还存在不少薄弱环节。这些问题，必须着力加以解决。</p>
<p>五年来的成就，是党中央坚强领导的结果，更是全党全国各族人民共同奋斗的结果。我代表中共中央，向全国各族人民，向各民主党派、各人民团体和各界爱国人士，向香港特别行政区同胞、澳门特别行政区同胞和台湾同胞以及广大侨胞，向关心和支持中国现代化建设的各国朋友，表示衷心的感谢！</p>
<p>同志们！改革开放之初，我们党发出了走自己的路、建设中国特色社会主义的伟大号召。从那时以来，我们党团结带领全国各族人民不懈奋斗，推动我国经济实力、科技实力、国防实力、综合国力进入世界前列，推动我国国际地位实现前所未有的提升，党的面貌、国家的面貌、人民的面貌、军队的面貌、中华民族的面貌发生了前所未有的变化，中华民族正以崭新姿态屹立于世界的东方。</p>
<p>经过长期努力，中国特色社会主义进入了新时代，这是我国发展新的历史方位。</p>
<p>中国特色社会主义进入新时代，意味着近代以来久经磨难的中华民族迎来了从站起来、富起来到强起来的伟大飞跃，迎来了实现中华民族伟大复兴的光明前景；意味着科学社会主义在二十一世纪的中国焕发出强大生机活力，在世界上高高举起了中国特色社会主义伟大旗帜；意味着中国特色社会主义道路、理论、制度、文化不断发展，拓展了发展中国家走向现代化的途径，给世界上那些既希望加快发展又希望保持自身独立性的国家和民族提供了全新选择，为解决人类问题贡献了中国智慧和中国方案。</p>
<p>这个新时代，是承前启后、继往开来、在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代，是决胜全面建成小康社会、进而全面建设社会主义现代化强国的时代，是全国各族人民团结奋斗、不断创造美好生活、逐步实现全体人民共同富裕的时代，是全体中华儿女勠力同心、奋力实现中华民族伟大复兴中国梦的时代，是我国日益走近世界舞台中央、不断为人类作出更大贡献的时代。</p>
<p>中国特色社会主义进入新时代，我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。我国稳定解决了十几亿人的温饱问题，总体上实现小康，不久将全面建成小康社会，人民美好生活需要日益广泛，不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长。同时，我国社会生产力水平总体上显著提高，社会生产能力在很多方面进入世界前列，更加突出的问题是发展不平衡不充分，这已经成为满足人民日益增长的美好生活需要的主要制约因素。</p>
<p>我们必须认识到，我国社会主要矛盾的变化没有改变我们所处社会主义历史阶段的判断，我国仍处于并将长期处于社会主义初级阶段的基本国情没有变，我国是世界上最大发展中国家的国际地位没有变。全党要牢牢把握社会主义初级阶段这个基本国情，牢牢立足社会主义初级阶段这个最大实际，牢牢坚持党的基本路线这个党和国家的生命线，人民的幸福线。领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明、和谐、美丽的社会主义现代化强国而奋斗。</p>
<p>同志们！中国特色社会主义进入新时代，在中华人民共和国发展史上、中华民族发展史上具有重大意义，在世界社会主义发展史上、人类社会发展史上也具有重大意义。全党要坚定信心、奋发有为，让中国特色社会主义展现出更加强大的生命力！</p>
<p>二、新时代中国共产党的历史使命</p>
<p>一百年前，十月革命一声炮响，给中国送来了马克思列宁主义。中国先进分子从马克思列宁主义的科学真理中看到了解决中国问题的出路。在近代以后中国社会的剧烈运动中，在中国人民反抗封建统治和外来侵略的激烈斗争中，在马克思列宁主义同中国工人运动的结合过程中，一九二一年中国共产党应运而生。从此，中国人民谋求民族独立、人民解放和国家富强、人民幸福的斗争就有了主心骨，中国人民就从精神上由被动转为主动。</p>
<p>中华民族有五千多年的文明历史，创造了灿烂的中华文明，为人类作出了卓越贡献，成为世界上伟大的民族。鸦片战争后，中国陷入内忧外患的黑暗境地，中国人民经历了战乱频仍、山河破碎、民不聊生的深重苦难。为了民族复兴，无数仁人志士不屈不挠、前仆后继，进行了可歌可泣的斗争，进行了各式各样的尝试，但终究未能改变旧中国的社会性质和中国人民的悲惨命运。</p>
<p>实现中华民族伟大复兴是近代以来中华民族最伟大的梦想。中国共产党一经成立，就把实现共产主义作为党的最高理想和最终目标，义无反顾肩负起实现中华民族伟大复兴的历史使命，团结带领人民进行了艰苦卓绝的斗争，谱写了气吞山河的壮丽史诗。</p>
<p>我们党深刻认识到，实现中华民族伟大复兴，必须推翻压在中国人民头上的帝国主义、封建主义、官僚资本主义三座大山，实现民族独立、人民解放、国家统一、社会稳定。我们党团结带领人民找到了一条以农村包围城市、武装夺取政权的正确革命道路，进行了二十八年浴血奋战，完成了新民主主义革命，一九四九年建立了中华人民共和国，实现了中国从几千年封建专制政治向人民民主的伟大飞跃。</p>
<p>我们党深刻认识到，实现中华民族伟大复兴，必须建立符合我国实际的先进社会制度。我们党团结带领人民完成社会主义革命，确立社会主义基本制度，推进社会主义建设，完成了中华民族有史以来最为广泛而深刻的社会变革，为当代中国一切发展进步奠定了根本政治前提和制度基础，实现了中华民族由近代不断衰落到根本扭转命运、持续走向繁荣富强的伟大飞跃。</p>
<p>我们党深刻认识到，实现中华民族伟大复兴，必须合乎时代潮流、顺应人民意愿，勇于改革开放，让党和人民事业始终充满奋勇前进的强大动力。我们党团结带领人民进行改革开放新的伟大革命，破除阻碍国家和民族发展的一切思想和体制障碍，开辟了中国特色社会主义道路，使中国大踏步赶上时代。</p>
<p>九十六年来，为了实现中华民族伟大复兴的历史使命，无论是弱小还是强大，无论是顺境还是逆境，我们党都初心不改、矢志不渝，团结带领人民历经千难万险，付出巨大牺牲，敢于面对曲折，勇于修正错误，攻克了一个又一个看似不可攻克的难关，创造了一个又一个彪炳史册的人间奇迹。</p>
<p>同志们！今天，我们比历史上任何时期都更接近、更有信心和能力实现中华民族伟大复兴的目标。</p>
<p>行百里者半九十。中华民族伟大复兴，绝不是轻轻松松、敲锣打鼓就能实现的。全党必须准备付出更为艰巨、更为艰苦的努力。</p>
<p>实现伟大梦想，必须进行伟大斗争。社会是在矛盾运动中前进的，有矛盾就会有斗争。我们党要团结带领人民有效应对重大挑战、抵御重大风险、克服重大阻力、解决重大矛盾，必须进行具有许多新的历史特点的伟大斗争，任何贪图享受、消极懈怠、回避矛盾的思想和行为都是错误的。全党要更加自觉地坚持党的领导和我国社会主义制度，坚决反对一切削弱、歪曲、否定党的领导和我国社会主义制度的言行；更加自觉地维护人民利益，坚决反对一切损害人民利益、脱离群众的行为；更加自觉地投身改革创新时代潮流，坚决破除一切顽瘴痼疾；更加自觉地维护我国主权、安全、发展利益，坚决反对一切分裂祖国、破坏民族团结和社会和谐稳定的行为；更加自觉地防范各种风险，坚决战胜一切在政治、经济、文化、社会等领域和自然界出现的困难和挑战。全党要充分认识这场伟大斗争的长期性、复杂性、艰巨性，发扬斗争精神，提高斗争本领，不断夺取伟大斗争新胜利。</p>
<p>实现伟大梦想，必须建设伟大工程。这个伟大工程就是我们党正在深入推进的党的建设新的伟大工程。历史已经并将继续证明，没有中国共产党的领导，民族复兴必然是空想。我们党要始终成为时代先锋、民族脊梁，始终成为马克思主义执政党，自身必须始终过硬。全党要更加自觉地坚定党性原则，勇于直面问题，敢于刮骨疗毒，消除一切损害党的先进性和纯洁性的因素，清除一切侵蚀党的健康肌体的病毒，不断增强党的政治领导力、思想引领力、群众组织力、社会号召力，确保我们党永葆旺盛生命力和强大战斗力。</p>
<p>实现伟大梦想，必须推进伟大事业。中国特色社会主义是改革开放以来党的全部理论和实践的主题，是党和人民历尽千辛万苦、付出巨大代价取得的根本成就。中国特色社会主义道路是实现社会主义现代化、创造人民美好生活的必由之路，中国特色社会主义理论体系是指导党和人民实现中华民族伟大复兴的正确理论，中国特色社会主义制度是当代中国发展进步的根本制度保障，中国特色社会主义文化是激励全党全国各族人民奋勇前进的强大精神力量。全党要更加自觉地增强道路自信、理论自信、制度自信、文化自信，既不走封闭僵化的老路，也不走改旗易帜的邪路，保持政治定力，坚持实干兴邦，始终坚持和发展中国特色社会主义。</p>
<p>伟大斗争，伟大工程，伟大事业，伟大梦想，紧密联系、相互贯通、相互作用，其中起决定性作用的是党的建设新的伟大工程。推进伟大工程，要结合伟大斗争、伟大事业、伟大梦想的实践来进行，确保党在世界形势深刻变化的历史进程中始终走在时代前列，在应对国内外各种风险和考验的历史进程中始终成为全国人民的主心骨，在坚持和发展中国特色社会主义的历史进程中始终成为坚强领导核心。</p>
<p>同志们！使命呼唤担当，使命引领未来。我们要不负人民重托、无愧历史选择，在新时代中国特色社会主义的伟大实践中，以党的坚强领导和顽强奋斗，激励全体中华儿女不断奋进，凝聚起同心共筑中国梦的磅礴力量！</p>
<p>三、新时代中国特色社会主义思想和基本方略</p>
<p>十八大以来，国内外形势变化和我国各项事业发展都给我们提出了一个重大时代课题，这就是必须从理论和实践结合上系统回答新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义，包括新时代坚持和发展中国特色社会主义的总目标、总任务、总体布局、战略布局和发展方向、发展方式、发展动力、战略步骤、外部条件、政治保证等基本问题，并且要根据新的实践对经济、政治、法治、科技、文化、教育、民生、民族、宗教、社会、生态文明、国家安全、国防和军队、“一国两制”和祖国统一、统一战线、外交、党的建设等各方面作出理论分析和政策指导，以利于更好坚持和发展中国特色社会主义。</p>
<p>围绕这个重大时代课题，我们党坚持以马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观为指导，坚持解放思想、实事求是、与时俱进、求真务实，坚持辩证唯物主义和历史唯物主义，紧密结合新的时代条件和实践要求，以全新的视野深化对共产党执政规律、社会主义建设规律、人类社会发展规律的认识，进行艰辛理论探索，取得重大理论创新成果，形成了新时代中国特色社会主义思想。</p>
<p>新时代中国特色社会主义思想，明确坚持和发展中国特色社会主义，总任务是实现社会主义现代化和中华民族伟大复兴，在全面建成小康社会的基础上，分两步走在本世纪中叶建成富强民主文明和谐美丽的社会主义现代化强国；明确新时代我国社会主要矛盾是人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾，必须坚持以人民为中心的发展思想，不断促进人的全面发展、全体人民共同富裕；明确中国特色社会主义事业总体布局是“五位一体”、战略布局是“四个全面”，强调坚定道路自信、理论自信、制度自信、文化自信；明确全面深化改革总目标是完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化；明确全面推进依法治国总目标是建设中国特色社会主义法治体系、建设社会主义法治国家；明确党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队；明确中国特色大国外交要推动构建新型国际关系，推动构建人类命运共同体；明确中国特色社会主义最本质的特征是中国共产党领导，中国特色社会主义制度的最大优势是中国共产党领导，党是最高政治领导力量，提出新时代党的建设总要求，突出政治建设在党的建设中的重要地位。</p>
<p>新时代中国特色社会主义思想，是对马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观的继承和发展，是马克思主义中国化最新成果，是党和人民实践经验和集体智慧的结晶，是中国特色社会主义理论体系的重要组成部分，是全党全国人民为实现中华民族伟大复兴而奋斗的行动指南，必须长期坚持并不断发展。全党要深刻领会新时代中国特色社会主义思想的精神实质和丰富内涵，在各项工作中全面准确贯彻落实。</p>
<p>（一）坚持党对一切工作的领导。党政军民学，东西南北中，党是领导一切的。必须增强政治意识、大局意识、核心意识、看齐意识，自觉维护党中央权威和集中统一领导，自觉在思想上政治上行动上同党中央保持高度一致，完善坚持党的领导的体制机制，坚持稳中求进工作总基调，统筹推进“五位一体”总体布局，协调推进“四个全面”战略布局，提高党把方向、谋大局、定政策、促改革的能力和定力，确保党始终总揽全局、协调各方。</p>
<p>（二）坚持以人民为中心。人民是历史的创造者，是决定党和国家前途命运的根本力量。必须坚持人民主体地位，坚持立党为公、执政为民，践行全心全意为人民服务的根本宗旨，把党的群众路线贯彻到治国理政全部活动之中，把人民对美好生活的向往作为奋斗目标，依靠人民创造历史伟业。</p>
<p>（三）坚持全面深化改革。只有社会主义才能救中国，只有改革开放才能发展中国、发展社会主义、发展马克思主义。必须坚持和完善中国特色社会主义制度，不断推进国家治理体系和治理能力现代化，坚决破除一切不合时宜的思想观念和体制机制弊端，突破利益固化的藩篱，吸收人类文明有益成果，构建系统完备、科学规范、运行有效的制度体系，充分发挥我国社会主义制度优越性。</p>
<p>（四）坚持新发展理念。发展是解决我国一切问题的基础和关键，发展必须是科学发展，必须坚定不移贯彻创新、协调、绿色、开放、共享的发展理念。必须坚持和完善我国社会主义基本经济制度和分配制度，毫不动摇巩固和发展公有制经济，毫不动摇鼓励、支持、引导非公有制经济发展，使市场在资源配置中起决定性作用，更好发挥政府作用，推动新型工业化、信息化、城镇化、农业现代化同步发展，主动参与和推动经济全球化进程，发展更高层次的开放型经济，不断壮大我国经济实力和综合国力。</p>
<p>（五）坚持人民当家作主。坚持党的领导、人民当家作主、依法治国有机统一是社会主义政治发展的必然要求。必须坚持中国特色社会主义政治发展道路，坚持和完善人民代表大会制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度、基层群众自治制度，巩固和发展最广泛的爱国统一战线，发展社会主义协商民主，健全民主制度，丰富民主形式，拓宽民主渠道，保证人民当家作主落实到国家政治生活和社会生活之中。</p>
<p>（六）坚持全面依法治国。全面依法治国是中国特色社会主义的本质要求和重要保障。必须把党的领导贯彻落实到依法治国全过程和各方面，坚定不移走中国特色社会主义法治道路，完善以宪法为核心的中国特色社会主义法律体系，建设中国特色社会主义法治体系，建设社会主义法治国家，发展中国特色社会主义法治理论，坚持依法治国、依法执政、依法行政共同推进，坚持法治国家、法治政府、法治社会一体建设，坚持依法治国和以德治国相结合，依法治国和依规治党有机统一，深化司法体制改革，提高全民族法治素养和道德素质。</p>
<p>（七）坚持社会主义核心价值体系。文化自信是一个国家、一个民族发展中更基本、更深沉、更持久的力量。必须坚持马克思主义，牢固树立共产主义远大理想和中国特色社会主义共同理想，培育和践行社会主义核心价值观，不断增强意识形态领域主导权和话语权，推动中华优秀传统文化创造性转化、创新性发展，继承革命文化，发展社会主义先进文化，不忘本来、吸收外来、面向未来，更好构筑中国精神、中国价值、中国力量，为人民提供精神指引。</p>
<p>（八）坚持在发展中保障和改善民生。增进民生福祉是发展的根本目的。必须多谋民生之利、多解民生之忧，在发展中补齐民生短板、促进社会公平正义，在幼有所育、学有所教、劳有所得、病有所医、老有所养、住有所居、弱有所扶上不断取得新进展，深入开展脱贫攻坚，保证全体人民在共建共享发展中有更多获得感，不断促进人的全面发展、全体人民共同富裕。建设平安中国，加强和创新社会治理，维护社会和谐稳定，确保国家长治久安、人民安居乐业。</p>
<p>（九）坚持人与自然和谐共生。建设生态文明是中华民族永续发展的千年大计。必须树立和践行绿水青山就是金山银山的理念，坚持节约资源和保护环境的基本国策，像对待生命一样对待生态环境，统筹山水林田湖草系统治理，实行最严格的生态环境保护制度，形成绿色发展方式和生活方式，坚定走生产发展、生活富裕、生态良好的文明发展道路，建设美丽中国，为人民创造良好生产生活环境，为全球生态安全作出贡献。</p>
<p>（十）坚持总体国家安全观。统筹发展和安全，增强忧患意识，做到居安思危，是我们党治国理政的一个重大原则。必须坚持国家利益至上，以人民安全为宗旨，以政治安全为根本，统筹外部安全和内部安全、国土安全和国民安全、传统安全和非传统安全、自身安全和共同安全，完善国家安全制度体系，加强国家安全能力建设，坚决维护国家主权、安全、发展利益。</p>
<p>（十一）坚持党对人民军队的绝对领导。建设一支听党指挥、能打胜仗、作风优良的人民军队，是实现“两个一百年”奋斗目标、实现中华民族伟大复兴的战略支撑。必须全面贯彻党领导人民军队的一系列根本原则和制度，确立新时代党的强军思想在国防和军队建设中的指导地位，坚持政治建军、改革强军、科技兴军、依法治军，更加注重聚焦实战，更加注重创新驱动，更加注重体系建设，更加注重集约高效，更加注重军民融合，实现党在新时代的强军目标。</p>
<p>（十二）坚持“一国两制”和推进祖国统一。保持香港、澳门长期繁荣稳定，实现祖国完全统一，是实现中华民族伟大复兴的必然要求。必须把维护中央对香港、澳门特别行政区全面管治权和保障特别行政区高度自治权有机结合起来，确保“一国两制”方针不会变、不动摇，确保“一国两制”实践不变形、不走样。必须坚持一个中国原则，坚持“九二共识”，推动两岸关系和平发展，深化两岸经济合作和文化往来，推动两岸同胞共同反对一切分裂国家的活动，共同为实现中华民族伟大复兴而奋斗。</p>
<p>（十三）坚持推动构建人类命运共同体。中国人民的梦想同各国人民的梦想息息相通，实现中国梦离不开和平的国际环境和稳定的国际秩序。必须统筹国内国际两个大局，始终不渝走和平发展道路、奉行互利共赢的开放战略，坚持正确义利观，树立共同、综合、合作、可持续的新安全观，谋求开放创新、包容互惠的发展前景，促进和而不同、兼收并蓄的文明交流，构筑尊崇自然、绿色发展的生态体系，始终做世界和平的建设者、全球发展的贡献者、国际秩序的维护者。</p>
<p>（十四）坚持全面从严治党。勇于自我革命，从严管党治党，是我们党最鲜明的品格。必须以党章为根本遵循，把党的政治建设摆在首位，思想建党和制度治党同向发力，统筹推进党的各项建设，抓住“关键少数”，坚持“三严三实”，坚持民主集中制，严肃党内政治生活，严明党的纪律，强化党内监督，发展积极健康的党内政治文化，全面净化党内政治生态，坚决纠正各种不正之风，以零容忍态度惩治腐败，不断增强党自我净化、自我完善、自我革新、自我提高的能力，始终保持党同人民群众的血肉联系。</p>
<p>以上十四条，构成新时代坚持和发展中国特色社会主义的基本方略。全党同志必须全面贯彻党的基本理论、基本路线、基本方略，更好引领党和人民事业发展。</p>
<p>实践没有止境，理论创新也没有止境。世界每时每刻都在发生变化，中国也每时每刻都在发生变化，我们必须在理论上跟上时代，不断认识规律，不断推进理论创新、实践创新、制度创新、文化创新以及其他各方面创新。</p>
<p>同志们！时代是思想之母，实践是理论之源。只要我们善于聆听时代声音，勇于坚持真理、修正错误，二十一世纪中国的马克思主义一定能够展现出更强大、更有说服力的真理力量！</p>
<p>四、决胜全面建成小康社会，开启全面建设社会主义现代化国家新征程</p>
<p>改革开放之后，我们党对我国社会主义现代化建设作出战略安排，提出“三步走”战略目标。解决人民温饱问题、人民生活总体上达到小康水平这两个目标已提前实现。在这个基础上，我们党提出，到建党一百年时建成经济更加发展、民主更加健全、科教更加进步、文化更加繁荣、社会更加和谐、人民生活更加殷实的小康社会，然后再奋斗三十年，到新中国成立一百年时，基本实现现代化，把我国建成社会主义现代化国家。</p>
<p>从现在到二〇二〇年，是全面建成小康社会决胜期。要按照十六大、十七大、十八大提出的全面建成小康社会各项要求，紧扣我国社会主要矛盾变化，统筹推进经济建设、政治建设、文化建设、社会建设、生态文明建设，坚定实施科教兴国战略、人才强国战略、创新驱动发展战略、乡村振兴战略、区域协调发展战略、可持续发展战略、军民融合发展战略，突出抓重点、补短板、强弱项，特别是要坚决打好防范化解重大风险、精准脱贫、污染防治的攻坚战，使全面建成小康社会得到人民认可、经得起历史检验。</p>
<p>从十九大到二十大，是“两个一百年”奋斗目标的历史交汇期。我们既要全面建成小康社会、实现第一个百年奋斗目标，又要乘势而上开启全面建设社会主义现代化国家新征程，向第二个百年奋斗目标进军。</p>
<p>综合分析国际国内形势和我国发展条件，从二〇二〇年到本世纪中叶可以分两个阶段来安排。</p>
<p>第一个阶段，从二〇二〇年到二〇三五年，在全面建成小康社会的基础上，再奋斗十五年，基本实现社会主义现代化。到那时，我国经济实力、科技实力将大幅跃升，跻身创新型国家前列；人民平等参与、平等发展权利得到充分保障，法治国家、法治政府、法治社会基本建成，各方面制度更加完善，国家治理体系和治理能力现代化基本实现；社会文明程度达到新的高度，国家文化软实力显著增强，中华文化影响更加广泛深入；人民生活更为宽裕，中等收入群体比例明显提高，城乡区域发展差距和居民生活水平差距显著缩小，基本公共服务均等化基本实现，全体人民共同富裕迈出坚实步伐；现代社会治理格局基本形成，社会充满活力又和谐有序；生态环境根本好转，美丽中国目标基本实现。</p>
<p>第二个阶段，从二〇三五年到本世纪中叶，在基本实现现代化的基础上，再奋斗十五年，把我国建成富强民主文明和谐美丽的社会主义现代化强国。到那时，我国物质文明、政治文明、精神文明、社会文明、生态文明将全面提升，实现国家治理体系和治理能力现代化，成为综合国力和国际影响力领先的国家，全体人民共同富裕基本实现，我国人民将享有更加幸福安康的生活，中华民族将以更加昂扬的姿态屹立于世界民族之林。</p>
<p>同志们！从全面建成小康社会到基本实现现代化，再到全面建成社会主义现代化强国，是新时代中国特色社会主义发展的战略安排。我们要坚忍不拔、锲而不舍，奋力谱写社会主义现代化新征程的壮丽篇章！</p>
<p>五、贯彻新发展理念，建设现代化经济体系</p>
<p>实现“两个一百年”奋斗目标、实现中华民族伟大复兴的中国梦，不断提高人民生活水平，必须坚定不移把发展作为党执政兴国的第一要务，坚持解放和发展社会生产力，坚持社会主义市场经济改革方向，推动经济持续健康发展。</p>
<p>我国经济已由高速增长阶段转向高质量发展阶段，正处在转变发展方式、优化经济结构、转换增长动力的攻关期，建设现代化经济体系是跨越关口的迫切要求和我国发展的战略目标。必须坚持质量第一、效益优先，以供给侧结构性改革为主线，推动经济发展质量变革、效率变革、动力变革，提高全要素生产率，着力加快建设实体经济、科技创新、现代金融、人力资源协同发展的产业体系，着力构建市场机制有效、微观主体有活力、宏观调控有度的经济体制，不断增强我国经济创新力和竞争力。</p>
<p>（一）深化供给侧结构性改革。建设现代化经济体系，必须把发展经济的着力点放在实体经济上，把提高供给体系质量作为主攻方向，显著增强我国经济质量优势。加快建设制造强国，加快发展先进制造业，推动互联网、大数据、人工智能和实体经济深度融合，在中高端消费、创新引领、绿色低碳、共享经济、现代供应链、人力资本服务等领域培育新增长点、形成新动能。支持传统产业优化升级，加快发展现代服务业，瞄准国际标准提高水平。促进我国产业迈向全球价值链中高端，培育若干世界级先进制造业集群。加强水利、铁路、公路、水运、航空、管道、电网、信息、物流等基础设施网络建设。坚持去产能、去库存、去杠杆、降成本、补短板，优化存量资源配置，扩大优质增量供给，实现供需动态平衡。激发和保护企业家精神，鼓励更多社会主体投身创新创业。建设知识型、技能型、创新型劳动者大军，弘扬劳模精神和工匠精神，营造劳动光荣的社会风尚和精益求精的敬业风气。</p>
<p>（二）加快建设创新型国家。创新是引领发展的第一动力，是建设现代化经济体系的战略支撑。要瞄准世界科技前沿，强化基础研究，实现前瞻性基础研究、引领性原创成果重大突破。加强应用基础研究，拓展实施国家重大科技项目，突出关键共性技术、前沿引领技术、现代工程技术、颠覆性技术创新，为建设科技强国、质量强国、航天强国、网络强国、交通强国、数字中国、智慧社会提供有力支撑。加强国家创新体系建设，强化战略科技力量。深化科技体制改革，建立以企业为主体、市场为导向、产学研深度融合的技术创新体系，加强对中小企业创新的支持，促进科技成果转化。倡导创新文化，强化知识产权创造、保护、运用。培养造就一大批具有国际水平的战略科技人才、科技领军人才、青年科技人才和高水平创新团队。</p>
<p>（三）实施乡村振兴战略。农业农村农民问题是关系国计民生的根本性问题，必须始终把解决好“三农”问题作为全党工作重中之重。要坚持农业农村优先发展，按照产业兴旺、生态宜居、乡风文明、治理有效、生活富裕的总要求，建立健全城乡融合发展体制机制和政策体系，加快推进农业农村现代化。巩固和完善农村基本经营制度，深化农村土地制度改革，完善承包地“三权”分置制度。保持土地承包关系稳定并长久不变，第二轮土地承包到期后再延长三十年。深化农村集体产权制度改革，保障农民财产权益，壮大集体经济。确保国家粮食安全，把中国人的饭碗牢牢端在自己手中。构建现代农业产业体系、生产体系、经营体系，完善农业支持保护制度，发展多种形式适度规模经营，培育新型农业经营主体，健全农业社会化服务体系，实现小农户和现代农业发展有机衔接。促进农村一二三产业融合发展，支持和鼓励农民就业创业，拓宽增收渠道。加强农村基层基础工作，健全自治、法治、德治相结合的乡村治理体系。培养造就一支懂农业、爱农村、爱农民的“三农”工作队伍。</p>
<p>（四）实施区域协调发展战略。加大力度支持革命老区、民族地区、边疆地区、贫困地区加快发展，强化举措推进西部大开发形成新格局，深化改革加快东北等老工业基地振兴，发挥优势推动中部地区崛起，创新引领率先实现东部地区优化发展，建立更加有效的区域协调发展新机制。以城市群为主体构建大中小城市和小城镇协调发展的城镇格局，加快农业转移人口市民化。以疏解北京非首都功能为“牛鼻子”推动京津冀协同发展，高起点规划、高标准建设雄安新区。以共抓大保护、不搞大开发为导向推动长江经济带发展。支持资源型地区经济转型发展。加快边疆发展，确保边疆巩固、边境安全。坚持陆海统筹，加快建设海洋强国。</p>
<p>（五）加快完善社会主义市场经济体制。经济体制改革必须以完善产权制度和要素市场化配置为重点，实现产权有效激励、要素自由流动、价格反应灵活、竞争公平有序、企业优胜劣汰。要完善各类国有资产管理体制，改革国有资本授权经营体制，加快国有经济布局优化、结构调整、战略性重组，促进国有资产保值增值，推动国有资本做强做优做大，有效防止国有资产流失。深化国有企业改革，发展混合所有制经济，培育具有全球竞争力的世界一流企业。全面实施市场准入负面清单制度，清理废除妨碍统一市场和公平竞争的各种规定和做法，支持民营企业发展，激发各类市场主体活力。深化商事制度改革，打破行政性垄断，防止市场垄断，加快要素价格市场化改革，放宽服务业准入限制，完善市场监管体制。创新和完善宏观调控，发挥国家发展规划的战略导向作用，健全财政、货币、产业、区域等经济政策协调机制。完善促进消费的体制机制，增强消费对经济发展的基础性作用。深化投融资体制改革，发挥投资对优化供给结构的关键性作用。加快建立现代财政制度，建立权责清晰、财力协调、区域均衡的中央和地方财政关系。建立全面规范透明、标准科学、约束有力的预算制度，全面实施绩效管理。深化税收制度改革，健全地方税体系。深化金融体制改革，增强金融服务实体经济能力，提高直接融资比重，促进多层次资本市场健康发展。健全货币政策和宏观审慎政策双支柱调控框架，深化利率和汇率市场化改革。健全金融监管体系，守住不发生系统性金融风险的底线。</p>
<p>（六）推动形成全面开放新格局。开放带来进步，封闭必然落后。中国开放的大门不会关闭，只会越开越大。要以“一带一路”建设为重点，坚持引进来和走出去并重，遵循共商共建共享原则，加强创新能力开放合作，形成陆海内外联动、东西双向互济的开放格局。拓展对外贸易，培育贸易新业态新模式，推进贸易强国建设。实行高水平的贸易和投资自由化便利化政策，全面实行准入前国民待遇加负面清单管理制度，大幅度放宽市场准入，扩大服务业对外开放，保护外商投资合法权益。凡是在我国境内注册的企业，都要一视同仁、平等对待。优化区域开放布局，加大西部开放力度。赋予自由贸易试验区更大改革自主权，探索建设自由贸易港。创新对外投资方式，促进国际产能合作，形成面向全球的贸易、投融资、生产、服务网络，加快培育国际经济合作和竞争新优势。</p>
<p>同志们！解放和发展社会生产力，是社会主义的本质要求。我们要激发全社会创造力和发展活力，努力实现更高质量、更有效率、更加公平、更可持续的发展！</p>
<p>六、健全人民当家作主制度体系，发展社会主义民主政治</p>
<p>我国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家，国家一切权力属于人民。我国社会主义民主是维护人民根本利益的最广泛、最真实、最管用的民主。发展社会主义民主政治就是要体现人民意志、保障人民权益、激发人民创造活力，用制度体系保证人民当家作主。</p>
<p>中国特色社会主义政治发展道路，是近代以来中国人民长期奋斗历史逻辑、理论逻辑、实践逻辑的必然结果，是坚持党的本质属性、践行党的根本宗旨的必然要求。世界上没有完全相同的政治制度模式，政治制度不能脱离特定社会政治条件和历史文化传统来抽象评判，不能定于一尊，不能生搬硬套外国政治制度模式。要长期坚持、不断发展我国社会主义民主政治，积极稳妥推进政治体制改革，推进社会主义民主政治制度化、规范化、法治化、程序化，保证人民依法通过各种途径和形式管理国家事务，管理经济文化事业，管理社会事务，巩固和发展生动活泼、安定团结的政治局面。</p>
<p>（一）坚持党的领导、人民当家作主、依法治国有机统一。党的领导是人民当家作主和依法治国的根本保证，人民当家作主是社会主义民主政治的本质特征，依法治国是党领导人民治理国家的基本方式，三者统一于我国社会主义民主政治伟大实践。在我国政治生活中，党是居于领导地位的，加强党的集中统一领导，支持人大、政府、政协和法院、检察院依法依章程履行职能、开展工作、发挥作用，这两个方面是统一的。要改进党的领导方式和执政方式，保证党领导人民有效治理国家；扩大人民有序政治参与，保证人民依法实行民主选举、民主协商、民主决策、民主管理、民主监督；维护国家法制统一、尊严、权威，加强人权法治保障，保证人民依法享有广泛权利和自由。巩固基层政权，完善基层民主制度，保障人民知情权、参与权、表达权、监督权。健全依法决策机制，构建决策科学、执行坚决、监督有力的权力运行机制。各级领导干部要增强民主意识，发扬民主作风，接受人民监督，当好人民公仆。</p>
<p>（二）加强人民当家作主制度保障。人民代表大会制度是坚持党的领导、人民当家作主、依法治国有机统一的根本政治制度安排，必须长期坚持、不断完善。要支持和保证人民通过人民代表大会行使国家权力。发挥人大及其常委会在立法工作中的主导作用，健全人大组织制度和工作制度，支持和保证人大依法行使立法权、监督权、决定权、任免权，更好发挥人大代表作用，使各级人大及其常委会成为全面担负起宪法法律赋予的各项职责的工作机关，成为同人民群众保持密切联系的代表机关。完善人大专门委员会设置，优化人大常委会和专门委员会组成人员结构。</p>
<p>（三）发挥社会主义协商民主重要作用。有事好商量，众人的事情由众人商量，是人民民主的真谛。协商民主是实现党的领导的重要方式，是我国社会主义民主政治的特有形式和独特优势。要推动协商民主广泛、多层、制度化发展，统筹推进政党协商、人大协商、政府协商、政协协商、人民团体协商、基层协商以及社会组织协商。加强协商民主制度建设，形成完整的制度程序和参与实践，保证人民在日常政治生活中有广泛持续深入参与的权利。</p>
<p>人民政协是具有中国特色的制度安排，是社会主义协商民主的重要渠道和专门协商机构。人民政协工作要聚焦党和国家中心任务，围绕团结和民主两大主题，把协商民主贯穿政治协商、民主监督、参政议政全过程，完善协商议政内容和形式，着力增进共识、促进团结。加强人民政协民主监督，重点监督党和国家重大方针政策和重要决策部署的贯彻落实。增强人民政协界别的代表性，加强委员队伍建设。</p>
<p>（四）深化依法治国实践。全面依法治国是国家治理的一场深刻革命，必须坚持厉行法治，推进科学立法、严格执法、公正司法、全民守法。成立中央全面依法治国领导小组，加强对法治中国建设的统一领导。加强宪法实施和监督，推进合宪性审查工作，维护宪法权威。推进科学立法、民主立法、依法立法，以良法促进发展、保障善治。建设法治政府，推进依法行政，严格规范公正文明执法。深化司法体制综合配套改革，全面落实司法责任制，努力让人民群众在每一个司法案件中感受到公平正义。加大全民普法力度，建设社会主义法治文化，树立宪法法律至上、法律面前人人平等的法治理念。各级党组织和全体党员要带头尊法学法守法用法，任何组织和个人都不得有超越宪法法律的特权，绝不允许以言代法、以权压法、逐利违法、徇私枉法。</p>
<p>（五）深化机构和行政体制改革。统筹考虑各类机构设置，科学配置党政部门及内设机构权力、明确职责。统筹使用各类编制资源，形成科学合理的管理体制，完善国家机构组织法。转变政府职能，深化简政放权，创新监管方式，增强政府公信力和执行力，建设人民满意的服务型政府。赋予省级及以下政府更多自主权。在省市县对职能相近的党政机关探索合并设立或合署办公。深化事业单位改革，强化公益属性，推进政事分开、事企分开、管办分离。</p>
<p>（六）巩固和发展爱国统一战线。统一战线是党的事业取得胜利的重要法宝，必须长期坚持。要高举爱国主义、社会主义旗帜，牢牢把握大团结大联合的主题，坚持一致性和多样性统一，找到最大公约数，画出最大同心圆。坚持长期共存、互相监督、肝胆相照、荣辱与共，支持民主党派按照中国特色社会主义参政党要求更好履行职能。深化民族团结进步教育，铸牢中华民族共同体意识，加强各民族交往交流交融，促进各民族像石榴籽一样紧紧抱在一起，共同团结奋斗、共同繁荣发展。全面贯彻党的宗教工作基本方针，坚持我国宗教的中国化方向，积极引导宗教与社会主义社会相适应。加强党外知识分子工作，做好新的社会阶层人士工作，发挥他们在中国特色社会主义事业中的重要作用。构建亲、清新型政商关系，促进非公有制经济健康发展和非公有制经济人士健康成长。广泛团结联系海外侨胞和归侨侨眷，共同致力于中华民族伟大复兴。</p>
<p>同志们！中国特色社会主义政治制度是中国共产党和中国人民的伟大创造。我们完全有信心、有能力把我国社会主义民主政治的优势和特点充分发挥出来，为人类政治文明进步作出充满中国智慧的贡献！</p>
<p>七、坚定文化自信，推动社会主义文化繁荣兴盛</p>
<p>文化是一个国家、一个民族的灵魂。文化兴国运兴，文化强民族强。没有高度的文化自信，没有文化的繁荣兴盛，就没有中华民族伟大复兴。要坚持中国特色社会主义文化发展道路，激发全民族文化创新创造活力，建设社会主义文化强国。</p>
<p>中国特色社会主义文化，源自于中华民族五千多年文明历史所孕育的中华优秀传统文化，熔铸于党领导人民在革命、建设、改革中创造的革命文化和社会主义先进文化，植根于中国特色社会主义伟大实践。发展中国特色社会主义文化，就是以马克思主义为指导，坚守中华文化立场，立足当代中国现实，结合当今时代条件，发展面向现代化、面向世界、面向未来的，民族的科学的大众的社会主义文化，推动社会主义精神文明和物质文明协调发展。要坚持为人民服务、为社会主义服务，坚持百花齐放、百家争鸣，坚持创造性转化、创新性发展，不断铸就中华文化新辉煌。</p>
<p>（一）牢牢掌握意识形态工作领导权。意识形态决定文化前进方向和发展道路。必须推进马克思主义中国化时代化大众化，建设具有强大凝聚力和引领力的社会主义意识形态，使全体人民在理想信念、价值理念、道德观念上紧紧团结在一起。要加强理论武装，推动新时代中国特色社会主义思想深入人心。深化马克思主义理论研究和建设，加快构建中国特色哲学社会科学，加强中国特色新型智库建设。高度重视传播手段建设和创新，提高新闻舆论传播力、引导力、影响力、公信力。加强互联网内容建设，建立网络综合治理体系，营造清朗的网络空间。落实意识形态工作责任制，加强阵地建设和管理，注意区分政治原则问题、思想认识问题、学术观点问题，旗帜鲜明反对和抵制各种错误观点。</p>
<p>（二）培育和践行社会主义核心价值观。社会主义核心价值观是当代中国精神的集中体现，凝结着全体人民共同的价值追求。要以培养担当民族复兴大任的时代新人为着眼点，强化教育引导、实践养成、制度保障，发挥社会主义核心价值观对国民教育、精神文明创建、精神文化产品创作生产传播的引领作用，把社会主义核心价值观融入社会发展各方面，转化为人们的情感认同和行为习惯。坚持全民行动、干部带头，从家庭做起，从娃娃抓起。深入挖掘中华优秀传统文化蕴含的思想观念、人文精神、道德规范，结合时代要求继承创新，让中华文化展现出永久魅力和时代风采。</p>
<p>（三）加强思想道德建设。人民有信仰，国家有力量，民族有希望。要提高人民思想觉悟、道德水准、文明素养，提高全社会文明程度。广泛开展理想信念教育，深化中国特色社会主义和中国梦宣传教育，弘扬民族精神和时代精神，加强爱国主义、集体主义、社会主义教育，引导人们树立正确的历史观、民族观、国家观、文化观。深入实施公民道德建设工程，推进社会公德、职业道德、家庭美德、个人品德建设，激励人们向上向善、孝老爱亲，忠于祖国、忠于人民。加强和改进思想政治工作，深化群众性精神文明创建活动。弘扬科学精神，普及科学知识，开展移风易俗、弘扬时代新风行动，抵制腐朽落后文化侵蚀。推进诚信建设和志愿服务制度化，强化社会责任意识、规则意识、奉献意识。</p>
<p>（四）繁荣发展社会主义文艺。社会主义文艺是人民的文艺，必须坚持以人民为中心的创作导向，在深入生活、扎根人民中进行无愧于时代的文艺创造。要繁荣文艺创作，坚持思想精深、艺术精湛、制作精良相统一，加强现实题材创作，不断推出讴歌党、讴歌祖国、讴歌人民、讴歌英雄的精品力作。发扬学术民主、艺术民主，提升文艺原创力，推动文艺创新。倡导讲品位、讲格调、讲责任，抵制低俗、庸俗、媚俗。加强文艺队伍建设，造就一大批德艺双馨名家大师，培育一大批高水平创作人才。</p>
<p>（五）推动文化事业和文化产业发展。满足人民过上美好生活的新期待，必须提供丰富的精神食粮。要深化文化体制改革，完善文化管理体制，加快构建把社会效益放在首位、社会效益和经济效益相统一的体制机制。完善公共文化服务体系，深入实施文化惠民工程，丰富群众性文化活动。加强文物保护利用和文化遗产保护传承。健全现代文化产业体系和市场体系，创新生产经营机制，完善文化经济政策，培育新型文化业态。广泛开展全民健身活动，加快推进体育强国建设，筹办好北京冬奥会、冬残奥会。加强中外人文交流，以我为主、兼收并蓄。推进国际传播能力建设，讲好中国故事，展现真实、立体、全面的中国，提高国家文化软实力。</p>
<p>同志们！中国共产党从成立之日起，既是中国先进文化的积极引领者和践行者，又是中华优秀传统文化的忠实传承者和弘扬者。当代中国共产党人和中国人民应该而且一定能够担负起新的文化使命，在实践创造中进行文化创造，在历史进步中实现文化进步！</p>
<p>八、提高保障和改善民生水平，加强和创新社会治理</p>
<p>全党必须牢记，为什么人的问题，是检验一个政党、一个政权性质的试金石。带领人民创造美好生活，是我们党始终不渝的奋斗目标。必须始终把人民利益摆在至高无上的地位，让改革发展成果更多更公平惠及全体人民，朝着实现全体人民共同富裕不断迈进。</p>
<p>保障和改善民生要抓住人民最关心最直接最现实的利益问题，既尽力而为，又量力而行，一件事情接着一件事情办，一年接着一年干。坚持人人尽责、人人享有，坚守底线、突出重点、完善制度、引导预期，完善公共服务体系，保障群众基本生活，不断满足人民日益增长的美好生活需要，不断促进社会公平正义，形成有效的社会治理、良好的社会秩序，使人民获得感、幸福感、安全感更加充实、更有保障、更可持续。</p>
<p>（一）优先发展教育事业。建设教育强国是中华民族伟大复兴的基础工程，必须把教育事业放在优先位置，加快教育现代化，办好人民满意的教育。要全面贯彻党的教育方针，落实立德树人根本任务，发展素质教育，推进教育公平，培养德智体美全面发展的社会主义建设者和接班人。推动城乡义务教育一体化发展，高度重视农村义务教育，办好学前教育、特殊教育和网络教育，普及高中阶段教育，努力让每个孩子都能享有公平而有质量的教育。完善职业教育和培训体系，深化产教融合、校企合作。加快一流大学和一流学科建设，实现高等教育内涵式发展。健全学生资助制度，使绝大多数城乡新增劳动力接受高中阶段教育、更多接受高等教育。支持和规范社会力量兴办教育。加强师德师风建设，培养高素质教师队伍，倡导全社会尊师重教。办好继续教育，加快建设学习型社会，大力提高国民素质。</p>
<p>（二）提高就业质量和人民收入水平。就业是最大的民生。要坚持就业优先战略和积极就业政策，实现更高质量和更充分就业。大规模开展职业技能培训，注重解决结构性就业矛盾，鼓励创业带动就业。提供全方位公共就业服务，促进高校毕业生等青年群体、农民工多渠道就业创业。破除妨碍劳动力、人才社会性流动的体制机制弊端，使人人都有通过辛勤劳动实现自身发展的机会。完善政府、工会、企业共同参与的协商协调机制，构建和谐劳动关系。坚持按劳分配原则，完善按要素分配的体制机制，促进收入分配更合理、更有序。鼓励勤劳守法致富，扩大中等收入群体，增加低收入者收入，调节过高收入，取缔非法收入。坚持在经济增长的同时实现居民收入同步增长、在劳动生产率提高的同时实现劳动报酬同步提高。拓宽居民劳动收入和财产性收入渠道。履行好政府再分配调节职能，加快推进基本公共服务均等化，缩小收入分配差距。</p>
<p>（三）加强社会保障体系建设。按照兜底线、织密网、建机制的要求，全面建成覆盖全民、城乡统筹、权责清晰、保障适度、可持续的多层次社会保障体系。全面实施全民参保计划。完善城镇职工基本养老保险和城乡居民基本养老保险制度，尽快实现养老保险全国统筹。完善统一的城乡居民基本医疗保险制度和大病保险制度。完善失业、工伤保险制度。建立全国统一的社会保险公共服务平台。统筹城乡社会救助体系，完善最低生活保障制度。坚持男女平等基本国策，保障妇女儿童合法权益。完善社会救助、社会福利、慈善事业、优抚安置等制度，健全农村留守儿童和妇女、老年人关爱服务体系。发展残疾人事业，加强残疾康复服务。坚持房子是用来住的、不是用来炒的定位，加快建立多主体供给、多渠道保障、租购并举的住房制度，让全体人民住有所居。</p>
<p>（四）坚决打赢脱贫攻坚战。让贫困人口和贫困地区同全国一道进入全面小康社会是我们党的庄严承诺。要动员全党全国全社会力量，坚持精准扶贫、精准脱贫，坚持中央统筹省负总责市县抓落实的工作机制，强化党政一把手负总责的责任制，坚持大扶贫格局，注重扶贫同扶志、扶智相结合，深入实施东西部扶贫协作，重点攻克深度贫困地区脱贫任务，确保到二〇二〇年我国现行标准下农村贫困人口实现脱贫，贫困县全部摘帽，解决区域性整体贫困，做到脱真贫、真脱贫。</p>
<p>（五）实施健康中国战略。人民健康是民族昌盛和国家富强的重要标志。要完善国民健康政策，为人民群众提供全方位全周期健康服务。深化医药卫生体制改革，全面建立中国特色基本医疗卫生制度、医疗保障制度和优质高效的医疗卫生服务体系，健全现代医院管理制度。加强基层医疗卫生服务体系和全科医生队伍建设。全面取消以药养医，健全药品供应保障制度。坚持预防为主，深入开展爱国卫生运动，倡导健康文明生活方式，预防控制重大疾病。实施食品安全战略，让人民吃得放心。坚持中西医并重，传承发展中医药事业。支持社会办医，发展健康产业。促进生育政策和相关经济社会政策配套衔接，加强人口发展战略研究。积极应对人口老龄化，构建养老、孝老、敬老政策体系和社会环境，推进医养结合，加快老龄事业和产业发展。</p>
<p>（六）打造共建共治共享的社会治理格局。加强社会治理制度建设，完善党委领导、政府负责、社会协同、公众参与、法治保障的社会治理体制，提高社会治理社会化、法治化、智能化、专业化水平。加强预防和化解社会矛盾机制建设，正确处理人民内部矛盾。树立安全发展理念，弘扬生命至上、安全第一的思想，健全公共安全体系，完善安全生产责任制，坚决遏制重特大安全事故，提升防灾减灾救灾能力。加快社会治安防控体系建设，依法打击和惩治黄赌毒黑拐骗等违法犯罪活动，保护人民人身权、财产权、人格权。加强社会心理服务体系建设，培育自尊自信、理性平和、积极向上的社会心态。加强社区治理体系建设，推动社会治理重心向基层下移，发挥社会组织作用，实现政府治理和社会调节、居民自治良性互动。</p>
<p>（七）有效维护国家安全。国家安全是安邦定国的重要基石，维护国家安全是全国各族人民根本利益所在。要完善国家安全战略和国家安全政策，坚决维护国家政治安全，统筹推进各项安全工作。健全国家安全体系，加强国家安全法治保障，提高防范和抵御安全风险能力。严密防范和坚决打击各种渗透颠覆破坏活动、暴力恐怖活动、民族分裂活动、宗教极端活动。加强国家安全教育，增强全党全国人民国家安全意识，推动全社会形成维护国家安全的强大合力。</p>
<p>同志们！党的一切工作必须以最广大人民根本利益为最高标准。我们要坚持把人民群众的小事当作自己的大事，从人民群众关心的事情做起，从让人民群众满意的事情做起，带领人民不断创造美好生活！</p>
<p>九、加快生态文明体制改革，建设美丽中国</p>
<p>人与自然是生命共同体，人类必须尊重自然、顺应自然、保护自然。人类只有遵循自然规律才能有效防止在开发利用自然上走弯路，人类对大自然的伤害最终会伤及人类自身，这是无法抗拒的规律。</p>
<p>（一）推进绿色发展。加快建立绿色生产和消费的法律制度和政策导向，建立健全绿色低碳循环发展的经济体系。构建市场导向的绿色技术创新体系，发展绿色金融，壮大节能环保产业、清洁生产产业、清洁能源产业。推进能源生产和消费革命，构建清洁低碳、安全高效的能源体系。推进资源全面节约和循环利用，实施国家节水行动，降低能耗、物耗，实现生产系统和生活系统循环链接。倡导简约适度、绿色低碳的生活方式，反对奢侈浪费和不合理消费，开展创建节约型机关、绿色家庭、绿色学校、绿色社区和绿色出行等行动。</p>
<p>（二）着力解决突出环境问题。坚持全民共治、源头防治，持续实施大气污染防治行动，打赢蓝天保卫战。加快水污染防治，实施流域环境和近岸海域综合治理。强化土壤污染管控和修复，加强农业面源污染防治，开展农村人居环境整治行动。加强固体废弃物和垃圾处置。提高污染排放标准，强化排污者责任，健全环保信用评价、信息强制性披露、严惩重罚等制度。构建政府为主导、企业为主体、社会组织和公众共同参与的环境治理体系。积极参与全球环境治理，落实减排承诺。</p>
<p>（三）加大生态系统保护力度。实施重要生态系统保护和修复重大工程，优化生态安全屏障体系，构建生态廊道和生物多样性保护网络，提升生态系统质量和稳定性。完成生态保护红线、永久基本农田、城镇开发边界三条控制线划定工作。开展国土绿化行动，推进荒漠化、石漠化、水土流失综合治理，强化湿地保护和恢复，加强地质灾害防治。完善天然林保护制度，扩大退耕还林还草。严格保护耕地，扩大轮作休耕试点，健全耕地草原森林河流湖泊休养生息制度，建立市场化、多元化生态补偿机制。</p>
<p>（四）改革生态环境监管体制。加强对生态文明建设的总体设计和组织领导，设立国有自然资源资产管理和自然生态监管机构，完善生态环境管理制度，统一行使全民所有自然资源资产所有者职责，统一行使所有国土空间用途管制和生态保护修复职责，统一行使监管城乡各类污染排放和行政执法职责。构建国土空间开发保护制度，完善主体功能区配套政策，建立以国家公园为主体的自然保护地体系。坚决制止和惩处破坏生态环境行为。</p>
<p>同志们！生态文明建设功在当代、利在千秋。我们要牢固树立社会主义生态文明观，推动形成人与自然和谐发展现代化建设新格局，为保护生态环境作出我们这代人的努力！</p>
<p>十、坚持走中国特色强军之路，全面推进国防和军队现代化</p>
<p>国防和军队建设正站在新的历史起点上。面对国家安全环境的深刻变化，面对强国强军的时代要求，必须全面贯彻新时代党的强军思想，贯彻新形势下军事战略方针，建设强大的现代化陆军、海军、空军、火箭军和战略支援部队，打造坚强高效的战区联合作战指挥机构，构建中国特色现代作战体系，担当起党和人民赋予的新时代使命任务。</p>
<p>适应世界新军事革命发展趋势和国家安全需求，提高建设质量和效益，确保到二〇二〇年基本实现机械化，信息化建设取得重大进展，战略能力有大的提升。同国家现代化进程相一致，全面推进军事理论现代化、军队组织形态现代化、军事人员现代化、武器装备现代化，力争到二〇三五年基本实现国防和军队现代化，到本世纪中叶把人民军队全面建成世界一流军队。</p>
<p>加强军队党的建设，开展“传承红色基因、担当强军重任”主题教育，推进军人荣誉体系建设，培养有灵魂、有本事、有血性、有品德的新时代革命军人，永葆人民军队性质、宗旨、本色。继续深化国防和军队改革，深化军官职业化制度、文职人员制度等重大政策制度改革，推进军事管理革命，完善和发展中国特色社会主义军事制度。树立科技是核心战斗力的思想，推进重大技术创新、自主创新，加强军事人才培养体系建设，建设创新型人民军队。全面从严治军，推动治军方式根本性转变，提高国防和军队建设法治化水平。</p>
<p>军队是要准备打仗的，一切工作都必须坚持战斗力标准，向能打仗、打胜仗聚焦。扎实做好各战略方向军事斗争准备，统筹推进传统安全领域和新型安全领域军事斗争准备，发展新型作战力量和保障力量，开展实战化军事训练，加强军事力量运用，加快军事智能化发展，提高基于网络信息体系的联合作战能力、全域作战能力，有效塑造态势、管控危机、遏制战争、打赢战争。</p>
<p>坚持富国和强军相统一，强化统一领导、顶层设计、改革创新和重大项目落实，深化国防科技工业改革，形成军民融合深度发展格局，构建一体化的国家战略体系和能力。完善国防动员体系，建设强大稳固的现代边海空防。组建退役军人管理保障机构，维护军人军属合法权益，让军人成为全社会尊崇的职业。深化武警部队改革，建设现代化武装警察部队。</p>
<p>同志们！我们的军队是人民军队，我们的国防是全民国防。我们要加强全民国防教育，巩固军政军民团结，为实现中国梦强军梦凝聚强大力量！</p>
<p>十一、坚持“一国两制”，推进祖国统一</p>
<p>香港、澳门回归祖国以来，“一国两制”实践取得举世公认的成功。事实证明，“一国两制”是解决历史遗留的香港、澳门问题的最佳方案，也是香港、澳门回归后保持长期繁荣稳定的最佳制度。</p>
<p>保持香港、澳门长期繁荣稳定，必须全面准确贯彻“一国两制”、“港人治港”、“澳人治澳”、高度自治的方针，严格依照宪法和基本法办事，完善与基本法实施相关的制度和机制。要支持特别行政区政府和行政长官依法施政、积极作为，团结带领香港、澳门各界人士齐心协力谋发展、促和谐，保障和改善民生，有序推进民主，维护社会稳定，履行维护国家主权、安全、发展利益的宪制责任。</p>
<p>香港、澳门发展同内地发展紧密相连。要支持香港、澳门融入国家发展大局，以粤港澳大湾区建设、粤港澳合作、泛珠三角区域合作等为重点，全面推进内地同香港、澳门互利合作，制定完善便利香港、澳门居民在内地发展的政策措施。</p>
<p>我们坚持爱国者为主体的“港人治港”、“澳人治澳”，发展壮大爱国爱港爱澳力量，增强香港、澳门同胞的国家意识和爱国精神，让香港、澳门同胞同祖国人民共担民族复兴的历史责任、共享祖国繁荣富强的伟大荣光。</p>
<p>解决台湾问题、实现祖国完全统一，是全体中华儿女共同愿望，是中华民族根本利益所在。必须继续坚持“和平统一、一国两制”方针，推动两岸关系和平发展，推进祖国和平统一进程。“一个中国”原则是两岸关系的政治基础，体现一个中国原则的九二共识明确鉴定了两岸关系的根本性质，是确保两岸关系和平发展的关键。承认九二共识的历史事实、认同两岸同属一个中国，两岸双方就能开展对话协商解决两岸同胞关心的问题。台湾任何政党和团体同大陆交往也不会存在障碍。(add)</p>
<p>两岸同胞是命运与共的骨肉兄弟，是血浓于水的一家人。我们秉持“两岸一家亲”理念，尊重台湾现有的社会制度和台湾同胞生活方式，愿意率先同台湾同胞分享大陆发展的机遇。我们将扩大两岸经济文化交流合作，实现互利互惠，逐步为台湾同胞在大陆学习、创业、就业、生活提供与大陆同胞同等的待遇，增进台湾同胞福祉。我们将推动两岸同胞共同弘扬中华文化，促进心灵契合。</p>
<p>我们坚决维护国家主权和领土完整，绝不容忍国家分裂的历史悲剧重演（鼓掌）。一切分裂祖国的活动都必将遭到全体中国人坚决反对（鼓掌）。我们有坚定的意志、充分的信心、足够的能力挫败任何形式的“台独”分裂图谋（鼓掌）。我们绝不允许任何人、任何组织、任何政党、在任何时候、以任何形式、把任何一块中国领土从中国分裂出去！（鼓掌）</p>
<p>同志们！实现中华民族伟大复兴，是全体中国人共同的梦想。我们坚信，只要包括港澳台同胞在内的全体中华儿女顺应历史大势、共担民族大义，把民族命运牢牢掌握在自己手中，就一定能够共创中华民族伟大复兴的美好未来！</p>
<p>十二、坚持和平发展道路，推动构建人类命运共同体</p>
<p>中国共产党是为中国人民谋幸福的政党，也是为人类进步事业而奋斗的政党。中国共产党始终把为人类作出新的更大的贡献作为自己的使命。</p>
<p>中国将高举和平、发展、合作、共赢的旗帜，恪守维护世界和平、促进共同发展的外交政策宗旨，坚定不移在和平共处五项原则基础上发展同各国的友好合作，推动建设相互尊重、公平正义、合作共赢的新型国际关系。</p>
<p>世界正处于大发展大变革大调整时期，和平与发展仍然是时代主题。世界多极化、经济全球化、社会信息化、文化多样化深入发展，全球治理体系和国际秩序变革加速推进，各国相互联系和依存日益加深，国际力量对比更趋平衡，和平发展大势不可逆转。同时，世界面临的不稳定性不确定性突出，世界经济增长动能不足，贫富分化日益严重，地区热点问题此起彼伏，恐怖主义、网络安全、重大传染性疾病、气候变化等非传统安全威胁持续蔓延，人类面临许多共同挑战。</p>
<p>我们生活的世界充满希望，也充满挑战。我们不能因现实复杂而放弃梦想，不能因理想遥远而放弃追求。没有哪个国家能够独自应对人类面临的各种挑战，也没有哪个国家能够退回到自我封闭的孤岛。</p>
<p>我们呼吁，各国人民同心协力，构建人类命运共同体，建设持久和平、普遍安全、共同繁荣、开放包容、清洁美丽的世界。要相互尊重、平等协商，坚决摒弃冷战思维和强权政治，走对话而不对抗、结伴而不结盟的国与国交往新路。要坚持以对话解决争端、以协商化解分歧，统筹应对传统和非传统安全威胁，反对一切形式的恐怖主义。要同舟共济，促进贸易和投资自由化便利化，推动经济全球化朝着更加开放、包容、普惠、平衡、共赢的方向发展。要尊重世界文明多样性，以文明交流超越文明隔阂、文明互鉴超越文明冲突、文明共存超越文明优越。要坚持环境友好，合作应对气候变化，保护好人类赖以生存的地球家园。</p>
<p>中国坚定奉行独立自主的和平外交政策，尊重各国人民自主选择发展道路的权利，维护国际公平正义，反对把自己的意志强加于人，反对干涉别国内政，反对以强凌弱。中国决不会以牺牲别国利益为代价来发展自己，也决不放弃自己的正当权益，任何人不要幻想让中国吞下损害自身利益的苦果。中国奉行防御性的国防政策。中国发展不对任何国家构成威胁。中国无论发展到什么程度，永远不称霸，永远不搞扩张。</p>
<p>中国积极发展全球伙伴关系，扩大同各国的利益交汇点，推进大国协调和合作，构建总体稳定、均衡发展的大国关系框架，按照亲诚惠容理念和与邻为善、以邻为伴周边外交方针深化同周边国家关系，秉持正确义利观和真实亲诚理念加强同发展中国家团结合作。加强同各国政党和政治组织的交流合作，推进人大、政协、军队、地方、人民团体等的对外交往。</p>
<p>中国坚持对外开放的基本国策，坚持打开国门搞建设，积极促进“一带一路”国际合作，努力实现政策沟通、设施联通、贸易畅通、资金融通、民心相通，打造国际合作新平台，增添共同发展新动力。加大对发展中国家特别是最不发达国家援助力度，促进缩小南北发展差距。中国支持多边贸易体制，促进自由贸易区建设，推动建设开放型世界经济。</p>
<p>中国秉持共商共建共享的全球治理观，倡导国际关系民主化，坚持国家不分大小、强弱、贫富一律平等，支持联合国发挥积极作用，支持扩大发展中国家在国际事务中的代表性和发言权。中国将继续发挥负责任大国作用，积极参与全球治理体系改革和建设，不断贡献中国智慧和力量。</p>
<p>同志们！世界命运握在各国人民手中，人类前途系于各国人民的抉择。中国人民愿同各国人民一道，推动人类命运共同体建设，共同创造人类的美好未来！</p>
<p>十三、坚定不移全面从严治党，不断提高党的执政能力和领导水平</p>
<p>中国特色社会主义进入新时代，我们党一定要有新气象新作为。打铁必须自身硬。党要团结带领人民进行伟大斗争、推进伟大事业、实现伟大梦想，必须毫不动摇坚持和完善党的领导，毫不动摇把党建设得更加坚强有力。</p>
<p>全面从严治党永远在路上。一个政党，一个政权，其前途命运取决于人心向背。人民群众反对什么、痛恨什么，我们就要坚决防范和纠正什么。全党要清醒认识到，我们党面临的执政环境是复杂的，影响党的先进性、弱化党的纯洁性的因素也是复杂的，党内存在的思想不纯、组织不纯、作风不纯等突出问题尚未得到根本解决。要深刻认识党面临的执政考验、改革开放考验、市场经济考验、外部环境考验的长期性和复杂性，深刻认识党面临的精神懈怠危险、能力不足危险、脱离群众危险、消极腐败危险的尖锐性和严峻性，坚持问题导向，保持战略定力，推动全面从严治党向纵深发展。</p>
<p>新时代党的建设总要求是：坚持和加强党的全面领导，坚持党要管党、全面从严治党，以加强党的长期执政能力建设、先进性和纯洁性建设为主线，以党的政治建设为统领，以坚定理想信念宗旨为根基，以调动全党积极性、主动性、创造性为着力点，全面推进党的政治建设、思想建设、组织建设、作风建设、纪律建设，把制度建设贯穿其中，深入推进反腐败斗争，不断提高党的建设质量，把党建设成为始终走在时代前列、人民衷心拥护、勇于自我革命、经得起各种风浪考验、朝气蓬勃的马克思主义执政党。</p>
<p>  (一)把党的政治建设摆在首位。旗帜鲜明讲政治是我们党作为马克思主义政党的根本要求。党的政治建设是党的根本性建设，决定党的建设方向和效果。保证全党服从中央，坚持党中央权威和集中统一领导，是党的政治建设的首要任务。全党要坚定执行党的政治路线，严格遵守政治纪律和政治规矩，在政治立场、政治方向、政治原则、政治道路上同党中央保持高度一致。要尊崇党章，严格执行新形势下党内政治生活若干准则，增强党内政治生活的政治性、时代性、原则性、战斗性，自觉抵制商品交换原则对党内生活的侵蚀，营造风清气正的良好政治生态。完善和落实民主集中制的各项制度，坚持民主基础上的集中和集中指导下的民主相结合，既充分发扬民主，又善于集中统一。弘扬忠诚老实、公道正派、实事求是、清正廉洁等价值观，坚决防止和反对个人主义、分散主义、自由主义、本位主义、好人主义，坚决防止和反对宗派主义、圈子文化、码头文化，坚决反对搞两面派、做两面人。全党同志特别是高级干部要加强党性锻炼，不断提高政治觉悟和政治能力，把对党忠诚、为党分忧、为党尽职、为民造福作为根本政治担当，永葆共产党人政治本色。</p>
<p>  (二)用新时代中国特色社会主义思想武装全党。思想建设是党的基础性建设。革命理想高于天。共产主义远大理想和中国特色社会主义共同理想，是中国共产党人的精神支柱和政治灵魂，也是保持党的团结统一的思想基础。要把坚定理想信念作为党的思想建设的首要任务，教育引导全党牢记党的宗旨，挺起共产党人的精神脊梁，解决好世界观、人生观、价值观这个“总开关”问题，自觉做共产主义远大理想和中国特色社会主义共同理想的坚定信仰者和忠实实践者。弘扬马克思主义学风，推进“两学一做”学习教育常态化制度化，以县处级以上领导干部为重点，在全党开展“不忘初心、牢记使命”主题教育，用党的创新理论武装头脑，推动全党更加自觉地为实现新时代党的历史使命不懈奋斗。</p>
<p>  (三)建设高素质专业化干部队伍。党的干部是党和国家事业的中坚力量。要坚持党管干部原则，坚持德才兼备、以德为先，坚持五湖四海、任人唯贤，坚持事业为上、公道正派，把好干部标准落到实处。坚持正确选人用人导向，匡正选人用人风气，突出政治标准，提拔重用牢固树立“四个意识”和“四个自信”、坚决维护党中央权威、全面贯彻执行党的理论和路线方针政策、忠诚干净担当的干部，选优配强各级领导班子。注重培养专业能力、专业精神，增强干部队伍适应新时代中国特色社会主义发展要求的能力。大力发现储备年轻干部，注重在基层一线和困难艰苦的地方培养锻炼年轻干部，源源不断选拔使用经过实践考验的优秀年轻干部。统筹做好培养选拔女干部、少数民族干部和党外干部工作。认真做好离退体干部工作。坚持严管和厚爱结合、激励和约束并重，完善干部考核评价机制，建立激励机制和容错纠错机制，旗帜鲜明为那些敢于担当、踏实做事、不谋私利的干部撑腰鼓劲。各级党组织要关心爱护基层干部，主动为他们排忧解难。</p>
<p>人才是实现民族振兴、赢得国际竞争主动的战略资源。要坚持党管人才原则，聚天下英才而用之，加快建设人才强国。实行更加积极、更加开放、更加有效的人才政策，以识才的慧眼、爱才的诚意、用才的胆识、容才的雅量、聚才的良方，把党内和党外、国内和国外各方面优秀人才集聚到党和人民的伟大奋斗中来，鼓励引导人才向边远贫困地区、边疆民族地区、革命老区和基层一线流动，努力形成人人渴望成才、人人努力成才、人人皆可成才、人人尽展其才的良好局面，让各类人才的创造活力竞相进发、聪明才智充分涌流。</p>
<p>  (四)加强基层组织建设。党的基层组织是确保党的路线方针政策和决策部署贯彻落实的基础。要以提升组织力为重点，突出政治功能，把企业、农村、机关、学校、科研院所、街道社区、社会组织等基层党组织建设成为宣传党的主张、贯彻党的决定、领导基层治理、团结动员群众、推动改革发展的坚强战斗堡垒。党支部要担负好直接教育党员、管理党员、监督党员和组织群众、宣传群众、凝聚群众、服务群众的职责，引导广大党员发挥先锋模范作用。坚持“三会一课”制度，推进党的基层组织设置和活动方式创新，加强基层党组织带头人队伍建设，扩大基层党组织覆盖面，着力解决一些基层党组织弱化、虚化、边缘化问题。扩大党内基层民主，推进党务公开，畅通党员参与党内事务、监督党的组织和干部、向上级党组织提出意见和建议的渠道。注重从产业工人、青年农民、高知识群体中和在非公有制经济组织、社会组织中发展党员。加强党内激励关怀帮扶。增强党员教育管理针对性和有效性，稳妥有序开展不合格党员组织处置工作。</p>
<p>  (五)持之以恒正风肃纪。我们党来自人民、植根人民、服务人民，一旦脱离群众，就会失去生命力。加强作风建设，必须紧紧围绕保持党同人民群众的血肉联系，增强群众观念和群众感情，不断厚植党执政的群众基础。凡是群众反映强烈的问题都要严肃认真对待，凡是损害群众利益的行为都要坚决纠正。坚持以上率下，巩固拓展落实中央八项规定精神成果，继续整治“四风”问题，坚决反对特权思想和特权现象。重点强化政治纪律和组织纪律，带动廉洁纪律、群众纪律、工作纪律、生活纪律严起来。坚持开展批评和自我批评，坚持惩前毖后、治病救人，运用监督执纪“四种形态”，抓早抓小、防微杜渐。赋予有干部管理权限的党组相应纪律处分权限，强化监督执纪问责。加强纪律教育，强化纪律执行，让党员、干部知敬畏、存戒惧、守底线，习惯在受监督和约束的环境中工作生活。</p>
<p>  (六)夺取反腐败斗争压倒性胜利。人民群众最痛恨腐败现象，腐败是我们党面临的最大威胁。只有以反腐败永远在路上的坚韧和执着，深化标本兼治，保证干部清正、政府清廉、政治清明，才能跳出历史周期率，确保党和国家长治久安。当前，反腐败斗争形势依然严峻复杂，巩固压倒性态势、夺取压倒性胜利的决心必须坚如磐石。要坚持无禁区、全覆盖、零容忍，坚持重遏制、强高压、长震慑，坚持受贿行贿一起查，坚决防止党内形成利益集团。在市县党委建立巡察制度，加大整治群众身边腐败问题力度。不管腐败分子逃到哪里，都要缉拿归案、绳之以法。推进反腐败国家立法，建设覆盖纪检监察系统的检举举报平台。强化不敢腐的震慑，扎牢不能腐的笼子，增强不想腐的自觉，通过不懈努力换来海晏河清、朗朗乾坤。</p>
<p>  (七)健全党和国家监督体系。增强党自我净化能力，根本靠强化党的自我监督和群众监督。要加强对权力运行的制约和监督，让人民监督权力，让权力在阳光下运行，把权力关进制度的笼子。强化自上而下的组织监督，改进自下而上的民主监督，发挥同级相互监督作用，加强对党员领导干部的日常管理监督。深化政治巡视，坚持发现问题、形成震慑不动摇，建立巡视巡察上下联动的监督网。深化国家监察体制改革，将试点工作在全国推开，组建国家、省、市、县监察委员会，同党的纪律检查机关合署办公，实现对所有行使公权力的公职人员监察全覆盖。制定国家监察法，依法赋予监察委员会职责权限和调查手段，用留置取代“两规”措施。改革审计管理体制，完善统计体制。构建党统一指挥、全面覆盖、权威高效的监督体系，把党内监督同国家机关监督、民主监督、司法监督、群众监督、舆论监督贯通起来，增强监督合力。</p>
<p>  (八)全面增强执政本领。领导十三亿多人的社会主义大国，我们党既要政治过硬，也要本领高强。要增强学习本领，在全党营造善于学习、勇于实践的浓厚氛围，建设马克思主义学习型政党，推动建设学习大国。增强政治领导本领，坚持战略思维、创新思维、辩证思维、法治思维、底线思维，科学制定和坚决执行党的路线方针政策，把党总揽全局、协调各方落到实处。增强改革创新本领，保持锐意进取的精神风貌，善于结合实际创造性推动工作，善于运用互联网技术和信息化手段开展工作。增强科学发展本领，善于贯彻新发展理念，不断开创发展新局面。增强依法执政本领，加快形成覆盖党的领导和党的建设各方面的党内法规制度体系，加强和改善对国家政权机关的领导。增强群众工作本领，创新群众工作体制机制和方式方法，推动工会、共青团、妇联等群团组织增强政治性、先进性、群众性，发挥联系群众的桥梁纽带作用，组织动员广大人民群众坚定不移跟党走。增强狠抓落实本领，坚持说实话、谋实事、出实招、求实效，把雷厉风行和久久为功有机结合起来，勇于攻坚克难，以钉钉子精神做实做细做好各项工作。增强驾驭风险本领，健全各方面风险防控机制，善于处理各种复杂矛盾，勇于战胜前进道路上的各种艰难险阻，牢牢把握工作主动权。</p>
<p>同志们！伟大的事业必须有坚强的党来领导。只要我们党把自身建设好、建设强，确保党始终同人民想在一起、干在一起，就一定能够引领承载看中国人民伟大梦想的航船破浪前进，胜利驶向光辉的彼岸！</p>
<p>同志们！中华民族是历经磨难、不屈不挠的伟大民族，中国人民是勤劳勇敢、自强不息的伟大人民，中国共产党是敢于斗争、敢于胜利的伟大政党。历史车轮滚滚向前，时代潮流浩浩荡荡。历史只会眷顾坚定者、奋进者、搏击者，而不会等待犹豫者、懈怠者、畏难者。全党一定要保持艰苦奋斗、戒骄戒躁的作风，以时不我待、只争朝夕的精神，奋力走好新时代的长征路。全党一定要自觉维护党的团结统一，保持党同人民群众的血肉联系，巩固全国各族人民大团结，加强海内外中华儿女大团结，团结一切可以团结的力量，齐心协力走向中华民族伟大复兴的光明前景。</p>
<p>青年兴则国家兴，青年强则国家强。青年一代有理想、有本领、有担当，国家就有前途，民族就有希望。中国梦是历史的、现实的，也是未来的；是我们这一代的，更是青年一代的。中华民族伟大复兴的中国梦终将在一代代青年的接力奋斗中变为现实。全党要关心和爱护青年，为他们实现人生出彩搭建舞台。广大青年要坚定理想信念，志存高远，脚踏实地，勇做时代的弄潮儿，在实现中国梦的生动实践中放飞青春梦想，在为人民利益的不懈奋斗中书写人生华章！</p>
<p>大道之行，天下为公。站立在九百六十多万平方公里的广裹土地上，吸吮着五千多年中华民族漫长奋斗积累的文化养分，拥有十三亿多中国人民聚合的磅礴之力，我们走中国特色社会主义道路，具有无比广阔的时代舞台，具有无比深厚的历史底蕴，具有无比强大的前进定力。全党全国各族人民要紧密团结在党中央周围，高举中国特色社会主义伟大旗帜，锐意进取，埋头苦干，为实现推进现代化建设、完成祖国统一、维护世界和平与促进共同发展三大历史任务，为决胜全面建成小康社会、夺取新时代中国特色社会主义伟大胜利、实现中华民族伟大复兴的中国梦、实现人民对美好生活的向往继续奋斗！</p>
<p>参考自：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/e6quFK5Ct4hDHRZ6Hv8j7g" target="_blank" rel="external">https://mp.weixin.qq.com/s/e6quFK5Ct4hDHRZ6Hv8j7g</a> 根据开幕式现场视频做出了增加。并将最后的图片识别为文字。</li>
<li><a href="http://tv.cctv.com/live/cctv13/" target="_blank" rel="external">http://tv.cctv.com/live/cctv13/</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 十九大 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[梯度下降及其优化算法]]></title>
      <url>/2017/10/17/DL_gradient_descent/</url>
      <content type="html"><![CDATA[<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>梯度下降是一个最优化算法，通俗的来讲也就是沿着梯度下降的方向来求出一个函数的极小值。</p>
<p>那么我们在高等数学中学过，对于一些我们了解的函数方程，我们可以对其求一阶导和二阶导，比如说二次函数。可是我们在处理问题的时候遇到的并不都是我们熟悉的函数，并且既然是机器学习就应该让机器自己去学习如何对其进行求解，显然我们需要换一个思路。因此我们采用梯度下降，不断迭代，沿着梯度下降的方向来移动，求出极小值。</p>
<h3 id="批量梯度下降（Batch-gradient-descent）"><a href="#批量梯度下降（Batch-gradient-descent）" class="headerlink" title="批量梯度下降（Batch gradient descent）"></a>批量梯度下降（Batch gradient descent）</h3><p>现在我们就要求出<code>J(θ)</code>取到极小值时的θT向量。之前已经说过了，沿着函数梯度的方向下降就能最快的找到极小值。</p>
<p>$$\theta=\theta-\eta \nabla_\theta{J(\theta)}$$</p>
<ul>
<li><p>计算<code>J(θ)</code>关于θT的<strong>偏导数</strong>,也就得到了向量中每一个θ的梯度。</p>
</li>
<li><p>沿着梯度的方向更新参数θ的值</p>
</li>
<li><p>迭代直到收敛。</p>
</li>
</ul>
<p>批量梯度下降算法使用整个训练集计算目标函数的梯度并更新参数。代码如下：</p>
<pre><code>for i in range(nb_epochs):
    params_grad = evaluate_gradient(loss_function, data, params)
    params = params - learning_rate * params_grad
</code></pre><p>可以看到，批量梯度下降是用了训练集中的所有样本。因此在数据量很大的时候，每次迭代都要遍历训练集一遍，<strong>开销</strong>会很大，所以在数据量大的时候，可以采用随机梯度下降法。</p>
<h3 id="随机梯度下降（Stochastic-gradient-descent）"><a href="#随机梯度下降（Stochastic-gradient-descent）" class="headerlink" title="随机梯度下降（Stochastic gradient descent）"></a>随机梯度下降（Stochastic gradient descent）</h3><p>和批量梯度有所不同的地方在于，每次迭代只选取一个样本的数据，一旦到达最大的迭代次数或是满足预期的精度，就停止。</p>
<p>可以得出随机梯度下降法的θ更新表达式。</p>
<p>$$\theta=\theta-\eta\nabla_\theta{J(\theta;x^{(i)},y^{(i)})}$$</p>
<p>因为每次只计算<strong>一个样本</strong>，所以<code>SGD</code>计算非常快并且适合线上更新模型。但是，频繁地更新参数也使得<strong>目标函数抖动</strong>非常厉害。</p>
<p><code>SGD</code>频繁地参数更新可以使算法跳出局部最优点，更可能寻找到接近全局最优的解。<br><code>SGD</code>代码如下：</p>
<pre><code>for i in range(nb_epochs):
  np.random.shuffle(data)
  for example in data:
    params_grad = evaluate_gradient(loss_function, example, params)
    patams = params - learning_rate * params_grad
</code></pre><p>注意，上面的代码在每个epoch都对训练数据进行了打乱操作，这样可以保证不同epoch学习到的特征和训练样本的出现顺序没有关系。</p>
<h2 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h2><p>如果仅从测试误差出发，标准梯度下降的效果会比随机梯度下降要好。但是标准梯度下降的训练时间会比随机梯度下降要长。</p>
<p>像线性回归这种简单的模型，训练时间的优先级不高，所以用标准梯度下降会比随机梯度下降要好。像神经网络这种复杂的模型，训练时间的优先级比较高，所以用随机梯度下降比较好。</p>
<p>如果模型的损失函数是<strong>凸函数</strong>，那么使用标准梯度下降一定能达到全局最优。如果<strong>模型比较复杂</strong>，容易进入局部最优，那么使用随机梯度下降会发生震荡，容易从局部最优中跳出，进入全局最优。</p>
<p>另外，神经网络模型使用标准梯度下降最重要的原因是神经网络容易过拟合，而不是训练时间。</p>
<h2 id="小批量梯度下降-mini-batch-gradient-descent"><a href="#小批量梯度下降-mini-batch-gradient-descent" class="headerlink" title="小批量梯度下降(mini-batch gradient descent)"></a>小批量梯度下降(mini-batch gradient descent)</h2><p>小批量梯度下降结合了批量梯度下降和随机梯度下降的优点，它一次以小批量的训练数据计算目标函数的权重并更新参数。公式如下：</p>
<p>$$\theta=\theta-\eta\nabla_\theta{J(\theta;x^{(i:i+n)};y^{(i:i+n)})}$$</p>
<p>其中，n为每批训练集的数量，一般设为50到256。 </p>
<pre><code>for i in range(nb_epochs):
  np.random.shuffle(data)
  for batch in get_batches(data, batch_size=50):
    params_grad = evaluate_gradient(loss_function, batch, params)
    params = params - learning_rate * params_grad
</code></pre><p>这个算法有下面几个方面的优点： </p>
<ol>
<li><p>相比较SGD增加了一次更新使用的训练数据量，使得目标函数收敛得更加平稳； </p>
</li>
<li><p>可以使用矩阵操作对每批数据进行计算，大大提升了算法的效率。</p>
</li>
</ol>
<h2 id="梯度下降的优缺点"><a href="#梯度下降的优缺点" class="headerlink" title="梯度下降的优缺点"></a>梯度下降的优缺点</h2><p><code>mini-batch gradient descent</code>虽然相较于批量梯度下降和随机梯度下降方法效果有所改善但是任然存在许多挑战： </p>
<ol>
<li>难以选择合适的学习速率：如果学习速率选择过小会造成网络收敛太慢，但是设得太大可能使得损失函数在最小点周围不断摇摆而永远达不到最小点； </li>
<li>可以在训练开始时设置一个较大地学习率然后每训练若干个周期后按比例降低学习率，虽然这个方法有一些作用，但是由于降低学习率的周期是人为事先设定的，所以它不能很好地适应数据内在的规律； </li>
<li>另一方面，我们对特征向量中的所有的特征都采用了相同的学习率，如果训练数据十分稀疏并且不同特征的变化频率差别很大，这时候对变化频率慢得特征采用大的学习率而对变化频率快的特征采用小的学习率是更好的选择。 </li>
<li>这些梯度下降方法难以逃脱”鞍点”, 如下图所示，鞍点既不是最大点也不是最小点，在这个点附近，所有方向上的梯度都接近于0，这些梯度下降算法很难逃离它。</li>
</ol>
<p><img src="/2017/10/17/DL_gradient_descent/Saddle.png" alt=""></p>
<h2 id="梯度下降算法的改进"><a href="#梯度下降算法的改进" class="headerlink" title="梯度下降算法的改进"></a>梯度下降算法的改进</h2><h3 id="冲量-Momentum"><a href="#冲量-Momentum" class="headerlink" title="冲量(Momentum)"></a>冲量(Momentum)</h3><p>实际中，我们遇到的目标函数往往在不同的维度上梯度相差很大，比如在下面的函数等高线图中可以看出函数在纵向上要比横向陡峭得多。</p>
<p><img src="/2017/10/17/DL_gradient_descent/SGD_momen.jpg" alt=""></p>
<p>然而`SGD等基本梯度下降算法并不知道这些，因为y方向梯度大x方向梯度小所以它们会在y方向上不断摇摆而沿x方向缓慢移动，但是我们知道在y方向的震荡是无用的只有x方向的才在不断接近最优点。</p>
<p>冲量方法在<code>SGD</code>的基础上，加上了上一步的梯度：</p>
<p><img src="/2017/10/17/DL_gradient_descent/equa_1.png" alt=""></p>
<p>其中γ通常设为0.9。</p>
<p>由于目标函数在y方向上摇摆，所以前后两次计算的梯度在y方向上相反，所以相加后相互抵消，而x方向上梯度方向不变，所以x方向的梯度是累加的，其效果就是损失函数在y方向上的震荡减小了，而更加迅速地从x方向接近最优点。</p>
<p>也可以把这个过程和在斜坡放一个球让其滚下类比：当从斜坡顶端释放一个小球时，由于重力的作用小球滚下的速度会越来越快；与此类似，冲量的作用会使相同方向的梯度不断累加，不同方向的梯度相互抵消，其效果就是逼近最优点的速度不断加快。</p>
<h3 id="Nesterov-accelerated-gradient"><a href="#Nesterov-accelerated-gradient" class="headerlink" title="Nesterov accelerated gradient"></a>Nesterov accelerated gradient</h3><p>想象小球从山坡上滑落，它的速度沿着山坡不断加快，然而这并不是令我们满意的结果，当小球接近山谷(最优点)时，它已经有了很大的速度，很可能会再次冲向山谷的另一边，而错过了最优点。我们需要一颗更加“聪明”的小球，它能够感知坡度的变化，从而在它再次冲上山坡之前减速而避免错过山谷。</p>
<p>Nesterov accelerated gradient(NAG)就是一种让小球变“聪明”的方法。NAG不但增加了动量项，并且计算参数的梯度时，在损失函数中减去了梯度项将其作为下一次参数所在位置的预估：</p>
<p><img src="/2017/10/17/DL_gradient_descent/equ_NAG.png" alt=""></p>
<p>同样，上式中的<code>γ</code> 一般设为0.9。 </p>
<p>如下图所示，蓝色的是动量方法的更新路径，首先计算一次梯度更新一小步，然后在下一次累加上一次计算的梯度从而更新一大步。而NAG算法每一步更新过程由两个步骤组成：第一步($\gamma v_{t−1}$, 图中棕色)使用之前计算的梯度移动一大步，第二步在移动后的位置计算的梯度方向移动一小步(图中红色线)进行修正，经过这样的两步合成了最终的绿线部分。</p>
<p><img src="/2017/10/17/DL_gradient_descent/NAG.png" alt=""></p>
<p>分析上面的原理可知，当“小球”将要冲上山坡的另一面时，红色线表示的预测梯度方向发生改变，从而将棕色向量往回拉达到了“减速”的效果。</p>
<p>通过NAG方法，我们使参数更新速率能够自适应“坡度”的变化，另一方面，我们希望每个单独的参数能够自适应各自的变化频率，比如，稀疏特征采用高的更新速率，其他特征采用相对较低的更新速率。下面介绍几种常用的方法。</p>
<p>详细介绍可以参见<code>Ilya Sutskever</code>的<code>PhD</code>论文<br><code>Sutskever, I. (2013). Training Recurrent neural Networks. PhD Thesis.</code></p>
<p><img src="/2017/10/17/DL_gradient_descent/opt1_mom.png" alt="梯度优化之Momentum"></p>
<p><img src="/2017/10/17/DL_gradient_descent/opt2_NAG.png" alt="梯度优化之NAG"></p>
<h3 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h3><h3 id="Adadelta"><a href="#Adadelta" class="headerlink" title="Adadelta"></a>Adadelta</h3><h3 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h3><h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p><code>Adam</code>的全称是<code>Adaptive Moment Estimation</code>, 它也是一种自适应学习率方法，与Adadelta和RMSprop类似，它将每个参数的历史梯度平方均值存于$v_t$中，不同的是，<code>Adam</code>还使用了类似冲量的衰减项$m_t$:</p>
<p><img src="/2017/10/17/DL_gradient_descent/adam.png" alt=""></p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>图a中，所有方法都从相同位置出发，经历不同的路径到达了最小点，其中<code>Adagrad</code>、<code>Adadelta</code>和<code>RMSprop</code>一开始就朝向正确的方向并且迅速收敛，而冲量、<code>NAG</code>则会冲向错误的方向，但是由于<code>NAG</code>会向前多“看”一步所以能很快找到正确的方向。</p>
<p><img src="/2017/10/17/DL_gradient_descent/gif_1.gif" alt=""></p>
<p>图b显示了这些方法逃离鞍点的能力，鞍点有部分方向有正梯度另一些方向有负梯度，<code>SGD</code>方法逃离能力最差，冲量和<code>NAG</code>方法也不尽如人意，而<code>Adagrad</code>、<code>RMSprop</code>、<code>Adadelta</code>很快就能从鞍点逃离出来。</p>
<p><img src="/2017/10/17/DL_gradient_descent/gif_2.gif" alt=""></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.cnblogs.com/Sinte-Beuve/p/6164689.html" target="_blank" rel="external">http://www.cnblogs.com/Sinte-Beuve/p/6164689.html</a></li>
<li><a href="http://blog.csdn.net/ortyijing/article/details/54984058" target="_blank" rel="external">http://blog.csdn.net/ortyijing/article/details/54984058</a></li>
<li><a href="http://blog.csdn.net/bupt_wx/article/details/52761751" target="_blank" rel="external">http://blog.csdn.net/bupt_wx/article/details/52761751</a></li>
<li><a href="http://blog.csdn.net/heyongluoyao8/article/details/52478715" target="_blank" rel="external">http://blog.csdn.net/heyongluoyao8/article/details/52478715</a></li>
<li><a href="http://cs231n.github.io/neural-networks-3/" target="_blank" rel="external">http://cs231n.github.io/neural-networks-3/</a></li>
<li><a href="http://www.360doc.com/content/16/1010/08/36492363_597225745.shtml" target="_blank" rel="external">http://www.360doc.com/content/16/1010/08/36492363_597225745.shtml</a><br>其中，第四个文章写得不错。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> gradient descent </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BAT批处理中的字符串处理(字符串截取等)]]></title>
      <url>/2017/10/10/batch_string_process/</url>
      <content type="html"><![CDATA[<h1 id="1、截取字符串"><a href="#1、截取字符串" class="headerlink" title="1、截取字符串"></a>1、截取字符串</h1><p>截取字符串可以说是字符串处理功能中最常用的一个子功能了，能够实现截取字符串中的特定位置的一个或多个字符。举例说明其基本功能：</p>
<pre><code>@echo off
set ifo=abcdefghijklmnopqrstuvwxyz0123456789
echo 原字符串（第二行为各字符的序号）：
echo %ifo%
echo 123456789012345678901234567890123456
echo 截取前5个字符：
echo %ifo:~0,5%
echo 截取最后5个字符：
echo %ifo:~-5%
echo 截取第一个到倒数第6个字符：
echo %ifo:~0,-5%
echo 从第4个字符开始，截取5个字符：
echo %ifo:~3,5%
echo 从倒数第14个字符开始，截取5个字符：
echo %ifo:~-14,5%
pause
</code></pre><p>当然，上面的例子只是将字符串处理的基本功能展示出来了，还看不出字符串处理具体有什么用处。下面这个例子是对时间进行处理。</p>
<pre><code>@echo off
echo 当前时间是：%time% 即 %time:~0,2%点%time:~3,2%分%time:~6,2%秒%time:~9,2%厘秒
pause
</code></pre><h1 id="2、替换字符串"><a href="#2、替换字符串" class="headerlink" title="2、替换字符串"></a>2、替换字符串</h1><p>替换字符串，即将某一字符串中的特定字符或字符串替换为给定的字符串。举例说明其功能：</p>
<pre><code>@echo off
set aa=伟大的中国！我为你自豪！
echo 替换前：%aa%
echo 替换后：%aa:中国=中华人民共和国%
echo aa = %aa%
set &quot;aa=%aa:中国=中华人民共和国%&quot;
echo aa = %aa%
pause
</code></pre><p>对于上面的例子有一点说明，对比两个echo aa = %aa%可以发现，如果要修改变量aa的内容的话，就需要将修改结果“%aa:中国=中华人民共和国%”赋值给变量aa。上面的字符串截取也有着同样的特点。</p>
<h1 id="3、字符串合并"><a href="#3、字符串合并" class="headerlink" title="3、字符串合并"></a>3、字符串合并</h1><p>其实，合并字符串就是将两个字符串放在一起就可以了。举例说明：</p>
<pre><code>@echo off
set aa=伟大的中国！
set bb=我为你自豪！
echo %aa%%bb%
echo aa=%aa%
echo bb=%bb%
set &quot;aa=%aa%%bb%&quot;
echo aa=%aa%
pause
</code></pre><p>同样，如果要改变变量aa的内容的话，就需要将合并结果“%aa%%bb%”赋值给变量aa。</p>
<h1 id="4、扩充字符串"><a href="#4、扩充字符串" class="headerlink" title="4、扩充字符串"></a>4、扩充字符串</h1><p>　“扩充”这个词汇来自于微软自己的翻译，意思就是对表示文件路径的字符串进行特殊的处理，具体功能罗列如下：</p>
<pre><code>=========================================
~I - 删除任何引号(&quot;)，扩充 %I
%~fI - 将 %I 扩充到一个完全合格的路径名
%~dI - 仅将 %I 扩充到一个驱动器号
%~pI - 仅将 %I 扩充到一个路径
%~nI - 仅将 %I 扩充到一个文件名
%~xI - 仅将 %I 扩充到一个文件扩展名
%~sI - 扩充的路径只含有短名
%~aI - 将 %I 扩充到文件的文件属性
%~tI - 将 %I 扩充到文件的日期/时间
%~zI - 将 %I 扩充到文件的大小
%~$PATH:I - 查找列在路径环境变量的目录，并将 %I 扩充到找到的第一个完全合格的名称。如果环境变量名未被定义，或者没有找到文件，此组合键会扩充到空字符串可以组合修饰符来得到多重结果:
%~dpI - 仅将 %I 扩充到一个驱动器号和路径
%~nxI - 仅将 %I 扩充到一个文件名和扩展名
%~fsI - 仅将 %I 扩充到一个带有短名的完整路径名
%~dp$PATH:i - 查找列在路径环境变量的目录，并将 %I 扩充到找到的第一个驱动器号和路径。
%~ftzaI - 将 %I 扩充到类似输出线路的 DIR
=========================================
</code></pre><p>以上内容引用于for /?帮助信息。其中的I代表变量I，不过需要说明的是，不是所有的变量都能够进行扩充的，有两个条件：1、该字符串代表一个文件路径；2、变量要用%x来表示，x可取a-z A-Z 0-9共62个字符中的任意一个。举例说明：</p>
<pre><code>@echo off
echo 正在运行的这个批处理：
echo 完全路径：%0
echo 去掉引号：%~0
echo 所在分区：%~d0
echo 所处路径：%~p0
echo 文件名：%~n0
echo 扩展名：%~x0
echo 文件属性：%~a0
echo 修改时间：%~t0
echo 文件大小：%~z0
pause
</code></pre><p>其中的%0是批处理里面的参数，代表当前运行的批处理的完全路径。类似的还有%1-%9，分别代表传递来的第1-9个参数。例子如下：</p>
<pre><code>@echo off
set aa=C:\Windows\PPP\a.btx
call :deal aaa %aa% &quot;c c&quot; ddd eee
pause&gt;nul
exit
:deal
echo %%0 = %0
echo %%1 = %1
echo %%2 = %2
echo %%3 = %3
echo %%4 = %4
echo %%5 = %5
</code></pre><p>其中，变量aa在之前是不可以扩充的，通过call命令并将aa作为参数传递给子函数:deal，将aa变量转换成了变量%1，即符合%x格式，从而可以进行字符串扩充。</p>
<p>至于%x中x取a-z A-Z的形式，可以复习一下for语句，for语句里面的变量就是用%x来表示的，因而可以直接进行扩充。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="C语中的strcpy函数"><a href="#C语中的strcpy函数" class="headerlink" title="C语中的strcpy函数"></a>C语中的strcpy函数</h2><p>C语中的strcpy函数，将一个字符串复制到另一个字符型指针或字符数组，覆盖原来的字符串。</p>
<p>C语言中的调用方法：strcpy(目标字符串,源字符串)</p>
<p>在批处理中的实现方法：</p>
<p>set 目标字符串=%源字符串%</p>
<p>示例：</p>
<pre><code>@echo off
::关闭屏幕回显（可选）
set str1=This is old string
::设置str1中存储的字符串，注意没有双引号，这点与C语言等不同！
set str2=This is new string
::设置str2中存储的字符串
echo 执行字符串拷贝以前：
echo str1=%str1%
echo str2=%str2%
::先输出一次原有的字符串
set str1=%str2%
::字符串拷贝
echo 执行字符串拷贝以后：
echo str1=%str1%
echo str2=%str2%
::输出执行完字符串拷贝后的字符串
echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit
::输出信息，当用户按任意键时，结束该批处理。
</code></pre><h2 id="2-C语中的strcat函数"><a href="#2-C语中的strcat函数" class="headerlink" title="2.C语中的strcat函数"></a>2.C语中的strcat函数</h2><p>C语中的strcat函数，将一个字符串连接到另一个字符型指针或字符数组的末尾。</p>
<p>C语言中的调用方法：strcat(目标字符串,源字符串)</p>
<p>在批处理中的实现方法：</p>
<p>set 目标字符串=%目标字符串%%源字符串%</p>
<p>示例：</p>
<pre><code>@echo off
set str1=This is string1
set str2=This is string2
::设置str1和str2中存储的字符串
echo 连接字符串以前：
echo str1=%str1%
echo str2=%str2%
::先输出一次原有的字符串
set str1=%str1%%str2%
::字符串连接
echo 连接字符串以后：
echo str1=%str1%
echo str2=%str2%
::输出执行完字符串连接后的两个字符串
echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit
</code></pre><h2 id="3、字符串截取"><a href="#3、字符串截取" class="headerlink" title="3、字符串截取"></a>3、字符串截取</h2><p>C中没有这种函数，不过可以通过语句实现，不再介绍，直接说批处理的。</p>
<pre><code>set 目标字符串=%源字符串:~起始值,截取长度%
</code></pre><p>注意，起始值从0开始！</p>
<p>截取长度是可选的，如果省略逗号和截取长度，将会从起始值一直截取到字符串的结尾。</p>
<p>示例：</p>
<pre><code>@echo off
set str1=This is string1
::设置str1中存储的字符串
set str2=%str1:~8,6%
set str3=%str1:~0,4%
set str4=%str1:~5%
::字符串截取
echo 原字符串：
echo str1=%str1%
echo 截取得到的字符串：
echo str2=%str2%
echo str3=%str3%
echo str4=%str4%
::输出执行结果
echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit
</code></pre><h2 id="4、C语中的strlen函数，取得字符串的长度。"><a href="#4、C语中的strlen函数，取得字符串的长度。" class="headerlink" title="4、C语中的strlen函数，取得字符串的长度。"></a>4、C语中的strlen函数，取得字符串的长度。</h2><p>C语言中的调用方法：strlen(字符串)</p>
<p>在批处理中的实现方法是利用goto和标签，形成循环结构，不断将字符串截短1字符，并用变量记录截短的次数，直到字符串变成空串。</p>
<p>示例：</p>
<pre><code>@echo off
set str1=This is a test string
set str2=Hello World
::设置两个字符串
set str=%str1%
::将str1复制到str
:next1
::标签，用于goto跳转
::注意与注释语句的区别，注释用两个冒号开头，标签则为一个冒号
if not &quot;%str%&quot;==&quot;&quot; (
::判断str是不是空串，如果不是则执行下边的语句
set /a num+=1
::算术运算，使num的值自增1，相当于num++或者++num语句
set &quot;str=%str:~1%&quot;
::截取字符串，赋给自身
goto next1
::跳转到next1标签
::这里利用goto和标签，构成循环结构
)
::当以上循环结构执行完毕时，会执行下边的语句
echo str1=%str1%
echo str1的长度为：%num%
::输出结果
set num=0
::将记和用的环境变量num置0，以便开始下一次运算。
set str=%str2%
::将str2复制到str
:next2
::定义一个新的标签
::注意不能与已有的标签同名，否则会出错！
if not &quot;%str%&quot;==&quot;&quot; (
set /a num+=1
set &quot;str=%str:~1%&quot;
goto next2
)
::和上一个循环相似，不再介绍
echo str2=%str2%
echo str2的长度为：%num%
::输出结果
echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit
</code></pre><p>5、C语中的strchr函数，在一个字符串中查找一个字符的首次出现位置，找到时返回所在位置，找不到时返回0值。</p>
<p>批处理中的思路：不断截短字符串，并取截短后字符串中的首字符，和要求的字符比较，如果相同就利用goto语句跳出循环，输出结果，如果没有相同的字符，执行到最后就输出0值。</p>
<p>示例：</p>
<pre><code>@echo off
Setlocal ENABLEDELAYEDEXPANSION
::启用命令扩展，参加setlocal /?命令
set str1=This is a test string
set ch1=t
::注意，这里是区分大小写的！
set str=%str1%
::复制字符串，用来截短，而不影响源字符串
:next
if not &quot;%str%&quot;==&quot;&quot; (
set /a num+=1
if &quot;!str:~0,1!&quot;==&quot;%ch1%&quot; goto last
::比较首字符是否为要求的字符，如果是则跳出循环
set &quot;str=%str:~1%&quot;
goto next
)
set /a num=0
::没有找到字符时，将num置零
:last
echo 字符&apos;%ch1%&apos;在字符串&quot;%str1%&quot;中的首次出现位置为%num%
echo 输出完毕，按任意键退出&amp;&amp;pause&gt;nul&amp;&amp;exit
</code></pre><p><a href="http://www.jb51.net/article/52744.htm" target="_blank" rel="external">http://www.jb51.net/article/52744.htm</a></p>
]]></content>
      
        <categories>
            
            <category> 批处理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 批处理 </tag>
            
            <tag> bat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习第五章：机器学习基础]]></title>
      <url>/2017/10/08/DL_chap_5/</url>
      <content type="html"><![CDATA[<h2 id="5-8-无监督学习"><a href="#5-8-无监督学习" class="headerlink" title="5.8 无监督学习"></a>5.8 无监督学习</h2><p>从不需要人为注释的样本中抽取信息。</p>
<p>通常与密度估计有关。 学习从分布中采样，学习从分布中去噪，寻找数据分布的流形 或是 将数据中相关的样本聚类。</p>
<p>一个经典的无监督学习任务：找到数据的“最佳”表示。</p>
<p>较简单表示主要有三种：<strong>低维表示</strong>、<strong>稀疏表示</strong>和<strong>独立表示</strong>。</p>
<p><strong>表示</strong>的概念是<font color="#0000FF">深度学习的核心主题</font>之一，也是本书的核心主题之一。</p>
<h3 id="5-8-1-主成分分析"><a href="#5-8-1-主成分分析" class="headerlink" title="5.8.1 主成分分析"></a>5.8.1 主成分分析</h3><p>通过线性变换W将数据从x投影到z时，得到的数据表示的协方差矩阵为<strong>对角</strong>的。即：z中的元素是<strong>彼此无关</strong>的。</p>
<h3 id="5-8-2-k-均值聚类"><a href="#5-8-2-k-均值聚类" class="headerlink" title="5.8.2 k-均值聚类"></a>5.8.2 k-均值聚类</h3><p>k均值聚类的算法提供了k维的<strong>one-hot编码向量h</strong>以表示输入x。当x属于聚类i时，有$h_i=1$，h的其他项为零。</p>
<p><strong>one-hot编码</strong>是稀疏表示的极端示例，丢失了很多分布式表示的优点。</p>
<p>k-均值聚类初始化k个不同的中心点$\mu^{(1)},\cdots ,\mu^{(k)}$，然后迭代交换两个不同的步骤直到收敛。</p>
<p>步骤一，每个训练样本分配到最近的中心点$\mu^{(i)}$所代表的聚类$i\ $。<br>步骤二，每个中心点更新为聚类$i\ $中所有训练样本$x^{(i)}$的均值。</p>
<p>聚类问题的本身是病态的。没有单一的标准去度量聚类的数据在真实世界中效果如何。</p>
<p>因此，我们可能更偏好于<strong>分布式表示</strong>。分布式表示可以对每个车辆赋予两个属性——一个表示它的颜色，一个表示它是汽车还是卡车。</p>
<h2 id="5-9-随机梯度下降"><a href="#5-9-随机梯度下降" class="headerlink" title="5.9 随机梯度下降"></a>5.9 随机梯度下降</h2><p>随机梯度下降：stochastic gradient descent,SGD。</p>
<p>机器学习中的代价函数通常可以分解为每个样本的代价函数的总和。</p>
<p><em>训练数据的负条件对数似然</em> $\;$可以写为：</p>
<p>$$J(\theta) = E_{x,\; y \sim \hat P_{data}}L(x,y,\theta ) = \frac 1m \sum_{i=1}^m  L(x^{(i)},y^{(i)},\theta )  $$</p>
<p>其中，L是每个样本的损失函数。</p>
<p>随机梯度下降的<strong>核心</strong>是，梯度是期望。<font color="#0000FF">期望可使用小规模的样本近似估计</font>。</p>
<h2 id="5-10-构建机器学习算法"><a href="#5-10-构建机器学习算法" class="headerlink" title="5.10 构建机器学习算法"></a>5.10 构建机器学习算法</h2><p>组合模型、代价和优化算法 来构建机器学习算法的配方。适用于监督学习以及非监督学习。</p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度学习第六章：前馈神经网络]]></title>
      <url>/2017/10/08/DL_chap_6/</url>
      <content type="html"><![CDATA[<h2 id="6-1-实例：学习XOR"><a href="#6-1-实例：学习XOR" class="headerlink" title="6.1 实例：学习XOR"></a>6.1 实例：学习XOR</h2><p>采用一个简单的前馈神经网络，一个隐含层，隐含层包含两个单元。</p>
<p>整个网络为：</p>
<p>$$f(x;W,c,w,b) = w^T\text{max}(0,W^Tx+c)+b$$</p>
<p>隐含层激活函数采用的是<code>ReLU</code>。</p>
<p>给出一个解：<br>$$W=<br>  \begin{bmatrix}<br>  1 &amp; 1  \\<br>  1 &amp; 1  \\<br>  \end{bmatrix}<br>$$<br>$$c=<br>  \begin{bmatrix}<br>  0   \\<br>  -1   \\<br>  \end{bmatrix}<br>$$<br>$$w=<br>  \begin{bmatrix}<br>  1   \\<br>  -2   \\<br>  \end{bmatrix}<br>$$<br>以及：$$ b = 0 $$</p>
<h2 id="6-2-基于梯度的学习"><a href="#6-2-基于梯度的学习" class="headerlink" title="6.2 基于梯度的学习"></a>6.2 基于梯度的学习</h2><p>对于前馈神经网络，将所有权重初始化为小的值是很重要的。偏置可以初始化为0或者小的正值(如0.1)。</p>
<p>第8章介绍迭代的基于梯度的优化算法，<em>8.4节</em>为参数初始化，<br><em>4.3节</em>介绍了一些特别的算法，是对梯度下降思想的改进和提纯。<br>随机梯度下降将算法的改进在<em>5.9节</em>。</p>
<h3 id="6-2-1-代价函数"><a href="#6-2-1-代价函数" class="headerlink" title="6.2.1 代价函数"></a>6.2.1 代价函数</h3><p>大多数情况下，参数模型定义了一个分布$p(y|x;\theta)$，并且简单地使用<strong>最大似然</strong>原理。<br>使用训练数据和模型预测间的交叉熵作为代价函数。</p>
<pre><code>完整的代价函数 = 基本代价函数 + 正则项。
</code></pre><p>最流行的正则化策略：<strong>权重衰减</strong>（weight decay）。</p>
<p><em>第7章</em>介绍更高级的正则化策略。</p>
<h4 id="6-2-1-1-使用最大似然学习条件分布"><a href="#6-2-1-1-使用最大似然学习条件分布" class="headerlink" title="6.2.1.1 使用最大似然学习条件分布"></a>6.2.1.1 使用最大似然学习条件分布</h4><p>使用最大似然训练意味着代价函数就是负的对数似然。</p>
<p><strong>负的对数似然 = 训练数据和模型分布间的交叉熵</strong> 。</p>
<p>代价函数为：</p>
<p>$$J(\theta) = E_{x,\; y \sim \hat P_{data}} logP_{model}(y|x)  $$</p>
<p>代价函数的具体形式取决于模型$logP_{model}$的具体形式。展开后的代价函数，可以舍去其中不依赖于模型的参数。</p>
<p>如果有：$$P_{model}(y|x)  = N(y;f(x;\theta),I) $$</p>
<p>就可以得到均方误差代价：</p>
<p>$$J(\theta) = \frac{1}{2} E_{x,\; y \sim \hat P_{data}} || y-f(x;\theta )||^2 +\text{const}  $$</p>
<p>代价函数的梯度必须足够大和具有足够的预测性，来为学习算法提供一个好的指引。</p>
<p><strong>饱和</strong>（变得非常平）的函数破坏了这一目标，梯度非常小。该情况很常见是因为隐藏单元或输出单元的激活函数会饱和。</p>
<h4 id="6-2-1-2-学习条件统计量"><a href="#6-2-1-2-学习条件统计量" class="headerlink" title="6.2.1.2 学习条件统计量"></a>6.2.1.2 学习条件统计量</h4><p>预测器$f(x;\theta)$，预测y的均值。</p>
<p>代价泛函(可以表示一大类函数中的任何一个函数，仅仅被一些特征所限制，而不是具有特殊的参数形式)。 <font color="#FF0000">泛函是指函数到实数的映射</font>。</p>
<p>对函数求解问题需要用到<strong>变分法</strong>(19.4.2节)。</p>
<p>变分法导出的第一个结果是解优化问题：<br>$$f^* =\underset{f}{\mathrm{argmin}} E_{x,\; y \sim  P_{data}}|| y-f(x)||^2$$</p>
<p>得到：<br>$$f^*(x) = E_{ y \sim  P_{data}(y|x)}[y]$$</p>
<p>最小化均方误差代价函数将得到一个函数，可以用来对每个x的值预测出y的<strong>均值</strong>。</p>
<p>第二个使用变分法得到的结果是：</p>
<p>$$f^* =  \underset{f}{\mathrm{argmin}} E_{x,\; y \sim  P_{data}}|| y-f(x)||_1$$</p>
<p>将得到一个函数可以对每个x预测y取值的<strong>中位数</strong>，只要这个函数在我们要优化的函数族里。这个函数通常被称为<strong>平均绝对误差</strong>(mean absolute error)。最小化平均绝对误差代价函数。</p>
<p><font color="#FF0000">交叉熵代价函数</font> 比均方误差或者平均绝对误差更受欢迎的原因也在此，饱和的输出单元当结合后两个代价函数时会产生非常小的梯度。</p>
<h3 id="6-2-2-输出单元"><a href="#6-2-2-输出单元" class="headerlink" title="6.2.2 输出单元"></a>6.2.2 输出单元</h3><p>代价函数的选择：大多数情况下，简单使用数据分布和模型分布间的<font color="#FF0000">交叉熵</font>。</p>
<p>本节中，假设前馈网络提供了一组定义为$h=f(x;\theta )$的<strong>隐藏特征</strong>。输出层的作用则是随后对这些特征进行额外的变换完成整个网络必须完成的任务。</p>
<h4 id="6-2-2-1-用于Bernoulli输出分布的sigmoid单元"><a href="#6-2-2-1-用于Bernoulli输出分布的sigmoid单元" class="headerlink" title="6.2.2.1 用于Bernoulli输出分布的sigmoid单元"></a>6.2.2.1 用于Bernoulli输出分布的sigmoid单元</h4><p>两个类的分类问题，即预测二值型变量y。</p>
<p>最大似然定义$y\ $在$x\ $条件下的<code>Bernoulli</code>分布。</p>
<h4 id="6-2-2-2-用于Multinoulli输出分布的softmax单元"><a href="#6-2-2-2-用于Multinoulli输出分布的softmax单元" class="headerlink" title="6.2.2.2 用于Multinoulli输出分布的softmax单元"></a>6.2.2.2 用于Multinoulli输出分布的softmax单元</h4><p>任何时候，当我们想要表示一个具有<strong>n个可能取值的离散型随机变量的分布</strong>时，都可以使用<strong>softmax</strong>函数。</p>
<p><code>softmax</code>函数最常用作分类器的输出，来表示$n\ $个不同类上的概率分布。</p>
<p>首先，线性层预测了未归一化的对数概率：<br>$$ z = W^Th+b$$<br>其中，$z_i = log \hat P (y=i|x)$，<code>softmax</code>函数然后对$z\ $<strong>指数化</strong>和<strong>归一化</strong>来获得需要的$\hat y$。最终，<code>softmax</code>函数的形式为：<br>$$ \text{softmax}(z)_i = \frac{\text{exp}(z_i)}{\sum_j \text{exp}(z_j)}$$</p>
<p>当使用最大化对数似然训练<code>softmax</code>来输出目标值$y\ $时，这时，我们想要最大化$logP(y=i;z)=\log \text{softmax}(z)_i$。将<code>softmax</code>定义为指数的形式是因为对数似然中的<code>log</code>可以抵消<code>softmax中</code>的<code>exp</code>：</p>
<p>$$\log \text{softmax(z)}_i = z_i -\log \sum_j \text{exp}(z_j)$$</p>
<p>关于<code>softmax</code>的解释：这个函数更接近<code>argmax</code>函数而不是max函数。“soft”术语来源于<code>softmax</code>函数是连续可微的。“argmax”函数的结果表示为一个<strong>one-hot向量</strong>（<em>只有一个元素为1，其余元素都为0的向量</em>），不是连续可微的。<code>softmax</code>函数因此提供了argmax的“软化”版本，max函数相应的软化版本是$\text{softmax}(z)^Tz$。可能最好是把softmax函数称为“<code>softargmax</code>”，但当前名字已经是一个根深蒂固的习惯了。</p>
<h4 id="6-2-2-4-其他的输出类型"><a href="#6-2-2-4-其他的输出类型" class="headerlink" title="6.2.2.4 其他的输出类型"></a>6.2.2.4 其他的输出类型</h4><h2 id="6-3-隐藏单元"><a href="#6-3-隐藏单元" class="headerlink" title="6.3 隐藏单元"></a>6.3 隐藏单元</h2><p><strong>整流线性单元</strong>是隐藏单元极好的默认选择。</p>
<p>大多数隐藏单元的区别仅仅在于<strong>激活函数</strong>$g(z)$的形式。</p>
<p>隐藏单元少数点不可微的解释。 可微的定义是：只有函数在$z\ $处的左导数与右导数都有定义并且相等时，函数在$z\ $处才是可微的。</p>
<p>$g(z) = \text{max}(0,z)$，在$z=0$处的左导数为0，右导数为1。软件中实现通常是返回左导数或者右导数的其中一个，而不是报告导数未定义或者产生一个错误。</p>
<h3 id="6-3-1-整流线性单元及其扩展"><a href="#6-3-1-整流线性单元及其扩展" class="headerlink" title="6.3.1 整流线性单元及其扩展"></a>6.3.1 整流线性单元及其扩展</h3><p>整流线性单元的激活函数：$g(z) = \text{max}(0,z)$</p>
<p>整流线性单元通常作用于仿射变换之上： $$h = g(W^Tx+b)$$</p>
<h3 id="6-3-2-logistic-sigmoid与双曲正切函数"><a href="#6-3-2-logistic-sigmoid与双曲正切函数" class="headerlink" title="6.3.2 logistic sigmoid与双曲正切函数"></a>6.3.2 logistic sigmoid与双曲正切函数</h3><p>双曲正切函数通常要比logistic sigmoid函数表现更好。</p>
<h3 id="6-3-3-其他隐藏单元"><a href="#6-3-3-其他隐藏单元" class="headerlink" title="6.3.3 其他隐藏单元"></a>6.3.3 其他隐藏单元</h3><p>其中一种是完全没有隐藏单元$g(z)$。也可以说是用单位函数作为激活函数。</p>
<p>softmax单元是一种经常用作输出的单元，但有时候也可以用作隐藏单元。<br>softmax单元很自然地表示具有k个可能值的离散型随机变量的概率分布，所以它们可以作为一种开关。将在<em>10.12节</em>介绍。</p>
<p>其他的一些隐藏单元包括：</p>
<ul>
<li>径向基函数(radial basis function, RBF)</li>
<li>softplus函数</li>
<li>硬双曲正切函数(hard tanh)</li>
</ul>
<h2 id="6-4-架构设计"><a href="#6-4-架构设计" class="headerlink" title="6.4 架构设计"></a>6.4 架构设计</h2><p>架构（architecture）一词指网络的整体结构：它应该具有多少单元，以及这些单元应该如何连接。</p>
<p>链式结构：每一层都是前一层的函数。主要的考虑因素是网络的深度和每层的宽度。</p>
<h3 id="6-4-1-万能近似性质和深度"><a href="#6-4-1-万能近似性质和深度" class="headerlink" title="6.4.1 万能近似性质和深度"></a>6.4.1 万能近似性质和深度</h3><p><strong>万能近似定理</strong>(universal approximation theorem)：一个前馈神经网络如果具有线性输出层和至少一层具有任何一种“挤压”性质的激活函数（例如sigmoid函数）的隐含层，只要给予网络足够数量的隐藏单元，它可以以任意的精度近似任何从一个有限维空间到另一个有限维空间的Borel可测函数。</p>
<p>单层的前馈网络虽然足以表示任何函数，但是网络层可能大得不可实现。<br>所以需要深度网络。</p>
<p>Montufar et al(2014):一些用深度整流网络表示的函数可能需要浅层网络（一个隐含层）<strong>指数级</strong>的隐藏单元才能表示。</p>
<p>根据经验，更深的模型确实在广泛的任务中泛化得更好。</p>
<h3 id="6-4-2-其他架构上的考虑"><a href="#6-4-2-其他架构上的考虑" class="headerlink" title="6.4.2 其他架构上的考虑"></a>6.4.2 其他架构上的考虑</h3><p>上述考虑的是简单的链式结构。在实践中，神经网络具有多样性。</p>
<p>用于计算机视觉的卷积神经网络的特殊架构在 <em>第9章</em> 中介绍。<br>前馈网络也可以推广到序列处理的循环神经网络，但有它们自己的架构考虑，将在<em>第10章</em>中介绍。</p>
<p>架构设计考虑的另一个关键点是如何将层与层之间连接起来。</p>
<h2 id="6-5-反向传播和其他的微分算法"><a href="#6-5-反向传播和其他的微分算法" class="headerlink" title="6.5 反向传播和其他的微分算法"></a>6.5 反向传播和其他的微分算法</h2><h3 id="6-5-1-计算图"><a href="#6-5-1-计算图" class="headerlink" title="6.5.1 计算图"></a>6.5.1 计算图</h3><p>图中每个节点表示一个变量。</p>
<h3 id="6-5-2-微积分中的链式法则"><a href="#6-5-2-微积分中的链式法则" class="headerlink" title="6.5.2 微积分中的链式法则"></a>6.5.2 微积分中的链式法则</h3><p>从标量扩展到向量的链式法则。</p>
<p>假设$x\in \mathbb R^m,\  y\in \mathbb R^n$，$g\ $是从$\mathbb R^m$到$\mathbb R^n$的映射，$f\ $是从$\mathbb R^n$到$\mathbb R\ $的映射。如果$y=g(x)$ 并且$z =f(y)$。那么：<br>$$\frac{\partial z}{\partial x_i} = \sum_j \frac{\partial z}{\partial y_j} \frac{\partial y_j}{\partial x_i}$$</p>
<p>使用向量记法，可以等价地写成：<br>$$\triangledown_xz = (\frac {\partial y}{\partial x})^T \triangledown_yz$$<br>这里的$\frac {\partial y}{\partial x}$是$g\ $的$n\times m $的<code>Jacobian</code>矩阵。</p>
<p>还可以从向量扩展到张量。</p>
<h3 id="6-5-3-递归地使用链式法则来实现反向传播"><a href="#6-5-3-递归地使用链式法则来实现反向传播" class="headerlink" title="6.5.3 递归地使用链式法则来实现反向传播"></a>6.5.3 递归地使用链式法则来实现反向传播</h3><h3 id="6-5-4-全连接MLP中的反向传播计算"><a href="#6-5-4-全连接MLP中的反向传播计算" class="headerlink" title="6.5.4 全连接MLP中的反向传播计算"></a>6.5.4 全连接MLP中的反向传播计算</h3><p>算法6.2反向传播时，偏导数的计算。</p>
<p>算法6.3是前向传播和代价函数的计算。</p>
<h3 id="6-5-5-符号到符号的导数"><a href="#6-5-5-符号到符号的导数" class="headerlink" title="6.5.5 符号到符号的导数"></a>6.5.5 符号到符号的导数</h3><p>符号表示</p>
<p>反向传播的方法。</p>
<p>1 符号到数值的微分：计算图和一组用于图的输入的数值</p>
<p>2 符号到符号的方法：采用计算图和添加额外的节点到计算图中，这些额外的节点提供了我们所需导数的符号描述。</p>
<h3 id="6-5-6-一般化的反向传播"><a href="#6-5-6-一般化的反向传播" class="headerlink" title="6.5.6 一般化的反向传播"></a>6.5.6 一般化的反向传播</h3><h3 id="6-5-7-实例：用于MLP训练的反向传播"><a href="#6-5-7-实例：用于MLP训练的反向传播" class="headerlink" title="6.5.7 实例：用于MLP训练的反向传播"></a>6.5.7 实例：用于MLP训练的反向传播</h3><p>训练多层感知机</p>
<p>交叉熵代价函数</p>
<h3 id="6-5-8-复杂化"><a href="#6-5-8-复杂化" class="headerlink" title="6.5.8 复杂化"></a>6.5.8 复杂化</h3><p>操作返回多个张量。反向传播的内存消耗、现实实现。</p>
<h3 id="6-5-9-深度学习界外的微分"><a href="#6-5-9-深度学习界外的微分" class="headerlink" title="6.5.9 深度学习界外的微分"></a>6.5.9 深度学习界外的微分</h3><p>自动微分领域关系如何以算法方式计算微分。</p>
<p>这里描述的反向传播算法只是自动微分算法的一种方法。</p>
<p>反向模式累加和前向模式累加。</p>
<p><code>Theano</code>和<code>TensorFlow</code>的实现使用基于匹配已知简化模式的试探法，以便重复地尝试去简化图。</p>
<p>在机器学习以外的社区，更常见的 是使用传统的编程语言来直接实现微分软件。例如用<code>Python</code>或者<code>C</code>来编程</p>
<h3 id="6-5-10-高阶微分"><a href="#6-5-10-高阶微分" class="headerlink" title="6.5.10 高阶微分"></a>6.5.10 高阶微分</h3><p>一些软件框架支持高阶导数。在深度学习软件框架中，这至少包括<code>Theano</code>和<code>TensorFlow</code>。</p>
<p>在深度学习的相关领域，很少会计算标量函数的单个二阶导数。相反，我们通常对<code>Hessian</code>矩阵的性质比较感兴趣。如果有函数$f:\mathbb{R}^n \to R$，那么<code>Hessian</code>矩阵的大小为$n\times n$。在典型的深度学习应用中，n将是模型的参数数量，可能很容易达到数十亿。因此，完整的<code>Hessian</code>矩阵甚至不能表示。</p>
<p>典型的深度学习方法是使用<code>Krylov</code>方法，而不是显式地计算<code>Hessian</code>矩阵。</p>
<p><code>Hessian</code>矩阵上使用<code>Krylov</code>方法，只需要计算<code>Hessian</code>矩阵$H$和一个任意向量$v$间的乘积即可。</p>
<h2 id="6-6-历史小记"><a href="#6-6-历史小记" class="headerlink" title="6.6 历史小记"></a>6.6 历史小记</h2><p>线性 -&gt; 非线性</p>
<p>反向传播</p>
<p>现代前馈网络的核心思想</p>
<p>交叉熵损失函数</p>
<p>分段线性隐藏单元（整流线性单元ReLU）</p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[准确率，召回率与F1值]]></title>
      <url>/2017/10/08/DL_Precision_and_Recall/</url>
      <content type="html"><![CDATA[<p>下面有关分类算法的准确率，召回率，F1 值的描述，错误的是？<br>A.准确率是检索出相关文档数与检索出的文档总数的比率，衡量的是检索系统的查准率<br>B.召回率是指检索出的相关文档数和文档库中所有的相关文档数的比率，衡量的是检索系统的查全率<br>C.正确率、召回率和 F 值取值都在0和1之间，数值越接近0，查准率或查全率就越高<br>D.为了解决准确率和召回率冲突问题，引入了F1分数</p>
<pre><code>TP——将正类预测为正类数
FN——将正类预测为负类数
FP——将负类预测为正类数
TN——将负类预测为负类数
</code></pre><h2 id="精确率（Precision）"><a href="#精确率（Precision）" class="headerlink" title="精确率（Precision）"></a>精确率（Precision）</h2><p>P = TP/(TP+FP)<br>反映了被分类器判定的正例中真正的正例样本的比重。</p>
<p>精确率是针对我们<strong>预测结果</strong>而言的，它表示的是预测为正的样本中有多少是真正的正样本。那么预测为正就有两种可能了，一种就是把正类预测为正类(TP)，另一种就是把负类预测为正类(FP)。</p>
<h2 id="准确率（Accuracy）："><a href="#准确率（Accuracy）：" class="headerlink" title="准确率（Accuracy）："></a>准确率（Accuracy）：</h2><p>A = （TP+TN）/ （P+N） = （TP+TN）/ （TP+FN+FP+TN）<br>准确率(正确率)：反映了分类器统对整个样本的判定能力——能将正的判定为正，负的判定为负。</p>
<p>被分对的样本数除以所有的样本数，通常来说，正确率越高，分类器越好。</p>
<h2 id="召回率（Recall）："><a href="#召回率（Recall）：" class="headerlink" title="召回率（Recall）："></a>召回率（Recall）：</h2><p>R = TP/（TP+FN）= 1-[FN/（TP+FN）]<br>反映了被正确判定的正例占总的正例的比重。</p>
<p>而召回率是针对我们<strong>原来的样本</strong>而言的，它表示的是样本中的正例有多少被预测正确了。那也有两种可能，一种是把原来的正类预测成正类(TP)，另一种就是把原来的正类预测为负类(FN)。</p>
<p>所有正例中被分对的比例，衡量了分类器对正例的识别能力。</p>
<p>精确率和召回率，两者取值在0和1之间，数值越接近<code>1</code>，查准率或查全率就越高。</p>
<h2 id="F1值"><a href="#F1值" class="headerlink" title="F1值"></a>F1值</h2><p>F1 = 2<em>（Recall </em> Precision）/（Recall + Precision）</p>
<p>精准率和召回率和F1取值都在0和1之间，精准率和召回率高，F1值也会高，不存在数值越接近0越高的说法，应该是数值越接近1越高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一句话概括：精确率Precision是<strong>预测的正例</strong>里有多少是预测正确的，召回率Recall是<strong>真正的正例</strong>里有多少预测正确的。</p>
<p><strong>精确是预测，召回是原本</strong>。</p>
<p>参考资料：</p>
<ul>
<li><p><a href="https://www.zhihu.com/question/19645541/answer/12502751" target="_blank" rel="external">https://www.zhihu.com/question/19645541/answer/12502751</a></p>
</li>
<li><p><a href="https://www.nowcoder.com/test/question/done?tid=11555865&amp;qid=14638#summary" target="_blank" rel="external">https://www.nowcoder.com/test/question/done?tid=11555865&amp;qid=14638#summary</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 准确率 </tag>
            
            <tag> 召回率 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MathJax的基本使用语法]]></title>
      <url>/2017/10/08/mathjax_basic/</url>
      <content type="html"><![CDATA[<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><ul>
<li>使用\mathbb或\Bbb来显示黑板粗体字，$\mathbb{NQRZ}$</li>
<li>使用\mathbf来显示粗体字，$\mathbf {ABCDabcd}$</li>
<li>使用\mathtt来显示打印式字体，$\mathtt{ABCDabcd}$</li>
<li>使用\mathrm来显示罗马字体，$\mathrm{ABCDabcd}$</li>
<li>使用\mathcal来显示手写字体，$\mathcal{ABCDabcd}$</li>
<li>使用\mathscr来显示剧本字体，$\mathscr{ABCDabcd}$</li>
<li>使用\mathfrak来显示Fraktur字母(一种旧的德国字体)，$\mathfrak{ABCDabcd}$</li>
</ul>
<h1 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h1><p>如果是在文本中插入公式，则用<code>$...$</code>。</p>
<p>如果公式自成段落，则使用<code>$$...$$</code>。</p>
<h1 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h1><p>如果要写出多行公式，就使用</p>
<pre><code>\begin{equation}\begin{split} 
end{split}\end{equation}
</code></pre><p>\\ 符号表示换行，再使用&amp;符号表示要对齐的位置，例子如下</p>
<pre><code>\begin{equation}\begin{split}
H(Y|X)&amp;=\sum_{x\in X} p(x)H(Y|X)\\
&amp;=-\sum_{x\in X} p(x)\sum_{y\in Y}p(y|x)\log p(y|x)\\
&amp;=-\sum_{x\in X} \sum_{y\in Y}p(y,x)\log p(y|x)
\end{split}\end{equation}
</code></pre><p>当然，再加上<code>$$...$$</code>之后，显示如下：<br>$$\begin{equation}\begin{split}<br>H(Y|X)&amp;=\sum_{x\in X} p(x)H(Y|X)\\<br>&amp;=-\sum_{x\in X} p(x)\sum_{y\in Y}p(y|x)\log p(y|x)\\<br>&amp;=-\sum_{x\in X} \sum_{y\in Y}p(y,x)\log p(y|x)<br>\end{split}\end{equation}$$</p>
<h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>通过大括号<code>{}</code>将操作数与符号分割开，消除二义性。</p>
<p>例如，若使用x^10，其效果为$x^10$，这里就要用到大括号，x^{10}，最终效果为$x^{10}$。</p>
<h1 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h1><p><code>MathJax</code>通常用自己的一套复杂策略来决定公式的空间距离。直接在两个元素之间加入空格是毫无用处的。</p>
<p>因此为了增加空间距离，使用<code>\,</code>可以增加稍许空间；使用<code>\;</code>可以增加更多的空间；<code>\quad</code>和<code>\qquad</code>分别对应更大的空间。</p>
<h1 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h1><h2 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h2><p>上标或下标只需在后面加上<code>^</code>或<code>_</code>。另外需要注意的是，如果上下标不止一个字符，就需要用大括号括起来，表示是一个整体<code>{...}</code>。</p>
<h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h2><p>有两种方式做到这个效果。 </p>
<ol>
<li>使用\frac ab。如\frac {1+a}{4+b}，效果为$\frac{1+a}{4+b}$; </li>
<li>使用a \over b。如{1+a} \over {4+b}，效果为${1+a}\over {4+b}$。 </li>
</ol>
<p>一般推荐使用<strong>第二种</strong>。个人倾向于使用<strong>第一种</strong>。</p>
<h2 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h2><p>平方根： \sqrt{x^3}，效果为 $\sqrt{x^3} $。</p>
<p>其余： \sqrt[4]{\frac xy}，效果为 $\sqrt[4]{\frac xy}$。</p>
<h2 id="关系比较符号"><a href="#关系比较符号" class="headerlink" title="关系比较符号"></a>关系比较符号</h2><pre><code>&lt;    \lt
&gt;    \gt
≤    \le
≥    \ge
≠    \neq
</code></pre><p>$$\begin{array}{c|lcr}<br>\text{符号} &amp; \text{\表示} \\<br>\hline<br>&lt; &amp; lt \\<br>> &amp; gt \\<br>≤ &amp; le \\<br>≥ &amp; ge \\<br>≠ &amp; neq \\<br>\end{array}$$</p>
<h2 id="argmax"><a href="#argmax" class="headerlink" title="argmax"></a>argmax</h2><pre><code>\underset{f}{\mathrm{argmin}}
</code></pre><p>效果如下：<br>$$\underset{f}{\mathrm{argmin}}$$</p>
<h2 id="不显示斜体"><a href="#不显示斜体" class="headerlink" title="不显示斜体"></a>不显示斜体</h2><p>对于常量部分，有时候我们不想让他显示成斜体，而是正常的竖直显示，可加上<code>\text{...}</code>，就可以正常显示。</p>
<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p>使用<code>$$\begin{matrix}…\end{matrix}$$</code>，每一行末用<code>\\</code>结束表示换行，用<code>&amp;</code>分隔矩阵元素。 </p>
<pre><code>$$
  \begin{matrix}
  1 &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; 0 \\
  0 &amp; 0 &amp; 1 \\
  \end{matrix}
$$
</code></pre><p>效果：<br>$$<br>\begin{matrix}<br>1 &amp; 0 &amp; 0 \\<br>0 &amp; 1 &amp; 0 \\<br>0 &amp; 0 &amp; 1 \\<br>\end{matrix}<br>$$</p>
<p>如果要加括号，可以使用上面的括号符号。<br>除此之外，还可以直接将<code>matrix</code>替换为<code>pmatrix</code>(小括号)，或者<code>bmatrix</code>(中括号)，或者<code>Bmatrix</code>(大括号)，或者<code>vmatrix</code>(竖线)，或者<code>Vmatrix</code>(是双竖线)</p>
<p>如果你想省略一些项，可以使用<code>\cdots</code>⋯，<code>\ddots</code>⋱，<code>\vdots</code>⋮。<br>如：</p>
<pre><code>$$
  \begin{pmatrix}
  1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n\\
  1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  
  1 &amp; a_n &amp; a_n^2 &amp; \cdots &amp; a_n^n  \\
  \end{pmatrix}
$$
</code></pre><p>效果：<br>$$<br>  \begin{pmatrix}<br>  1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n\\<br>  1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \\<br>  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>  1 &amp; a_n &amp; a_n^2 &amp; \cdots &amp; a_n^n  \\<br>  \end{pmatrix}<br>$$</p>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>不同语言的代码块，可以用不同的标识符。如python语言，则代码块表示为` <figure class="highlight python"><figcaption><span>//下一行写具体代码 ```  `。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">就是用三个点号（英文状态下、键盘左上角、ESC下面的那个键）包围的部分就是代码块。</div><div class="line"></div><div class="line"></div><div class="line">测试：</div><div class="line"></div><div class="line"></div><div class="line">JavaScript代码块效果如下：</div><div class="line"></div><div class="line">```javascript</div><div class="line"><span class="keyword">if</span> (condition)&#123;</div><div class="line">    <span class="keyword">return</span> true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Python代码块效果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(A)</span>:</span></div><div class="line">	<span class="string">'''intresting document.'''</span></div><div class="line">    <span class="keyword">return</span> len(A)</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MathJax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[批处理的常用命令及用法]]></title>
      <url>/2017/10/05/batch_basic_usage/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在这里，先解释什么是DOS？</p>
<p>DOS，即Disk Operation System，磁盘操作系统。</p>
<p>命令行就是在Windows操作系统中打开DOS窗口，以字符串的形式执行Windows管理程序。</p>
<p>那么，我们如何进入命令行窗口？</p>
<p>开始–&gt;运行–&gt;键入”cmd”，回车即可。</p>
<p>阅读本文需要一定的dos基础概念，例如：盘符、文件、目录(文件夹)、子目录、根目录、当前目录</p>
<p>每个命令的完整说明请加 /? 参数参考微软的帮助文档可以看到。</p>
<p>注：如果对某一命令还不是很熟悉，可以在命令行窗口下输入：命令名/?的方式来获得帮助。</p>
<p>例如：对dir命令的应用不熟悉，可以在命令行窗口下输入：</p>
<p><code>dir /?</code></p>
<p>批处理定义：顾名思义，批处理文件是将一系列命令按一定的顺序集合为一个可执行的文本文件，其扩展名为BAT或者CMD。这些命令统称批处理命令。</p>
<p>小知识：可以在键盘上按下Ctrl+C组合键来强行终止一个批处理的执行过程。</p>
<h2 id="1-echo-和-回显控制命令"><a href="#1-echo-和-回显控制命令" class="headerlink" title="1 echo 和 @回显控制命令"></a>1 echo 和 @回显控制命令</h2><pre><code>@                    #关闭单行回显
echo off             #从下一行开始关闭回显
@echo off            #从本行开始关闭回显。一般批处理第一行都是这个
echo on              #从下一行开始打开回显
echo                 #显示当前是 echo off 状态还是 echo on 状态
echo.                #输出一个&quot;回车换行&quot;，一般就是指空白行
echo hello world     #输出hello world
</code></pre><p>“关闭回显”是指运行批处理文件时，不显示文件里的每条命令，只显示运行结果。批处理开始和结束时，系统都会自动打开回显</p>
<h2 id="2-errorlevel程序返回码"><a href="#2-errorlevel程序返回码" class="headerlink" title="2 errorlevel程序返回码"></a>2 errorlevel程序返回码</h2><pre><code>echo %errorlevel%
</code></pre><p>每个命令运行结束，可以用这个命令行格式查看返回码用于判断刚才的命令是否执行成功默认值为0，</p>
<p>一般命令执行出错会设 errorlevel 为1</p>
<h2 id="3-dir显示目录中的文件和子目录列表"><a href="#3-dir显示目录中的文件和子目录列表" class="headerlink" title="3 dir显示目录中的文件和子目录列表"></a>3 dir显示目录中的文件和子目录列表</h2><pre><code>dir                 #显示当前目录中的文件和子目录
dir /a              #显示当前目录中的文件和子目录，包括隐藏文件和系统文件
dir c: /a:d         #显示 C 盘当前目录中的目录
dir c:\ /a:-d       #显示 C 盘根目录中的文件
dir d:\mp3 /b/p     #逐屏显示 d:\mp3 目录里的文件，只显示文件名，不显示时间和大小

dir *.exe /s        #显示当前目录和子目录里所有的.exe文件。
</code></pre><p>其中 <em> 是通配符，代表所有的文件名，还有一个通配符 ? 代表一个任意字母或汉字。如 `c</em>.*<code>代表以 c 开头的所有文件。</code>?.exe` 代表所有文件名是一个字母的.exe文件。</p>
<p>如果指定的目录或文件不存在，将返回 <code>errorlevel</code> 为1;每个文件夹的 dir 输出都会有2个子目录<code>.</code>和<code>..</code>。<code>.</code> 代表当前目录， <code>..</code> 代表当前目录的上级目录。</p>
<pre><code>dir .               #显示当前目录中的文件和子目录
dir ..              #显示当前目录的上级目录中的文件和子目录
</code></pre><p>其它参数可参考<code>dir /?</code></p>
<h2 id="4-cd更改当前目录"><a href="#4-cd更改当前目录" class="headerlink" title="4 cd更改当前目录"></a>4 cd更改当前目录</h2><pre><code>cd mp3              #进入当前目录中的mp3 目录
cd ..               #进入当前目录中的上级目录
cd\                 #进入根目录
cd                  #显示当前目录
cd /d d:\mp3        #可以同时更改盘符和目录
cd &quot;Documents and Settings&quot;\All users
</code></pre><p>文件名带空格，路径前需要加上引号！！如果更改到的目录不存在，则出错返回 <code>errorlevel=1</code></p>
<p><code>cd /d d:</code> 更改盘符需要加上/d参数。</p>
<h2 id="5-md创建目录"><a href="#5-md创建目录" class="headerlink" title="5 md创建目录"></a>5 md创建目录</h2><pre><code>md abc              #在当前目录里建立子目录 abc
md d:\a\b\c         #如果 d:\a 不存在，将会自动创建
</code></pre><h2 id="6-rd删除目录"><a href="#6-rd删除目录" class="headerlink" title="6 rd删除目录"></a>6 rd删除目录</h2><pre><code>rd abc              #删除当前目录里的 abc 子目录，要求为空目录
rd /s/q d:\temp     #删除 d:\temp 文件夹及其子文件夹和文件，不需要按 Y 确认
</code></pre><h2 id="7-del删除文件"><a href="#7-del删除文件" class="headerlink" title="7 del删除文件"></a>7 del删除文件</h2><pre><code>del d:\test.txt     #删除指定文件，不能是隐藏、系统、只读文件
del *.*删除当前目录里的所有文件，不包括隐藏、系统、只读文件，要求按 Y 确认
del /q/a/f d:\temp\*.*删除 d:\temp 文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录
del /q/a/f/s d:\temp\*.*删除 d:\temp 及子文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录
</code></pre><h2 id="8-ren文件重命名"><a href="#8-ren文件重命名" class="headerlink" title="8 ren文件重命名"></a>8 ren文件重命名</h2><pre><code>ren 1.txt 2.bak     #把 1.txt 更名为 2.bak
ren *.txt *.ini     #把当前目录里所有.txt文件改成.ini文件
ren d:\temp tmp     #支持对文件夹的重命名
</code></pre><h2 id="9-cls清屏"><a href="#9-cls清屏" class="headerlink" title="9 cls清屏"></a>9 cls清屏</h2><h2 id="10-type显示文件内容"><a href="#10-type显示文件内容" class="headerlink" title="10 type显示文件内容"></a>10 type显示文件内容</h2><pre><code>type c:\boot.ini    #显示指定文件的内容，程序文件一般会显示乱码
type *.txt          #显示当前目录里所有.txt文件的内容
</code></pre><h2 id="11-copy拷贝文件"><a href="#11-copy拷贝文件" class="headerlink" title="11 copy拷贝文件"></a>11 copy拷贝文件</h2><pre><code>copy c:\test.txt d:\         #复制 c:\test.txt 文件到 d:\
copy c:\test.txt d:\test.bak #复制 c:\test.txt 文件到 d:\ ，并重命名为 test.bak
copy c:\*.*                  #复制 c:\ 所有文件到当前目录，不包括隐藏文件和系统文件不指定目标路径，则默认目标路径为当前目录
copy con test.txt            #从屏幕上等待输入，按 Ctrl+Z 结束输入，输入内容存为test.txt文件con代表屏幕，prn代表打印机，nul代表空设备
copy 1.txt + 2.txt 3.txt     #合并 1.txt 和 2.txt 的内容，保存为 3.txt 文件如果不指定 3.txt ，则保存到 1.txt
copy test.txt +              #复制文件到自己，实际上是修改了文件日期
</code></pre><h2 id="12-title设置cmd窗口的标题"><a href="#12-title设置cmd窗口的标题" class="headerlink" title="12 title设置cmd窗口的标题"></a>12 title设置cmd窗口的标题</h2><pre><code>title 新标题        #可以看到cmd窗口的标题栏变了
</code></pre><h2 id="13-ver显示系统版本"><a href="#13-ver显示系统版本" class="headerlink" title="13 ver显示系统版本"></a>13 ver显示系统版本</h2><h2 id="14-label-和-vol设置卷标"><a href="#14-label-和-vol设置卷标" class="headerlink" title="14 label 和 vol设置卷标"></a>14 label 和 vol设置卷标</h2><pre><code>vol                 #显示卷标
label               #显示卷标，同时提示输入新卷标
label c:system      #设置C盘的卷标为 system
</code></pre><h2 id="15-pause暂停命令"><a href="#15-pause暂停命令" class="headerlink" title="15 pause暂停命令"></a>15 pause暂停命令</h2><p>运行该命令时，将显示下面的消息：请按任意键继续 . . .<br>一般用于看清楚屏幕上显示的内容</p>
<h2 id="16-rem-和-注释命令"><a href="#16-rem-和-注释命令" class="headerlink" title="16 rem 和 ::注释命令"></a>16 rem 和 ::注释命令</h2><p>注释行，不执行操作</p>
<h2 id="17-date-和-time日期和时间"><a href="#17-date-和-time日期和时间" class="headerlink" title="17 date 和 time日期和时间"></a>17 date 和 time日期和时间</h2><pre><code>date          #显示当前日期，并提示输入新日期，按&quot;回车&quot;略过输入
date/t        #只显示当前日期，不提示输入新日期
time          #显示当前时间，并提示输入新时间，按&quot;回车&quot;略过输入
time/t        #只显示当前时间，不提示输入新时间
</code></pre><h2 id="18-goto-和-跳转命令"><a href="#18-goto-和-跳转命令" class="headerlink" title="18 goto 和 :跳转命令"></a>18 goto 和 :跳转命令</h2><pre><code>:label        #行首为:表示该行是标签行，标签行不执行操作
goto label    #跳转到指定的标签那一行
</code></pre><h2 id="19-find-外部命令-查找命令"><a href="#19-find-外部命令-查找命令" class="headerlink" title="19 find (外部命令)查找命令"></a>19 find (外部命令)查找命令</h2><pre><code>find &quot;abc&quot; c:\test.txt在 c:\test.txt 文件里查找含 abc 字符串的行如果找不到，将设 errorlevel 返回码为1
find /i &quot;abc&quot; c:\test.txt查找含 abc 的行，忽略大小写
find /c &quot;abc&quot; c:\test.txt显示含 abc 的行的行数
</code></pre><h2 id="20-more-外部命令-逐屏显示"><a href="#20-more-外部命令-逐屏显示" class="headerlink" title="20 more (外部命令)逐屏显示"></a>20 more (外部命令)逐屏显示</h2><pre><code>more c:\test.txt    #逐屏显示 c:\test.txt 的文件内容
</code></pre><h2 id="21-tree显示目录结构"><a href="#21-tree显示目录结构" class="headerlink" title="21 tree显示目录结构"></a>21 tree显示目录结构</h2><pre><code>tree d:\            #显示D盘的文件目录结构
</code></pre><h2 id="22-amp-顺序执行多条命令，而不管命令是否执行成功"><a href="#22-amp-顺序执行多条命令，而不管命令是否执行成功" class="headerlink" title="22 &amp;顺序执行多条命令，而不管命令是否执行成功"></a>22 &amp;顺序执行多条命令，而不管命令是否执行成功</h2><pre><code>c: &amp; cd\ &amp; dir /w   #相当于把下面3行命令写到1行去了c:cd\dir /w
</code></pre><h2 id="23-amp-amp-顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令"><a href="#23-amp-amp-顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令" class="headerlink" title="23 &amp;&amp;顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令"></a>23 &amp;&amp;顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令</h2><pre><code>f: &amp;&amp; cd\ &amp;&amp; dir &gt;c:\test.txt #注意如果f盘不存在，那么后面2条命令将不会执行
find &quot;ok&quot; c:\test.txt &amp;&amp; echo 成功  #如果找到了&quot;ok&quot;字样，就显示&quot;成功&quot;，找不到就不显示
</code></pre><h2 id="24-顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令"><a href="#24-顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令" class="headerlink" title="24 ||顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令"></a>24 ||顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令</h2><pre><code>find &quot;ok&quot; c:\test.txt || echo 不成功  #如果找不到&quot;ok&quot;字样，就显示&quot;不成功&quot;，找到了就不显示
</code></pre><h2 id="25-管道命令"><a href="#25-管道命令" class="headerlink" title="25 |管道命令"></a>25 |管道命令</h2><p>前一个命令的执行结果输出到后一个命令</p>
<pre><code>dir *.* /s/a | find /c &quot;.exe&quot;
</code></pre><p>管道命令表示先执行 dir 命令，对其输出的结果执行后面的 find 命令该命令行结果：输出当前文件夹及所有子文件夹里的.exe文件的个数</p>
<pre><code>type c:\test.txt|more 这个和 more c:\test.txt 的效果是一样的
</code></pre><h2 id="26-gt-和-gt-gt-输出重定向命令"><a href="#26-gt-和-gt-gt-输出重定向命令" class="headerlink" title="26 &gt; 和 &gt;&gt;输出重定向命令"></a>26 &gt; 和 &gt;&gt;输出重定向命令</h2><pre><code>&gt; 清除文件中原有的内容后再写入

&gt;&gt; 追加内容到文件末尾，而不会清除原有的内容主要将本来显示在屏幕上的内容输出到指定文件中指定文件如果不存在，则自动生成该文件

echo hello world&gt;c:\test.txt生成c:\test.txt文件，内容为hello world这个格式在批处理文件里用得很多，可以成 .reg .bat .vbs 等临时文件

type c:\test.txt &gt;prn屏幕上不显示文件内容，转向输出到打印机
echo hello world&gt;con在屏幕上显示hello world，实际上所有输出都是默认 &gt;con 的
copy c:\test.txt f: &gt;nul拷贝文件，并且不显示&quot;文件复制成功&quot;的提示信息，但如果f盘不存在，还是会显示出错信息
copy c:\test.txt f: &gt;nul 2&gt;nul不显示&quot;文件复制成功&quot;的提示信息，并且f盘不存在的话，也不显示错误提示信息
echo ^^W ^&gt; ^W&gt;c:\test.txt生成的文件内容为 ^W &gt; W^ 和 &gt; 是控制命令，要把它们输出到文件，必须在前面加个 ^ 符号
</code></pre><h2 id="27-lt-从文件中获得输入信息，而不是从屏幕上"><a href="#27-lt-从文件中获得输入信息，而不是从屏幕上" class="headerlink" title="27 &lt;从文件中获得输入信息，而不是从屏幕上"></a>27 &lt;从文件中获得输入信息，而不是从屏幕上</h2><p>一般用于 date time label 等需要等待输入的命令</p>
<pre><code>@echo offecho 2005-05-01&gt;temp.txtdate &lt;temp.txtdel temp.txt这样就可以不等待输入直接修改当前日期
</code></pre><h2 id="28-命令行传递给批处理参数"><a href="#28-命令行传递给批处理参数" class="headerlink" title="28 命令行传递给批处理参数"></a>28 命令行传递给批处理参数</h2><p>%0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %<em>命令行传递给批处理的参数<br>%0 批处理文件本身%1 第一个参数%9 第九个参数%</em> 从第一个参数开始的所有参数在C盘根目录新建test.bat，内容如下：</p>
<pre><code>@echo off
echo %0
echo %1
echo %2
echo %*
</code></pre><p>运行cmd，输入 <code>c:\test.bat &quot;/a&quot; /b /c /d</code>可以看出每个参数的含意</p>
<p>修改test.bat内容如下</p>
<pre><code>@echo off
echo %1
echo %~1
echo %0
echo %~f0
echo %~d0
echo %~p0
echo %~n0
echo %~x0
echo %~s0
echo %~a0
echo %~t0
echo %~z0
</code></pre><p>再运行cmd，输入 c:\test.bat “/a” /b /c /d可以参照 call/? 或 for/? 看出每个参数的含意。注意这里可以对文件进行日期比较和大小比较</p>
<pre><code>echo load &quot;%%1&quot; &quot;%%2&quot;&gt;c:\test.txt
</code></pre><p>生成的文件内容为 load “%1” “%2”<br>批处理文件里，用这个格式把命令行参数输出到文件</p>
<h2 id="31-set设置变量"><a href="#31-set设置变量" class="headerlink" title="31 set设置变量"></a>31 set设置变量</h2><p>引用变量可在变量名前后加 % ，即 %变量名%</p>
<pre><code>set                    #显示目前所有可用的变量，包括系统变量和自定义的变量
echo %SystemDrive%     #显示系统盘盘符。系统变量可以直接引用
set p                  #显示所有以p开头的变量，要是一个也没有就设errorlevel=1
set p=aa1bb1aa2bb2     #设置变量p，并赋值为 = 后面的字符串，即aa1bb1aa2bb2
echo %p%               #显示变量p代表的字符串，即aa1bb1aa2bb2
echo %p:~6%            #显示变量p中第6个字符以后的所有字符，即aa2bb2
echo %p:~6,3%          #显示第6个字符以后的3个字符，即aa2
echo %p:~0,3%          #显示前3个字符，即aa1
echo %p:~-2%           #显示最后面的2个字符，即b2
echo %p:~0,-2%         #显示除了最后2个字符以外的其它字符，即aa1bb1aa2b
echo %p:aa=c%          #用c替换变量p中所有的aa，即显示c1bb1c2bb2
echo %p:aa=%           #将变量p中的所有aa字符串置换为空，即显示1bb12bb2
echo %p:*bb=c%         #第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2
set p=%p:*bb=c%        #设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2
set /a p=39            #设置p为数值型变量，值为39
set /a p=39/10         #支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3
set /a p=p/10          #用 /a 参数时，在 = 后面的变量可以不加%直接引用
set /a p=&quot;1&amp;0&quot;         #&quot;与&quot;运算，要加引号。其它支持的运算符参见set/?
set p=                 #取消p变量
set /p p=请输入         #屏幕上显示&quot;请输入&quot;，并会将输入的字符串赋值给变量p注意这条可以用来取代 choice 命令
</code></pre><p>注意变量在 if 和 for 的复合语句里是一次性全部替换的，如</p>
<pre><code>@echo off
set p=aaa
if %p%==aaa (    
  echo %p%   
  set p=bbb    
  echo %p%    )
</code></pre><p>结果将显示aaaaaa因为在读取 if 语句时已经将所有 %p% 替换为aaa这里的”替换”，在 /? 帮助里就是指”扩充”、”环境</p>
<p>变量扩充”可以启用”延缓环境变量扩充”，用 ! 来引用变量，即 !变量名!</p>
<pre><code>@echo off
SETLOCAL ENABLEDELAYEDEXPANSION
set p=aaaif %p%==aaa (  
  echo %p%    
set p=bbb    
echo !p!    )
ENDLOCAL
</code></pre><p>结果将显示aaabbb<br>还有几个动态变量，运行 set 看不到<br>    %CD%                  #代表当前目录的字符串<br>    %DATE%                #当前日期<br>    %TIME%                #当前时间<br>    %RANDOM%              #随机整数，介于0~32767<br>    %ERRORLEVEL%          #当前ERRORLEVEL 值<br>    %CMDEXTVERSION%       #当前命令处理器扩展名版本号<br>    %CMDCMDLINE%          #调用命令处理器的原始命令行可以用echo命令查看每个变量值，如 echo %time%注意 %time% 精确到毫秒，在批处理需要延时处理时可以用到</p>
<h2 id="32-start调用外部程序"><a href="#32-start调用外部程序" class="headerlink" title="32 start调用外部程序"></a>32 start调用外部程序</h2><p>批处理中调用外部程序的命令，否则等外部程序完成后才继续执行剩下的指令</p>
<pre><code>start explorer d:\调用图形界面打开D盘
@echo off cd /d %~dp0regedit /s 劲舞团.regstart patcher.exe
</code></pre><p>不加 start 命令的话，”劲舞团”运行时，后面会有个黑乎乎的cmd窗口</p>
<h2 id="33-call调用另外一个批处理"><a href="#33-call调用另外一个批处理" class="headerlink" title="33 call调用另外一个批处理"></a>33 call调用另外一个批处理</h2><p>批处理中调用另外一个批处理的命令，否则剩下的批处理指令将不会被执行有时有的应用程序用start调用出错的，也可以call调用</p>
<h2 id="34-choice-外部命令"><a href="#34-choice-外部命令" class="headerlink" title="34 choice (外部命令)"></a>34 choice (外部命令)</h2><p>选择命令让用户输入一个字符，从而选择运行不同的命令，返回码errorlevel为1234……win98里</p>
<p>是choice.com win2000pro里没有，可以从win98里拷过来win2003里是choice.exechoice /N /C y /T 5 /D y&gt;nul延时5秒</p>
<p>下面是个 choice 语句的例子<br>    @echo off<br>    rem 以下在win2000pro运行通过，从win98里拷的chioce.com文件<br>    choice /c:abc aaa,bbb,ccc<br>    if errorlevel 3 goto ccc<br>    if %errorlevel%==2 goto bbb<br>    if errorlevel==1 goto aaa<br>rem 必须先判断数值高的返回码rem 可以看到 errorlevel 值的判断有3种写法，有时某种写法不好用，可以用另外的写法<br>rem 直接运行</p>
<p>chioce相当于运行</p>
<pre><code>choice /c:yn:aaa
echo aaa
goto end
:bbb
echo bbb
goto end
:ccc
echo ccc
goto end
:end
</code></pre><h2 id="35-assoc-和-ftype文件关联"><a href="#35-assoc-和-ftype文件关联" class="headerlink" title="35 assoc 和 ftype文件关联"></a>35 assoc 和 ftype文件关联</h2><p>assoc 设置’文件扩展名’关联，关联到’文件类型’ftype 设置’文件类型’关联，关联到’执行程序和参数’</p>
<p>当你双击一个.txt文件时，windows并不是根据.txt直接判断用 notepad.exe 打开而是先判断.txt属于 txtfile ‘文件类型’再调用 txtfile 关联的命令行 txtfile=%SystemRoot%\system32\NOTEPAD.EXE %1</p>
<p>可以在”文件夹选项”→”文件类型”里修改这2种关联</p>
<pre><code>assoc           #显示所有&apos;文件扩展名&apos;关联
assoc .txt      #显示.txt代表的&apos;文件类型&apos;，结果显示 .txt=txtfile
assoc .doc      #显示.doc代表的&apos;文件类型&apos;，结果显示 .doc=Word.Document.8
assoc .exe      #显示.exe代表的&apos;文件类型&apos;，结果显示 .exe=exefile
ftype           #显示所有&apos;文件类型&apos;关联
ftype exefile   #显示exefile类型关联的命令行，结果显示 exefile=&quot;%1&quot; %* assoc .txt=Word.Document.8设置.txt为word类型的文档，可以看到.txt文件的图标都变了
assoc .txt=txtfile恢复.txt的正确关联 ftype exefile=&quot;%1&quot; %*恢复 exefile 的正确关联
</code></pre><p>如果该关联已经被破坏，可以运行 command.com ，再输入这条命令</p>
<h2 id="36-pushd-和-popd切换当前目录"><a href="#36-pushd-和-popd切换当前目录" class="headerlink" title="36 pushd 和 popd切换当前目录"></a>36 pushd 和 popd切换当前目录</h2><pre><code>@echo off
c: &amp; cd\ &amp; md mp3       #在 C:\ 建立 mp3 文件夹
md d:\mp4               #在 D:\ 建立 mp4 文件夹
cd /d d:\mp4            #更改当前目录为 d:\mp4
pushd c:\mp3            #保存当前目录，并切换当前目录为 c:\mp3
popd                    #恢复当前目录为刚才保存的 d:\mp4一般用处不大，在当前目录名不确定时，会有点帮助
</code></pre><h2 id="37-subst-外部命令-映射磁盘。"><a href="#37-subst-外部命令-映射磁盘。" class="headerlink" title="37 subst (外部命令)映射磁盘。"></a>37 subst (外部命令)映射磁盘。</h2><pre><code>subst z: \\server\d     #这样输入z:就可以访问\\server\d了
subst z: /d             #取消该映射
subst                   #显示目前所有的映射
</code></pre><h2 id="38-xcopy-外部命令-文件拷贝"><a href="#38-xcopy-外部命令-文件拷贝" class="headerlink" title="38  xcopy (外部命令)文件拷贝"></a>38  xcopy (外部命令)文件拷贝</h2><pre><code>xcopy d:\mp3 e:\mp3 /s/e/i/y  #复制 d:\mp3 文件夹、所有子文件夹和文件到 e:\ ，覆盖已有文件。加 /i 表示如果 e:\ 没有 mp3 文件夹就自动新建一个，否则会有询问
</code></pre><h2 id="39-一些不常用的内部命令"><a href="#39-一些不常用的内部命令" class="headerlink" title="39 一些不常用的内部命令"></a>39 一些不常用的内部命令</h2><pre><code>&gt;&amp; 将一个句柄的输出写入到另一个句柄的输入中
&lt;&amp; 从一个句柄读取输入并将其写入到另一个句柄输出中shift 命令行传递给批处理的参数不止9个时，用以切换参数color 设置cmd窗口的显示颜色
pormpt 更改命令提示符号，默认都是 盘符:\路径\&gt; ，如 c:\&gt;
</code></pre><h2 id="40-format-外部命令-格式化硬盘"><a href="#40-format-外部命令-格式化硬盘" class="headerlink" title="40 format (外部命令)格式化硬盘"></a>40 format (外部命令)格式化硬盘</h2><pre><code>format c: /q/u/autotest/q表示快速格式化，/autotest表示自动格式化，不需要按 Y 确认/u表示每字节用 

F6 覆盖硬盘数据，使其不可用软件恢复format c: /c格式化C盘，并检测坏道
</code></pre><h2 id="41-fdisk-外部命令-硬盘分区win2000不带"><a href="#41-fdisk-外部命令-硬盘分区win2000不带" class="headerlink" title="41 fdisk (外部命令)硬盘分区win2000不带"></a>41 fdisk (外部命令)硬盘分区win2000不带</h2><p>该命令win98里的fdisk不支持80G以上大硬盘，winme里的支持fdisk/mbr重建硬盘分区表，一般用于清除引导区病毒、还原精灵注意使用该命令不能从硬盘启动，必须软驱或光驱启动后直接运行</p>
<h2 id="42-ping-外部命令"><a href="#42-ping-外部命令" class="headerlink" title="42 ping (外部命令)"></a>42 ping (外部命令)</h2><pre><code>ping -l 65500 -t 192.168.1.200不停的向192.168.1.200计算机发送大小为65500byte的数据包
ping -n 10 127.0.0.1&gt;nulping自己10次，可用于批处理延时10秒
</code></pre><h2 id="43-SC-外部命令-服务控制命令"><a href="#43-SC-外部命令-服务控制命令" class="headerlink" title="43 SC (外部命令)服务控制命令"></a>43 SC (外部命令)服务控制命令</h2><pre><code>sc create aaa displayname= bbb start= auto binpath= &quot;C:\WINDOWS\System32\alg.exe&quot;创建服务，服务名称aaa，显示名称bbb，启动类型:自动可执行文件的路径&quot;C:\WINDOWS\System32\alg.exe&quot;
sc description aaa &quot;ccc&quot;更改aaa的描述为ccc
sc config aaa start= disabled binpath= &quot;C:\WINDOWS\System32\svchost.exe -k netsvcs&quot;更改aaa的启动类型:已禁用更改aaa的可执行文件的路径&quot;C:\WINDOWS\System32\svchost.exe -k netsvcs&quot;
sc config aaa start= demand displayname= ddd更改aaa的启动类型:手动更改aaa的显示名称ddd
sc start aaa启动aaa服务
sc stop aaa停止aaa服务
sc delete aaa删除aaa服务
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://bbs.bathome.net/thread-39-1-1.html" target="_blank" rel="external">http://bbs.bathome.net/thread-39-1-1.html</a></li>
<li><a href="http://www.cnblogs.com/DswCnblog/p/5436245.html" target="_blank" rel="external">http://www.cnblogs.com/DswCnblog/p/5436245.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 批处理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 批处理 </tag>
            
            <tag> bat </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[纪录片《轮回》观后记录]]></title>
      <url>/2017/09/25/samsara_documentary/</url>
      <content type="html"><![CDATA[<p><img src="/2017/09/25/samsara_documentary/samsara.png" alt=""></p>
<p><img src="/2017/09/25/samsara_documentary/douban.png" alt=""></p>
<blockquote>
<p>多图预警，流量慎点。GIF较大，可能加载会比较慢。</p>
</blockquote>
<p>001300 - 001640 延时摄影，日月星辰，风景变换。</p>
<h3 id="001804"><a href="#001804" class="headerlink" title="001804"></a>001804</h3><p><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkp6wv52cj20z50ev1kx.jpg" alt=""></p>
<p>海啸后两幢平房中间翻斜挤压变形的汽车。</p>
<h3 id="00-21-06"><a href="#00-21-06" class="headerlink" title="00:21:06"></a>00:21:06</h3><p><img src="https://wx4.sinaimg.cn/mw690/c38a0784ly1fmkqnssi3jj20ws0elaz2.jpg" alt=""></p>
<p>巴西圣保罗的教堂中，儿童们在接受洗礼。 与此对比的是，00:25:15处一个夭折的小男孩躺在棺材里。 </p>
<h3 id="00-34-50"><a href="#00-34-50" class="headerlink" title="00:34:50"></a>00:34:50</h3><p>车灯比较有意思。车道右侧是向上前进的车，尾灯是红色的，前灯有白色的，还有蓝青色的。</p>
<p><img src="/2017/09/25/samsara_documentary/3.gif" alt=""></p>
<p>追踪汽车尾灯的效果实在是太赞了。 </p>
<h3 id="00-39-49"><a href="#00-39-49" class="headerlink" title="00:39:49"></a>00:39:49</h3><p>法国行为艺术家Olivier de Sagazan震撼人心的表演。此人以往自己脸上身上涂粘土和颜料著称，展现人类内在的兽性。</p>
<p>当这个诡异的类似伏地魔的表演结束之后，用一个机器人表现出震惊的样子，实在是笑死。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkp69l047g20bt08h7wh.gif" alt=""></p>
<p>前面的表演的确震惊，表面斯文的人，作出如此疯狂的动作。</p>
<h3 id="00-41-00"><a href="#00-41-00" class="headerlink" title="00:41:00"></a>00:41:00</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkpldoazvj21ej0l8kjl.jpg" alt=""></p>
<p>人跌倒时候的配乐是亮点，第一次看的时候忍不住笑了，这么正经的片子，居然还有这种效果，哈哈。</p>
<h3 id="00-41-11"><a href="#00-41-11" class="headerlink" title="00:41:11"></a>00:41:11</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkqns1fskj20z60eq1ee.jpg" alt=""><br><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkplbrdpfj20yt0em1kx.jpg" alt=""><br><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkplc97q0j20yz0es1kx.jpg" alt=""></p>
<p>迪拜的一系列人工奇迹：号称世界上唯一的七星级酒店——阿联酋迪拜的阿拉伯塔酒店（Burj Al Arab）。（阿拉伯塔酒店因外形酷似船帆，又称迪拜帆船酒店）</p>
<p>第一张图的右侧是其外观，左侧为清真寺。</p>
<p><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkplcixuoj20z10el7wh.jpg" alt=""><br><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkqnrxy5qj20zk0doe4l.jpg" alt=""></p>
<p>大型的填海工程令人叹为观止。</p>
<p><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkplc8shaj20zg0ez1kx.jpg" alt=""></p>
<p>迪拜的一系列人工奇迹: 迪拜购物中心，全球第一大购物中心。</p>
<p>室内瀑布也是迪拜购物中心的标志景观，位于中庭处，24米高的瀑布至今还保持着一个世界纪录，即世界上第一高的室内喷泉。瀑布中还设置了一排排跳水运动员塑像，动作整齐划一，栩栩如生。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkplcszhuj20yl0eyhcm.jpg" alt=""></p>
<p>迪拜的一系列人工奇迹: 世界第一高楼——哈里发塔（Burj Khalifa），也可译为哈利法塔。</p>
<p>这座全球第一高塔位于Downtown，与迪拜音乐喷泉（The Dubai Fountain）、迪拜购物中心（The Dubai Mall）相距不远。</p>
<h3 id="00-44-35"><a href="#00-44-35" class="headerlink" title="00:44:35"></a>00:44:35</h3><p>两名时尚女郎走在意大利米兰的埃马努埃莱二世拱廊（Galleria Vittorio Emanuele II）中。拱廊一端的斯卡拉大剧院（La Scala）。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkp6aeghxg20bt0721ky.gif" alt=""></p>
<p>左边这妹子的裤子看来需要我帮她提一下哈哈哈。</p>
<h3 id="……"><a href="#……" class="headerlink" title="……"></a>……</h3><p>中间省略一些，主要是繁忙的交通、生产（销毁）流水线、超市疯狂采购以及疯狂吃的人越来越胖具体内容如下：</p>
<p>日本东京繁忙的地铁。一些另类的奇装异服者。</p>
<p>厦门灿坤集团在福建漳州的小家电工厂城。工人们在流水线上如机器人般的劳作。马上跟着回收站中各种电器被压扁、绞碎、封存、筛选。同样是流水作业，一个制造，一个销毁。<br>郑州三全食品股份有限公司的速冻食品生产基地。一个个饺子就这样高效的产出。</p>
<p>在高度机械化的丹麦，一台神奇的机器把一只只活鸡收入囊中。在中国长春，身着粉红色防护服的工人们在把整鸡大卸八块。在美国加州，奶牛们头朝内尾朝外肩并肩的被放在大转盘上转啊转的被挤奶。</p>
<p>超市里，人们在疯狂购物。餐厅里，三个胖子在饕餮着垃圾食品。</p>
<p>最后，讽刺地是，吃胖了的人也得像鸡、猪一样，被画线切开、动手术。</p>
<p>同样需要画线的还有充气娃娃。。。</p>
<h3 id="00-57-30"><a href="#00-57-30" class="headerlink" title="00:57:30"></a>00:57:30</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkqnsykipj20zc0erkga.jpg" alt=""></p>
<p>日本生产充气娃娃的工厂。后面的就不截了。</p>
<h3 id="00-58-35"><a href="#00-58-35" class="headerlink" title="00:58:35"></a>00:58:35</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkqnta9q7j20zc0ey4qp.jpg" alt=""></p>
<p>泰国人妖俱乐部里，人妖们身着比基尼搔首弄姿的跳着钢管舞。</p>
<h3 id="01-00-20"><a href="#01-00-20" class="headerlink" title="01:00:20"></a>01:00:20</h3><p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkqnsdia3j20z10e9x0r.jpg" alt=""></p>
<p>伏见稻荷大社，日本京都市伏见区的稻荷神社（Fushimi Inari-taisha）。竖立的鸟居（Torii）排列成一条长长的甬道，即闻名于世的千本鸟居。</p>
<p>稻荷神是农业与商业的神明，香客前来祭拜求取农作丰收、生意兴隆、交通安全。它是京都地区香火最盛的神社之一。（摘自百科）</p>
<h3 id="01-01-31"><a href="#01-01-31" class="headerlink" title="01:01:31"></a>01:01:31</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkpljuhi3j20z30ef1kx.jpg" alt=""></p>
<p>上海黄浦江畔高楼林立。</p>
<h3 id="01-03-50"><a href="#01-03-50" class="headerlink" title="01:03:50"></a>01:03:50</h3><p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkp6pt1usj20z50eq4qp.jpg" alt=""></p>
<p>菲律宾宿务市（Cebu City）的一个监狱~ 比起让犯人做什么手工活，大概每个月都教他们一个新的舞蹈，还要在家属面前表演…</p>
<p>男人们卖力的跳着，女人们轻柔的和着，典狱长漠然的看着。</p>
<h3 id="01-06-59"><a href="#01-06-59" class="headerlink" title="01:06:59"></a>01:06:59</h3><p><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkqns0xh9j20nm0a0ast.jpg" alt=""></p>
<p>这种房子的结构不错。</p>
<p>一边住人，一边养花草。很赞，第一次见到。</p>
<h3 id="01-10-00"><a href="#01-10-00" class="headerlink" title="01:10:00"></a>01:10:00</h3><p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkplbyledj20xy0ed1kx.jpg" alt="sulphur"></p>
<p>印尼的（卡瓦）伊真（Ijen）（活）火山上，赤膊的工人们在极具腐蚀性的硫酸雾气中把成筐的硫磺矿挑走。</p>
<h3 id="01-17-40"><a href="#01-17-40" class="headerlink" title="01:17:40"></a>01:17:40</h3><p><img src="/2017/09/25/samsara_documentary/yuebing.png" alt=""></p>
<p>中国国庆大阅兵。</p>
<h3 id="01-18-16"><a href="#01-18-16" class="headerlink" title="01:18:16"></a>01:18:16</h3><p><img src="/2017/09/25/samsara_documentary/school.png" alt=""></p>
<p>少林寺塔沟武校。</p>
<p>小时候，看了少年包青天之类的电视剧，就好想去武校学习的啊，可惜。</p>
<h3 id="01-19-31"><a href="#01-19-31" class="headerlink" title="01:19:31"></a>01:19:31</h3><p><img src="https://wx3.sinaimg.cn/mw690/c38a0784ly1fmkp6pck6oj20nm09zam0.jpg" alt=""></p>
<p>韩国的条子。不要问我怎么知道的（看字）。</p>
<h3 id="01-20-00"><a href="#01-20-00" class="headerlink" title="01:20:00"></a>01:20:00</h3><p><img src="https://wx4.sinaimg.cn/mw690/c38a0784ly1fmkp68jz5ej20nm09w188.jpg" alt="Berlin_Wall"></p>
<p>柏林墙是是这种大块的条状建筑组成，上面有很多涂鸦。</p>
<p><img src="/2017/09/25/samsara_documentary/Wailing_Wall.png" alt=""></p>
<p>耶路撒冷哭墙（Western/Wailing Wall）。哭墙是由砖块石头组成。</p>
<p>之前两个没有区分开，所以特此说明一下。</p>
<h3 id="01-33-00"><a href="#01-33-00" class="headerlink" title="01:33:00"></a>01:33:00</h3><p>千手观音是最美的。</p>
<p>由21位聋哑人表演的千手观音舞蹈。领舞是自幼失聪的邰丽华。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkp6a4yhrg20fr07p1ky.gif" alt=""></p>
<p>首尾呼应。此处有表演，开头的时候没有。</p>
<h3 id="01-25-29"><a href="#01-25-29" class="headerlink" title="01:25:29"></a>01:25:29</h3><p>影片接近尾声，镜头来到沙特麦加，记录下几百万汇聚在清真寺周围的虔诚信徒，如沙，如画。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkp68zpl5g20fr06mhdt.gif" alt=""></p>
<p>沙特麦加的禁寺（Masjid al-Haram）朝拜。镜头越来越高，那如沙砾般的白点点啊，围着克尔白（Kaaba）不停的转啊转。 </p>
<p>(让我想起了刚做的数模中动目标检测的那个素材。。17年全国研究生数模D题)</p>
<h3 id="01-30-47"><a href="#01-30-47" class="headerlink" title="01:30:47"></a>01:30:47</h3><p>转眼间，镜头又回到了华美绚烂而又精密有序的坛城沙画。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkplcn5epj20vi0dbb29.jpg" alt=""></p>
<p>然而，讶异的观众们此时看见，这个刚刚用沙子堆砌起来的世界，历经了积年累月呕心沥的创作，却在完成之后被毫不犹豫地全盘抹去。</p>
<p><img src="https://wx1.sinaimg.cn/mw690/c38a0784ly1fmkqnrutzaj20nm0a97n3.jpg" alt=""></p>
<p>一件拥有无上艺术价值的作品，顷刻之间，便化为乌有。</p>
<p>对于修行者来说，他们和它们的使命都已完成。于是那些色泽明艳的细沙将被装入瓶中，倾倒入河，顺流而去。</p>
<p><img src="https://wx2.sinaimg.cn/mw690/c38a0784ly1fmkqnrwlpej20nm0aawwb.jpg" alt=""></p>
<p><strong>繁华世界，不过一掬细沙</strong>。</p>
<blockquote>
<p>部分文字参考自豆瓣影评<a href="https://movie.douban.com/review/5584916/" target="_blank" rel="external">一沙一世界</a>，<a href="https://movie.douban.com/review/5815859/" target="_blank" rel="external">无声引导沉思</a>。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 观影指南 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 轮回 </tag>
            
            <tag> 纪录片 </tag>
            
            <tag> samsara </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DeepLearnToolBox之BP算法]]></title>
      <url>/2017/09/23/DeepLearnToolBox_BP/</url>
      <content type="html"><![CDATA[<h1 id="工具箱下载"><a href="#工具箱下载" class="headerlink" title="工具箱下载"></a>工具箱下载</h1><p>下载地址：<br><a href="https://github.com/rasmusbergpalm/DeepLearnToolbox" target="_blank" rel="external">https://github.com/rasmusbergpalm/DeepLearnToolbox</a></p>
<h1 id="总体测试代码"><a href="#总体测试代码" class="headerlink" title="总体测试代码"></a>总体测试代码</h1><p>\tests\test_example_NN.m</p>
<pre><code>nn = nnsetup([784 100 10]);  
opts.numepochs =  1;   //  Number of full sweeps through data  
opts.batchsize = 100;  //  Take a mean gradient step over this many samples  
[nn, L] = nntrain(nn, train_x, train_y, opts);  
[er, bad] = nntest(nn, test_x, test_y); 
</code></pre><p>很简单的几步就训练了一个NN，我们发现其中最重要的几个函数就是<code>nnsetup</code>,<code>nntrain</code>和<code>nntest</code>了。</p>
<h1 id="nnsetup"><a href="#nnsetup" class="headerlink" title="nnsetup"></a>nnsetup</h1><p><code>NNSETUP</code>创建前向反馈神经网络。</p>
<h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><p>详细代码如下：</p>
<pre><code>function nn = nnsetup(architecture)
%NNSETUP creates a Feedforward Backpropagate Neural Network
% nn = nnsetup(architecture) returns an neural network structure with n=numel(architecture)
% layers, architecture being a n x 1 vector of layer sizes e.g. [784 100 10]

    nn.size   = architecture;
    nn.n      = numel(nn.size);

    nn.activation_function              = &apos;tanh_opt&apos;;   %  Activation functions of hidden layers: &apos;sigm&apos; (sigmoid) or &apos;tanh_opt&apos; (optimal tanh).
    nn.learningRate                     = 1;            %  learning rate Note: typically needs to be lower when using &apos;sigm&apos; activation function and non-normalized inputs.
    nn.momentum                         = 0.5;          %  Momentum 权值动量因子
    nn.scaling_learningRate             = 1;            %  Scaling factor for the learning rate (each epoch) 学习率变化因子 (each epoch)
    nn.weightPenaltyL2                  = 0;            %  L2 regularization
    nn.nonSparsityPenalty               = 0;            %  Non sparsity penalty 非稀疏惩罚
    nn.sparsityTarget                   = 0.05;         %  Sparsity target 稀疏目标值
    nn.inputZeroMaskedFraction          = 0;            %  Used for Denoising AutoEncoders 自动编码的去噪作用
    nn.dropoutFraction                  = 0;            %  Dropout level (http://www.cs.toronto.edu/~hinton/absps/dropout.pdf)
    nn.testing                          = 0;            %  Internal variable. nntest sets this to one. 一个标志参数--在nntest.m这个函数中会用到
    nn.output                           = &apos;softmax&apos;;       %  output unit &apos;sigm&apos; (=logistic), &apos;softmax&apos; and &apos;linear&apos;

    for i = 2 : nn.n   
        % weights and weight momentum
        nn.W{i - 1} = (rand(nn.size(i), nn.size(i - 1)+1) - 0.5) * 2 * 4 * sqrt(6 / (nn.size(i) + nn.size(i - 1)));
        nn.vW{i - 1} = zeros(size(nn.W{i - 1}));

        % average activations (for use with sparsity)
        nn.p{i}     = zeros(1, nn.size(i));   
    end
end
</code></pre><p>nnsetup初始化网络结构以及一系列参数。对照着代码，看一下具体含义。</p>
<p><code>nn = nnsetup(architecture)</code>返回一个神经网络结构，<code>architecture</code>为结构参数。<code>architecture</code>是一个n x 1 向量，表示每一层神经元的个数。</p>
<p>比如<code>architecture=[784 100 10]</code>，表示输入层为784维输入，100个隐含层，10个输出层</p>
<p>为什么是输入为784：因为每一个手写体大小为28*28的，也就是784维度</p>
<p>隐含层为什么是100：随便设置的，可以随意修改，需要设计</p>
<p>输出为什么是10：手写体有0-9这10种结果，所以为10</p>
<p>//对每一层的网络结构进行初始化，一共三个参数W,vW，p，其中W是主要的参数<br>//<code>vW</code>是更新参数时的临时参数，p是所谓的<code>sparsity</code>，(等看到代码了再细讲) </p>
<p>##使用实例</p>
<pre><code>nn=nnsetup([size(feature,2) 200 200 length(azimuth)]);
</code></pre><h1 id="nntrain"><a href="#nntrain" class="headerlink" title="nntrain"></a>nntrain</h1><p>截取出的主要框架为：</p>
<pre><code>for i = 1 : numepochs 
    for l = 1 : numbatches  

        nn = nnff(nn, batch_x, batch_y);  
        nn = nnbp(nn);  
        nn = nnapplygrads(nn);  
        L(n) = nn.L;  
        n = n + 1;  
    end  
end  
</code></pre><p>第一层for循环为迭代次数。第二次为遍历所有的batch。其中，先计算前向传播（<code>ff</code>），在计算反向传播（<code>bp</code>），接着更新参数（<code>nnapplygrads</code>），最后计算损失函数（代价函数）L。</p>
<p>下面分析三个函数<code>nnff</code>,<code>nnbp</code>和<code>nnapplygrads</code>。</p>
<h2 id="nnff"><a href="#nnff" class="headerlink" title="nnff"></a>nnff</h2><p>nnff就是进行<code>feedforward pass</code>，其实非常简单，就是整个网络正向跑一次就可以了</p>
<p>当然其中有dropout和sparsity的计算,具体的参见论文“<code>Improving Neural Networks with Dropout</code>“和<code>Autoencoders and Sparsity</code></p>
<p>提取出主要框架为：</p>
<pre><code>for i = 2 : n-1  （遍历隐含层）
    //根据激活函数计算隐层输出

    //隐层的dropout计算，舍弃部分输出

    //计算sparsity，nonSparsityPenalty 是对没达到sparsitytarget的参数的惩罚系数

    //Add the bias term 
end

//根据输出层的结构计算输出层的输出。

//计算误差以及损失函数  
</code></pre><h2 id="nnbp"><a href="#nnbp" class="headerlink" title="nnbp"></a>nnbp</h2><p>代码：<code>\NN\nnbp.m</code><br>nnbp呢是进行<code>back propagation</code>的过程。值得注意的还是dropout和sparsity的部分。</p>
<p>提取出主要框架为：</p>
<pre><code>①计算输出层的输出
②依次反向计算隐层输出
for i = (n - 1) : -1 : 2 （反向遍历隐层）
    d_act为隐层 激活函数的导数

    d{i}为隐层输出函数的导数。 计算中用到非稀疏惩罚项，以及dropout
end

③计算权值的导数nn.dW{i}
</code></pre><p>dW{i}基本就是计算的<code>gradient</code>(梯度)了，只是后面还要加入一些东西，进行一些修改。</p>
<h2 id="nnapplygrads"><a href="#nnapplygrads" class="headerlink" title="nnapplygrads"></a>nnapplygrads</h2><p>代码文件：<code>\NN\nnapplygrads.m</code></p>
<pre><code>for i = 1 : (nn.n - 1)

    //应用weightPenaltyL2，learningRate ，momentum修正dW

    nn.W{i} = nn.W{i} - dW;  //权值W更新

end
</code></pre><p>这个内容就简单了，<code>nn.weightPenaltyL2</code>是<code>weight decay</code>的部分，也是nnsetup时可以设置的一个参数</p>
<p>有的话就加入<code>weight Penalty</code>，防止过拟合，然后再根据<code>momentum</code>的大小调整一下，最后改变<code>nn.W{i}</code>即可</p>
<h1 id="nntest"><a href="#nntest" class="headerlink" title="nntest"></a>nntest</h1><pre><code>function [er, bad] = nntest(nn, x, y)  
    labels = nnpredict(nn, x);  
    [~, expected] = max(y,[],2);  
    bad = find(labels ~= expected);      
    er = numel(bad) / size(x, 1);  
end  
</code></pre><p><code>nntest</code>再简单不过了，就是调用一下<code>nnpredict</code>，在和test的集合进行比较</p>
<h2 id="nnpredict"><a href="#nnpredict" class="headerlink" title="nnpredict"></a>nnpredict</h2><p>代码文件：<code>\NN\nnpredict.m</code></p>
<pre><code>function labels = nnpredict(nn, x)  
    nn.testing = 1;  
    nn = nnff(nn, x, zeros(size(x,1), nn.size(end)));  
    nn.testing = 0;  

    [~, i] = max(nn.a{end},[],2);  
    labels = i;  
end  
</code></pre><p>继续非常简单，<code>predict</code>不过是<code>nnff</code>一次，得到最后的output~~</p>
<p><code>max(nn.a{end},[],2);</code> 是返回每一行的最大值以及所在的列数，所以labels返回的就是标号啦<br>(这个test好像是专门用来test分类问题的，我们知道nnff得到最后的值即可)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章只要是基于代码的简单分析，基于公式推导的文章请参阅：<a href="https://qwerty200696.github.io/2017/09/12/BP_derivation/" target="_blank" rel="external">BP神经网络部分具体的推导</a>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.sina.com.cn/s/blog_4a1853330102vupc.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4a1853330102vupc.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017“华为杯”第十四届中国研究生数学建模竞赛回顾]]></title>
      <url>/2017/09/22/review_of_MathModel/</url>
      <content type="html"><![CDATA[<h1 id="试题下载地址"><a href="#试题下载地址" class="headerlink" title="试题下载地址"></a>试题下载地址</h1><p>中国研究生数模竞赛官网：<a href="http://gmcm.seu.edu.cn/01/49/c12a329/page.htm" title="2017年研究生数模竞赛试题公布" target="_blank" rel="external">http://gmcm.seu.edu.cn/01/49/c12a329/page.htm</a></p>
<p>我们组选择了D题。</p>
<h2 id="D题题目"><a href="#D题题目" class="headerlink" title="D题题目"></a>D题题目</h2><h3 id="基于监控视频的前景目标提取"><a href="#基于监控视频的前景目标提取" class="headerlink" title="基于监控视频的前景目标提取"></a>基于监控视频的前景目标提取</h3><p>视频监控是中国安防产业中最为重要的信息获取手段。随着“平安城市”建设的顺利开展，各地普遍安装监控摄像头，利用大范围监控视频的信息，应对安防等领域存在的问题。近年来，中国各省市县乡的摄像头数目呈现井喷式增长，大量企业、部门甚至实现了监控视频的全方位覆盖。如北京、上海、杭州监控摄像头分布密度约分别为71、158、130个/平方公里，摄像头数量分别达到115万、100万、40万，为我们提供了丰富、海量的监控视频信息。</p>
<p>目前，监控视频信息的自动处理与预测在信息科学、计算机视觉、机器学习、模式识别等多个领域中受到极大的关注。而如何有效、快速抽取出监控视频中的前景目标信息，是其中非常重要而基础的问题[1-6]。这一问题的难度在于，需要有效分离出移动前景目标的视频往往具有复杂、多变、动态的背景[7，8]。这一技术往往能够对一般的视频处理任务提供有效的辅助。以筛选与跟踪夜晚时罪犯这一应用为例：若能够预先提取视频前景目标，判断出哪些视频并未包含移动前景目标，并事先从公安人员的辨识范围中排除；而对于剩下包含了移动目标的视频，只需辨识排除了背景干扰的纯粹前景，对比度显著，肉眼更易辨识。因此，这一技术已被广泛应用于视频目标追踪，城市交通检测，长时场景监测，视频动作捕捉，视频压缩等应用中。</p>
<p>下面简单介绍一下视频的存储格式与基本操作方法。一个视频由很多帧的图片构成，当逐帧播放这些图片时，类似放电影形成连续动态的视频效果。从数学表达上来看，存储于计算机中的视频，可理解为一个3维数据，其中代表视频帧的长，宽，代表视频帧的帧数。视频也可等价理解为逐帧图片的集合，即，其中为一张长宽分别为的图片。3维矩阵的每个元素（代表各帧灰度图上每个像素的明暗程度）为0到255之间的某一个值，越接近0，像素越黑暗；越接近255，像素越明亮。通常对灰度值预先进行归一化处理（即将矩阵所有元素除以255），可将其近似认为[0,1]区间的某一实数取值，从而方便数据处理。一张彩色图片由R（红），G（绿），B（蓝）三个通道信息构成，每个通道均为同样长宽的一张灰度图。由彩色图片构成的视频即为彩色视频。本问题中，可仅考虑黑白图片构成的视频。在Matlab环境下，视频的读取、播放及相应基本操作程序见附件1。如采用其他编程环境，也可查阅相关资料获得相应操作程序。</p>
<p>题目的监控视频主要由固定位置监控摄像头拍摄，要解决的问题为提取视频前景目标。请研究生通过设计有效的模型与方法，自动从视频中分离前景目标。注意此类视频的特点是相对于前景目标，背景结构较稳定，变化幅度较小，可充分利用该信息实现模型与算法设计。</p>
<p>请你们查阅相关资料和数据，结合视频数据特点，回答下列问题：</p>
<h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a><strong>问题1</strong></h3><p>对一个不包含动态背景、摄像头稳定拍摄时间大约5秒的监控视频，构造提取前景目标（如人、车、动物等）的数学模型，并对该模型设计有效的求解方法，从而实现类似图1的应用效果。（附件2提供了一些符合此类特征的监控视频）</p>
<p><img src="/2017/09/22/review_of_MathModel/pic_1.png" alt=""></p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a><strong>问题2</strong></h3><p>对包含动态背景信息的监控视频（如图2所示），设计有效的前景目标提取方案。（附件2中提供了一些符合此类特征的典型监控视频）</p>
<p><img src="/2017/09/22/review_of_MathModel/pic_2.png" alt=""></p>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a><strong>问题3</strong></h3><p>在监控视频中，当监控摄像头发生晃动或偏移时，视频也会发生短暂的抖动现象（该类视频变换在短时间内可近似视为一种线性仿射变换，如旋转、平移、尺度变化等）。对这种类型的视频，如何有效地提取前景目标？（附件2中提供了一些符合此类特征的典型监控视频，其它一些典型视频可从 <a href="http://wordpress-jodoin.dmi.usherb.ca/dataset2014/" target="_blank" rel="external">http://wordpress-jodoin.dmi.usherb.ca/dataset2014/</a> 下载）</p>
<h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a><strong>问题4</strong></h3><p>在附件3中提供了8组视频（avi文件与mat文件内容相同）。请利用你们所构造的建模方法，从每组视频中选出包含显著前景目标的视频帧标号，并将其在建模论文正文中独立成段表示。务须注明前景目标是出现于哪一个视频（如Campus视频）的哪些帧（如241-250，421-432帧）。</p>
<h3 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a><strong>问题5</strong></h3><p>如何通过从不同角度同时拍摄的近似同一地点的多个监控视频中（如图3所示）有效检测和提取视频前景目标？请充分考虑并利用多个角度视频的前景之间（或背景之间）相关性信息（一些典型视频可从<br><a href="http://cvlab.epfl.ch/research/surv/multi-people-tracking" target="_blank" rel="external">http://cvlab.epfl.ch/research/surv/multi-people-tracking</a> 下载）</p>
<p><img src="/2017/09/22/review_of_MathModel/pic_3.png" alt=""></p>
<h3 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a><strong>问题6</strong></h3><p>利用所获取前景目标信息，能否自动判断监控视频中有无人群短时聚集、人群惊慌逃散、群体规律性变化（如跳舞、列队排练等）、物体爆炸、建筑物倒塌等异常事件？可考虑的特征信息包括前景目标奔跑的线性变化形态特征、前景规律性变化的周期性特征等。尝试对更多的异常事件类型，设计相应的事件检测方案。（请从网络下载包含各种事件的监控视频进行算法验证）</p>
<p>注：强烈建议深刻考虑问题内涵，建造合理、高效的数学模型和求解方法，鼓励进行具有开放思路与创新思维的探索性尝试。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] Andrews Sobral &amp; Antoine Vacavant, A comprehensive review of background subtraction algorithms evaluated with synthetic and real videos, Computer Vision and Image Understanding, Volume 122, May 2014, Pages 4-21</p>
<p>[2] B. Lee and M. Hedley, “Background estimation for video surveillance,” IVCNZ02, pp. 315–320, 2002.</p>
<p>[3] C. Stauffer and W. E. L. Grimson, “Adaptive background mixture models for real-time tracking,” in Computer Vision and Pattern Recognition, 1999. IEEE Computer Society Conference on., vol. 2. IEEE, 1999.</p>
<p>[4] E. J. Cand`es, X. Li, Y. Ma, and J. Wright, “Robust principal component analysis?” Journal of the ACM (JACM), vol. 58, no. 3, p. 11, 2011.</p>
<p>[5] D. Meng and F. De la Torre, “Robust matrix factorization with unknown noise,” in IEEE International Conference on Computer Vision, 2013, pp. 1337–1344.</p>
<p>[6] Q. Zhao, D. Meng, Z. Xu,W. Zuo, and L. Zhang, “Robust principal component analysis with complex noise,” in Proceedings of the 31st International Conference on Machine Learning (ICML-14), 2014, pp. 55–63.</p>
<p>[7] Y. Peng, A. Ganesh, J. Wright, W. Xu, and Y. Ma, “RASL: Robust alignment by sparse and low-rank decomposition for linearly correlated images,” Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 34, no. 11, pp. 2233–2246, 2012.</p>
<p>[8] M. Babaee, D. T. Dinh, and G. Rigoll, “A deep convolutional neural network for background subtraction,” arXiv preprint arXiv: 1702.01731, 2017.</p>
<h1 id="思路流程"><a href="#思路流程" class="headerlink" title="思路流程"></a>思路流程</h1><p>不阐述为什么这么做（因为我也不知道为什么），只记录下我所做的工作历程。</p>
<h2 id="BGSLibrary编译安装与BGSlibrary-GUI的下载与使用"><a href="#BGSLibrary编译安装与BGSlibrary-GUI的下载与使用" class="headerlink" title="BGSLibrary编译安装与BGSlibrary GUI的下载与使用"></a>BGSLibrary编译安装与BGSlibrary GUI的下载与使用</h2><p>这部分详情可参考我的博客：<a href="https://qwerty200696.github.io/2017/09/20/BGSlibrary/" target="_blank" rel="external">https://qwerty200696.github.io/2017/09/20/BGSlibrary/</a></p>
<h2 id="ViBe算法"><a href="#ViBe算法" class="headerlink" title="ViBe算法"></a>ViBe算法</h2><p>一种像素级视频背景建模或前景检测的算法。</p>
<p>详细地可参考ViBe算法官网主页：<a href="http://www.telecom.ulg.ac.be/research/vibe/" target="_blank" rel="external">ViBe官网链接</a></p>
<p>该官网包含ViBe源码以及可在Windows和Linux中运行的程序。想了解该算法的童鞋可以详细探索该网站。</p>
<p>这篇<a href="http://blog.csdn.net/zouxy09/article/details/9622285" target="_blank" rel="external">CSDN博客</a>介绍的也比较全面，可作参考。</p>
<h2 id="光流法"><a href="#光流法" class="headerlink" title="光流法"></a>光流法</h2><p>LK光流法分析及其源码请参考我的这篇文章：<a href="https://qwerty200696.github.io/2017/09/21/optical_flow/" target="_blank" rel="external">https://qwerty200696.github.io/2017/09/21/optical_flow/</a></p>
<h2 id="视频抗抖动算法"><a href="#视频抗抖动算法" class="headerlink" title="视频抗抖动算法"></a>视频抗抖动算法</h2><p>参考链接：<a href="http://nghiaho.com/?p=2093" target="_blank" rel="external">SIMPLE VIDEO STABILIZATION USING OPENCV</a></p>
<p>采用的方法是基于optical flow 光流法。</p>
<p>算法流程：</p>
<p>&emsp;1 使用所有帧中的光流信息来查找从前一帧到当前帧的转换</p>
<p>&emsp;2 累积变换以获得每个帧的x，y，a 的轨迹</p>
<p>&emsp;3 使用滑动平均窗口对轨迹平滑处理</p>
<p>&emsp;4 创建一个新的变换，使得$F_{new}$ = $F_{old}$ + ( $T_{smoothed}$ - $T_{before}$ )</p>
<p>&emsp;5 将新的转换应用到视频中，得到去抖后的视频</p>
<p>其中 dx、dy 为x 和y 方向的流向，da 为抖动中旋转角度的变化量; $F_{new}$、$F_{old}$分别为新的变换与原先的变换，$T_{smoothed}$、$T_{before}$分别为平滑前后的轨迹。</p>
<p><font color="#FF0000"> Camera Jitter 相机抖动</font> 数据集下载：<br><a href="http://wordpress-jodoin.dmi.usherb.ca/dataset2014/" target="_blank" rel="external">http://wordpress-jodoin.dmi.usherb.ca/dataset2014/</a></p>
<h2 id="opencv视频保存方法"><a href="#opencv视频保存方法" class="headerlink" title="opencv视频保存方法"></a>opencv视频保存方法</h2><p>视频保存方法请参考这篇博文：<a href="https://qwerty200696.github.io/2017/09/21/opencv_SaveVideo/" target="_blank" rel="external">https://qwerty200696.github.io/2017/09/21/opencv_SaveVideo/</a></p>
<h2 id="opencv-contrib安装"><a href="#opencv-contrib安装" class="headerlink" title="opencv_contrib安装"></a>opencv_contrib安装</h2><p>opencv_contrib的安装说明可以参考这篇博文<a href="https://qwerty200696.github.io/2017/09/21/opencv_contrib/" target="_blank" rel="external">https://qwerty200696.github.io/2017/09/21/opencv_contrib/</a></p>
<h2 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h2><h3 id="动目标检测"><a href="#动目标检测" class="headerlink" title="动目标检测"></a>动目标检测</h3><p><a href="http://wordpress-jodoin.dmi.usherb.ca/dataset2014/" target="_blank" rel="external">dataset 2014</a> 里面的视频分类详细，很好的数据集。</p>
<h3 id="目标跟踪"><a href="#目标跟踪" class="headerlink" title="目标跟踪"></a>目标跟踪</h3><p><a href="http://www.learnopencv.com/object-tracking-using-opencv-cpp-python/" target="_blank" rel="external">Object Tracking using OpenCV (C++/Python)</a></p>
<p>这个算是做的比较好的了，很有参考价值。</p>
<p>D题问题五给出的网址：<a href="http://cvlab.epfl.ch/research/surv/multi-people-tracking" target="_blank" rel="external">http://cvlab.epfl.ch/research/surv/multi-people-tracking</a></p>
<p>视频流跟踪目标<a href="https://github.com/gnebehay/OpenTLD" target="_blank" rel="external">OpenTLD</a></p>
<p><a href="http://mha.cs.umn.edu/proj_tracking.shtml" target="_blank" rel="external">Real-Time Tracking</a></p>
<h3 id="多角度多目标跟踪"><a href="#多角度多目标跟踪" class="headerlink" title="多角度多目标跟踪"></a>多角度多目标跟踪</h3><p><a href="http://www.pierrebaque.com/page-DeepOcclusion/" target="_blank" rel="external">Deep Occlusion Reasoning for Multi-Camera Multi-Target Detection</a></p>
<p><a href="https://github.com/pierrebaque/DeepOcclusion" target="_blank" rel="external">DeepOcclusion</a></p>
<h3 id="人群异常行为检测"><a href="#人群异常行为检测" class="headerlink" title="人群异常行为检测"></a>人群异常行为检测</h3><p><a href="http://groups.inf.ed.ac.uk/vision/BEHAVEDATA/INTERACTIONS/" target="_blank" rel="external">BEHAVE Interactions Test Case Scenarios</a></p>
<p><a href="http://mha.cs.umn.edu/proj_events.shtml" target="_blank" rel="external">Detection of Events</a></p>
<p>UCF数据集：<a href="http://crcv.ucf.edu/data/crowd.php" target="_blank" rel="external">Crowd Segmentation Data Set</a> 这是正常行为的，没找到不正常行为的。据说有的。</p>
<p><img src="/2017/09/22/review_of_MathModel/UCF.jpg" alt=""></p>
<p>UMN数据集：<a href="http://mha.cs.umn.edu/Movies/Crowd-Activity-All.avi" target="_blank" rel="external">Detection of Unusual Crowd Activity</a></p>
<p><img src="/2017/09/22/review_of_MathModel/UMN.jpg" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，花了两天时间稍微记录了一下我自己做的工作吧，算是opencv小白入门记。（之后暂时应该不会研究了，毕竟不是学这个的）</p>
<p>最后附上一个收录计算机视觉题材的地址：<a href="https://github.com/imistyrain/Way4CV" target="_blank" rel="external">百炼成金，计算机视觉修炼之道</a>，想要从事相关研究的童鞋不容错过。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[opencv_contrib安装说明与错误解决方案]]></title>
      <url>/2017/09/21/opencv_contrib/</url>
      <content type="html"><![CDATA[<p>在数模的时候，需要实现目标跟踪，因此需要安装opencv附加库，即opencv_contrib。</p>
<p>没有安装该附加库的时候，会提示如下错误：</p>
<p><img src="/2017/09/21/opencv_contrib/no_tracking.png" alt=""></p>
<h2 id="opencv-contrib下载"><a href="#opencv-contrib下载" class="headerlink" title="opencv_contrib下载"></a>opencv_contrib下载</h2><p><code>opencv_contrib</code>的项目地址为：<a href="https://github.com/opencv/opencv_contrib" target="_blank" rel="external">https://github.com/opencv/opencv_contrib</a></p>
<p>先将<code>opencv_contrib</code>下载下来，为后续安装做准备。</p>
<p>此外还需要的是<a href="https://github.com/opencv/opencv" target="_blank" rel="external">opencv</a>以及<a href="https://cmake.org/download/" target="_blank" rel="external">cmake</a>。</p>
<h2 id="opencv-contrib安装步骤概述"><a href="#opencv-contrib安装步骤概述" class="headerlink" title="opencv_contrib安装步骤概述"></a>opencv_contrib安装步骤概述</h2><h3 id="windows控制台"><a href="#windows控制台" class="headerlink" title="windows控制台"></a>windows控制台</h3><p>依次输入如下命令：</p>
<pre><code>$ cd &lt;opencv_build_directory&gt;
$ cmake -DOPENCV_EXTRA_MODULES_PATH=&lt;opencv_contrib&gt;/modules &lt;opencv_source_directory&gt;
$ make -j5
</code></pre><p>之后会在<code>&lt;opencv_build_directory&gt;</code>目录下生成<code>opencv_contrib</code>库的所有模块。如果不想安装所有的模块，则使用<code>cmake</code>命令的<code>BUILD_opencv_*</code>选项。示例程序如下：</p>
<pre><code>$ cmake -DOPENCV_EXTRA_MODULES_PATH=&lt;opencv_contrib&gt;/modules -DBUILD_opencv_legacy=OFF &lt;opencv_source_directory&gt;
</code></pre><h3 id="GUI图形界面安装"><a href="#GUI图形界面安装" class="headerlink" title="GUI图形界面安装"></a>GUI图形界面安装</h3><ul>
<li>打开<code>cmake-gui</code>；</li>
</ul>
<ul>
<li>选择源码文件夹以及build文件夹；</li>
</ul>
<ul>
<li>点击<code>configue</code>按钮。可以看到opencv build时的一系列参数；</li>
</ul>
<ul>
<li>浏览参数并找到<code>OPENCV_EXTRA_MODULES_PATH</code>，将其路径设为<code>&lt;opencv_contrib&gt;/modules</code>；</li>
</ul>
<p><img src="/2017/09/21/opencv_contrib/extra_path.jpg" alt="extra_path"></p>
<ul>
<li>点击<code>configue</code>按钮，完成后再点击<code>generate</code>按钮。（第一次会询问Makefile的类型）</li>
</ul>
<ul>
<li><p>点击open project，使用你选择的方法来生成<code>opencv core</code>。(上一步是Unix makfile，则相应的make，make install)</p>
</li>
<li><p>在自己的代码/IDE中添加相应模块的连接器标志（linker flags）。比如想使用aruco模块，则需要加上<code>&quot;-lopencv_aruco&quot;</code>。</p>
</li>
</ul>
<blockquote>
<p>上述步骤为该项目英文安装指南对应的翻译。</p>
</blockquote>
<p>图形界面的安装可参考这篇文章：<br><a href="http://blog.csdn.net/cv_jason/article/details/70037545" target="_blank" rel="external">http://blog.csdn.net/cv_jason/article/details/70037545</a></p>
<h2 id="opencv-contrib安装错误解决方案"><a href="#opencv-contrib安装错误解决方案" class="headerlink" title="opencv_contrib安装错误解决方案"></a>opencv_contrib安装错误解决方案</h2><h3 id="cmake出错Failed-to-download"><a href="#cmake出错Failed-to-download" class="headerlink" title="cmake出错Failed to download"></a>cmake出错Failed to download</h3><p>Cmd下输入</p>
<pre><code>wang@wang-PC MINGW64 /d/Program Files/opencv3/build
$ cmake -DOPENCV_EXTRA_MODULES_PATH=&quot;D:\opencv_contrib-master\modules&quot; &quot;D:\Program Files\opencv3\sources&quot;
</code></pre><p>时出现下载错误，如下图所示：</p>
<p><img src="/2017/09/21/opencv_contrib/cmake_error.png" alt=""></p>
<pre><code>CMake Error at D:/Program Files/opencv3/sources/cmake/OpenCVUtils.cmake:1047 (message):
  Failed to download .  Status=
Call Stack (most recent call first):
  D:/opencv_contrib-master/modules/dnn_modern/CMakeLists.txt:18 (ocv_download)
</code></pre><p>即：无法下载对应的模块。</p>
<p>遇到此错误的解决方案为：将以下三处的<code>filename</code>改为<code>PACKAGE</code>。（代码中的<code>PACKAGE</code>原为<code>filename</code>）</p>
<pre><code>D:\opencv\opencv_contrib\modules\dnn_modern\CMakeLists.txt
20行改为
ocv_download(PACKAGE &quot;v1.0.0a3.tar.gz&quot;

D:\opencv\opencv_contrib\modules\xfeatures2d\cmake\download_boostdesc.cmake
22行改为
 ocv_download(PACKAGE ${name_${id}}

D:\opencv\opencv_contrib\modules\xfeatures2d\cmake\download_vgg.cmake
16行改为
ocv_download(PACKAGE ${name_${id}}
</code></pre><p>修改后安装成功，可以在输出中查看具体的安装信息：</p>
<p><img src="/2017/09/21/opencv_contrib/cmake_ok.png" alt=""></p>
<p>从图中可以发现，我所需要的tracking库也已经安装成功了。</p>
<h3 id="没有make指令"><a href="#没有make指令" class="headerlink" title="没有make指令"></a>没有make指令</h3><p>在使用命令行界面安装时，没有最后一步的make指令。</p>
<p>那么只能自己安装了。或者直接用cmake GUI安装。</p>
<p>打开之前<code>opencv_contrib</code>的build文件夹，找到已经生成的opencv项目并打开。</p>
<p>打开VS之后，可以看到完整的OpenCV项目。然后直接编译即可（看个人情况，可自行选择Release或者Debug）。时间相当长。。。</p>
<p>编译成功后，在<code>CMakeTargets</code>中找到<code>INSTALL</code>，然后生成INSTALL，得到我们想要的最终文件。</p>
<h2 id="半永久配置"><a href="#半永久配置" class="headerlink" title="半永久配置"></a>半永久配置</h2><p>上述步骤的确很麻烦，并且非常容易出错。</p>
<p>有热心网友给出了自己配置好的文件，可以半永久配置。读者感兴趣的可以自己尝试下：<a href="http://www.cnblogs.com/wjy-lulu/p/6605306.html" target="_blank" rel="external">http://www.cnblogs.com/wjy-lulu/p/6605306.html</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><p><a href="https://stackoverflow.com/questions/28619037/opencv-where-is-tracking-hpp" target="_blank" rel="external">https://stackoverflow.com/questions/28619037/opencv-where-is-tracking-hpp</a></p>
</li>
<li><p><a href="http://blog.csdn.net/qsy2000/article/details/70158537" target="_blank" rel="external">http://blog.csdn.net/qsy2000/article/details/70158537</a></p>
</li>
<li><p><a href="http://blog.csdn.net/cv_jason/article/details/70037545" target="_blank" rel="external">http://blog.csdn.net/cv_jason/article/details/70037545</a></p>
</li>
</ol>
<blockquote>
<p>其实这篇教程写的并不算太详细，cmake GUI可以对照着第三个博客安装。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 邂逅opencv </category>
            
        </categories>
        
        
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客使用MathJax并解决markdown渲染冲突问题]]></title>
      <url>/2017/09/21/markdown_mathjax/</url>
      <content type="html"><![CDATA[<h2 id="利用MathJax来渲染LaTeX数学公式"><a href="#利用MathJax来渲染LaTeX数学公式" class="headerlink" title="利用MathJax来渲染LaTeX数学公式"></a>利用MathJax来渲染LaTeX数学公式</h2><p>hexo主题Next中已经集成了对mathjax的支持。在<code>主题配置文件</code>，<code>blog\themes\next\_config.yml</code>中定位到如下片段:</p>
<pre><code># MathJax Support
mathjax:
  enable: true
  per_page: false
  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML
</code></pre><p>将enable中的false改为true即可。</p>
<p>另外，再安装一个自动部署MathJax的<a href="http://catx.me/2014/03/09/hexo-mathjax-plugin/" target="_blank" rel="external">hexo插件</a> 。安装方式也很简单，在你的博客文件夹下执行：</p>
<pre><code>npm install hexo-math --save
hexo math install
</code></pre><p>然后在新建的博文中写上一个麦克斯韦方程组查看LaTeX效果：</p>
<pre><code>$$
\begin{eqnarray}
\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\
\nabla\cdot\vec{B} &amp;=&amp; 0 \\
\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\
\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)
\end{eqnarray}
$$
</code></pre><p>$$<br>\begin{eqnarray}<br>\nabla\cdot\vec{E} &amp;=&amp; \frac{\rho}{\epsilon_0} \\<br>\nabla\cdot\vec{B} &amp;=&amp; 0 \\<br>\nabla\times\vec{E} &amp;=&amp; -\frac{\partial B}{\partial t} \\<br>\nabla\times\vec{B} &amp;=&amp; \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)<br>\end{eqnarray}<br>$$</p>
<p>这时如果你会发现出了一些问题，原因是hexo先用<code>marked.js</code>渲染，然后再交给<code>MathJax</code>渲染。在<code>marked.js</code>渲染的时候下划线_是被escape掉并且换成了<code>&lt;em&gt;</code>标签，即斜体字，另外LaTeX中的<code>\\</code>也会被转义成一个\，这样会导致<code>MathJax</code>渲染时不认为它是一个换行符了。</p>
<h2 id="mathjax与markdown默认渲染冲突"><a href="#mathjax与markdown默认渲染冲突" class="headerlink" title="mathjax与markdown默认渲染冲突"></a>mathjax与markdown默认渲染冲突</h2><p>解决方案为：修改Hexo渲染源码。</p>
<p>这个方法是我目前使用的，相对来说，通用性较高的一种方式。思路就是修改hexo的渲染源码: <code>nodes_modules/lib/marked/lib/marked.js</code>:</p>
<ul>
<li>去掉<code>\</code>的额外转义</li>
</ul>
<ul>
<li>将em标签对应的符号中，去掉_,因为<code>markdown</code>中有<code>*</code>可以表示斜体，<code>—</code>就去掉了。</li>
</ul>
<p>具体思路参考了使Marked.js与MathJax共存, 打开<code>nodes_modules/marked/lib/marked.js</code>:<br>第一步: 找到下面的代码:</p>
<pre><code>escape: /^\\([\\`*{}\[\]()# +\-.!_&gt;])/,
</code></pre><p>改为:</p>
<pre><code>escape: /^\\([`*{}\[\]()# +\-.!_&gt;])/,
</code></pre><p>这样就会去掉\的转义了。<br>第二步: 找到em的符号:</p>
<pre><code>em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
</code></pre><p>改为:</p>
<pre><code>em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
</code></pre><p>去掉_的斜体含义,这样就解决了。为什么说通用性很高，因为我们没有修改文章的内容，可以放到别的引擎下也会顺利渲染。</p>
<blockquote>
<p>这个困扰我许久的问题终于这么解决了。之前一直按照标准mathjax语法写公式，但是有的时候就会无法显示公式。</p>
<p>按照上述修改后，markdown不再处理(公式中的)<code>_</code>以及<code>\</code>。mathjax语法畅行无阻。</p>
</blockquote>
<p>参考资料：</p>
<p><a href="https://segmentfault.com/a/1190000007261752" target="_blank" rel="external">https://segmentfault.com/a/1190000007261752</a></p>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> MathJax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LK光流法分析及其源码]]></title>
      <url>/2017/09/21/optical_flow/</url>
      <content type="html"><![CDATA[<h2 id="光流法简介"><a href="#光流法简介" class="headerlink" title="光流法简介"></a>光流法简介</h2><p>光流的概念是Gibson在1950年首先提出来的。它是空间运动物体在观察成像平面上的像素运动的瞬时速度，是利用图像序列中像素在时间域上的变化以及相邻帧之间的相关性来找到上一帧跟当前帧之间存在的对应关系，从而计算出相邻帧之间物体的运动信息的一种方法。</p>
<p>光流法，是利用目标物体在监控场景中的空间运动，体现在视频图像序列中为不同图像颜色分布变化。导致目标物在监控场景中的空间运动场，在图像中转化为光流场，体现图像中每一个像素点的变化趋势。光流场可视为监控场景中的瞬时速度场。</p>
<p>研究光流场的目的就是为了从图片序列中近似得到不能直接得到的运动场。运动场，其实就是物体在三维真实世界中的运动；光流场，是运动场在二维图像平面上（人的眼睛或者摄像头）的投影。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>光流法的三种计算方法：LK，HS，最常用的还是LK。</p>
<h3 id="Lucas–Kanade算法"><a href="#Lucas–Kanade算法" class="headerlink" title="Lucas–Kanade算法"></a>Lucas–Kanade算法</h3><p>这个算法是最常见，最流行的。它计算两帧在时间t到t+δt之间每个每个像素点位置的移动。由于它是基于图像信号的泰勒级数，这种方法称为差分，这就是对于空间和时间坐标使用偏导数。</p>
<p>图像约束方程，也是光流法的基本方程，可以写为$I(x,y,z,t)=I(x +δx,y+δy,z+δz,t+δt)$</p>
<p>$I(x,y,z,t)$ 为在$(x,y,z)$位置的体素。</p>
<p>我们假设移动足够的小，那么对图像约束方程使用泰勒公式，我们可以得到：</p>
<p><img src="/2017/09/21/optical_flow/equ_1.png" alt=""></p>
<p>H.O.T.指更高阶，在移动足够小的情况下可以忽略。从这个方程中我们可以得到：</p>
<p><img src="/2017/09/21/optical_flow/equ_2.png" alt=""></p>
<p>或者</p>
<p><img src="/2017/09/21/optical_flow/equ_3.png" alt=""></p>
<p>我们得到：</p>
<p><img src="/2017/09/21/optical_flow/equ_4.png" alt=""></p>
<p>Vx ,Vy ,Vz 分别是$I(x,y,z,t)$的光流向量中x，y，z的组成。 $\frac{∂I}{∂x}$, $\frac{∂I}{∂y}$, $\frac{∂I}{∂z}$和 $\frac{∂I}{∂t}$则是图像在$(x,y,z,t)$这一点向相应方向的差分。<br>所以<br>$$I_x V_x + I_y V_y + I_z V_z = −I_t$$<br>写做：</p>
<p><img src="/2017/09/21/optical_flow/equ_5.png" alt=""></p>
<p>这个方程有三个未知量，尚不能被解决，这也就是所谓光流算法的光圈问题。那么要找到光流向量则需要另一套解决的方案。而Lucas-Kanade算法是一个非迭代的算法：<br>假设流(Vx,Vy,Vz)在一个大小为$m*m*m$(m&gt;1)的小窗中是一个常数，那么从像素 $1,2,…,n,n =m^3$ 中可以得到下列一组方程：</p>
<p>$$I_{x1}  V_x + I_{y1}  V_y + I_{z1}  V_z = -I_{t_1}  $$</p>
<p>$$I_{x2}  V_x + I_{y2}  V_y + I_{z2}  V_z = -I_{t_2}  $$</p>
<p>$$ \vdots  $$</p>
<p>$$I_{xn}  V_x + I_{yn}  V_y + I_{zn}  V_z = -I_{t_n}  $$</p>
<p>三个未知数但是有多于三个的方程，这个方程组自然是个超定方程，也就是说方程组内有冗余，方程组可以表示为：</p>
<p><img src="/2017/09/21/optical_flow/equ_6.png" alt=""></p>
<p>记作：</p>
<p>$$A \vec{v} = -b $$</p>
<p>为了解决这个超定问题，我们采用最小二乘法：</p>
<p>$$A^T A \vec{v} = A^T (-b) $$</p>
<p>or</p>
<p>$$ \vec{v} = (A^T A)^{-1}  A^T (-b) $$</p>
<p>得到：</p>
<p><img src="/2017/09/21/optical_flow/equ_7.png" alt=""></p>
<p>其中的求和是从1到n。</p>
<p>另外，由于LK算法假设是小位移，为了解决大位移问题，需要在多层图像缩放金字塔上求解，每一层的求解结果乘以2后加到下一层：</p>
<p><img src="/2017/09/21/optical_flow/LK_ta.png" alt=""></p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>C++代码来自于：</p>
<p><a href="http://download.csdn.net/download/crzy_sparrow/4183674" target="_blank" rel="external">http://download.csdn.net/download/crzy_sparrow/4183674</a></p>
<p>有两点修改的地方：</p>
<p>①void handleTrackedPoint(Mat &frame;,Mat &output;)声明过程中循环条件points[i]要改为<code>points[1]</code>；</p>
<p>②新建项目时加上预编译头。</p>
<p>如果出现这个：<br><code>warning:opening fiile(../../modules/highgui/src/cap_ffmpeg_impl.hpp:545)</code><br>注意要把avi格式的视频文件放在debug下，可以用格式工厂转，注意视频编码那里要换成avc</p>
<p>效果：可以检测到运动目标。</p>
<p>参考资料：</p>
<p><a href="http://blog.csdn.net/crzy_sparrow/article/details/7407604" target="_blank" rel="external">http://blog.csdn.net/crzy_sparrow/article/details/7407604</a><br><a href="http://blog.csdn.net/u014568921/article/details/46638557" target="_blank" rel="external">http://blog.csdn.net/u014568921/article/details/46638557</a><br><a href="http://www.cnblogs.com/gnuhpc/archive/2012/12/04/2802124.html" target="_blank" rel="external">http://www.cnblogs.com/gnuhpc/archive/2012/12/04/2802124.html</a></p>
]]></content>
      
        <categories>
            
            <category> 邂逅opencv </category>
            
        </categories>
        
        
        <tags>
            
            <tag> opencv </tag>
            
            <tag> 光流法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[opencv视频保存方法详解]]></title>
      <url>/2017/09/21/opencv_SaveVideo/</url>
      <content type="html"><![CDATA[<h1 id="Opencv视频保存"><a href="#Opencv视频保存" class="headerlink" title="Opencv视频保存"></a>Opencv视频保存</h1><h2 id="视频保存流程与示例"><a href="#视频保存流程与示例" class="headerlink" title="视频保存流程与示例"></a>视频保存流程与示例</h2><p>视频保存三步走：</p>
<p>一开始（循环外）</p>
<pre><code>VideoWriter outputVideo;
outputVideo.open(&quot;E:\\modeling\\视频\\compare3.avi&quot;, -1, 30, cvSize(cur.rows, cur.cols * 2 + 10),true);
</code></pre><p>接着（循环中）</p>
<pre><code>outputVideo &lt;&lt; canvas; //保存每帧图片到视频
</code></pre><p>最后释放（循环外）</p>
<pre><code>outputVideo.release(); //可以不要
</code></pre><h2 id="视频保存详解"><a href="#视频保存详解" class="headerlink" title="视频保存详解"></a>视频保存详解</h2><p>第一步中：</p>
<p>先定义VideoWriter对象，并指定输出文件。其中，open函数的定义为：</p>
<pre><code>open ( const char* filename, int fourcc, double fps, CvSize frame_size, int is_color=1 );
</code></pre><p>第一个参数filename为输出视频文件名。输出目录要存在，输出文件不存在时会自动创建。目录中注意使用<code>转义字符</code>。</p>
<p>第二个参数fourcc为编码格式。四个字符来表示压缩帧的codec。例如：</p>
<ol>
<li>CV_FOURCC(‘P’,’I’,’M’,’1’) = MPEG-1 codec</li>
<li>CV_FOURCC(‘M’,’J’,’P’,’G’) = motion-jpeg codec</li>
<li>CV_FOURCC(‘M’, ‘P’, ‘4’, ‘2’) = MPEG-4.2 codec</li>
<li>CV_FOURCC(‘D’, ‘I’, ‘V’, ‘3’) = MPEG-4.3 codec</li>
<li>CV_FOURCC(‘D’, ‘I’, ‘V’, ‘X’) = MPEG-4 codec</li>
<li>CV_FOURCC(‘U’, ‘2’, ‘6’, ‘3’) = H263 codec</li>
<li>CV_FOURCC(‘I’, ‘2’, ‘6’, ‘3’) = H263I codec</li>
<li>CV_FOURCC(‘F’, ‘L’, ‘V’, ‘1’) = FLV1 codec</li>
</ol>
<p><strong>若编码器代号为 -1，则运行时会弹出一个编码器选择框。</strong></p>
<p>详细的视频编解码格式可参考：<a href="http://fourcc.org/codecs.php" target="_blank" rel="external">Video Codecs by FOURCC</a></p>
<p>第三个参数fps 被创建视频流的帧率。</p>
<p>第四个参数frame_size 视频流的大小。</p>
<p>第五个参数is_color 如果非零(true)，编码器将希望得到彩色帧并进行编码；否则，是灰度帧（只有在Windows下支持这个标志）。</p>
<h1 id="出错详解"><a href="#出错详解" class="headerlink" title="出错详解"></a>出错详解</h1><p>输出路径不对肯定就没有视频了。此外，容易出现的问题有保存的视频大小为0，保存的视频乱码或打不开。</p>
<h2 id="保存的视频大小为0"><a href="#保存的视频大小为0" class="headerlink" title="保存的视频大小为0"></a>保存的视频大小为0</h2><p>可能的原因有： </p>
<h3 id="编码格式不对"><a href="#编码格式不对" class="headerlink" title="编码格式不对"></a>编码格式不对</h3><p>在open函数中第二个参数是编码格式，一定按照提供的编码格式进行填写，在应用中最好的解决方法是为<strong>-1</strong>。当为-1时，程序对弹出如下对话框供你选择：</p>
<p><img src="/2017/09/21/opencv_SaveVideo/video_save.png" alt=" "></p>
<p>本人电脑上只有选择<code>全帧（非压缩的）</code>才能正常打开。</p>
<h3 id="帧速率不匹配"><a href="#帧速率不匹配" class="headerlink" title="帧速率不匹配"></a>帧速率不匹配</h3><p>该项会导致视频时间不同。</p>
<h3 id="后缀名不对"><a href="#后缀名不对" class="headerlink" title="后缀名不对"></a>后缀名不对</h3><p> 选择<code>.avi</code>格式没有问题，其它待定。</p>
<h2 id="保存的视频乱码或打不开"><a href="#保存的视频乱码或打不开" class="headerlink" title="保存的视频乱码或打不开"></a>保存的视频乱码或打不开</h2><p>这个情况一般就是编码格式不对造成的，也就是open函数中第二个参数。最好的解决方法是设为<strong>-1</strong>，然后手动选择编解码器。</p>
<p><a href="http://www.cnblogs.com/polly333/p/5165290.html" target="_blank" rel="external">http://www.cnblogs.com/polly333/p/5165290.html</a></p>
]]></content>
      
        <categories>
            
            <category> 邂逅opencv </category>
            
        </categories>
        
        
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BGSLibrary编译安装与BGSlibrary GUI的下载与使用]]></title>
      <url>/2017/09/20/BGSlibrary/</url>
      <content type="html"><![CDATA[<blockquote>
<p>安装前提：需要安装了<code>opencv</code>以及<code>VS</code>，可以参考<a href="http://www.cnblogs.com/linshuhe/p/5764394.html" target="_blank" rel="external">这篇博文</a>，写的很详细。</p>
</blockquote>
<h1 id="BGSLibrary简介"><a href="#BGSLibrary简介" class="headerlink" title="BGSLibrary简介"></a>BGSLibrary简介</h1><p><code>BGSLibrary</code>由<code>Andrews Sobral</code>开发，并提供了一个执行背景减除（BGS）的<code>C++</code>框架。该代码可以在Windows或Linux上运行。</p>
<p>目前，该库提供了35种BGS算法（PBAS算法从BGSLibrary中删除，因为它基于专利算法<code>ViBE</code>）。 几位作者提供了大量的算法。 </p>
<p>源代码可以在<code>GNU GPL v3</code>许可证下获得，图书馆免费，学术目的开源。 任何用户都可以使用SVN客户端下载最新的项目源代码。</p>
<h2 id="BGSLibrary地址"><a href="#BGSLibrary地址" class="headerlink" title="BGSLibrary地址"></a>BGSLibrary地址</h2><p>该项目的github主页地址为：<a href="https://github.com/andrewssobral/bgslibrary" target="_blank" rel="external">github地址</a></p>
<h2 id="详细安装指南（官方修正版）"><a href="#详细安装指南（官方修正版）" class="headerlink" title="详细安装指南（官方修正版）"></a>详细安装指南（官方修正版）</h2><p>在该项目的github主页上可以看到安装指导。本人的电脑配置为VS2015，Opencv3.2.0，所以在github主页上依次点击：</p>
<blockquote>
<p>Installation instructions 中的<code>Windows installation</code> </p>
<p>-&gt;  BGSLibrary with OpenCV 3.2.0 and Visual Studio 2015 from CMAKE (Recommended)</p>
</blockquote>
<p>该界面下，详细的安装步骤（及修正）为：</p>
<ul>
<li><strong>打开</strong><code>windows控制台（cmd）</code></li>
</ul>
<ul>
<li><strong>克隆</strong><code>BGSLibrary库</code>到本地</li>
</ul>
<p>克隆指令为：</p>
<pre><code>git clone https://github.com/andrewssobral/bgslibrary.git
</code></pre><ul>
<li><strong>切换</strong>到<code>bgslibrary/build</code><strong>目录</strong></li>
</ul>
<ul>
<li>设置opencv路径</li>
</ul>
<blockquote>
<pre><code>特别注意：windows环境下没有`setlocal`命令。
</code></pre></blockquote>
<p>所以跳过该步骤，直接进行下一步。</p>
<ul>
<li>调用<strong>cmake命令</strong>安装</li>
</ul>
<p>安装命令为：</p>
<pre><code>cmake -DOpenCV_DIR=%OpenCV_DIR% -G &quot;Visual Studio 14 Win64&quot; ..
</code></pre><p>注意：由于我们没有设置上一步的opencv路径，因此，上述cmake命令中的<code>%OpenCV_DIR%</code>需要用详细路径的形式替换，即直接指定opencv目录。笔者所用的命令为：</p>
<pre><code>cmake -D OpenCV_DIR=&quot;D:\Program Files\opencv3\build&quot; -G &quot;Visual Studio 14 Win64&quot; ..
</code></pre><blockquote>
<p>命令中最后的两个点也是需要的。<code>-D</code>与<code>OpenCV_DIR</code>分开或者合在一起都可以。</p>
<p>上述两步骤的变化是笔者花了不少时间尝试出来的。</p>
</blockquote>
<p><img src="/2017/09/20/BGSlibrary/cmake_success.png" alt="cmake成功截图"></p>
<ul>
<li>将opencv可执行文件目录添加到系统<strong>环境变量</strong>PATH中</li>
</ul>
<p>计算机上右键 – 属性 – 高级系统设置 – 环境变量 – 系统变量中的PATH –添加opencv目录。</p>
<pre><code>D:\Program Files\opencv3\build\x64\vc14\bin;
</code></pre><blockquote>
<p>最后的是英文状态下的分号，表示不同路径间的分隔符。</p>
</blockquote>
<ul>
<li>VS中打开<code>bgs.sln</code>解决方案文件，切换到“<code>RELEASE</code>”模式（并且要注意选择x64而不是x86模式）下，点击“<code>ALL_BUILD</code>”项目开始<strong>生成</strong>。</li>
</ul>
<ul>
<li>安装完成，可以开始跑demo，跑BGSLibrary了。</li>
</ul>
<p>主要有两种方式运行<code>BGSLibrary</code>，第一种是在cmd命令行下，第二种是运行写好的脚本文件。</p>
<h2 id="运行方法一：windows控制台"><a href="#运行方法一：windows控制台" class="headerlink" title="运行方法一：windows控制台"></a>运行方法一：windows控制台</h2><p>在windows控制台（cmd）下运行：</p>
<p> ①用摄像头跑BGSLibrary </p>
<pre><code>C:\bgslibrary&gt;  build\bgslibrary.exe --use_cam --camera=0
</code></pre><p> ②运行dome程序</p>
<pre><code>C:\bgslibrary&gt;  build\bgs_demo.exe dataset/video.avi
</code></pre><p> ③运行demo2程序</p>
<pre><code>C:\bgslibrary&gt;  build\bgs_demo2.exe
</code></pre><blockquote>
<p>注意：此时的目录为bgslibrary根目录。</p>
</blockquote>
<h2 id="运行方法二：直接运行脚本文件"><a href="#运行方法二：直接运行脚本文件" class="headerlink" title="运行方法二：直接运行脚本文件"></a>运行方法二：直接运行脚本文件</h2><p>经过上述的成功生成过程后，可在<code>bgslibrary根目录</code>下找到写好的脚本文件（<code>bat</code>或者<code>sh</code>），直接双击运行即可。如下图所示：</p>
<p><img src="/2017/09/20/BGSlibrary/BGSLibrary_run.png" alt="脚本文件截图"></p>
<h1 id="BGSlibrary-GUI的下载与使用"><a href="#BGSlibrary-GUI的下载与使用" class="headerlink" title="BGSlibrary GUI的下载与使用"></a>BGSlibrary GUI的下载与使用</h1><h2 id="BGSlibrary-GUI简介"><a href="#BGSlibrary-GUI简介" class="headerlink" title="BGSlibrary GUI简介"></a>BGSlibrary GUI简介</h2><p>是否还在为上述繁琐的安装过程而苦恼，那么就快来下载<code>BGSlibrary GUI</code>吧。</p>
<p>BGSlibrary GUI是BGSLibrary的可执行版本，可用于Windows 32位和64位。 对于Linux和Mac用户，可以使用Makefile来编译所有文件并生成可执行示例。</p>
<p>该GUI中集成了37种背景建模算法，可以显示输入视频/图像、基于背景建模得到的前景和背景建模得到的背景图像，还可以显示出每种算法的计算复杂度等等。并且，测试的可以是视频、图片序列以及摄像头输入视频。</p>
<h2 id="下载方式一"><a href="#下载方式一" class="headerlink" title="下载方式一"></a>下载方式一</h2><p>文件名：<code>bgslibrary_x86_v1.9.2_with_mfc_gui_v1.4.2.7z</code></p>
<p>下载地址：<a href="http://download.csdn.net/download/frd2009041510/8691475" target="_blank" rel="external">CSDN</a> (找的网上的，亲测可用)</p>
<p>上传者设置了积分，没有积分的童鞋可以联系我，我私下发给你，或者我看情况可以上传百度云啥的。</p>
<h2 id="下载方式二"><a href="#下载方式二" class="headerlink" title="下载方式二"></a>下载方式二</h2><p>最新版本：<code>BGSLibrary v1.9.1 with MFC GUI v1.4.1 (x86/x64)</code></p>
<p>下载地址：<a href="https://github.com/andrewssobral/bgslibrary/blob/master/binaries/mfc_bgslibrary_x86_v1.4.1.zip" target="_blank" rel="external">GITHUB（bgslibrary/binaries/）</a></p>
<h2 id="BGSlibrary-GUI的使用"><a href="#BGSlibrary-GUI的使用" class="headerlink" title="BGSlibrary GUI的使用"></a>BGSlibrary GUI的使用</h2><p>已经是GUI界面了，所以使用非常简单，在此不再赘述。基本上和编译完成后能实现的功能相同。</p>
<p><img src="/2017/09/20/BGSlibrary/GUI.png" alt="GUI界面截图"></p>
]]></content>
      
        <categories>
            
            <category> 邂逅opencv </category>
            
        </categories>
        
        
        <tags>
            
            <tag> opencv </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BP神经网络部分具体的推导]]></title>
      <url>/2017/09/12/BP_derivation/</url>
      <content type="html"><![CDATA[<blockquote>
<p>mathjax公式中不能有多余的{}</p>
</blockquote>
<h2 id="网络结构参数说明"><a href="#网络结构参数说明" class="headerlink" title="网络结构参数说明"></a>网络结构参数说明</h2><h3 id="BP神经网络示意图"><a href="#BP神经网络示意图" class="headerlink" title="BP神经网络示意图"></a><strong>BP神经网络示意图</strong></h3><p><img src="/2017/09/12/BP_derivation/bp_net.png" alt="BP神经网络示意图"></p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a><strong>网络结构</strong></h3><p>一个输入层，两个隐含层，一个输出层。</p>
<h3 id="参数标记"><a href="#参数标记" class="headerlink" title="参数标记"></a><strong>参数标记</strong></h3><ul>
<li>输入层神经元个数n、输出层神经元个数m【其中有m=n，每一帧都有对应的输出】</li>
</ul>
<ul>
<li>两个隐含层神经元个数均为100</li>
</ul>
<ul>
<li>权值：输入层与第一个隐含层之间的权值为$w_{ij}$，两个隐含层之间的权值为$w_{jk}$，第二个隐含层与输出层之间的权值为$w_{kl}$</li>
</ul>
<ul>
<li>阈值：两个隐含层$a^1_j,a^2_k$,输出层$b_l$</li>
</ul>
<p>其中，$i=1,2,…,n$，$j,k=1,2,…,100$，$l=1,2,…,m$<br>凡是下标含有$i,j,k,l$的，均表示单个神经元。</p>
<h2 id="BP网络推导"><a href="#BP网络推导" class="headerlink" title="BP网络推导"></a>BP网络推导</h2><h3 id="两个隐含层及输出层的输出"><a href="#两个隐含层及输出层的输出" class="headerlink" title="两个隐含层及输出层的输出"></a>两个隐含层及输出层的输出</h3><p>$$H_j^1 = f(\sum_{i=1}^n w_{ij} x_i - a_{j}^1 )\ \ \ j=1,2,…,100$$</p>
<p>$$<br>H_{k}^2 = f(\sum^{100}_{j=1} w_{jk} H^1_{j} - a^2_{k} )\ \ \  k = 1,2, \cdots ,100<br>$$</p>
<p>$$<br>O_l = \sum_{k = 1}^{100} w_{kl}H_{k}^2 - {b_l} \ \ \ l = 1,2, \cdots ,m<br>$$</p>
<h3 id="误差"><a href="#误差" class="headerlink" title="误差"></a>误差</h3><p>$$e_l = y_l - O_l\ \ \  l = 1,2, \cdots ,m$$</p>
<h3 id="反向传播的权值更新"><a href="#反向传播的权值更新" class="headerlink" title="反向传播的权值更新"></a>反向传播的权值更新</h3><p>$$\begin{equation}\begin{split}<br>w_{kl} &amp;= w_{kl} - dw_{kl} \\<br>&amp;= w_{kl} - \eta \frac{\partial e_l}{\partial w_{kl}}\\<br>&amp;= w_{kl} + \eta H_k^2 e_l \ \ \ \ \ \  k = 1,2, \cdots ,100 \\<br>\end{split}\end{equation}$$</p>
<p>$$\begin{equation}\begin{split}<br>{w_{jk}}  &amp;= {w_{jk}} - \eta \frac{\partial e_l}{\partial w_{jk}} \\<br>&amp;= {w_{jk}} - \eta \frac{\partial e_l}{\partial O_l} \frac{\partial O_l}{\partial H_{k}^2} \frac{\partial H_{k}^2}{\partial w_{jk}} \\<br>&amp;= {w_{jk}} - \eta (-e_l)(\sum_{l = 1}^m w_{kl}) (f’_{H_k^2} H_j^1) \\<br>&amp;= {w_{jk}} + \eta f’_{H_k^2} H_j^1 \sum_{l = 1}^m w_{kl}e_l \ \ \ \ \  j = 1,2, \cdots ,100 \\<br>\end{split}\end{equation}$$</p>
<p>$$\begin{equation}\begin{split}<br>{w_{ij}}  &amp;= {w_{ij}} - \eta \frac{\partial e_l}{\partial w_{ij}} \\<br>&amp;= {w_{jk}} - \eta \frac{\partial e_l}{\partial O_l} \frac{\partial O_l}{\partial H_{k}^2} \frac{\partial H_{k}^2}{\partial H_{j}^1} \frac{\partial H_{j}^1}{\partial w_{ij}} \\<br>&amp;= {w_{jk}} - \eta (-e_l)(\sum_{l = 1}^m w_{kl}) (f’_{H_k^2} \sum_{k = 1}^{100} w_{jk}) (f’_{H_j^1} x_i) \\<br>&amp;= {w_{ij}} + \eta f’_{H_j^1}{x_i}\sum_{k = 1}^{100} [(\sum_{l = 1}^m w_{kl}e_l)w_{jk}f’_{H_k^2}] \\<br>\ \ \ \  &amp;其中 i = 1,2, \cdots ,n;j = 1,2, \cdots ,100 \\<br>\end{split}\end{equation}$$</p>
<h2 id="关于激活函数的说明"><a href="#关于激活函数的说明" class="headerlink" title="关于激活函数的说明"></a>关于激活函数的说明</h2><p>上述公式中，$f’_{H_k^2}$, $f’_{H_j^1}$ 之所以没有代入具体值，是因为这取决与所采用的激活函数。<code>DeepLearnToolBox</code>之BP算法中可采用的激活函数有两种，一是sigmoid函数，二是双曲正切函数。</p>
<h3 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h3><p>当激活函数为sigmoid函数$f(x) = \frac{1} { 1 +  e^{-x}  }$时，<strong>sigmoid函数的导数</strong>具有下面的一个性质：</p>
<p>其导数为：</p>
<p>$$\begin{equation}\begin{split}<br>f’(x) &amp;= \frac{e^{ - x}}{(1 + e^{ - x})^2} \\<br>&amp;= \frac{e^{ - x}}{(1 + e^{ - x})}\frac{1}{(1 + e^{ - x})}\\<br>&amp;= (1 - \frac{1}{(1 + e^{-x})})(\frac{1}{(1 + e^{ - x})}) \\<br>&amp;= (1-f(x))f(x)\\<br>\end{split}\end{equation}$$</p>
<p>因此，比如说，在$H^2_K$中对$f$求导，结果为$f’_{H_k^2} = H_k^2(1-H_k^2)$，同理$f’_{H_k^1} = H_k^1(1-H_k^1)$</p>
<h3 id="tanh函数"><a href="#tanh函数" class="headerlink" title="tanh函数"></a>tanh函数</h3><p>激活函数也可以是双曲正切函数$tanhx= \frac{sinhx}{coshx} = \frac{e^x-e^{-x}}{e^x+e^{-x}}$。</p>
<p>双曲正切函数的图形夹在水平直线y=1及y=-1之间，且当x的绝对值很大时，它的图形在第一象限内接近于直线y=1，而在第三象限内接近于直线y=-1。[1]<br>即双曲正切函数的值域是(-1,1)。</p>
<p><img src="/2017/09/12/BP_derivation/tanhx.png" alt="matlab作出的tanhx"></p>
<p><img src="/2017/09/12/BP_derivation/tanx_2.png" alt="matlab作出的tanhx"></p>
<p>tanh(4) = (exp(4)-exp(-4))/(exp(4)+exp(-4))  = 0.9993</p>
<p>超过[-4,4]的范围已经可以看为1了。</p>
<p>双曲正切函数的标准导数公式：</p>
<p>$$ tanh(x) = \frac{1}{cosh(x)^2} = 1- tanh(x)^2 $$</p>
<p>用如下命令作图，并画出导数图像：</p>
<pre><code>plot(x,1-tanh(x).^2)
plot(x,1./cosh(x).^2)
</code></pre><p><img src="/2017/09/12/BP_derivation/tanhx_deri.png" alt="tanhx的真实导数"></p>
<p>代码中给出的导数公式为：</p>
<p>$$f’_{tanhx} = 1.7159 * \frac{2}{3}  (1 -\frac{1}{1.7159^2}tanhx^2) $$</p>
<p>用如下命令<code>plot(x,1.7159*2/3*(1-1/1.7159^2*tanh(x).^2))</code>作图，画出导数图像：</p>
<p><img src="/2017/09/12/BP_derivation/tanhx_deri_2.png" alt="tanhx的逼近导数"></p>
<p>可以看到，总体形状是类似的，但是幅度上还是存在着较大差异。具体缩放的原因还不太清楚。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章只要是基于公式推导BP网络的整体流程。基于代码的实现请参阅： <a href="https://qwerty200696.github.io/2017/09/23/DeepLearnToolBox_BP/" target="_blank" rel="external">DeepLearnToolBox之BP算法</a>。</p>
]]></content>
      
        <categories>
            
            <category> 深度学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> deep learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo搭建的Github博客之优化]]></title>
      <url>/2017/09/09/blog-opti/</url>
      <content type="html"><![CDATA[<p>本篇教程基于NexT主题的博客配置，实现更换主题、评论、打赏等36项功能，接下来根据这些功能进行分点描述，附上个人博客以供比对参考：<a href="https://qwerty200696.github.io" target="_blank" rel="external">链接</a>。</p>
<h1 id="搭建基本Hexo博客"><a href="#搭建基本Hexo博客" class="headerlink" title="搭建基本Hexo博客"></a>搭建基本Hexo博客</h1><p>Hexo博客基本搭建参考：《<a href="https://qwerty200696.github.io/2017/09/08/blog_setup/#more" target="_blank" rel="external">hexo+GitHub博客搭建实战</a>》一文，，笔者按照教程的顺序一步一步来，是没有出现错误的，如果读者们在搭建的时候遇到了问题不知如何解决，笔者会尽自己所能帮助读者，并将遇到的问题及解决方法附在文章下方。</p>
<h1 id="Hexo博客绑定域名"><a href="#Hexo博客绑定域名" class="headerlink" title="Hexo博客绑定域名"></a>Hexo博客绑定域名</h1><p>关于Hexo博客如何绑定自己的域名，详情可参阅《<a href="http://www.jianshu.com/p/cea41e5c9b2a" target="_blank" rel="external">hexo搭建的Github博客绑定域名</a>》一文。</p>
<p>博主按照上述教程，已经成功地绑定域名<a href="wangwlj.com">wangwlj.com</a>。</p>
<h1 id="更换Hexo主题"><a href="#更换Hexo主题" class="headerlink" title="更换Hexo主题"></a>更换Hexo主题</h1><p>笔者更换后的主题为NexT，其Github网址为：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> 。首先将NexT的主题源文件下载到本地，使用Git克隆指令如下：</p>
<pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><p>下载后，将压缩包解压缩(文件位于指令运行的当前目录)，复制其中名称为<code>next</code>的文件夹到<code>Hexo</code>的主题目录下，主题目录的路径为：</p>
<blockquote>
<p>Hexo博客根目录/themes/</p>
</blockquote>
<p>在Hexo根目录下有一个以<code>_config.yml</code>命名的文件（下称<strong>站点配置文件</strong>），用<code>Sublime/NotePad++</code>等文本编辑器打开，在其中找到<code>theme</code>属性，将其由<code>landscape</code>改为<code>next</code>。</p>
<p>然后在Hexo根目录执行部署Hexo指令：</p>
<pre><code>// 清理缓存
hexo clean
// 生成文件
hexo generate
// 部署
hexo deploy
</code></pre><p>便可以在远程的博客上看到修改主题后的样式了。</p>
<h1 id="设置Hexo主题模式"><a href="#设置Hexo主题模式" class="headerlink" title="设置Hexo主题模式"></a>设置Hexo主题模式</h1><p>看到上图，读者可能会产生疑问，为什么自己的主题样式和笔者的不一样，这是因为在Hexo主题中，有四种不同的模式，通过切换模式，让NexT主题显示不一样的样式。</p>
<p>在<code>NexT</code>根目录下有一个同样名称为<code>_config.yml</code>，为了区分<code>hexo</code>根目录下的<code>_config.yml</code>，将前者称为<strong>主题配置文件</strong>，在其中找到scheme属性，如下图所示：</p>
<pre><code># Schemes
#scheme: Muse
#scheme: Mist
scheme: Pisces
#scheme: Gemini
</code></pre><p>NexT主题默认使用Muse模式，笔者采用的是Pisces模式，读者可根据自己的喜好，选择其中一种模式。</p>
<h1 id="设置预览摘要"><a href="#设置预览摘要" class="headerlink" title="设置预览摘要"></a>设置预览摘要</h1><p>设置完模式后，读者们会发现，尽管首页显示的是所有文章的列表，但是每一篇文章都显示了所有内容，这样感觉看起来不舒服，这时候可以启用预览摘要模式，在主题配置文件中找到<code>auto_excerpt</code>属性，将<code>enable</code>设置为<code>true</code> ，将<code>length</code>设置为想要预览到的字数，如下图所示：</p>
<pre><code>auto_excerpt:
enable: true #将原有的false改为true
length: 300  #设置预览的字数
</code></pre><blockquote>
<p>这里说明一下：上述的部署指令中<code>hexo deploy</code>可以换成<code>hexo server</code>，两者的区别在于，前者是将博客部署到<strong>远程</strong>的Github上，而后者是运行在<strong>本地</strong>，通过<code>http://localhost:4000</code>在浏览器中访问。后者是为了调试配置方便而使用，但是最终本地博客还是需要<code>hexo deploy</code>指令将其部署至Github上。</p>
</blockquote>
<h1 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h1><p>NexT目前出到5.1.0版本，功能模块已经相当的丰富。NexT主题集成了评论系统，只需要设置相关的属性即可实现功能，其目前支持<strong>多说、Disqus、Facebook评论、Hyper评论、网页云跟帖</strong>等，其中“多说”是NexT推荐的评论系统，但是多说评论系统不稳定，经常会出现服务异常的问题。</p>
<p>~~笔者采用的是一款名为友言的评论系统，它也是NexT已经集成好的，可以直接拿来用的。下面对其操作进行讲解：</p>
<p>~~- <strong>注册友言账号</strong></p>
<p>~~打开<a href="http://www.uyan.cc/" target="_blank" rel="external">友言官网</a>，单击“注册”按钮后，按照套路可完成账号注册。</p>
<p>~~- <strong>获取uid</strong></p>
<p>~~注册完登录后，在首页单击“后台管理”按钮进入后台界面便可看到自己的用户ID，将其复制下来。</p>
<p>~~- <strong>设置uid</strong></p>
<p>~~打开<strong>主题配置文件</strong>，在其中找到属性<code>youyan_uid</code>，然后在: 后添加之前复制的uid。</p>
<p>~~&gt; 提醒一下，<strong>:</strong> 冒号后面一定要有一个空格</p>
<p>~~然后部署一下Hexo，可以在本地或远程看到实现的评论功能，如下图所示：</p>
<p><img src="/2017/09/09/blog-opti/youyan.jpg" alt="youyan评论界面"></p>
<p><del>&gt; 在笔者配置评论功能的时候，笔者遇到了一个问题：<em>本地博客有评论功能，而远程博客却没有</em> 。折腾了一下午，始终不知道其原因所在。后来，当笔者对博客绑定自己的域名后，发现远程的博客自动出现了评论功能。在此推测为域名的缘故。若没有绑定域名的读者们遇到这个情况，可以放放，先配置其他功能。</del></p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>目前的评论系统，友言，网易云跟帖都挂了。所以，我最终采用的是来必力。</p>
<p>这边详细地介绍一下。我新写一篇文章简要介绍一下。会更新在<a href="http://wangwlj.com">我的博客</a>上。</p>
<h1 id="设置侧边栏显示效果"><a href="#设置侧边栏显示效果" class="headerlink" title="设置侧边栏显示效果"></a>设置侧边栏显示效果</h1><p>在<strong>主题配置文件</strong>中，找到<code>sidebar</code>的<code>display</code>属性，<code>display</code>属性有四种显示模式：分别为：</p>
<pre><code>post    // 默认显示方式
always  // 一直显示
hide    // 初始隐藏
remove  // 移除侧边栏
</code></pre><p>笔者将其设置为hide模式，读者们可根据个人喜好进行设置。</p>
<h1 id="添加菜单选项"><a href="#添加菜单选项" class="headerlink" title="添加菜单选项"></a>添加菜单选项</h1><p>默认情况下，菜单导航栏有首页、归档、关于三个选项，除此之外笔者还添加了分类、标签和关于。在<strong>主题配置文件</strong>中，找到<code>menu</code>属性，并去掉<code>categories、 tags、about</code>的的注释，如下图所示：</p>
<p>然后在Hexo根目录执行指令如下：</p>
<pre><code>// 添加分类页面
hexo new page &quot;categories&quot;
// 添加标签页面
hexo new page “tags”
// 添加关于页面
hexo new page &quot;about&quot;
</code></pre><p>执行完上述指令后，在Hexo根目录<code>/source/</code>文件夹下创建三个文件夹，命名分别为：<code>categories、tags、about</code>文件夹，在这些文件夹中分别会创建一个以<code>index</code>命名的Markdown文件，对这三个Markdown文件内容进行修改，使之分别为：</p>
<pre><code>---
title: categories
date: 2017-03-12 22:06:24
type: &quot;categories&quot;
---

---
title: 标签
date: 2017-03-12 17:27:16
type: &quot;tags&quot;
---

---
title: about
date: 2017-03-12 22:07:26
type: &quot;about&quot;
---
</code></pre><p>完成文件的修改，然后部署Hexo即可完成菜单选项的添加。</p>
<h1 id="添加阅读次数统计"><a href="#添加阅读次数统计" class="headerlink" title="添加阅读次数统计"></a>添加阅读次数统计</h1><p>注册<code>LeanCloud</code>账号，完成激活；点击左上角的”应用”-“创建新应用”-点击“数据”右边的齿轮–点击创建类class，类名字叫做<code>Counter</code>。</p>
<p>然后，修改<strong>主题配置文件</strong>，找到<code>leancloud_visitors</code>，添加修改：</p>
<pre><code>leancloud_visitors:
  enable: true #将原来的false改为true
  app_id: #&lt;app_id&gt;
  app_key: #&lt;app_key&gt;
</code></pre><p>从设置中找到相应的id和key：</p>
<p><img src="/2017/09/09/blog-opti/LeanCloud_id_key.png" alt="LeanCloud中的id和key"></p>
<p>然后预览，如图：</p>
<p><img src="/2017/09/09/blog-opti/view_count.png" alt="阅读次数统计效果图"></p>
<h1 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h1><p>笔者希望在个人博客中加入自己的微博、知乎和Github链接以提高访问量，接下来了解一下社交链接如何添加：</p>
<ul>
<li><strong>添加链接及图标</strong></li>
</ul>
<p>在<strong>主题配置文件</strong>中找到<code>social</code>属性，在其下方添加社交链接及图标，其格式为：</p>
<pre><code>社交平台名称：链接 || 图标
</code></pre><p>链接的图标全部来自于<a href="http://fontawesome.io/icons/" target="_blank" rel="external">Font Awesome</a></p>
<ul>
<li><strong>个人配置</strong></li>
</ul>
<p>笔者社交链接添加情况如以下代码所示：</p>
<pre><code>social:
  GitHub: https://github.com/qwerty200696 || github
  E-Mail: mailto:yourname@gmail.com || envelope
  知乎: https://www.zhihu.com/people/LijieWang || gratipay 
  微博: https://weibo.com/3280603012 || weibo
  Google: https://plus.google.com/yourname || google
  Twitter: https://twitter.com/yourname || twitter
  FB Page: https://www.facebook.com/yourname || facebook
  #VK Group: https://vk.com/yourname || vk
  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow
  YouTube: https://youtube.com/yourname || youtube
  Instagram: https://instagram.com/yourname || instagram
</code></pre><p>其中，微博有其对应的图标，而知乎在图标库中却没有找到，笔者找了一款<code>gratipay</code>的图标来代替知乎图标。</p>
<blockquote>
<p>如果没有找到指定的图标，将会启用默认的图标。</p>
</blockquote>
<ul>
<li><strong>效果展示</strong></li>
</ul>
<p>配置完成后，具体效果显示如下：</p>
<p><img src="/2017/09/09/blog-opti/social.png" alt="社交链接效果图"></p>
<h1 id="添加友情链接功能"><a href="#添加友情链接功能" class="headerlink" title="添加友情链接功能"></a>添加友情链接功能</h1><p>在<strong>主题配置文件</strong>中找到<code>links</code>属性，修改<code>links_title</code>属性的值为“友情链接”（也可以是其他文案），取消注释<code>links:</code>，然后添加上好友的博客名称和博客地址，其格式如下：</p>
<pre><code># Blog rolls
links_title: 友情链接 #修改名称
#links_layout: block
#links_layout: inline
links: #该行取消注释
  小草莓: http://my.csdn.net/qq_31196849
  qingkong: http://my.csdn.net/qingkong1994
</code></pre><p>笔者友情链接出现位置在社交链接的下方，效果如下图所示：</p>
<p><img src="/2017/09/09/blog-opti/friend_link.png" alt="友情链接示意图"></p>
<h1 id="设置博文内链接为蓝色"><a href="#设置博文内链接为蓝色" class="headerlink" title="设置博文内链接为蓝色"></a>设置博文内链接为蓝色</h1><ul>
<li><strong>修改原因</strong></li>
</ul>
<p>链接的默认颜色是白色的，和普通字体颜色相同，不容易区分，如下图所示：</p>
<p><img src="/2017/09/09/blog-opti/link_color.png" alt="链接的默认颜色"></p>
<ul>
<li><strong>修改方法</strong></li>
</ul>
<p>通过路径：</p>
<blockquote>
<p><code>F:Hexo\themes\next\source\css\_common\components\post\</code></p>
</blockquote>
<p>打开<code>post.styl</code>文件，在文件中添加，如下字段：</p>
<pre><code>.post-body p a{
  color: #0593d3;
  border-bottom: none;
  &amp;:hover {
    color: #0477ab;
    text-decoration: underline;
  }
}
</code></pre><p>最好将新添加的内容放在原文件内容的底部，便于查看。</p>
<ul>
<li><strong>效果预览</strong></li>
</ul>
<p>设置完成后部署一下，预览效果如图：</p>
<p><img src="/2017/09/09/blog-opti/link_color_changed.png" alt="链接颜色为蓝色"></p>
<p>图中Git的链接出现的下划线是鼠标悬停时的效果。</p>
<h1 id="设置文章末尾”本文结束”标记"><a href="#设置文章末尾”本文结束”标记" class="headerlink" title="设置文章末尾”本文结束”标记"></a>设置文章末尾”本文结束”标记</h1><p><strong>实现方法</strong></p>
<p>在路径<code>F:\Hexo\themes\next\layout\_macro</code>下，新建一个文件<code>passage-end-tag.swig</code>,文件内容中添加以下代码：</p>
<pre><code>{% if theme.passage_end_tag.enabled %}
	<div style="text-align:center;color: #ccc;font-size:14px;">
		------ 本文结束<i class="fa fa-paw"></i>感谢您的阅读 ------</div>
	{% endif %}
</code></pre><p>代码截图如下(在网站中看到的div标签生效消失了，故此截图)：</p>
<p><img src="/2017/09/09/blog-opti/code_end_tag.png" alt="passage-end-tag"></p>
<p>这里可以更改字体显示的颜色，大小，以及内容，例如可将本文结束用The Happy Ending代替，并将字体颜色设置为了自己喜欢的#CDBA96，你可以去<a href="http://tool.oschina.net/commons?type=3" target="_blank" rel="external">这里</a>选择自己喜欢的颜色对应的RGB值。</p>
<p>然后在路径<code>\themes\next\layout\_macro\</code>下找到并打开<code>post.swig</code>文件，在 <code>post-body</code> 之后， <code>post-footer</code> 之前添加如下代码（post-footer之前两个DIV）：</p>
<pre><code>{% if not is_index %}
	  <div>
		{% include 'passage-end-tag.swig' %}
	  </div>
	{% endif %}
</code></pre><p>具体位置如下图所示：</p>
<p><img src="/2017/09/09/blog-opti/end_tag.png" alt="post.swig文件中的具体位置"></p>
<p>最后在<strong>主题配置文件</strong>中，在末尾添加如下语句：</p>
<pre><code>passage_end_tag:
  enabled: true
</code></pre><p><strong>实现效果图</strong></p>
<p>最终实现效果如下：</p>
<p><img src="/2017/09/09/blog-opti/end_tag_view.png" alt="效果图"></p>
<h1 id="显示每篇文章字数"><a href="#显示每篇文章字数" class="headerlink" title="显示每篇文章字数"></a>显示每篇文章字数</h1><p><strong>实现方法</strong></p>
<p>首先安装插件，执行以下命令：</p>
<pre><code>npm install hexo-wordcount --save
</code></pre><p>然后修改<strong>主题配置文件</strong>，定位到<code>post_wordcount</code>，将<code>wordcount</code>由<code>false</code>改为<code>true</code>即可。</p>
<p><strong>实现效果图</strong></p>
<p>在每篇文章标题下会有如下效果：</p>
<p><img src="/2017/09/09/blog-opti/word_count.png" alt="字数统计效果图"></p>
<h1 id="显示站点文章总字数"><a href="#显示站点文章总字数" class="headerlink" title="显示站点文章总字数"></a>显示站点文章总字数</h1><p><strong>实现方法</strong></p>
<p>首先安装插件，插件安装同上（已经“显示每篇文章字数”则忽略这步）。</p>
<p>然后修改<strong>主题配置文件</strong>，定位到<code>post_wordcount</code>，将<code>totalcount</code>由<code>false</code>改为<code>true</code>即可。</p>
<p><strong>实现效果图</strong></p>
<p>在页面最底部会有如下效果：</p>
<p><img src="/2017/09/09/blog-opti/total_count.png" alt="字数统计效果图"></p>
<h1 id="文章末尾添加版权说明"><a href="#文章末尾添加版权说明" class="headerlink" title="文章末尾添加版权说明"></a>文章末尾添加版权说明</h1><p>直接修改<strong>主题配置文件</strong>，定位到<code>post_copyright</code>，将<code>enable</code>由<code>false</code>改为<code>true</code>即可。</p>
<p>该字段如下：</p>
<pre><code># Declare license on posts
post_copyright:
  enable: true
  license: CC BY-NC-SA 3.0
  license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/
</code></pre><p>实现效果如图所示：</p>
<p><img src="/2017/09/09/blog-opti/copyright.png" alt="版权说明效果图"></p>
<h1 id="设置个人头像"><a href="#设置个人头像" class="headerlink" title="设置个人头像"></a>设置个人头像</h1><p>通过上面切换到Pisces发现，自己的头像还是属于匿名状态，因此，我们有必要设置一下自己的头像。</p>
<p><strong>实现方法</strong></p>
<p>在<strong>主题配置文件</strong>中找到<code>avatar</code>字段,进行修改:</p>
<pre><code># Sidebar Avatar
# in theme directory(source/images): /images/avatar.gif
# in site  directory(source/uploads): /uploads/avatar.gif
avatar: /images/head_icon.jpg
</code></pre><p>先将<code>avatar</code>字段前的#删除，然后粘贴上头像的目录位置或者链接。</p>
<p>笔者将突破保存在了主题目录下的<code>source/images</code>文件夹，也可以存放在站点目录下的<code>source/uploads</code>文件夹。也可以将自己的头像图片，保存在百度网盘或者新浪微盘的某个地方，然后将对应的<code>url</code>地址复制过来，添加在<code>avatar</code>字段后即可。</p>
<p><strong>实现效果图</strong></p>
<p>其效果如下图所示：</p>
<p><img src="/2017/09/09/blog-opti/head_icon.png" alt="头像效果展示"></p>
<p>达到效果后即可部署至远程。</p>
<h1 id="设置头像动态特效"><a href="#设置头像动态特效" class="headerlink" title="设置头像动态特效"></a>设置头像动态特效</h1><p>在路径<code>F:\Hexo\themes\next\layout\_partials</code>找到<code>head.swig</code>文件并打开，在其末尾添加，如下字段：</p>
<pre><code>&lt;link href=&quot;//cdn.bootcss.com/animate.css/3.5.0/animate.min.css&quot; rel=&quot;stylesheet&quot;&gt;
</code></pre><p>并在路径<code>themes\next\source\css\_common\components\sidebar\</code>下找到<code>sidebar-author.styl</code>文件并打开，添加如下语句：</p>
<pre><code>.site-author-image:hover {
  -webkit-animation: jello 1s;
  animation: jello 1s;
};
</code></pre><p>其中<code>jello</code>是我选择的动态效果，你可以在<a href="https://daneden.github.io/animate.css/" target="_blank" rel="external">这里</a>找到你喜欢的特效;然后更换上述代码中的<code>jello</code>字段，达到预期效果后，即可部署至远程。</p>
<h1 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h1><p><strong>实现方法</strong></p>
<p>打开主题配置文件，找到以下字段，进行相应的修改：</p>
<pre><code># Put your favicon.ico into `hexo-site/source/` directory.
favicon: /web_icon.jpg
</code></pre><p>然后预览，在自己的博客网站上有这样的图标：</p>
<p><img src="/2017/09/09/blog-opti/web_icon.png" alt="网站图标展示"></p>
<p>因为我使用了与头像一样的图片，所以图标与头像一样。达到效果后即可部署至远程。</p>
<h1 id="添加留言版块"><a href="#添加留言版块" class="headerlink" title="添加留言版块"></a>添加留言版块</h1><p>我们还可以在菜单栏增加一个”留言板”,让他人可以通过留言板直接给我们留言。</p>
<p><strong>实现方法</strong></p>
<p>在博客目录中，执行以下命令，新建一个页面：</p>
<pre><code>hexo n page guestbook
</code></pre><p>然后通过路径<code>F:\Hexo\source\guestbook</code>找到并打开<code>guestbook</code>文件夹下的<code>index.md</code>文件，然后再文件中添加以下代码:</p>
<pre><code>&lt;div class=&quot;ds-recent-visitors&quot; data-num-items=&quot;28&quot; data-avatar-size=&quot;42&quot; id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt;
</code></pre><p>然后打开主题配置文件，在menu字段下，添加如下字段：</p>
<pre><code>menu:
  home: / || home
  about: /about/ || user
  tags: /tags/ || tags
  categories: /categories/ || th
  archives: /archives/ || archive
  留言板: /guestbook || newspaper-o #自己添加的字段
</code></pre><p><code>newspaper-o</code>是留言板的图标，可以在<a href="http://fontawesome.io/icons/" target="_blank" rel="external">这里</a>找到自己喜欢的图标。</p>
<p>笔者采用的youyan评论系统，默认在新建页面上会产生评论板块。效果如下：</p>
<p><img src="/2017/09/09/blog-opti/guestbook.png" alt="留言板效果图"></p>
<blockquote>
<p>这个效果暂时不稳定，可能是由于笔者暂时还没有绑定域名的关系。</p>
</blockquote>
<h1 id="项目主页添加README"><a href="#项目主页添加README" class="headerlink" title="项目主页添加README"></a>项目主页添加README</h1><p>在建立Github上建立自己的博客仓库的时候，没有生成<code>README</code>文件，这样使得其他人无法知道我们这个仓库是做什么，即我们的这个仓库缺少一个说明文件；但是如果直接使用命令<code>hexo n README</code>，再部署至远程的时候，hexo会将它解析为<code>html</code>文件，这不是我们想要的。</p>
<p><strong>实现方法</strong></p>
<p>因此，解决方式是在路径<code>F:\Hexo\source</code>下手动新建<code>README.mdown</code>注意这里的后缀是<code>.mdown</code>，<code>Mardownpad</code>可以将文件保存为<code>.mdown</code>后缀文件；然后再在这个新建文件中写<code>README</code>即可。再之后<code>hexo g</code>会把它复制到<code>public</code>文件夹，而不会被解析成<code>html</code>文件，发布在博客中。</p>
<p><strong>实现效果图</strong></p>
<p>预览效果，如图：</p>
<p><img src="/2017/09/09/blog-opti/readme.png" alt="README效果图"></p>
<h1 id="实现fork-me-on-github"><a href="#实现fork-me-on-github" class="headerlink" title="实现fork me on github"></a>实现fork me on github</h1><p>在右上角或者左上角实现fork me on github。</p>
<p><strong>实现方法</strong></p>
<p>点击<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="external">这里</a>挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码： </p>
<p><img src="/2017/09/09/blog-opti/fork_ex.png" alt="fork me代码图"></p>
<p>然后粘贴刚才复制的代码到<code>themes/next/layout/_layout.swig</code>文件中(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面)，并把<code>href</code>标签改为你的<code>github</code>地址：</p>
<p><img src="/2017/09/09/blog-opti/fork_place.png" alt="fork me具体位置"></p>
<p><strong>实现效果图</strong></p>
<p>实现效果图如下（右上角）：</p>
<p><img src="/2017/09/09/blog-opti/fork_me.png" alt="fork me效果图"></p>
<h1 id="实现点击出现桃心效果"><a href="#实现点击出现桃心效果" class="headerlink" title="实现点击出现桃心效果"></a>实现点击出现桃心效果</h1><p><strong>实现方法</strong></p>
<p>打开浏览器，输入如下网址</p>
<blockquote>
<p><a href="http://7u2ss1.com1.z0.glb.clouddn.com/love.js" target="_blank" rel="external">http://7u2ss1.com1.z0.glb.clouddn.com/love.js</a></p>
</blockquote>
<p>然后将里面的代码copy一下，新建<code>love.js</code>文件并且将代码复制进去，然后保存。将<code>love.js</code>文件放到路径<code>/themes/next/source/js/src</code>里面，然后打开<code>\themes\next\layout\_layout.swig</code>文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：</p>
<pre><code>&lt;!-- 页面点击小红心 --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;
</code></pre><p><strong>实现效果图</strong></p>
<p><img src="/2017/09/09/blog-opti/love.gif" alt="love效果图"></p>
<h1 id="修改文章底部的-号标签"><a href="#修改文章底部的-号标签" class="headerlink" title="修改文章底部的#号标签"></a>修改文章底部的#号标签</h1><p><strong>实现方法</strong></p>
<p>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将其中的 <code>#</code> 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<p><strong>实现效果图</strong></p>
<p><img src="/2017/09/09/blog-opti/tag_new.png" alt="新标签符号图"></p>
<h1 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h1><p><strong>实现方法</strong></p>
<p>在主题配置文件中，定位到如下部分：</p>
<pre><code># Canvas-nest
canvas_nest: true

# three_waves
three_waves: false

# canvas_lines
canvas_lines: false

# canvas_sphere
canvas_sphere: false

# Only fit scheme Pisces
# Canvas-ribbon
canvas_ribbon: false
</code></pre><p>这是已经集成好的几个动态效果，笔者采用的是canvas_nest，读者可依次体验(将false改为true)，选择最喜欢的动态背景。</p>
<p><strong>实现效果图</strong></p>
<p><img src="/2017/09/09/blog-opti/canvas_nest.gif" alt="动态背景效果图"></p>
<h1 id="代码块样式自定义"><a href="#代码块样式自定义" class="headerlink" title="代码块样式自定义"></a>代码块样式自定义</h1><p><strong>实现方法</strong></p>
<p>打开\themes\next\source\css_custom\custom.styl,向里面加入：(颜色可以自己定义)</p>
<pre><code>// Custom styles.
code {
    color: #ff7600;
    background: #fbf7f8;
    margin: 2px;
}
// 大代码块的自定义样式
.highlight, pre {
    margin: 5px 0;
    padding: 5px;
    border-radius: 3px;
}
.highlight, code, pre {
    border: 1px solid #d6d6d6;
}
</code></pre><p><strong>实现效果图</strong></p>
<p><img src="/2017/09/09/blog-opti/code_block.png" alt="代码块样式效果图"></p>
<h1 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h1><p><strong>实现方法</strong></p>
<p>打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码：</p>
<p><img src="/2017/09/09/blog-opti/add_password_1.png" alt="文章加密访问"></p>
<p>代码如下：</p>
<pre><code>&lt;script&gt;
    (function(){
        if(&apos;{{ page.password }}&apos;){
            if (prompt(&apos;请输入文章密码&apos;) !== &apos;{{ page.password }}&apos;){
                alert(&apos;密码错误！&apos;);
                history.back();
            }
        }
    })();
&lt;/script&gt;
</code></pre><p>然后在文章上写成类似这样：</p>
<p><img src="/2017/09/09/blog-opti/add_password_2.png" alt="文章加密访问"></p>
<p><strong>实现效果图</strong></p>
<p><img src="/2017/09/09/blog-opti/add_password_3.gif" alt="文章加密访问"></p>
<h1 id="添加jiathis分享"><a href="#添加jiathis分享" class="headerlink" title="添加jiathis分享"></a>添加jiathis分享</h1><p><strong>实现方法</strong></p>
<p>在<strong>主题配置文件</strong>中，jiathis为true，就行了，代码如下：</p>
<pre><code># Share
# This plugin is more useful in China, make sure you known how to use it.
# And you can find the use guide at official webiste: http://www.jiathis.com/.
# Warning: JiaThis does not support https.
jiathis: true
  ##uid: Get this uid from http://www.jiathis.com/
#add_this_id:
</code></pre><p><strong>实现效果图</strong></p>
<p><img src="/2017/09/09/blog-opti/jia_this.png" alt="分享效果图"></p>
<h1 id="自定义鼠标样式"><a href="#自定义鼠标样式" class="headerlink" title="自定义鼠标样式"></a>自定义鼠标样式</h1><p><strong>实现方法</strong></p>
<p>打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码</p>
<pre><code>// 鼠标样式
  * {
      cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important
  }
  :active {
      cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important
  }
</code></pre><p>其中 <code>url</code> 里面必须是 <code>ico</code> 图片，<code>ic</code>o 图片可以上传到网上（我是使用七牛云图床），然后获取外链，复制到 <code>url</code> 里就行了</p>
<p>#支持mathjax公式</p>
<p>看到网上说明安装hexo-math工具，或者其他的一系列教程，如<a href="http://cn.clanzd.com/mathjax-for-hexo.html" target="_blank" rel="external">这个</a>。</p>
<p>其实在目前的hexo/NexT主题已经集成了mathjax，所以不需要那么麻烦的设置了。</p>
<p><strong>实现方法</strong></p>
<p>在<strong>主题配置文件</strong>中，定位到mathjax，将后面的选项为true，就行了。</p>
<p>另外，虽然这样设置了，但是在编写的时候还会出现mathjax与markdown默认渲染不兼容的问题，导致有时候公式一复杂就显示不出来。</p>
<p>解决上述问题的方法请参照我写的另一片博客：<a href="https://qwerty200696.github.io/2017/09/21/markdown_mathjax/" target="_blank" rel="external">https://qwerty200696.github.io/2017/09/21/markdown_mathjax/</a></p>
<h1 id="修改部分字体的颜色，大小"><a href="#修改部分字体的颜色，大小" class="headerlink" title="修改部分字体的颜色，大小"></a>修改部分字体的颜色，大小</h1><p>比如说，想在文章中对某一部分的文字进行强调（改变大小，颜色），该操作具体说明如下：</p>
<p>如果想自定义字体大小以及颜色，可以直接在 Markdown 文档中使用 html 语法：</p>
<pre><code>&lt;font size=4 &gt; 这里输入文字，自定义大小 &lt;/font&gt;
&lt;font color=&quot;#FF0000&quot;&gt; 这里输入文字，自定义颜色的字体 &lt;/font&gt; 
</code></pre><p>其中<code>#FF0000</code>为RGB颜色代码，读者可去<a href="http://www.114la.com/other/rgb.htm" target="_blank" rel="external">RGB颜色查询对照表网站</a>查找自己喜欢的颜色。</p>
<p>若想在RGB颜色值与十六进制颜色码之间相互转化，可查看<a href="http://www.sioe.cn/yingyong/yanse-rgb-16/" target="_blank" rel="external">该网站</a>。</p>
<h1 id="实现首行缩进"><a href="#实现首行缩进" class="headerlink" title="实现首行缩进"></a>实现首行缩进</h1><p>由于markdown语法主要考虑的是英文，所以对于中文的首行缩进并不太友好，因此想要实现行缩进需要加上相应的代码，如下。</p>
<p>在需要缩进行的开头处，先输入下面的代码，然后紧跟着输入文本即可。分号也不要漏掉。 </p>
<p>直接写:</p>
<p>半方大的空白<code>&amp;ensp;</code>或<code>&amp;#8194</code>;<br>全方大的空白<code>&amp;emsp;</code>或<code>&amp;#8195</code>;<br>不断行的空白格<code>&amp;nbsp;</code>或<code>&amp;#160</code>;</p>
<p>亲测可行。</p>
<h1 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h1><p>插入表格的代码是：<br>    <table class="table table-bordered table-striped table-condensed"><br>        <tr><br>            <td>北京</td><br>        <td>雾霾</td><br>        </tr><br>        <tr><br>            <td>深圳</td><br>        <td>暴雨</td><br>        </tr><br>    </table>  </p>
<p>效果为：</p>
<table class="table table-bordered table-striped table-condensed"><br>    <tr><br>        <td>北京</td><br>    <td>雾霾</td><br>    </tr><br>    <tr><br>        <td>深圳</td><br>    <td>暴雨</td><br>    </tr><br></table>  

<h1 id="Hexo博客提交百度和Google收录"><a href="#Hexo博客提交百度和Google收录" class="headerlink" title="Hexo博客提交百度和Google收录"></a>Hexo博客提交百度和Google收录</h1><p>TODO 最后这几个由于感觉暂时没有必要，就先搁置了，有空补。</p>
<h1 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h1><p>TODO</p>
<h1 id="添加搜索功能"><a href="#添加搜索功能" class="headerlink" title="添加搜索功能"></a>添加搜索功能</h1><p>TODO</p>
<h1 id="添加打赏功能"><a href="#添加打赏功能" class="headerlink" title="添加打赏功能"></a>添加打赏功能</h1><p>TODO</p>
<h1 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h1><p>TODO</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><p><a href="http://www.jianshu.com/p/5973c05d7100" target="_blank" rel="external">【干货】2个小时教你hexo博客添加评论、打赏、RSS等功能</a></p>
</li>
<li><p><a href="https://tzkang.github.io/2016/10/17/2016-10-17/#more" target="_blank" rel="external">GitHub+Hexo+NexT搭建个人博客</a></p>
</li>
<li><p><a href="http://blog.csdn.net/com_ma/article/details/76039859" target="_blank" rel="external">hexo博客的背景设置</a></p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> GitHub </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo+GitHub博客搭建实战]]></title>
      <url>/2017/09/08/blog_setup/</url>
      <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1、安装 Node.js: <a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a></p>
<p>2、安装 Git: <a href="https://github.com/waylau/git-for-win" target="_blank" rel="external">https://github.com/waylau/git-for-win</a></p>
<p>Git教程 <code>https://github.com/waylau/git-for-win</code>廖雪峰老师的教程，非常好。</p>
<p>3、安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，名称和邮箱是Github上的。</p>
<p><img src="/2017/09/08/blog_setup/git_1.png" alt="Git Bash界面与指令"></p>
<p>4、安装 Hexo。所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<pre><code>$ npm install -g hexo-cli
</code></pre><p>5、安装hexo出错：<code>unable to verify the first certificate</code>（无法验证第一证书）</p>
<p><img src="/2017/09/08/blog_setup/hexo_1.png" alt="安装hexo出错截图"></p>
<p>查找到解决方案：</p>
<p><img src="/2017/09/08/blog_setup/hexo_2.png" alt="解决方案截图-推荐方案一"></p>
<p>参考网址：<a href="http://www.zhimengzhe.com/Javascriptjiaocheng/243010.html" title="npm报错" target="_blank" rel="external">npm报错</a></p>
<p>依据解决方案所述，在命令行输入如下命令，来取消ssl验证：</p>
<pre><code>npm config set strict-ssl false
</code></pre><p>之后安装就会成功了，显示如下：</p>
<p><img src="/2017/09/08/blog_setup/hexo_3.png" alt="hexo安装成功"></p>
<h2 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h2><p>首先注册、登录 <a href="https://github.com/" target="_blank" rel="external">https://github.com/</a></p>
<p>记住自己的Username（很重要）</p>
<p>然后右上角选择 Create a new repository <a href="https://github.com/new" target="_blank" rel="external">https://github.com/new</a></p>
<p>Repository name（填自己的名字） yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了)</p>
<p><img src="/2017/09/08/blog_setup/github_1.png" alt="githhub创建仓库截图"></p>
<p>仓库创建完成后，开始生成添加秘钥。</p>
<p>在终端（cmd）输入：</p>
<pre><code>ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot;
</code></pre><p>一路Enter过来就好，待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub，用带格式的记事本打开id_rsa.pub，Ctrl + a复制里面的所有内容，然后进入<a href="https://github.com/settings/ssh：" target="_blank" rel="external">https://github.com/settings/ssh：</a></p>
<p><img src="/2017/09/08/blog_setup/github_2.png" alt="githhub输入秘钥"></p>
<p>将复制的内容粘贴到Key的输入框，随便写好Title里面的内容，点击Add SSH key按钮即可。</p>
<p>若没有配置GitHub，就执行第三步（初始化博客），会出现如下错误：</p>
<p><img src="/2017/09/08/blog_setup/hexo_4.png" alt="初始化错误"></p>
<h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p>在电脑F盘（自己随意）目录下新建文件夹 test，进入test，按住Shift键点击鼠标右键，点击“在此处打开命令窗口”：</p>
<p><img src="/2017/09/08/blog_setup/blog_1.png" alt="右键选择菜单"></p>
<p>输入</p>
<pre><code>hexo init blog
</code></pre><p>稍微等待下，速度有点慢。成功提示：</p>
<pre><code>INFO  Start blogging with Hexo!
</code></pre><p>因为你初始化hexo 之后source目录下自带一篇<code>hello world</code>文章, 所以直接执行下方命令:</p>
<pre><code>$ hexo generate
# 启动本地服务器
$ hexo server
# 在浏览器输入 http://localhost:4000/就可以看见网页和模板了
INFO  Start processing
INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.
</code></pre><p>访问<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>，便可以看到网站初步的模样，不要激动，我们还要把网页发布到Github上去。</p>
<p><img src="/2017/09/08/blog_setup/blog_local_server.png" alt="localhost上的网站初步形状"></p>
<h2 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h2><p>在<code>blog</code>目录下，用<code>sublime/notepad++</code>等文本编辑器打开<code>_config.yml</code>文件，修改参数信息</p>
<p>特别提醒，在每个参数的：后都要加一个空格</p>
<h3 id="修改网站相关信息"><a href="#修改网站相关信息" class="headerlink" title="修改网站相关信息"></a>修改网站相关信息</h3><pre><code>title: wangwlj测试所用博客
subtitle: 积跬步以至千里！
description: 网页描述
author: wangwlj
language: zh-CN
timezone: Asia/Shanghai
</code></pre><p><code>language</code>和<code>timezone</code>都是有输入规范的，详细可参考 <a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes" target="_blank" rel="external">语言规范</a>和<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="external">时区规范</a>。</p>
<h3 id="配置部署"><a href="#配置部署" class="headerlink" title="配置部署"></a>配置部署</h3><p>代码中的qwerty200696，修改成自己的。</p>
<pre><code>deploy:
  type: git
  repo: https://github.com/qwerty200696/qwerty200696.github.io
  branch: master
</code></pre><p>其中<code>repo</code>项是之前<code>Github</code>上创建好的仓库的地址，可以通过如下图所示的方式得到：</p>
<p><img src="/2017/09/08/blog_setup/github_3.png" alt="repo地址"></p>
<p>branch是项目的分支，我们默认用主分支<code>master</code>。</p>
<h3 id="配置统一资源定位符"><a href="#配置统一资源定位符" class="headerlink" title="配置统一资源定位符"></a>配置统一资源定位符</h3><p>如果有个人域名的话可以设置，否则跳过即可。如果是github.io的网址，也是可以填上的。</p>
<pre><code>url: https://qwerty200696.github.io
</code></pre><p>对于root（根目录）、permalink（永久链接）、permalink_defaults（默认永久链接）等其他信息保持默认。</p>
<h2 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h2><p>1.新建一篇博文，在CMD中输入:</p>
<pre><code>$ hexo new &quot;我的测试文章&quot;

INFO  Created: F:\test\blog\source\_posts\我的测试文章.md
</code></pre><p>2.找到该文章，打开，使用Markdown语法编辑文章。</p>
<p>该语法介绍可以查看：<a href="https://zhangslob.github.io/2017/02/26/%E5%88%A9%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/" target="_blank" rel="external">markdown语法</a></p>
<p>在文章的一开始处，可以按如下格式添加文章标题，日期，分类、标签以及描述等。</p>
<pre><code>---
title: title #文章標題
date: 2017-09-08 23:47:44 #文章生成時間
categories: &quot;Hexo教程&quot; #文章分類目錄 可以省略
tags: #文章標籤 可以省略
     - 标签1
     - 标签2
 description: #你對本頁的描述 可以省略
---
</code></pre><p>3.接着输入如下的一系列命令：</p>
<pre><code>F:\test\blog
$ hexo clean
INFO  Deleted database.
INFO  Deleted public folder.

F:\test\blog
$ hexo generate
INFO  Start processing
INFO  Files loaded in 1.48 s
#省略
INFO  29 files generated in 4.27 s

$ hexo server
INFO  Start processing
INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.
</code></pre><p>我直接跑的server，也可以。</p>
<p>最后一步，发布到网上，执行：</p>
<pre><code>F:\test\blog
$ hexo deploy
INFO  Deploying: git
INFO  Clearing .deploy_git folder...
INFO  Copying files from public folder...
#省略
</code></pre><p>其中会跳出Github登录，直接登录，如果没有问题，在浏览器输入<code>qwerty200696（换成你的）.github.io/</code></p>
<p>我的测试所用博客 <code>https://qwerty200696.github.io/</code></p>
<p>然后就可以看到已经发布了。</p>
<h3 id="错误记录一"><a href="#错误记录一" class="headerlink" title="错误记录一"></a>错误记录一</h3><pre><code>deploy not found： git
</code></pre><p><img src="/2017/09/08/blog_setup/error_1.png" alt="deploy not found： git"></p>
<p>解决方案：执行如下语句后， 再部署即可：</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>参考自：<a href="https://www.v2ex.com/t/175940" target="_blank" rel="external">https://www.v2ex.com/t/175940</a></p>
<p><img src="/2017/09/08/blog_setup/error_1_done.png" alt="错误一修正"></p>
<h3 id="错误记录二"><a href="#错误记录二" class="headerlink" title="错误记录二"></a>错误记录二</h3><p>今天运行：</p>
<pre><code>hexo deploy
</code></pre><p>同步文章到<code>github</code>时，出错：</p>
<pre><code>fatal: unable to access &apos;https://username:password@github.com/username/username.github.io.git/&apos;: SSL certificate problem: unable to get local issuer certificate
FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html
Error: fatal: unable to access &apos;https://username:password@github.com/username/username.github.io.git/&apos;: SSL certificate problem: unable to get local issuer certificate

    at ChildProcess.&lt;anonymous&gt; (D:\test\blog2\node_modules\hexo-util\lib\spawn.js:37:17)
    at emitTwo (events.js:106:13)
    at ChildProcess.emit (events.js:191:7)
    at ChildProcess.cp.emit (D:\test\blog2\node_modules\cross-spawn\lib\enoent.js:40:29)
    at maybeClose (internal/child_process.js:920:16)
    at Process.ChildProcess._handle.onexit (internal/child_process.js:230:5)
</code></pre><p><img src="/2017/09/08/blog_setup/git_hexo_deploy_error.png" alt="SSL错误"></p>
<p>解决方法：执行如下语句：</p>
<pre><code>$ git config --global http.sslVerify false
</code></pre><p>参考自：<a href="http://windigniter.com/itblog/detail/2015/06/git-ssl-certificate-problem" target="_blank" rel="external">git获取代码提示SSL certificate problem: unable to get local issuer certificate</a></p>
<p>（optional）另外，可将<code>_config.yml</code>中的<code>repo</code>修改为如下标准格式：</p>
<pre><code>repo: https://用户名:密码@github.com/用户名/用户名.github.io.git
</code></pre><p>参考自： <a href="http://blog.csdn.net/w20101310/article/details/52796721?locationNum=6&amp;fps=1" target="_blank" rel="external">hexo提交报错 unable to access</a></p>
<p>之后再次运行发布指令，终于成功：</p>
<pre><code>hexo deploy
</code></pre><p><img src="/2017/09/08/blog_setup/git_hexo_deploy_error_done.png" alt="SSL错误解决"></p>
<h2 id="添加图片"><a href="#添加图片" class="headerlink" title="添加图片"></a>添加图片</h2><p>经过上面的配置后，发现上传的博客文章里面的本地图片居然显示不来（没有同步上传）。</p>
<p>于是，找到解决方案：</p>
<p>1 把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
<p>2 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件</p>
<p>3 等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成<code>md</code>博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p>
<p>4 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p>
<pre><code>![你想输入的替代文字](xxxx/图片名.jpg)
</code></pre><p>注意： <code>xxxx</code>是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入<code>xxxx</code>这个文件夹内就好了，很像引用相对路径。</p>
<p>5 最后检查一下，<code>hexo g</code>生成页面后，进入<code>public\2017\02\26\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/02/26/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>
<p>6.<code>hexo s</code>，运行本地服务器，打开<code>http://localhost:4000/</code>，可实时查看修改情况。</p>
<p>7.<code>hexo g</code>，同步到github。</p>
<p>参考自：<a href="http://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="external">hexo生成博文插入图片</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发布文章的步骤：</p>
<p>1、<code>hexo new</code> 创建文章</p>
<p>2、<code>Markdown</code>语法编辑文章</p>
<p>3、部署（所有打开CMD都是在blog目录下）</p>
<pre><code>hexo clean #清除缓存 网页正常情况下可以忽略此条命令
hexo generate #生成
hexo server #启动服务预览，非必要，可本地浏览网页
hexo deploy #部署发布
</code></pre><p>简写Tips：</p>
<ol>
<li><p>hexo n “我的博客” == hexo new “我的博客” #新建文章</p>
</li>
<li><p>hexo p == hexo publish</p>
</li>
<li><p>hexo g == hexo generate#生成</p>
</li>
<li><p>hexo s == hexo server #启动服务预览</p>
</li>
<li><p>hexo d == hexo deploy#部署</p>
</li>
</ol>
<p>参考文献：</p>
<ol>
<li><a href="https://zhangslob.github.io/2017/02/28/%E6%95%99%E4%BD%A0%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%8CHexo-Github/" target="_blank" rel="external">教你免费搭建个人博客，Hexo&amp;Github</a></li>
<li><a href="http://blog.csdn.net/sugar_rainbow/article/details/57415705" target="_blank" rel="external">hexo生成博文插入图片</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 博客搭建系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> GitHub </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows下TensorFlow完整安装流程及出错解决方案]]></title>
      <url>/2017/09/07/TensorFlow_setup/</url>
      <content type="html"><![CDATA[<h2 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h2><h3 id="通过Pip在Windows上安装Python"><a href="#通过Pip在Windows上安装Python" class="headerlink" title="通过Pip在Windows上安装Python"></a>通过Pip在Windows上安装Python</h3><p><code>TensorFlow</code>在<code>Windows</code>上只支持64位<code>Python3.5</code>，可以通过<a href="https://www.python.org/downloads/release/python-352/" title="Python 3.5.2" target="_blank" rel="external">Python 3.5 from python.org</a> 下载并安装<code>Python3.5.2</code>（注意选择正确的操作系统）。</p>
<p>或者通过<a href="https://www.python.org/downloads/" title="python下载" target="_blank" rel="external">https://www.python.org/downloads/</a>选择3.5的任意版本。</p>
<h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p>上一步安装时，如果勾选了“自动配置环境变量”操作，即：在<code>cmd</code>中输入<code>pip</code>，如果找到了该命令，则可省去该步骤。</p>
<p>若在<code>cmd</code>中输入<code>pip</code>找不到该命令，则需要将<code>Python</code>安装路径下“<code>%安装路径%\Scripts</code>”添加到Path下；再到cmd中输入pip看到若干命令提示，则代表<code>python</code>安装成功（<code>Python</code>安装包自带<code>pip</code>）。“开始”-&gt;“所有程序”，也可以找到<code>Python</code>终端。</p>
<p>参考自：<a href="http://blog.csdn.net/include1224/article/details/53452824" title="原生Windows安装TensorFlow 0.12方法" target="_blank" rel="external">http://blog.csdn.net/include1224/article/details/53452824</a></p>
<h2 id="cuda以及cudnn的安装"><a href="#cuda以及cudnn的安装" class="headerlink" title="cuda以及cudnn的安装"></a>cuda以及cudnn的安装</h2><p><code>TensorFlow</code>分为<code>CPU</code>版和<code>GPU</code>版，如果你打算安装<code>GPU</code>版，请先安装如下两个驱动：</p>
<p>1、CUDA安装：<code>https://developer.nvidia.com/cuda-downloads</code></p>
<p><img src="/2017/09/07/TensorFlow_setup/cuda_download.png" alt="cuda截图"></p>
<p>2、CuDNN安装：<code>https://developer.nvidia.com/cudnn</code>（要注册Nvidia用户，并加入CuDNN开发组，填若干问卷就可以下载了）选择下载版本时要注意和Cuda版本匹配。</p>
<p>我的账户是<strong>qq邮箱</strong>。</p>
<p>解压后（三个目录，分别是：bin、include、lib），覆盖至CUDA的安装目录下。例如：</p>
<pre><code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v8.0\
</code></pre><h2 id="安装tensorflow"><a href="#安装tensorflow" class="headerlink" title="安装tensorflow"></a>安装tensorflow</h2><p>我安装的是GPU版本。</p>
<p><code>windows</code>不支持<code>pip</code>在线安装。即不支持：<code>pip install tensorflow-gpu</code>该命令。</p>
<p>两种方法安装<code>tensorflow</code>：</p>
<h3 id="手动下载tensorflow-gpu版本文件："><a href="#手动下载tensorflow-gpu版本文件：" class="headerlink" title="手动下载tensorflow gpu版本文件："></a>手动下载tensorflow gpu版本文件：</h3><p><code>tensorflow_gpu-0.12.0rc0-cp35-cp35m-win_amd64.whl</code><br>下载网址：<a href="https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-0.12.1-cp35-cp35m-win_amd64.whl" title="tensorflow下载网址" target="_blank" rel="external">https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-0.12.1-cp35-cp35m-win_amd64.whl</a></p>
<p>下载完成后，打开cmd，切换到安装文件目录，输入: </p>
<pre><code>pip install tensorflow_gpu-0.12.0rc0-cp35-cp35m-win_amd64.whl
</code></pre><p>即可成功安装。</p>
<p><img src="/2017/09/07/TensorFlow_setup/tensorflow_setup.png" alt="tensorflow安装"></p>
<h3 id="输入pip命令"><a href="#输入pip命令" class="headerlink" title="输入pip命令"></a>输入pip命令</h3><pre><code>pip install --upgrade https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-0.12.1-cp35-cp35m-win_amd64.whl
</code></pre><p>参考自tensorflow官网：<a href="https://www.tensorflow.org/versions/r0.12/get_started/os_setup#pip_installation_on_windows" title="tensorflow官网" target="_blank" rel="external">https://www.tensorflow.org/versions/r0.12/get_started/os_setup#pip_installation_on_windows</a></p>
<p>mac和linux可另行参考网上教程。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试是否安装成功。</p>
<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><pre><code>import tensorflow as tf
</code></pre><p>导入tensorflow时出现错误：</p>
<pre><code>“Couldn&apos;t open CUDA library cudnn64_5.dll”
</code></pre><p><img src="/2017/09/07/TensorFlow_setup/error_1.png" alt="测试"></p>
<p>找到解决方案：<br>安装时没有注意cudnn版本要求，下载安装了cudnnv6.0，安装完后自己查找文件，只有cudnn64_6.dll，没有cudnn64_5.dll。</p>
<p><img src="/2017/09/07/TensorFlow_setup/error_1_1.png" alt="测试"></p>
<p>解决方案为将cudnnV6.0替换为cudnnV5.1即可。</p>
<p>即重新下载cudnn5.1版本。 <a href="https://developer.nvidia.com/rdp/cudnn-download" title="cudnn下载地址" target="_blank" rel="external">https://developer.nvidia.com/rdp/cudnn-download</a></p>
<p><img src="/2017/09/07/TensorFlow_setup/error_1_2.png" alt="测试"></p>
<p>解决方案来自：<a href="http://blog.csdn.net/suo_ivy/article/details/70445103" title="TensorFlow “Couldn&#39;t open CUDA library cudnn64_5.dll”" target="_blank" rel="external">http://blog.csdn.net/suo_ivy/article/details/70445103</a></p>
<p>替换完成后，该错误消失。</p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p><img src="/2017/09/07/TensorFlow_setup/error_2.png" alt="测试"></p>
<p>执行<code>tf.Session()</code>的时候，出现如下提示：</p>
<pre><code>Could not identify NUMA node of /job:localhost/replica:0/task:0/gpu:0, defaulting to 0.  Your kernel may not have been built with NUMA support.`
</code></pre><p>不过这并不影响最终结果的执行。（只是个警告）</p>
<p><img src="/2017/09/07/TensorFlow_setup/error_2_1.png" alt="测试"></p>
<p>网上找到相关说明： <a href="http://blog.csdn.net/baixiaozhe/article/details/54598346" title="NUMA support" target="_blank" rel="external">http://blog.csdn.net/baixiaozhe/article/details/54598346</a><br>可供参考一下。<br>大体上的意思是：只要我们不是使用多GPU，这个警告应该是可以忽略的，所以我们目前也不需要担心了。</p>
<p>至此，tensorflow 测试完成，并成功运行了测试样例。</p>
<p>(optional) 测试程序源码</p>
]]></content>
      
        <categories>
            
            <category> TensorFlow系列 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
